'******************************************************************************
'                       bc9Basic - The Basic To C/C++ Translator
'******************************************************************************
'                      portions (c) 1999 - 2011 Kevin Diggins
'******************************************************************************
CONST Version$ = "9.2.5.9 (2017/01/27)" 'bc9 version number and date (YYYY/MM/DD)
'******************************************************************************
'
'BCX is distributed under the terms of the GNU General Public License Ver.(2).
'The complete source code that is PRODUCED BY BCX is subject to a License
'Exception to the GPL, which allows you to produce commercial applications.
'
'******************************************************************************
'                             BCX LICENSE EXCEPTION
'******************************************************************************
'
'As a special exception, the BCX license gives permission for additional uses
'of the text contained in its release of BCX. The exception is that, if you use
'BCX to create source code that will link the BCX libraries with other files to
'produce an executable, this does not by itself cause the resulting executable
'to be covered by the GNU GPL.  Your use of that executable is in no way
'restricted on account of using BCX to produce source code that will link the
'BCX library code into it.
'
'This exception does not invalidate any other reasons why the executable file
'might be covered by the GNU General Public License.  This exception applies
'only to the code released with this BCX explicit exception. If you add or copy
'code from other sources, as the General Public License permits, the above
'exception does not apply to the code that you add in this way.
'
'To avoid misleading anyone as to the status of such modified files, you must
'delete this exception notice from them.  If you write modifications of your
'own for BCX, it is your choice whether to permit this exception to apply to
'your modifications.

'This program is distributed in the hope that it will be useful, but WITHOUT
'ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY  OF MERCHANTABILITY OR FITNESS
'FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
'
'You should have received a copy of the GNU General Public License along with
'this program; if not, write to the Free Software Foundation, Inc.,
'59 Temple Place - Suite 330, Boston, MA  02111-1307, USA or visit
'http://www.gnu.org/copyleft/gpl.html#SEC1


$COMMENT - Comment section added 10/20/2004 05:00AM by Vic McClung
*******************************************************************************
Developer Guidelines
*******************************************************************************
Code should be written in BCX Basic. If it can not be written in BCX Basic for
some reason or results in code that seems too inefficient then this may be a
cue that a new Basic function is needed.

* All KEYWORDS should be capitalized
* Use two space indentation
* Use spaces not tabs
* Record all notes in reverse chronological order
* When adding a runtime function please enclose it as described below:
* The first line of code should be formatted as follows, that is the
* first line should be type name ( param1, parm1, ....)
* for example:
* FPRINT Outfile,"int Eof(FILE* stream)"
* DO NOT split the line!
* second line should only cantain the opening bracket, for example:
* FPRINT Outfile,"{"
* there should be no space between Outfile and the comma and no space
* between the comma and opening double quote, just like the example below:
*

IF Use_Eof THEN
  Add this line--->  IF Use_Library THEN FPRINT Outfile,"// BCXRTLIB: Eof"  <---- name of file used in RTL (Eof.c or Eof.cpp)
  FPRINT Outfile,"int EoF (FILE* stream)"
  FPRINT Outfile,"{"
  FPRINT Outfile,"  register int c, status = ((c = fgetc(stream)) == EOF);"
  FPRINT Outfile,"  ungetc(c,stream);"
  FPRINT Outfile,"  return status;"
  FPRINT Outfile,sENDBCXRTLIB$
END IF

* The last line of code in the function should be:
* FPRINT Outfile,"}\n\n"
* When adding a runtime procedure, include in the UseAll subroutine: Use_Eof = TRUE
* This enables creating the runtime library without writing a full-fledged parser to do it.
* And most importantly....Have fun!

*****************************************************************************************
    This section is used to communicate to-do's, changes, ideas, suggestions, etc.
*****************************************************************************************
* Fix List - not a problem for now but will be later
*     SET VarTypeLookup[] AS CHAR PTR
*       "int", "int", "char *", "double", "float", "FILE *", "long double"
*     END SET
*   emits
*     static char* VarTypeLookup[]=
*   should emit (the const should be applied even if not present)
*     static const char* VarTypeLookup[]=
*
* Fix this warning message (should only show for dynamic types)
* Warning("Local dynamic variables are automatically freed.", 1)
*
* Reduce complexity of following functions/sub in order from highest complexity
*   to least to reduce the intoduction of bugs when new features are added.
*   TokenSubstitutions
*   RunTimeFunctions
*   SetUsed
*   SetFlags
*   Emit_ControlFlow                    - can be split into separate functions
*   FixUps
*   main
*   XParse
*   Emit_OtherProcs                     - can be split into separate functions
*   Library_Support                     - with rewrite of assembling of final file may eliminate most of this code
*   BCX_COM_Parse_GetProperty
*   BCX_COM_PREBUILD_PARAMETER_LIST
*   DimVar
*   SpecialCaseHandler
*   GetVarCode
*   GetVarTypeName
*   Emit_GUIProcs                       - can be split into separate functions
*   Find_COM_statement
*   PrintWriteFormat
*   ComParamType
*   Emit_CPP                            - can be split into separate functions
*   EmitIfCond
*   Emit_FileIOProcs                    - can be split into separate functions
*   EmitOld
*   MakeDecProto
*   Transforms
*   JoinStrings
*   BracketHandler
*   Emit_FuncSub
*   StripCode
*   Emit_ArrayProcs                     - can be split into separate functions
*   Emit_Dynamic                        - can be split into separate functions
*   ProcessSetCommand
*   SplitLines
*   Emit_Shared_Global
*   GetParameter



* New features to add - Wayne Halsdorf
*   Reason: To allow multiple data sets
*     BEGIN DATA <dataname>  / END DATA
*     READDATA(<dataname>,<stringholder>)       return 0 with stringholder$ = "" if past end of data
*     RESETDATA(<dataname>,<N>)                 reset the counter for the DATA statement to N
*   Reason: To take advantage of jump table to reduce code size and execution time
*     C/C++ switch/case<break>/default statement structure
*   Extended strings E"text here"
* Enhance printer functions - (Started 4/06)
'=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
'==============================================================================
'changes for 9.2.5.9
' removed register
'==============================================================================
'changes for 9.2.5.8
'  01/23/2017
'    update FindInType to handle unicode. It's in the parsing of the basic source
'    not the RTL function
'==============================================================================
'changes for 9.2.5.7
'  01/10/2017
'    added const to ansitowide  
'    did a bit of tweaking on OpenFile And LineInput
'  12/20/2016
'    added Use_TCLib to KILL for DeleteFile 
'  12/06/2016
'    added BC9_HANDLE_MSG
'  11/26/2016
'    attempt to add dpi awareness
'    use DPI instead of PIXEL in GUI "classname",DPI|PIXELS
'==============================================================================
'changes for 9.2.5.6
'  10/29/2016
'    added ReadBufferSize = 2048 For LineInput
'  10/13/2016
'    added for TCLib :
'	   FPRINT FP_WRITE,"FILE* stdin;"
'	   FPRINT FP_WRITE,"FILE* stdout;"
'	   FPRINT FP_WRITE,"FILE* stderr;"

'  10/07/2016
'    adding an fPrints for fstring with char passed as parameter
'  10/03/2016
'    added -nfs for No fred string to see how much it reduces size
'  09/22/2016
'    for VAL using TCLib changed atof -> _atof
'  09/20/2016
'    added code in docppfixup to change % d -> %d  in a printf statement
'  09/09/2016
'    need to create compatible UNICODE source especially for wstring usage.
'    no default std::string functions if using unicode
'==============================================================================
'changes for 9.2.5.5
'------------------------------------------------------------------------------
'  08/23/2016
'    added #include <uxtheme.h> and uxTheme.lib to includes
'    added #include <psapi.h>
'    added #include <shlwapi.h> and shlwapi.lib to includes
'------------------------------------------------------------------------------
'  08/10/2016
'    fPrintS and LineInput for fstring want a pointer 
'      pass address:
'         Raw As fstring sTmp
'         sTmp = "abc"
'         fPrintS(hFile,&sTmp)			
'		  LineInput(hFile,&sTmp)
'       or just pass itself if created with new
'       Raw As fstring Ptr spTmp = new fstring("Hello There")   
'       fPrintS(hFile,sTmp)		
'------------------------------------------------------------------------------	
'    for fstring OpenFile append an "*" to the file name if it was created with "new"
'    as in:
'      Raw As fstring Ptr sFile = new fstring("db01.dat")
'      OpenFile sFile* For OutPut As hFile
'     DO NOT use the "*" in this case:
'	    Dim As fstring sFile = "db01.dat"
'       OpenFile sFile For OutPut As hFile
'==============================================================================
'changes for 9.2.5.4
'  08/07/2016
'    added new SysStr for c++ UNICODE
'    added bNew(bstr) for BSTR's -> SysAllocString(bstr)
'    added bLen(bstr) for BSTR's -> SysStringLen(bstr) 
'    added bFree(bstr) for BSTR's -> SysFreeString(bstr)
'  08/05/2016
'   adding an iif template for c++ 
'==============================================================================
'changes for 9.2.5.3
'  08/05/2016
'    Because of the new CLASS_METHODS_START CLASS_METHODS_ENDS it is possible
'    to use and pick up reserved words as in Sub Center(...) for CWindow
'    best not to use reserved words but I added a hack to make sure center was
'    first word with iMatchLft.
'  07/31/2016
'     fixed an issue with astyle changing _X( to _X (  with a hack in DoCppFixUps
'------------------------------------------------------------------------------
'  07/29/2016
'    changed itoa to _itoa in bin
'------------------------------------------------------------------------------
'  bracketed SYSSTR code with UNICODE AWARE
'  need a method to not include code unless we have a USE_xxxx
'  I want a system similar to Pb dead code removal of Fb PRIVATE Functions
'  It appears to be working ??:)
'  add a space separated list of names using the the Directive: $USE 
'  $USE USE_bc9FileSaveDialog USE_bc9FileOpenDialog
'  wrap the func/subs with 
'  $IFUSE USE_bc9FileSaveDialog
'  Function bc9FileSaveDialog()
'  End Function
.  $ENDUSE
'==============================================================================
'changes for 9.2.5.2
'  Added CLASS_METHODS_START CLASS_METHODS_END to wrap Class method code.
'  CLASS_METHODS_START MyClassName
'     Function MyFunction(a As int) As Long
'	      Function = 122
'     End Function
'  No need for the MyClass:: as in  Function MyClass::MyFunction1(a As int) As Long
'==============================================================================
'changes for 9.2.5.1
'  07/22/2016
'    added USE_ZTRACE and $ZTRACE directive to #include ztrace.h.
'    #include ztrace.h is added right after #include <windows.h>
'    $ZTRACE is picked up in DoJcfStuff. 
'  05/24/2016
'     modified functions passed fstrings from ref to ptr including OpenFile
'     added fPrintS for char*
'  05/23/2016
'   added fix in DoCppFixUps for the translation of Function ZVectorBuffer::size()const As int
'   it translated to:
'     int ZVectorBuffer::size (int )) const
'    It probably could be fixed in the actual parsing but ......
'    Now it outputs the correct syntax:
'      int ZVectorBuffer::size () const
'  05/20/2016
'    adding winapi functions for crt get/getc/put/seek
'      already have OpenFile which was added for TCLib but can be used generically
'      new functions FGet,FGetC,FPut,FSeek
'==============================================================================
'changes for 9.2.5.0
'  05/19/2016
'    added fprintS for TCLib fstrings to asci txt file
'    added LineInput for TCLib fstrings
'  05/17/2016
'    changed many If UseCpp to If UseCpphdr for TCLib use.   
'==============================================================================
'changes for 9.2.4.9
'  04/04/2016
'     removed UseFlag from Exist
'  04/03/2016
'    added more support for TCLib
'  03/30/2016
'    issues when trying to use char in a ULEXed UNICODE app.
'    adding:
'    //<---UNICODE AWARE
'	typedef char _char;
'	#define _strlen strlen
'   //>---UNICODE AWARE
 
'  03/29/2016
'    Add Pause For TCLib
'  03/28/2016
'    more changes for TCLib usage
'      need to eliminate parameters in main() Done
'      need to eliminate g_argc, g_argv  use  Done
'    Revert to code prior to this fix in 9,2,4,0
''      Try fo fix DYNAMIC deallocation not added in Function main() where it is added
'        in Sub main()
'          02/11/2016
'      A     dded Robert's Fix in Emit_EndFuncSub

'==============================================================================
'changes for 9.2.4.8
'  03/25/2016
'    added WaitKey back for TCLib translates to getchar()
'    add -tcl option for Fred's TCLib
'  03/24/2016
'    removed WAITKEY
'------------------------------------------------------------------------------
'  tracking down issues with dynamic dll loading code generation
'  changed the definition of zTrace in $HEADER AGAIN. I compiled it and
'  pretty sure 32bit IS stdcall
'==============================================================================
'changes for 9.2.4.7
' I thought the adding of double returns was fixed but apparently not.
' uncommented code in cppfixups to re-fix
'==============================================================================
'changes for 9.2.4.6
'  03/12/2016
	'changed 'FPRINT FP_HDR,"#ifndef HANDLE"
	'To
    '  FPRINT FP_HDR,"#ifndef _WINDOWS_"
'
    ' I cannot remember why I added -p. Maybe for support
    ' of $NOAPI directive which is really moot as these 
    ' values need to be set before any parsing of the source
    'I added this in main
'    IF szTmp$ = "-x" THEN
'    	UseWinApi = FALSE
'    	WinHeaders = FALSE
'    End If
'------------------------------------------------------------------------------
'  03/07/2016
'    new bc9 data types bc9char, _char, cchar which represent a char in c/c++
'    Dim As _char cc
'    cc = "'A'"  or cc = E"\'A\'" or cc = E"'A'"
'    reason for this is bc9/bcx treated single chars as strings.  
'  03/04/2016
'    reformatted the DimVar Sub. I really hate single line If statements
'    first attempt failed %s -> %c if vt_CHAR
'    more work in PrintWriteFormat
' 
'==============================================================================
'changes for 9.2.4.5
'  03/11/2016
'  added FPRINT FP_HDR,"#ifndef HANDLE" for use with no win where windows.h is
'  #included in basic source
'  03/09/2016
'   changed the definition of zTrace in $HEADER
' 03/04/2016
'   changed the code from below to
'    sLine = Replace(sLine,"% ","%")
'------------------------------------------------------------------------------
' 03/03/2016
'   added this to cppfixups. waiting on reply from Robert on why there is space 
'   between % and d.
'    If iMatchLft(LTrim$(sLine.c_str()),"printf") Then
'      sLine = Replace(sLine,"% d","%d")
'    End If
'
'------------------------------------------------------------------------------
'changes for 9.2.4.4
' change return value from BOOL to INT_PTR on DlgCallBack
' removed AddLibrary("olepro32.lib") from SUB Emit_Pragmas()
'==============================================================================
'changes for 9.2.4.3
'Now it should be 9.2.4.3 in git
'------------------------------------------------------------------------------
'  02/26/2016
'    This got saved as 9.2.4.2 in git
'    added typedef int BOOL;
'    for no win include
''------------------------------------------------------------------------------
'  02/25/2016 
'    Did a full wholesale replacement of DimVar with BCX 7.2.7 version
'    found a difference with BCX 7.2.7 and bc9 in Sub DimVar 
'    getting = {0} added when var is already initialize v% = 0
'==============================================================================
'changes for 9.2.4.2
'  02/23/2016
'    added request for command line -m ($SOURCE)
'       If szTmp$ = -m Then SrcFlag = TRUE
'==============================================================================
'changes for 9.2.4.1
'  02/22/2016
'     changed
'       FPRINT FP_WRITE,"            *(((int *)vp)) = 0;"
'     To
'       FPRINT FP_WRITE,"            *(((void **)vp)) = NULL;"
'     in Createarr. thanks to PellesC moderator frankie
'------------------------------------------------------------------------------
'  02/20/2016
'    It appears DYNAMIC arrays are fixed even for REDIM
'    thanks to PellesC moderator frankie
'------------------------------------------------------------------------------ 
'  02/18/2016
'  working on the frankie DYNAMIC array fix
'==============================================================================
'changes for 9.2.4.0
'  Try fo fix DYNAMIC deallocation not added in Function main() where it is added
'  in Sub main()
'    02/11/2016
'      Added Robert's Fix in Emit_EndFuncSub
'==============================================================================
' 9.2.3.9 got save as 9.2.3.8 in git 
'==============================================================================
'changes for 9.2.3.9
'  01/31/2016
'    need to scan for <windows.h>
'    well it was already done but the #defines/typedefs are added in main so
'    they needed to be removed in CppFixUps.
'==============================================================================
'changes for 9.2.3.8
'  01/12/2016
'    change C++ compiler defines when created STDCALL DLL
'==============================================================================
'changes for 9.2.3.7
'  Added more #defines/typedef for data types needed with NoWinApi
'  specifically for 64 bit tcc
'	typedef void *PVOID;
'	typedef PVOID HANDLE;
'	typedef HANDLE HINSTANCE;
'	#define WINAPI __stdcall
'	#define APIENTRY __stdcall

'==============================================================================
'changes for 9.2.3.6
'  11/18/2015
'    added
'      FPRINT FP_WRITE,"  typedef std::wstring wstdstr;"
'  11/04/2015
'    added $EXTC directive for use with c++ translations which adds extern "C" to sub/functions
'    it is a toggle on/off
'==============================================================================
'changes for 9.2.3.5
'  10/07/2015
'     added text stating library creation was not available for bc9Basic
'  10/01/2015
'    choose appears to be working
'      retval = choose([BIT | BITS [delim]] Index,var1,var2,.... [ELSE elseval])
'  09/28/2015
'    more choose refinements

'==============================================================================
'changes for 9.2.3.4
' 09/28/2015
'   added rtrim$ for wstring .The way bc9 is configured now it appears it's all
'   or nothing with UNICODE or NOT ?
'   choose is still a work in progress but close
'------------------------------------------------------------------------------
'  09/25/2015
'    adding Choose function ala PB

'==============================================================================
'changes for 9.2.3.3
'  09/25/2015
'    updated stripping of zero re 9.2.1.9
'    'binary assingment now works
'    i = 0b00000000000000000000000000000010
------------------------------------------------------------------------------
'    add BIT twiddleing
'    added bit function to test if a bit in an integer is set
'      if bit(var,bitNum) Then ....
'        c++ translation uses bc9_bit to prevent possible duplicate names
'    added BIT [SET | RESET | TOGGLE] intvar,bitNumber (0-31) for integers
'==============================================================================
'changes for 9.2.3.2
'  09/25/2015
'    Added typedef unsigned char BYTE; when using $NOAPI (-p)
'  09/14/2015
'    changed stricmp to _stricmp in ContainedIn
'  09/11/2015
'    adding new extract$ for std::string
'    I don't think this is needed Removed
'==============================================================================
'changes for 9.2.3.1
'  09/04/2015
'    did another mod on line input
'  09/03/2015
'    added
'    Function FileScan(filename$,Byref LineCount As Integer ,Byref LongestLine As Integer) As Integer
'      Pass it the file name and the address of two integers for linecount and longest line
'==============================================================================
'changes for 9.2.3.0
'  09/02/2015
'    Fixed I think
'    rework line input again and use a string for BufferSize instead of an integere
'==============================================================================
' changes for 9.2.2.9
'  09/01/2015
'     IsPtr throws a warnibg under 64 bit
'       changed
'         FPRINT FP_WRITE,"#define IsPtr(a)((DWORD)a)"
'       To
'         FPRINT FP_WRITE,"#define IsPtr(a)((LPSTR)a)"
'------------------------------------------------------------------------------
'   08/28/2015
'     No changes from 9.2.2.7
'------------------------------------------------------------------------------
'
'==============================================================================
'changes for 9.2.2.8
'  DO NOT USE. Wild goose chase but decided to leave in git
'==============================================================================
'changes for 9.2.2.7
'  Trying Robert's modification for 08/11/2015 change in 9.2.2.6
'  Fixed the =0=0 in DimSubFunc instead of cppfixup'
'==============================================================================
'changes for 9.2.2.6
'  08/12/2015
'    In AssembleParts swapped the order
'      CALL User_Defined_Types_And_Unions(FP_W)
'      CALL SYSTEM_VARIABLES(FP_W)
'    To
'      CALL SYSTEM_VARIABLES(FP_W)
'      CALL User_Defined_Types_And_Unions(FP_W)
'      problem with classes using system variables because the classes appear before
'      the system variables.
'  08/11/2015
'    In Emit_FuncSub return type was stripped from class methods (sub/func)
'    if the method started with the same name as the class. May be left over
'    from time before Constructor/Destructor?? I removed it.
'  08/10/2015
'    virtual Sub Draw() = 0 is translated to virtual void Draw(void) = 0 = 0;
'    actually it is translated to virtual void Draw(void)=0=0;
'    astyle adds the spaces
'    will use cppfixup to correct DONE
'==============================================================================
'changes for 9.2.2.5
'  while RemoveExt$ was added to the translator it was never added to the RTL
'  I changed all references and function name in bc9 source to RemoveExtension$
'  in anticipation of adding RemoveExt$ to the RTL. I then discovered the
'  BCXSplitPath$ using FNAME accomplishes the same thing.
'  May use this version for a ReplaceAny$ function.
'==============================================================================
'changes for 9.2.2.4
'  astyle pads all operators with spaces. I don't remember why I need this but it
'  breaks code for declaring functions in dll's with operators in their names
'  ex: gtk-3.0
'  fixed 08-03-2015
'==============================================================================
'changes for 9.2.2.3
'  Use extended literal E"\'{\'" for c++ single quoted characters. DQ removed
'  in Docppfixups. This is for situations where you NEED a '{' literal translation.
'  using asc("{") works in some situations but not all
'  Added SQNLSQ (single quote,New Line,single quote) will be relaced with '\n'
''==============================================================================
'changes for 9.2.2.2
'  add $A for $ONEXIT to represent the directory where bc9 is located
'  fixing _true _false replace using regex it was flagging gtk_false
'==============================================================================
'changes for 9.2.2.1
'  06/09/2015
'    changed:
'    FPRINT FP_WRITE,"  if(CreateProcess (NULL,Cmdline,NULL,NULL,FALSE, NORMAL_PRIORITY_CLASS,NULL,NULL,&si,&pi)==0)"
'    To
'    FPRINT FP_WRITE,"  if(CreateProcess (NULL,(LPSTR)Cmdline,NULL,NULL,FALSE, NORMAL_PRIORITY_CLASS,NULL,NULL,&si,&pi)==0)"
'    In Run code generation
'  05/30/2015
'    added #define overloaded"
'==============================================================================
'changes for 9.2.2.0
'  reworking line input
'  I did not have to do much. See 9.1.5.3 changes
'    I had everything in place but did not fully document it.
'    There is a third optional parameter to file LINE INPUT. The Maximum number
'    of characters to read. With the latest port to linux I was getting big WARNINGS
'    LINE INPUT fp1,a$,1024
'==============================================================================
'changes for 9.2.1.9
'  05/18/2015
'    changed .C extension to .c
'  05/17/2015
'    fixed the stripping of zero preceeding a decimal point in TokenSubstitution Sub
'      CONST DEF_WIDTH = 0.03
'      was translated to
'      #define DEF_WIDTH .03
'      Changed this
'      IF *Stk[Tmp] = ASC("0") AND NOT iMatchWrd(MID$(Stk$[Tmp],2,1),"x") AND NOT iMatchWrd(MID$(Stk$[Tmp],2,1),"l") THEN
'      To This
'      IF *Stk[Tmp] = ASC("0") AND NOT iMatchWrd(MID$(Stk$[Tmp],2,1),"x") AND NOT iMatchWrd(MID$(Stk$[Tmp],2,1),".") AND NOT iMatchWrd(MID$(Stk$[Tmp],2,1),"l") THEN
'------------------------------------------------------------------------------
'  05/16/2015
'    investigating -nix and fltk
'    need to supress conio.h for -nix (DONE)
'------------------------------------------------------------------------------
'  05/14/2015
'    issues with run. need to surpress when precedded by double colon ::
'    fixed!
'==============================================================================
'------------------------------------------------------------------------------
'changes for 9.2.1.8
'  05/06/2015
'    added code to supress including urlmon.h for tiny c
'  05/04/2015
'    added BC9_HCenterCtrlOnDialog and BC9_VCenterCtrlOnDialog for centering a control
'     on a dialog in Horizonal and Vertical directions
'     parameters HWND of Control, HWND Of Dialog
'  05/03/2015
'    added BC9_Tab and support BC9_TabPage
'    updated bc9_status
'  05/02/2015
'    Added Global Use_BC9Tab
'    In System Defined Constants added
'		If Use_BC9Tab Then
'			FPRINT FP_WRITE,"#ifndef IDC_TAB_STATIC"
'			FPRINT FP_WRITE,"    #define IDC_TAB_STATIC 12345"
'			FPRINT FP_WRITE,"#endif"
'		End If
'    The static control is needed for the tab background when using an XP manifest
'  05/01/2015
'    added BC9_Control
'  fix problem with bc9_dlgshow. 0 had been hard coded as Parent instead of using
'  hParent
'==============================================================================
'changes for 9.2.1.7
'  03/31/2015
'    Removed 9.2.1.6 change on 03/31/2015 in EmitOld
'==============================================================================
'changes for 9.2.1.6
'  03/31/2015
'    changed
'      IF Stk$[A]= "&" AND Stk$[A-1] <> "," AND Stk$[A-1] <> "(" THEN
'    To
'      IF (Stk$[A]= "&" OR Stk$[A]= "+")AND Stk$[A-1] <> "," AND Stk$[A-1] <> "(" THEN
'    In EmitOld to fix string concat error
'------------------------------------------------------------------------------
'  03/30/2015
'    I'm not sure how $LIBERROR is to be used. It appeared broken so I removed it's
'    functionality in CheckForMain and added dll/process fail code
'------------------------------------------------------------------------------
'  03/28/2015
'    problems handling  windowsx,h HANDLE_MSG
'==============================================================================
'changes for 9.2.1.5
'  03/27/2015
'    added #define CTLHNDL(id) GetDlgItem(hWnd,id)
'  03/24/2015
'    added Robert's BCX_Thread fix
'==============================================================================
'changes for 9.2.1.4
'  Any library routine that uses BCX_DynaCall, BCX_DynaCallA/B fails under 64 bit because
'  they use assembler.
'  Added new Download function that works with both 32 and 64.
'  Note: BCX_Thread and its variants not supported in 64bit
'==============================================================================
'changes for 9.2.1.3
'  03/18/2015
'    added join fix from bcx 7.1.9
'      Added AmpCnt varaiable and moved Use_Join in SUB FixUps
'==============================================================================
'changes for 9.2.1.2
'  03/07/2015
'    Making the bc9_Dialog controls more compatable by default with Jeffrey Richter's
'    Layout
'==============================================================================
'changes for 9.2.1.1
'  03/05/2015
'    changed $FILETEST default to FALSE
'  03/04/2015
'    changing default StyleEx to -1  -> client edge on some controls
'  03/02/2015
'    bc9_Input done
'    bc9_Edit done
'    bc9_Listbox done
'==============================================================================
'changes for 9.2.1.0
'  frankie posted a generic patch for PellesC and _msize so removing code added
'  in 9.2.0.9. adding  #includes for  patch files
'==============================================================================
'changes for 9.2.0.9
'  03/01/2015
'    change BCX_DLGWIN to BC9_DLGWIN
'  02/18/2015
'    Added These #includes for no includes when using bc9_XXX.... gui functions
'      #include <windows.h>
'      #include <commctrl.h>
'      #include <richedit.h>
'      #include <wchar.h>
'      #include "Win95ADG.h"
'      #include "DlgTmplt.h"
'      #include "DlgTmplt.c"
'    and these libs when using VS12 and PellesC
'      #pragma comment(lib,"kernel32.lib")
'      #pragma comment(lib,"user32.lib")
'      #pragma comment(lib,"gdi32.lib")
'      #pragma comment(lib,"comctl32.lib")
'      #pragma comment(lib,"winmm.lib")
'      #pragma comment(lib,"comdlg32.lib")

'  02/16/2015
'    added code provided by PellesC forum member frankie to allow PellesC to work
'    with the Jeffrey Richter Dynamic Dialog Box template toolkit functions
'  02/15/2015
'    did a lot of hacking in EmitProlog to get includes and VC libraries  when using
'    "no includes" to translate. The reason behind this was to get 64bit Tiny C working
'    using the new bc9_xxxx gui functions.
'    These are added automatically:
'       #include <windows.h>
'       #include <commctrl.h>
'       #include "Win95ADG.h"
'       #include "DlgTmplt.h"
'       #include "DlgTmplt.c"
''------------------------------------------------------------------------------
'  02/14/2015
'    changed bc9_DlgShowModal and bc9_DlgShowModeless to use ...IndirectParam
'
'==============================================================================
'changes for 9.2.0.8
' 02/14/2015
'     Added BC9_Input single line edit control
' 02/10/2015
'    a little hacking with command line options in main to make  it
'    compatible with FbEdit sending otions before file name
'------------------------------------------------------------------------------
'changes for 9.2.0.7
'  Added replacements for some of the BCX_xxx controls for use with dialog template code
'    BC9_Button
'    BC9_Checkbox
'    BC9_Group
'    BC9_Combobox
'    BC9_BlackRect
'    BC9_GrayRect
'    BC9_WhiteRect
'    BC9_DatePick
'    BC9_Edit
'    BC9_Label
'    BC9_Listbox
'    BC9_Listview
'    BC9_Bitmap
'    BC9_Icon
'    BC9_Radio
'    BC9_RichEdit
'    BC9_Status
'------------------------------------------------------------------------------
'changes for 9.2.0.6
' 02/02/2015
'  Added BC9_Dialog  (creates template)
'  Added BC9_DlgShow (creates modeless dialog)
'  Added BC9_DlgShowModal (creates modal dialog)
' adding true Dialog template using Jeffrey Richter Dynamic Dialog Box template toolkit functions.
' BC9_xxx
'------------------------------------------------------------------------------
'changes for 9.2.0.5
' compliment to BC9_DIALOG using resource dialogs
'
' BC9_RESDLG(id,Callback Proc,optional hparent,optional LPARAM) -> modeless
' created with CreateDialogParam

' BC9_RESMDLG(id,Callback Proc,optional hparent,optional LPARAM) -> modal
'created with DialogBoxParam
'------------------------------------------------------------------------------
  01/27/2015
    'added BC9_MsgPump()
'------------------------------------------------------------------------------
'  01/24/2015
	'these changes were made to use BEGIN [DIALOG] [MODAL DIALOG] with resource
	'and Richter template dialogs.
	'added If Use_BCXDialogCommon Then wrapper in SpecialCaseHandle
	'jcfuller 01/24/2015
	'If Use_BCXDialogCommon Then
	'  CALL AddExpressionToStack("SetDialogScale(hWnd,0)")
	'End If
	'------------------------------------------------------------------------------
	'commented out in TokenSubsitutions -> CASE "dialog"
	'This might break code???
	'jcfuller changed 01/24/2015
	  'Use_BCXDialogCommon = TRUE
'==============================================================================
'changes for 9.2.0.4
'01/19/2015
' added ability to use BEGIN EVENTS callBack with resource dialog with class
' Added option to GUI
'GUI "classname" [,PIXELS, ICON, ResInt%,MENU,ResMenuId%,DLG,Callback Proc name]
'GUI "classname",DLG,cbProc
'Resource Dialog window -> BCX_DLGWIN(dialog resource id)
'The resource dialog must use the same "classname" as in the GUI statement
' The BEGIN EVENTS must use the Callback Proc name
'==============================================================================
'GUI "DialogTest",DLG,cbProc
''==============================================================================
'GLOBAL Form1 As CONTROL
'CONST DLG_ID = 1000
''==============================================================================
''Create a standard window using a resource script passing the id of the dialog
''==============================================================================
'Sub FormLoad
	'Form1 = BCX_DLGWIN(DLG_ID)
'End Sub
''==============================================================================
'BEGIN EVENTS cbProc
	'Select Case CBMSG
		'CASE WM_CLOSE
			'DestroyWindow(CBHWND)
		'CASE WM_DESTROY
			'PostQuitMessage(0)
	'End Select
'End Events
'==============================================================================
'------------------------------------------------------------------------------
'changes for 9.2.0.3
' need wstring functions (not done)
  12/29/2014
'    removed the (void) -> () code in DoCppFixUps
'------------------------------------------------------------------------------
'changes for 9.2.0.2
'  want to be able to translated .bi -> .h
' add a IsBiFile flag.
' still a work in progress
'==============================================================================
changes for 9.2.0.1
  check for "#include <windows.h>" in header and not emit typedefs
  revist prepend ??

'==============================================================================
changes for 9.2.0.0
	11/25/2014
		added #define EQU == to	system defined constants
	11/22/2014
	  SHAREDSET was  parsing "::" as CHR$(15)CHR$(15)
	  Did a hack in cppfixup
	11/11/2014
	  adding support for Visual Studio 2013 Community mfc
'==============================================================================
changes for 9.1.9.2
    $PRJUSE work
changes for 9.1.9.1
	changing crt #includes if using c++
	<stdio.h> -> <cstdio>
'==============================================================================
changes for 9.1.9.0
' ????
'==============================================================================
changes for 9.1.8.9
    fixed _switch, _case, _default again
'==============================================================================
'changes for 9.1.8.8
   adding more wxWidget code to match ubxWx
   need to have an application class. It will use the name following $WXG or $WXC
   bc9 will create the class but you must have an OnInit() method/function
   If you do not supply an application class name "MyApp" will be used.
   $CPP and $NOMAIN are implemented by use of $WXG | $WXC as are a number of wx #includes.
   You still seed to add $HEADER #includes for specific items re: wxnotebook,wxgrid ....
   item changed in OktoUsememset (?)
'==============================================================================
changes for 9.1.8.7
  05/10/2014
    adding code for partial c++ switch/case
    use _switch and _case
    for now need BeginBlock/EndBlock
       _switch(choice)
       BeginBlock
         _case 1
           do case 1 stuff
           break
         _case 2
           do case 2 stuff
           break
         _default
           do default stuff
       EndBlock
  03/10/2014
    adding command line option to clean up output
    not sure how to do it yet.
    Added code for wxWidget's.
      command line options -wxc and -wxg
changes for 9.1.8.6
  2/22/2014
      added code for unicode support in cppfixups
      need to use extern "C" for _tmain but ULEX wanted to _T() the "C"
      wrapped the "C" with _X("C") for now. Looks strange but ....
      added #define _X(y) y to fool ULEX
      Need to use Function _tmain for unicode console apps

  trying to find a place for PCHAR
  for now it's at ~ line 4785

'==============================================================================
changes for 9.1.8.5
  2/3/2014
    Added code to DoCppFixUps to eliminate space before dot
	  " ." -> "."

  1/18/2014
    commented out the whole section in EmitProlog
	problem with location of:
	// ***************************************************
	// types from winapi that may be needed
	// ***************************************************
	when there are no includes. Needs to be moved down after $HEADER code
	may do it in DoCppFixUps.
'==============================================================================
changes for 9.1.8.4
  changed containedin proto and parameters back to const

'==============================================================================
changes for 9.1.8.3
  12/12/2013
    Found problem with $PROPS introduced in 9.1.8.0 and corrected in DoJcfStuff
    reverted to 9.1.7.1 code
'==============================================================================
changes for 9.1.8.2
  12/10/2013
    on further investigation the c++ CALLBACK is a MACRO for __stdcall defined
    in windef.h so the use uf bc9 STDCALL will subsituted just fine.
    Removed from DoCppfixups.
  12/05/2013
    bad translation of:
     Sub CCTest::printNumber() const
     fixed in DoJcfStuff
'==============================================================================
changes for 9.1.8.1
  12/03/2013
    Added code to handle virtual destructor as in:
		Destructor ~Window() As virtual
		End Destructor

  12/02/2013
    added this to DoCppfixups:
		If Instr(sLine," _CALLBACK") Then
			sLine = Replace(sLine," _CALLBACK"," CALLBACK")
		End If
    CALLBACK is a bc9 reserved word

    working on bc9Project code
'==============================================================================
changes for 9.1.8.0
  11/21/2013
	another hack to get the Dim to translate correctly. I could not find the relevent code so I hacked away
	I already have a major hack for the () and [] operators.
	Class my_visitor inherits boost::static_visitor<int>
		public:
			Dim Function operator() (i As int) const As int
			Dim Function operator() ( str As const stdstr Ref) const As int
	End Class
	To
	class my_visitor: public boost::static_visitor<int>
	{
	public:
		int   operator()(int) const ;
		int   operator()(const stdstr&) const ;
	};


    The problem was the const was not put in the correct place
  11/16/2013
	removed old depreciated auto
	It's a real hack as I had code to use _auto but now both _auto and auto should work
	also don't use _auto_ in your app as it's an internal reserved word.
'==============================================================================
changes for 9.1.7.1
	fixed $COMMENTS block to not write to c/c++ file. Use $REMS to add comments to c/c++ file
'==============================================================================
changes for 9.1.7.0
  11/09/2013
    added -xorig to command line for supressing the deletion of ASTYLE's backup file
    added:
    #ifdef UNICODE
      typedef std::wstring _string;
    #else
      typedef std::string _string;
    #endif

  11/07/2013
    another hack in docppfixups to fix an added space
    " ->" To "->"
    For i = 0 To parray->rgsabound[0].cElements -1
    translated to
    for(i=0; i<=parray ->rgsabound[0].cElements-1; i+=1)
'==============================================================================
changes for 9.1.6.9
  11/04/2013
    added shell to ASTYLE -p to format source
    removed the fixups for << >> added in 9.1.6.7 ASTYLE fixes it.
    added #define _X(y) y
      for use with literal ansi strings in a unicode source with ulex and -u
      Raw As stdstr ss = _X("abcd")
      added code to ULEX so it is now possible to mix _T() _X() and L"
      in a single source.
  11/03/2013
    added sscvrt for conversion to/from std:string and std::wstring
      Raw As stdstr ss = "abcd"
      Raw As wstring ws = sscvrt(ss)
      ss = sscvrt(ws)
    added strim$ for std::string/wstring
    added #define scout cout for use with std::string ouput when using
    unicode and ULEX.
  11/02/2013
    added sstr(Number) and wstr(Number) for std::string std::wstring STR$ function
  10/31/2013
     MIN/MAX library code only added if UseCpp = FALSE
  10/30/2013
    added  BCX_HANDLE_MSG
'==============================================================================
changes for 9.1.6.8
  10/30/2013
    removed Watcom and Borland support
    reverted back to my original zeroing of variables using ={0} instead of memset
  10/28/2013
    Wrapped stdstr trim with
      //<---UNICODE AWARE
      //>---UNICODE AWARE
      there may be others that need it.
  10/27/2013
    problems with bc9 built with VS12
    trying to track down issue. maybe a pcre problem? NO
    "FOUND IT". initial compile was done with ver bc9166 instead of bc9131.
'==============================================================================
changes for 9.1.6.7
  10/26/2013
    Added spaces to << and >> in DoCppfixups so ULEX could parse correctly
    Removed call to ULEX from bc9.exe. Use $ONEXIT
    Added a TCHARXLATER_VC.TXT file for VS12 unicode
    Added ULEX command line parameter for TCHARXLATER file. Defaults to TCHARXLATER.TXT

  10/24/2013
  Several If xxx=true items fixed
changes for 9.1.6.6
  10/22/2013
    fixed issue with properties
    added Function = 0 in DoCppFixups
    problems with removal of extra return (regression fix by removal) still need
    a true fix?

'==============================================================================
changes for 9.1.6.5
  10/13/2013
    removed LCC reference in EmitLibs Sub
  10/12/2013
     added code in DoCppFixUps to remove extra return.
  10/10/2013
    MinGW has issues with console UNICODE apps. There appear(?) to be no problems with gui apps
    standard ansi apps are run through Ian/Wayne unicodelexer.
    code added to fix the console unicode problem. See DoJcfStuff
  wchar.h is part of the c/c++ library
=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
changes for 9.1.6.4
  changed
    {1,(char*)"template"               ,(char*)""                      ,1,comvt_BAD},  ' C++ Word
  To
    {1,(char*)"template"               ,(char*)"template"                      ,3,comvt_BAD},  ' C++ Word
  In SET BCXWords[]
------------------------------------------------------------------------------
  add Wayne's BCX 7.0.8 fixes
	Replaced Emit_FuncSub
	Replaced SpecialCaseHandler from BCX 7.0.9
	Updated OSVERSION from Waynes BCX 7.0.8
'==============================================================================
changes for 9.1.6.3
  add optional parameter to InputBox$ for use with a password

'==============================================================================
changes for 9.1.6.2
  add interface/end interface
  reworked output of Function main()[As int]. bc9Basic now outputs:
      int main (int argc,PCHAR* argv)
      {
        g_argc= argc;
        g_argv= argv;
        note: the above are globals available anywhere in your code.
'==============================================================================
changes for 9.1.6.1
  08/18/2013
    Wayne added another fix for the GLOBAL problem
  08/17/2013
    Another Wayne fix for FixAnyArrays(Arg$)
    It fixed the translation of:
    Function grade(midterm As double, final As double,hw As const vector<double>&) As double

    BUT broke translation of: GLOBAL As vector<string> g_tempfiles
    got around it by using:
    CONST VECTOR_STD_STRING = vector<std::string>
    GLOBAL g_tempfiles  As VECTOR_STD_STRING

  08/13/2013
      added clipboard text functions
        ClipboardGetText() As char*
        ClipboardSetText(char*)
        ClipboardGetTextSize() As DWORD


'==============================================================================
changes for 9.1.6.0
  major changes to support templates via Wayne's bc 7.0.7

'==============================================================================
changes for 9.1.5.7
  8/09/2013
    Removed SpecialCaseHandler code added in 9.1.5.6
    From Waynes bcx 7.0.6
      Added:
        FixAnyArrays Sub
      Added to Translate:
        IF UseCpp OR UseCpphdr THEN CALL FixAnyArrays(Arg$)
      Added To EmitMain
        REPLACE CHR$(18) WITH "," IN Stk$[i]

'==============================================================================
changes for 9.1.5.6
  08/06/2013
  'jcfuller added To EmitMain from Wayne's bcx 7.0.5
    REPLACE CHR$(16) WITH "<" IN Stk$[i]
    REPLACE CHR$(17) WITH ">" IN Stk$[i]

    Fixed bcx_dispatchobject using pcre

    added CALL XParse(pp_Src$) in Find_COM_statement per Wayne's addition to bcx 7.0.5

    added code to SpecialCaseHandler from Wayne's 7.0.5 fixup

  08/03/2013
    added
    #define WAITKEY system("pause")
    in System Defined Constants
------------------------------------------------------------------------------
  08/02/2013
    add c++ additions to MakeLCaseTbl
==============================================================================
changes for 9.1.5.5
  07/31/2013
    fixed c++ template. Now needs an AS type where type is the type returned from
    the function.
		template <typename T1,typename T2> As T1
		inline Function tmax( a As T1 const Ref,b As T2 const Ref) As T1
			If a < b Then
				Function = b
			Else
				Function = a
			End If
		End Function

  Changed all calls to BCX_TmpStr to use 1 instead of 128
  Changed BCX_TmpStr declaration to 0 instead of 128 for optional default iPad parameter
==============================================================================
changes for 9.1.5.4
  07/24/2013
    Thanks to Kevin I discovered Mike Hennings InsertOptArg app. I will use it as a replacement
    for cfix.
    This app also adds missing optional parameters so it is now possible to use optional parameters
    in your source.
    I tweaked it a bit.
------------------------------------------------------------------------------
  07/23/2013
    transferred tcc support for LinkRes2Exe to cifx 1.1.7
      #ifdef __TINYC__
        int dummy __attribute__ ((section(".rsrc")));
      #endif
'------------------------------------------------------------------------------
  07/22/3013
    eliminated 256+ decade old kludge in DimDynaString and the realloc and calloc in Emit_OtherProcs

  Another kludge?
  I changed
    FPRINT FP_WRITE,"  if(iAlloc) StrFunc[StrCnt]=(char*)calloc(Bites+128,sizeof(char));"
  To
    FPRINT FP_WRITE,"  if(iAlloc) StrFunc[StrCnt]=(char*)calloc(Bites+1,sizeof(char));"
  For the  BCX_TmpStr function
==============================================================================
changes for 9.1.5.3
	07/20/2013
	fix for buffer overrun and Line input in Emit_FileIOProcs
		In TokenSubstitutions I changed the case "line" to:
		  IF iMatchWrd(Stk$[Tmp+1],"input") THEN
			Stk$[Tmp] = "lineinput"
			Stk$[Tmp+1]=""
			For j = 3 To Ndx
			  IF *Stk$[j] = ASC(",") Then
				Stk$[j]=""
			  END IF
			Next j
			INCR CompPtr
		  END IF

		In Function Emit_FileIOProcs
		Just before the FPRINT statements Near the end of the case "lineinput"
		I added:
		Raw As Integer BufSize=cMaxSrcLen
		If Ndx = 4 Then
		  BufSize = VAL(Stk$[Ndx])
		End If

		I replaced:
		FPRINT Outfile,Scoot$;"fgets(" ; Var$ ; ",";cMaxSrcLen;","; Clean$(Stk$[2]) ; ");"
		With:
		FPRINT Outfile,Scoot$;"fgets(" ; Var$ ; ",";BufSize;","; Clean$(Stk$[2]) ; ");"


------------------------------------------------------------------------------
  07/19/2013
	adding code to create header and c++ source for single file using $PRJ
	added IF Src$ = "Use_Iif" THEN Use_Iif = TRUE to SetUsed Sub
==============================================================================
changes for 9.1.5.2
  07/15/2013
    added $Using directive. Note ";" separates multiple entries on the same line
    $Using std::istream ; using std::vector
------------------------------------------------------------------------------
  07/13/2013
  'Wayne fix  in SUB ProcessSetCommand(GS) 07/14/2013
    VarCode.IsPtrFlag = 0

     added Wayne's FUNCTION JoinStrTest(iStart AS INT, iEarly AS INT) fix

     In Emit_FuncSub
     Added my fix for no user prototypes thanks to Wayne's location of the problem
      changed
        IF INSTR(VarCode.Proto$,"::") = 0 AND IAmNot(InNameSpace) AND IAmNot(InClassModule) AND IAmNot(InPPTypeModule) THEN
      To
        Raw tmp$
        tmp$ = Extract$(VarCode.Proto$,"(")
        IF INSTR(tmp$,"::") = 0 AND IAmNot(InNameSpace) AND IAmNot(InClassModule) AND IAmNot(InPPTypeModule) THEN
------------------------------------------------------------------------------
  07/13/2013
     (This breaks existing c++ code)
     In Emit_FuncSub
     added Wayne's fix for no user prototype emitted from
     Function median(vec As std::vector<double> ) As double
==============================================================================
changes for 9.1.5.1
  07/10/2013
    added RAW As fix from Wayne in Sub DimVar
  added Wayne's fix for throw in Emit_CPP
  adding  Sub CheckForDirectives() to parse for Directives first thing in main
  removed BCXPATH$ = "Not Found" registry code ( I thought I did this ages ago?)
  todo:
  Emit_ConditionalCompilation needs work to remove comments
==============================================================================
changes for 9.1.5.0
	07/05/2013
	  added code in CppFixups to remove TCC specific code in c++ apps
	07/03/2013
	  removed c++ BOOL to bool translation also in iif iif$
	  added translation of _bool to bool. use _bool for c++ bool.
	  Use bool,BOOL,WINBOOL for Windows BOOL
	07/01/2013
	   removed c++  TRUE/FALSE -> true/false translation
	   use _true _false for c++ true false

	   where variable is a BOOL
	   changed all IF variable = TRUE THEN
	   to
	   IF  variable THEN
    06/30/2013
      added code for bool,BOOL in EmitCompilerDefines()
	06/29/2013
	  Added Wayne's fix for SUB BuildDelimStr
	  Added Wayne and Robert's fix for Doccode
	    use with a parameter $CCODE set|header|const|udt|enum|funcsub
	06/27/2913
	  added Wayne's changes for BCX 7.0.3
==============================================================================
changes for 9.1.4.4
	06/21/2013
		remove g_argv and g_argc from a gui app
	06/17/2013
		added a #define cfree free.
		using cfree instead of free eliminates all the warnings.
    06/16/2013
      revised DLGCALLBACK so no "Function = 0" is needed
	06/12/2013
	  Removed the CALLBACK FUNCTION fix. the help file will be updated with correct
	  examples and a revised CALLBACK section

=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
changes for 9.1.4.3
  Fixed CALLBACK FUNCTION generated code in SUB AssembleParts() using BCX 6.73 code


=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
"Note 9.1.4.2 skipped as code added was not needed but decided not to delete from git"
=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
'------------------------------------------------------------------------------
changes for 9.1.4.1
  Changed bc9 to bx9Basic in PRINTS
 doing some testing to fix dll problem with A$[]
  6/06/2013 -> added Wayne's fix for FuncSubDecs1
  6/9/2013
    Changed IF Use_BCX_RegWnd  THEN
      To
            IF Use_BCX_RegWnd OR Use_BCX_InitGUI THEN
    In SUB SYSTEM_VARIABLES

changed
  SUB EmitIfCond OPTIONAL(CondType$, iOutputMethod AS INT, szOut$="")
To
  SUB EmitIfCond OPTIONAL(CondType$, iOutputMethod AS INT, szOut$=0)

changed
  SUB EmitOptimize OPTIONAL(Str1$,Str2$,Str3$="")
To
  SUB EmitOptimize OPTIONAL(Str1$,Str2$,Str3$=0)

Changed
  SUB FuncSubDecs1(s$, iStart AS INT, iEnd AS INT, ptVar AS VARCODE PTR)
To
  SUB FuncSubDecs1(sccp As const char Ptr, iStart AS INT, iEnd AS INT, ptVar AS VARCODE PTR)
    Raw s$
    s$ = (char*)sccp


**********************************************************************
'------------------------------------------------------------------------------
changes for 9.1.4.0
    changed auto to emit C++11 auto
    '----------------------------------------------
    added but forgot to document a DoCppFixUps Sub
    '----------------------------------------------
    Replaced:
      Arg$ = INS$(Arg$, i, " and ")
    with:
      Arg$ = INS$(Arg$, i, " __RVR__ ")
    In XParse Sub to allow usage of &&
    __RVR__ was already employed in the DoCppFixUps Sub
    '----------------------------------------------
    added Robert's ModStyle and SetColor fix from bcx 7.0.1
'==============================================================================
changes for 9.1.3.6
	added zTrace functionality for debugging bc9 use -zt on command line to activate
	added acceptance of c++(11)constexpr as in:
	constexpr static double pi = 3.1415927

'==============================================================================
changes for 9.1.3.5
	added a couple of () in bcx_msgpump to eliminate warning
'------------------------------------------------------------------------------
changes for 9.1.3.4
  added keyword ref to be used just as ptr is used for var references.
   also instead of __RVR__ listed below. use -> ref ref to get &&

changes for 9.1.3.3
   add set_fpu(mode) function
   I decided against adding it for now.
   4/12/2013
   Added __RVR__ as a substitute for C11 RValue Reference "&&"
changes for 9.1.3.2
   add rbFor (range-based for) new for (C11)
   added _auto for the new C11 auto type inference feature
changes for 9.1.3.1
   fix Raw and c++

changes for 9.1.3.0
  to do
    adding std::string procedures
      left,right,mid,ltrim,rtrim,trim,strim,instr,extract,remain,ins,del
      replace,remove,iremove,ireplace
      ucase$,lcase$ has two formats in-place and return
      use ucase$(MyStdStr,1) and MyStdStr wil be uppercased
      or use the traditional way MyStdStr2 = UCASE$(MyStdStr1)

changes for 9.1.2.2
  2013/02/26
    add info for -x
changes for 9.1.2.1
 2013/02/17
    fixed set_color and modstyle to compile for 64 bit

    changed (HMENU)id to (HMENU)(INT_PTR)id in all createwindowex to eliminate
    g++ 64 bit warning

    changed
    FPRINT FP_WRITE,"          int    IsNT;"
    to
    FPRINT FP_WRITE,"          int    IsNT={0};"
    in FindFirstInstance
2013/02/25
    added "typedef const char* ccptr;"
2013 /02/10
  changes for 9.1.2.0
   rewrite BCX_DynaCallB

2013/01/31
  changes for 9.1.1.1
    clean up PostProcess
    added -dll command line switch to supress adding g_argv,g_argc
    2/4/2013 DllMain is not exported
2013/01/29
  changes for 9.1.1.0
  compiler$,linker$,resource$ work in PostProcess.

2013/01/28
    changes for 9.1.0.8 and 9.1.0.9 (both show 9.1.0.9 as version)
    added Robert's $RESOURCE fix
    A number of changes to support source file names with multi periods.
    Only two extensions will now be recognized .bas and .bcx
    Added RemoveExt$ Function which returns a string with it's extension (if any) and periods removed
    still need to clean up the additions
    more work needed on compiler$,linker$,resource$

2013/01/27
    changes for 9.1.0.7
       fixed $FILE$ so any characters added to it ($FILE$__.rc) are within the DQ
2013/01/22
    changes for 9.1.0.6
      changed local dim again to output var={0} instead of memset in DimVar()
      Moved var declartion in EmitOld()
2013/01/21
    changes for 9.1.0.5
    dumped 9.1.0.4 changes and reverted to 9.1.0.3
    eliminate "static" for LOCAL and DIM and fix not zeroing of var's with c++
    This will probably break using LOCAL and DIM in c++ classes but Raw should
    be used there anyway.

2013/01/11
    changes for 9.1.0.3
    more changes to eliminate g++ warnings

2013/01/05
    changes for 9.1.0.2
    massive changes to eliminate all g++ warnings

2013/01/02
    changes for 9.1.0.1
       start of WxWidget support
'------------------------------------------------------------------------------
2013/01/01
    changes for 9.1.0.0
      Compile as a MinGW c++ app
      Added My properties from Bcx8

2012/12/27
    changes for 9.0.4.3
      needs a number of fixes in order to work with bcxrt
      use char *LowCase; instead of static char *LowCase; (done)
      fix menu from resource. Needs a global var: gResMenu (done)
        added BCX_WndClass.lpszMenuName=g_ResMenu; to both BCX_InitGui and
        BCX_RegWnd. Added assignment in WinMain
2012/10/20
    changes for 9.0.4.2
      fixed menu not showing under XP with the revised GUI command
2012/10/19
    changes for 9.0.4.1
      added tcc support for LinkRes2Exe

      #ifdef __TINYC__
        int dummy __attribute__ ((section(".rsrc")));
      #endif

2012/10/16
    changes for 9.0.4.0
    reworked Emit_GUIProcs
      added provisions for a resource menu Id
        GUI "classname" [,PIXELS, ICON, ResInt%,MENU,ResMenuId%]

2012/10/15
    changes for 9.0.3.2
    added code so could use EZ-GUI type dialog callbacks with resource dialogs.
2012/10/13
    changes for 9.0.3.1
    added code so $FILE$ is wrapped with DQ's

2012/10/07
    changes for 9.0.3.0
    added Wayne's changes for bcx 6.9.9
    -----------------------------------
	2012/10/05 17:00:00 GMT-5
	* Changes to 6.9.8 for 6.9.9
	* Wayne Halsdorf
	* Fixed bug in prototype/header generation involved changed to several functions
	*    to allow for recursion
	* Changed CONST InternalDebugOff to GLOBAL InternalDebugOff to elimate warnings
	* Fixed label generator for select/end select to prevent unneed labels being generated.
	* Changed strlwr to _strlwr
	* Fixed bug temporary files not being deleted.
	* Fixed bug STRARRAY not correctly translated when generating C++ code.

2012/10/04
    changes for 9.0.2.8
    add code to delete bcx temp files
2012/09/25
    changes for 9.0.2.7
    changed MAX_PATH (260) to just 260
2012/09/12
    changes for 9.0.2.6
    attempt to add support for TINYC _ANONYMOUS_UNION _ANONYMOUS_STRUCT failed
    I added to the TINYC batch file and it appears to work fine
2012/08/31
    changes for 9.0.2.5
    adding $NOINC
2012/08/30
    changes for 9.0.2.4
    added my rendition of bcx 6.9.8 $CPPHDR. No need to add $CPP to your source if used

2012/08/27
	changes for 9.0.2.3
	added #define _MAX_PATH MAX_PATH to types from winapi
	MinGWTDM64 was missing it
	added ,byte to types from winapi
'------------------------------------------------------------------------------

2012/08/22
  changes for 9.0.2.2
    supressed Use_console when only using cls
2012/08/15
  changes for 9.0.2.1
    replaced command library with non windows dependant one

2012/08/14
  changes for 9.0.2.0
  fixed constructor problem
  added c++ header item
  added optional BCX_TmpStr parameters in command library function
2012/08/03
  changes for 9.0.0.9
  added updates from Robert's 6.9.2

'-----------------------------------------------------------------------------
2012/03/24 James C. Fuller
    changes for 9.0.0.7
      added linux _splitpath
      added linux _getch
      added Wayne's fix for ULONGLONG
2012/03/22 James C. Fuller
    changes for 9.0.0.6
      reworked instat. kbhit() is depreciated and there is no Linux version

2012/03/22 James C. Fuller
    changes for 9.0.0.5
    Added:
      IF InFunc OR InClassModule OR InNameSpace OR InTypeDef THEN
    For:
      IF InFunc OR InClassModule OR InNameSpace THEN
    per Ian by way of Wayne
'------------------------------------------------------------------------------
    changed:
      Cmd$ = UCASE$(EXTRACT$(COMMAND$(1),".")) + ".BAS"  ' Assume implicit .BAS
    To:
      Cmd$ = EXTRACT$(COMMAND$(1),".") + ".bas"  ' Assume implicit .BAS
'------------------------------------------------------------------------------
    replaced depreciated strupr,strlwr
'------------------------------------------------------------------------------
2012/03/20 James C. Fuller
  changes for 9.0.0.4
    changed lof for use With $NOAPI and -xinc
    fixed c_declare for use with $NOAPI
2012/03/19 James C. Fuller
  Changes for 9.0.0.3
    added some additional typedef's when using UseWinApi = FALSE
2012/03/12 James C. Fuller
  Changes for 9.0.0.2
    need WinApi calls for full console functionality so removed added UseWinApi for Use_Console
    changed cls to a system call.
    Removed fflush(stdout); from BCX_RegWnd Sub. It forced stdio.h to be included when there
    is no console.
    added code to suppress cpp includes when using -xinc
2012/02/25  James C. Fuller
  Changes for 9.0.0.1
	Added typedef unsigned int UINT; when using $NOAPI (-p)
	Added -xinc command line param to exclude all #include statements
	Added -nix command line param for creation of linux compatable source code generation
	Note: because of the structure of the bc source $NOAPI will not work as intended.
	      You need to use "-P" command line parameter when compiling
2012/02/25	James C. Fuller
  Changes for 9.0.0.0
    Added $NOAPI
    Added -p for $NOAPI
    Added struct/end struct
    Removed Use_Keypress for pause
    Added default optional parameters to all BCX_TmpStr calls.
    chr$() changed to only one parameter
    Replaced a couple of chr$() multi parameter calls with vchr$
    Updated command$ for use with $NOAPI
    Updated MakeLCaseTbl for use with $NOAPI


'------------------------------------------------------------------------------
2012/02/04 17:00 GMT-8   Robert Wishlaw
* Changes to 6.8.6 for 6.8.7
* 02/05 - Modified - (Casey) - cMaxConstMacros value changed from 128 to 512.

2012/02/04 17:00 GMT-8   Robert Wishlaw
* Changes to 6.8.5 for 6.8.6
* 02/04 - Fixed Bug - (Halsdorf) - modified Emit_PPType function to accomodate C++ "using"
* 02/04 - Fixed Bug - (Diggins) - corrected Download function call to DeleteUrlCacheEntry function.

2012/01/03 James C. Fuller
  changes for 6.8.5.3
  moved placement of "using namespace std;"
2011/12/19 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.8.4 for 6.8.5
* 12/07 - Fixed Bug - (Fuller) - Not all inline C code emitted correctly in namespace/class
* 12/08 - Fixed Bug - (Casey) - "=<" not correctly translated to "<="
* 12/09 - Fixed Bug - (Fuller) - $CCODE not emiting proper code when in a Class or NameSpace
* 12/12 - Added - (Fuller) - Added C++ operator ()
* 12/14 - Added - (Fuller) - Various improvements to C++ code generation.
* 12/18 - Fixed Bug - (Fuller) - Fixed misplacement of * in parameter's of a constructor

2011/12/04 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.8.3 for 6.8.4
* 10/24 - Added the ability to use CONST expressions to TYPE/END TYPE
* 11/14 - Fixed Bug - (Fuller) - Inline C code in class module not handled correctly.
* 12/04 - Fixed Bug - (Fuller) - Inline C code in namespace module not handled correctly.
* 12/06 - Added RegExist - A positive number is an error/missing on the key a negative number is an error/missing on the subkey.

2011/10/24 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.8.2 for 6.8.3
* 10/17 - Fixed Bug - (Ad Rienks) - placement of single line c code.
* 10/24 - Fixed Bug - (mr_unreliable57) - Bug in Join string

2011/10/14 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.8.1 for 6.8.2
* 10/12 - Removed missed debugging info
* 10/13 - Fixed Bug - (mr_unreliable57) - string joining bug
* 10/13 - Fixed Bug - (Richard Meyer) - scientific notation output bug
* 10/14 - Implimented Ian suggested that ABS should behave like VB ABS and use IABS for integer absolute value
* 10/14 - Fixed Bug - (Casey) - the placement order of $ccode

2011/10/07 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.8.0 for 6.8.1
*  9/08 - Fixed Bug - (Robert) Datatype in SUB ProcessSetCommand not checked correctly.
*  9/10 - Fixed Bug - (Kevin) - Prototype bug envolving variables of the form szK$[] most noticable in C++
*  9/17 - Fixed Bug - (Richard Meyer) - main(...) not removed from DLL generated code.
*  9/25 - Fixed Bug - (Casey) - $CCODE incorrectly saved to wrong internal file.
* 10/02 - Fixed Bug - (Casey) - string assignment of a structure member when structure is passed as a reference.
* 10/02 - Fixed Bug - (Fuller) - .def file not closed.
* 10/07 - Victor McClung - Added function, Get_RTL_Version$, to Runtime Library to ID the version it was made with.

2011/09/06 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.7.3 for 6.8.0
* 6/05 - Added - Kevin - EXIT NEST - will exit out of the current loop types until a different type encountered.
* 6/10 - Fixed bug - (Vic) - date.c file was not created.
* 7/16 - Fixed ABS bug - (Ian/Robert) - After some reading on how absolute values are handled and how they
*        are used internally in BCX it would be best to add all of the various types of absolute values
*        considering how little is needed to add each type (1 line each). Crude BCX discriptions
*        vt_INTEGER abs(vt_INTEGER)
*        vt_LONG labs(vt_LONG)
*        vt_LLONG llabs(vt_LLONG)
*        vt_DOUBLE fabs(vt_DOUBLE)
*        vt_FLOAT  fabsf(vt_FLOAT)
*        vt_LDOUBLE fabsl(vt_LDOUBLE)
*        A note in the help file stating that while you can use the absolute function within calculations
*        it is better to use temporary holders for the value of absolute function that use floating point
*        values since on very rare occasions it needs to be normalized on return. The storing of an
*        unnormalized floating point variable forces normalization.
* 7/23 - Fixed bug - (Robert) - Spacing bug. Appeared first in SIZEOF()
* 7/30 - Fixed bug - (Robert) - ULONG was being emitted when ULONGLONG was suppose to be
* 7/31 - Fixed bug - (Robert) - Internal const was being emited instrad of actual value.
* 8/08 - Fixed bug - (Ad Rienks) - bug in RECLEN code generation
* 8/17 - Fixed bug - (Ad Rienks) - Renamed parameters of MsgBox function to avoid possible error messages
* 8/22 - Added AlphaNumeric option to QSORT - Kevin
* 9/05 - Finished Rewrite of sections envolving the assembling of the various parts into the final c/cpp file.

2011/06/04 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.7.2 for 6.7.3
* 6/2  - Fixed bug - (Vic) Truncation of lines in header file.
* 6/4  - Fixed bug - (Vic) Global defines were missing in BCXRT.H

2011/05/25 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.7.1 for 6.7.2
* 5/22 - Added NotEqualTo and EqualTo to lexicon R = (A NotEqualTo B) OrElse (A EqualTo C)
* 5/22 - Change method of making directory string locations for RTL
* 5/25 - Fixed bug - Out of order enty in tTypes
* 5/25 - Added additional table checking in InitReservedWordsLookup
* 6/1  - Added longlong as a printable type

2011/05/20 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.7.0 for 6.7.1
* 5/12 - Added routine to handle c++ vector - (Fuller)
* 5/15 - Fixed bug - (Doyle) - error in COM support - COM types not placed before prototypes.
* 5/15 - Fixed bug - (Fuller) - translation of call type in class
* 5/20 - Fixed bug - (Fuller) - translation of function initializer in class
* 5/20 - Fixed bug - Introduced when header portion of program was reordered.

2011/05/11 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.6.1 for 6.7.0
* 5/5 - Fixed bug - WINBOOL (Fuller) not handled when used in a class
* 5/6 - Changed UseCpp and UseIO interaction - (Fuller) - Message #41776
* 5/7 - Fixed bug - (Fuller) - Bug in rebuild of string found when RAW AS __int32
* 5/10 - Fixed bug - (Fuller) - iif was not changed to reflect CPP changes.
* 5/11 - Began splitting functions to reduce complexity/length

2011/05/05 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.6.0 for 6.6.1
* 4/26 - Fixed elipse bug (Fuller) elispse not emitted when in c++
* 4/27 - Fixed DialogBox bug (Fuller) wrong case emitted.
* 4/29 Removed IncludeCount (no longer used)
* 4/29 - Fixed bug in difference between -c and $CPP - (Fuller)
* 5/5 - Fixed  bug in PPTYPE (Wishlaw) - extra bumpdown called
* 5/5 - Added WINBOOL as type will emit BOOL as type for use in C++

2011/04/25 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.5.0 for 6.6.0
* 4/17 Project_Support - Started code reduction/complexity (65%/50% of orignal)
* 4/20 Made BCX_GET_COM_STATUS a seperate function in the RTL
* 4/21 - Fixed destructor bug (Fuller)
* 4/21 - Fixed SET bug (Fuller) was not being placed in UDT when in class or namespace
* 4/21 - Added $NOIO directive (Fuller)
* 4/23 - Renamed string to stringx (Fuller)
* 4/25 - Fixed BOOL/bool bug (Fuller) not correctly outputted when in class or local variable
* 4/25 - Fixed case changing of word next (Fuller) - The words case was changed when it was not acting as a reserved word

2011/04/20 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.5.0BetaRC2 for 6.5.0
* 3/25 - Fixed bug (Robert) Window headers were removed if $CPP or -c was used.
* 3/27 - Changed (Armando) GetWordInfo use of strcmp to str_cmp
* 3/27 - Changed FindWord use of strcmp to str_cmp
* 3/28 - Added bcx internal str_Cmp to lexicon
* 4/03 - Added $LIBERROR directive to lexicon
*   Syntax $LIBERROR "string literal" where a log of libaries and functions that failed.
* 4/04 - Changed (Robert) enhanced enum to include typedef when emitted
* 4/04 - Clean up code
* 4/05 - Fixed bug (Ian) in SpecialCaseHandler
* 4/06 - Fixed potential bug (Ian) StrToken
* 4/06 - Added printer changes (Ian)
*          PrinterOpen (char * fontname,int PointSize,int charset)
*          PrinterOpen (char * ="Courier New",int=12,int=DEFAULT_CHARSET)
*          more changes possible in future.
* 4/14 - Fixed bug in BCXRT routine - extra BCX_Hinstance was tring to being added.
* 4/20 - Fixed bugs in BCX Runtime Library

2011/03/25 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.5.0BetaRC1 for 6.5.0BetaRC2
* 3/23 - Fixed bug (Ian) when emitting CONST
* 3/23 - Fixed bug (Ian) reguarding BCX_hInstance (was not always emitted)
* 3/23 - Fixed bug (Ian) reguarding DefaultFont (was not always emitted)
* 3/23 - Fixed bug (Don) in case statement emitted =< when <= should have been
* 3/25 - Fixed bug (Robert) in PREPEND sizeof PrependVar$ not declared correctly
* 3/25 - Fixed bug (Jeff) FOR EACH intendion bug
* 3/25 - Revert CREATEOBJECT to 6.2.2 method of creation

2011/03/21 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.5.0AlphaRC5 for 6.5.0BetaRC1
* Enhanced ENUM
*   Syntax: TypeOfEnum AS ENUM or ENUM AS TypeOfEnum
*   Emits   enum TypeOfEnum
* This will allow TypeOfEnum to act as a type taking only named values that are
*   in the enum/end enum list.
* More code cleanup, adding/changing comments
* Changed PREPEND/END PREPEND syntax , removed tic marks as encapsulator
*   PREPEND `fprint fpout,` is now PREPEND fprint fpout,
* Fixed switch bug -c

2011/03/04 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.5.0AlphaRC4 for 6.5.0AlphaRC5
* Added PREPEND/END PREPEND to lexicon (JCFuller). See prepend.txt
* Began changing variable names in functions/subs to make it easier to read
*   resulting in finding non-executable code and obscure bugs.
* Bug fixes envolving function prototypes
* Fixed bug when using a multiword cast inside of an IF/THEN statement

2011/02/19 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.5.0AlphaRC3 for 6.5.0AlphaRC4
* Continued replacement of fixed values(Magic Number) in code  with constants to make them more usable.
* Continued adding checks to prevent going past array end
* Bug fixes envolving function prototypes
* Bug fix SWAP - missing )
* Bug fix DATA$ isn't case-sensitive
* Bug fix IsCallBack flag not being reset
* Replacement for PRIVATE CONST    ENUM ONE = 1
* Exiting loop warnings will only show if -w switch is used

2011/02/17 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.5.0AlphaRC2 for 6.5.0AlphaRC3
* Began replacement of fixed values(Magic Number) in code  with constants to make them more usable.
* Began adding checks to prevent going past array end
* various bug fixes in new code for C++
* various bug fixes in new code
* Minor changes in code for clarity

2011/01/13 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.5.0AlphaRC1 for 6.5.0AlphaRC2
* various bug fixes in new code

2011/01/07 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.2.4 for 6.5.0AlphaRC1
* Fixed bugs intorduced in 6.2.4
* A rewrite of the emitter routines.
* Merged directives into keywords list
* A number of changes in the translator routines to reduce the occurance of recursion
* Began adding more suport for C++
*   $CPP now required for C++ (no longer checks to see if intended by code examination)
*   bool is now emitted instead of BOOL for C++
*   CLASS to Replace $CLASS
*   NAMESPACE to replace $NAMESPACE
*   TRY to replace $try
*   THROW to replace $THROW
*   CATCH to replace $CATCH
*
* Added more error checking some in the form of warnings.
* EXIT without a control named results in a warning message with
*   the inner most loop named. The code generated results in the
*   exiting of the inner most control loop.
*   See notes.txt
*
* Added Me to lexicon to replace This so that This can be used for C++
* Added declaration of variables with forword propagation of variable type
*   DIM AS DOUBLE A, B, C[2]                  ' all variables are doubles
*   RAW AS INT A[] = {4,5}, B, C[2] = {0,1}   ' all variables are integers
*   DIM AS CHAR PTR PTR A, B[3]               ' all variables are POINTERS to POINTERS of char
* Added boolean operators ANDALSO and ORELSE to lexicon
*   DIM AS BOOL bReault1, bReault2, bX1, bX2
*   DIM szBuf$
*   bX1 = TRUE
*   bX2 = FALSE
*   bReault1 = bX1 ANDALSO bX2
*   bReault2 = bX1 ORELSE bX2
*   PRINT "bX1 bX2 bX1 ANDALSO bX2 bX1 ORELSE bX2"
*   sprintf(szBuf,"%3i %3i     %2i               %2i",bX1,bX2,bReault1, bReault2)
*   PRINT szBuf
*   PAUSE

2010/11/06 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.2.3 for 6.2.4
* Fixed bugs introduced in last relase
*   BFF function - Return value wasn't misnamed
*   EVENTS - InFunc wasn't reset to false at end
* Added more code in preperation for C++ additions
* Fixed #include directive
* Removed Ella's Use_GoSub routine that was accidently merged (not compatible with all compilers)

2010/10/31 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.2.2 for 6.2.3
* Merged some changes from Ella Kogan's modified version of BCX
* Fixed Set bug
* Removed some old commented code
* Renamed some of the internal names in preporation of adding more C++ support to avoid possible conflicts


2010/10/10 00:00 GMT-7   Kevin Diggins
* Changes to 6.2.1 for 6.2.2
* Replaced C99 deprecated 'gets' code with 'fgets'
* Fixed problem in DOWNLOAD function
* Reformatted InkeyD and Keypress runtime codes
* Compiled with MSVC++ V.14.00.50727.762

2010/10/10 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.2.0 for 6.2.1
* Added translation code for $NAMESPACE/$ENDNAMESPACE code generation
* Fixed bug in cpp METHOD sub/function code generation

2010/09/14 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.1.9 for 6.2.0
* Fix bug in $INTERFACE/$ENDINTERFACE and $CLASS/$ENDCLASS
* Changed detection and parsing of directives to allow for leading spaces

2010/09/13 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.1.8 for 6.1.9
* Added -b command line option. See Message #40891
* Added warning to free command that local dynamic variables are automatically freed.
* Added $INTERFACE/$ENDINTERFACE to be used the same way as $CLASS/$ENDCLASS
* Added XFOR/XNEXT to lexicon
* Now$ and Date$ can now take an option parameter, if non zero it returns UTC time
*   defaults for Now$ and Date$ return local time
* Incresed size of INFOBOXs used for warnings and abort messages
* Fixed bug in DO/LOOP checking (removed hard coding and moved/added resetting/testing of flags)

2010/08/18 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.1.7 for 6.1.8
* Fixed bug introduced in previous version involving fix for SELECT/END SELECT

2010/08/17 00:00 GMT-5   Wayne Halsdorf
* Changes to 6.1.6 for 6.1.7
* Put back adding of comment lines into C source code using the directive $REMS
*   which work as a toggle (default start value off). A comment line may have leading white spaces.
* Added check for unfinished BumpDowns (Indent > 0  at end of END SUB/END FUNCTION This should be 0)
*   most likly cause is missing END IF since the other errors envolving WHILE/DO/SELECT will have shown up
* Fixed bug involving multiple occurences nested SELECT/END SELECT within SELECT/END SELECT
* Added test to check for DO CONTIDION/LOOP CONTIDION
* Added second optional parameter to TIME$(x,u) to return UTC values
*   default value for u is 0 for local, non 0 for UTC
* Added some scope limit detection of variable types.
*   This will reduces the warnings about two variables being named
*   with two different data types.

2010/08/02 00:00 GMT-5   Wayne Halsdorf
* Updated OSVERSION for Vista and Windows 7
* Fixed bug in the FOR EACH/NEXT loop checker, the FOR EACH was not checked
* Fixed bug in CreateArr_internal as result of 32/64 bit conversion
* Fixed bug in BCX_MDialog as result of 32/64 bit conversion
* Fixed strong type checking of BCX_SETCOLOR parameters introduce in 6.14  as result of 32/64 bit conversion

2010/07/29 00:00 GMT-5   Wayne Halsdorf
* Fixed bug introduced in previous version reguarding balance of
*   DO/LOOP, no dection of DO WHILE being converted to WHILE

2010/07/27 00:00 GMT-5   Wayne Halsdorf
* Added association checks for FOR/NEXT, WHILE/WEND, DO/LOOP and SELECT/END SELECT
* Added Kevin's long type to FOR/NEXT
* Added simple check to see if FOR/NEXT is balanced.
* Added code to WITH statement so that the object of the WITH staement
*   can now be a pointer
* WITH pO
*   ->szName$ = "test"
*   ->iCnt    = 1
* ENDWITH
* Updated Download function so that cached files are not used
* Fixed - $ONENTRY to correctly echo the cmd to be exectuted
* Fixed - $COMPILER to correctly echo and emit the cmd to be exectuted
* Fixed - $LINKER to correctly echo and emit the cmd to be exectuted
* Changed all occurances of GetWindowLong and SetWindowLong to GetWindowLongPtr and SetWindowLongPtr
*   and GWL_yadayda to GWLP_yadayda where required
* Changed all occurance of GetClassLong and SetClassLong to GetClassLongPtr and SetClassLongPtr
*   and GCL_yadayada to GCLP_yadayada where required
* Added LONG_PTR casts where needed including places where while not
*   now needed but may change in future.
* Added PtrToUlong to BCX_OLE_WIDTH/BCX_OLE_HEIGHT macros and to calls made in ModStyle and Set_Color

2010/07/01 00:00 GMT-5   Wayne Halsdorf
* Changed all occurances of GWL_HINSTANCE to GWLP_HINSTANCE
* Added test to limit number of nested BEGINBLOCK/ENDBLOCK to 16
*   anything that complex is in need of a rewrite
* Rewrite of variable declaration routine.
*   Note: it is posible to have a variable that is both volitile and const
* Fixed bug: DestroySafeArray not properly recognized

2010/06/27 00:00 GMT-5   Wayne Halsdorf
* Added const as modifier to variable types
*   Example:
*     dim cspA AS CONST CHAR PTR
*   translates to
*     static const char    *cspA;

2010/06/21 00:00 GMT-5   Wayne Halsdorf
* Return type changes
*   InitSafeArray changed to a HRESULT
*   DestroySafeArray changed to a HRESULT
* Moved inline c test (!lineofcode) to right after
*   line input block.
*   This results in no testing being performed on inline c

2010/06/15 00:00 GMT-5   Wayne Halsdorf
* Added code for SafeArrays
*   InitSafeArray(safearrayptr, variabletype, dims, lowerbound1, numberofelements1, lowerbound2, numberofelements2, ...)
*   ArrayPutElement(safearrayptr,Variant, dims, dim1, ...)
*   ArrayGetElement(safearrayptr,Variant, dims, dim1, ...)
*   DestroySafeArray(safearrayptr)
* Added BEGINBLOCK/ENDBLOCK to BCX Lexicon to allow allocated varibles limited scope
* Fixed LPWORD lpwAlign (LPWORD lpIn) so that it is no longer compiler dependent when compiling
*   for either 32/64 bit targets
*
* Armando Rivera's Fix for
*   Correction to "insertmenu"
* Kevin's Modification MINGW64
*        $ELSEIF __MINGW64__
*          PRINT "MinGW64 C"

2010/05/30 16:00 GMT-5   Wayne Halsdorf
* Added LCASE, MCASE and UCASE as to appear in the SET command as function pointers
*  see MSG #40585
* Added BCX_GET_COM_STATUS(&oOBJECT) returns TRUE if active else FALSE (comes in handy when debugging)

2010/05/27 16:00 GMT-5   Wayne Halsdorf
* Added translation of ASC("?") back into set command, along with several others OR/BOR AND/BAND BNOT

2010/05/10 16:00 GMT-5   Wayne Halsdorf
* Fixed - $NOWIN misses one include file: #include <commdlg.h>
*   as per JCFuller.
* Increased limit of maximum number of prototypes and added code
*   to check if limit is exceeded
* Added BCX_VERSION$ to BCX so you can put the version
*   used to translate into your program

2010/03/17 16:00 GMT-5   Wayne Halsdorf
* Changed the length of the allocated string in STR$ from 16 to 24
*   when scientific notation is emitted it exceeds 16 characters
* Fixed $class/$endclass to emit correct code
* Added code to allow METHOD sub/function code generation
*   function CLASSNAME::METHOD()
*     'code here
*   end function
* Fixed bug in DATA statement

2010/02/25 18:00 GMT-8   Robert Wishlaw
* Published BCX 6.0.3

2010/02/24  00:00 GMT-8 - Robert Wishlaw
 *** Rewrote the MakeLCaseTbl procedure to remove compiler dependent casts.
 *** Changed the MakeLCaseTbl procedure to run once, when the application using it
     is started, instead of it being called repeatedly from the loops of dependent procedures.
 *** Removed the redundant MakeLCaseTbl calls from the _stristr_ and Hex2Dec functions.

2009/12/10 00:00 GMT-8 - Robert Wishlaw
* Added an optional FillType parameter to the BCX_FLOODFILL function to allow the flooding
  of an area which is contained by a multicoloured boundary. This is an extension to the
  existing BCX_FLOODFILL wrapper of theWindows GDI ExtFloodFill function. For more detail
  see the documentation for the FLOODFILLSURFACE value of the fuFillType parameter
  of the Microsoft Windows GDI ExtFloodFill function.

2009/12/03 14:00 GMT-5   Wayne Halsdorf
* Added code to allow global declarations of OBJECTs in sub/function
* Moved enum output to before const output to allow use of enum values in other output
  types such as const
* Made changes to the SET command to allow the following
  SET psX[] as PCHAR
    "this \"is a test\"",
    "hurray"
  END SET

2009/11/03 03:00 GMT-8   Robert Wishlaw
* Published BCX 6.0.1

2009/10/25 00:00 GMT-8   Robert Wishlaw
* Added HKEY_CURRENT_USER registry section entries for BCXPATH$.

2009/08/20 00:00 GMT-8   Robert Wishlaw
* Revised SUB EmitCmdLineConst and moved the call in order
  to emit the command line defines before any other code
  to provide for use of those defines within any subsequent headers
  or code. This change allows, for example, -D:_WIN32_WINNT=0x0500
  to be defined on the BCX command line and, in the translated C source code,
  to have the defines positioned before the included header files.
  Such placement is required, for example, for compilation of the
  translated BCX Gui demo Rebar.bas with the Pelle's C compiler.
* Removed unreachable "return 0" from KEYPRESS procedure.

2009/08/02 02:08 GMT-8   Robert Wishlaw
* Moved the call to CheckParQuotes to immediately after the ReProcess: label.
* Changed line 27380 from
  CASE vt_STRVAR
  to
  CASE vt_STRVAR, vt_CHAR

2009/06/02 05:00 GMT-5   Mike Henning
* Changed version to 6.00 as requested by Robert Wishlaw.
* Fixed a naming conflict with the new BCX_Dynacall when used as a return value.

2009/04/27 05:00 GMT-5   Mike Henning
* Merged my changes with Waynes
* New changes include handling of FREE and FREE DYNAMIC.
* DYNAMIC is ignored now relying on free to choose the appropriate method.
* The behavior should be the same now with or without parenthesis.
* Fixed some bugs in the SET statement handling - Variables were not being
* added or recognized properly.
* Fixed the output when using $TRACE
* Some bad code in BCX_PREPARE_COM_TRACE_LINE
* Added a variation of BCX_DynaCall for easier runtime execution of functions
  not known at compile time.
  BCX_DynaCall("Dll_Name", "Function_Name", NumberOFArgs, ArgArray)

2009/03/12 05:00 GMT-5   Wayne Halsdorf
* Reformatted some of the code
* Added some addition tests for invalid type combinations in COM
* Added additional return types to COM
* Applied Robert Wishlaw's reformating of code

2009/02/12 05:00 GMT-5   Wayne Halsdorf
* Finished correcting all the bugs that I'm aware off in the COM section.
* To DO: 1. Reformat code (anyone up for this)
*        2. Add code to handle all variant types. (much easier to do now)
*        3. Put together a collection of COM examples to serve as a test base.
*        4. Inform Robert as to changes in COM that differ from currently in help file.

2009/01/27 05:00 GMT-5   Wayne Halsdorf
* Start of modification of COM routines to be able to handle arrays of OBJECTs.
* Note: Not every posible combination has been tried.
*       I use a modified version of BCX where I test out various ideas to improve
*       the performance and the expandablity of BCX. This version contains
*       some of those modifications to make it easier to modify changes in
*       the COM routines. Some can be easily added to the current version of BCX.
* Added internal FUNCTIONS FindWord & GetWordInfo to lookup various words
*       and return information on type.
*       The function FindWord uses a binary searcg method, with GetWordInfo
*       using a modified version, resulting in a maximum
*       lookup attempts (for x number words) equal to LOG(x)/LOG(2)
*
2009/01/27 00:00 GMT-5    Mike Henning
* Fixed a bug in the BCX_SETCOLOR function that would cause many color
  combinations to not show transparent correctly.


2009/01/24 11:00 GMT-7    Kevin Diggins
* Found and removed more unused global variables
* Minor text editing

2009/01/23 05:00 GMT-7    Kevin Diggins
* Found and removed more unused global variables
* Found and removed commented, deprecated code fragments
* Minor text editing and formatting

2009/01/21 05:00 GMT-5    Wayne Halsdorf
* Fixed bug in OPTIONAL (introduced in last fix of OPTIONAL) was adding phantom varible
* Fixed BCX_SETCOLOR when 3 parameters supplied

2009/01/19 05:00 GMT-7    Kevin Diggins
* Reformatting & general text editing of this document for easier reading
* Removed StkTmp$[] & related dead code
* Removed Xport$ related dead code
* Removed CObjectTest related dead code
* Removed LinesWritten dead function
* Removed CompStructVars dead function
* Removed Obsolete switches
* Replace FUNCTION BraceCount with new version by Mike Henning


2009/01/16 00:00 GMT-5    Wayne Halsdorf
* Fixed joining of strings detection routine
* 1. handle arrays of structures with string elements - structure[i].string$ , structure[i]->string$
* 2. handle dereference of pointer to structure with string element (*structure).string$
* Fixed bug in OPTIONAL. Example:  a=1 as int  would output wrong code for prototype
* Added code to SET/END SET so that the translator knows what type it is.

01/10/2009 00:00 GMT-5    Mike Henning
* Fixed the Descending dynamic string in qsort
* Added Kevins fixes for the COM functions
* Fixed the handling of the image index for BCX_TOOLBAR
* Removed a couple of function returns that were not needed giving
* "code can not be reached" compiler warnings.
* Added "return" to be sensed when removing dead callback code.
* Increased the buffers in USING$ from 100 to 512

2008/10/08 00:00 GMT-5    Wayne Halsdorf
* Fixed bug introduced in FREE when it was exteneded
* Fixed bug in type detection in CheckGlobal and CheckLocal

2008/10/07 00:00 GMT-5    Wayne Halsorf
* Fixed bug in SWAP when dealing with undefined typed
* Fixed internal bug for getting information from GetTypeInfo when
*   _CLASS is appended to structure type
* Extened usage of DYNAMIC and FREE to include use in structures

2008/08/22 00:00 GMT-5 -  Wayne Halsdorf
* fixed bug in getprocaddress
* fixed on ... goto,gosub,call so that the argument can be of the form (x BAND 7)
* Fixed obscure bug in SplitLines FUNCTION involving parentheses
* SWAP - Changed char to byte for safer swapping based on size
*      - Can now handle dynamic strings
* Rolled chdir, _chdir, rmdir, _rmdir, mkdir, _mkdir into one operation

2008/07/08 00:00 GMT-8 -  Robert Wishlaw
* Replaced instances of while(1) with for(;;)

2008/07/08 00:00 GMT-8 -  Wayne Halsdorf
* Modified TALLY Function to accept an optional case insensitivity argument.

2008/05/28 19:00 GMT-8 -  Wayne Halsdorf
* Modified CONTAINEDIN Function to work with Borland compiler.

2008/05/26 20:00 GMT-8 -  Wayne Halsdorf
* Revised IncludeCount value to 29 to accomodate process.h header file.

2008/05/25 19:00 GMT-8 -  Wayne Halsdorf
* Repaired WITH ... END WITH bug

2007/02/23 15:45PM GMT-8 - Mike Henning
* Fixed the SAVEBMP function.



$COMMENT ================== END OF COMMENT SECTION ============================




CONST CCP=const char*
CONST cDefaultStringSize = 2048
CONST csSizeOfDefaultString = "2048"
CONST cSizeOfADefaultString = "[cSizeOfDefaultString]"
CONST InternalDebug = 0
CONST __BCX__ = 1 ' define BCX so we know we are in bc.bas
CONST IAm(X) = ((X) <> 1)
CONST IAmNot(X) = ((X) == 0)
CONST FirstTime(X) = ((X) == 0)
CONST IDont(X) = ((X) == 0)
CONST WordsInTable(A) = (SIZEOF(A)/SIZEOF(A[0]))
CONST cINDENT = 2
CONST ZPRINT(x) = zTrace(ANSITOWIDE((char*)(x)))
$CPP
$CPPHDR
$NOMAIN

$GENFREE
$IPRINT_OFF
$NOINI
'$LEANANDMEAN meaningless with Win32
'$TURBO

$HEADER
  typedef long (CALLBACK *CPP_FARPROC)(char *);
  static CPP_FARPROC PPProc;
  #include <pcrecpp.h>								//jcfuller
  #include <vector>
  #include <iterator>
  #include <malloc.h>
//  using namespace std;
  typedef long (__stdcall *BCXFPROT1)(const WCHAR*);
//  I think the above is wrong ??
//    typedef LONG_PTR (__cdecl *BCXFPROT1)(const WCHAR*);
	static BCXFPROT1 zTrace;
	#define _bool bool
	#define _true	true
	#define _false false
$HEADER

ENUM
  vt_UNKNOWN             '  Not a Variable
  vt_STRLIT              '  "Quoted String Literal"
  vt_INTEGER             '  Integer%
  vt_INT = vt_INTEGER
  vt_SINGLE              '  Single!
  vt_FLOAT = vt_SINGLE
  vt_DOUBLE              '  Double#
  vt_LDOUBLE             '  Long Double
  vt_LLONG               '  Long Long
  vt_STRVAR              '  StringVariable$
  vt_DECFUNC             '  Translated Decimal Func: Strlen,Asin
  vt_NUMBER              '  A Pure Literal Number
  vt_FILEPTR             '  @ FILE*
  vt_UDT                 '  User ( or Windows ) Defined Type
  vt_STRUCT              '  Structures
  vt_UNION               '  Unions
  vt_LPSTR
  vt_BOOL
  vt_CHAR
  vt_LPSTRPTR
  vt_PCHAR
  vt_CHARPTR
  vt_VOID
  vt_LONG
  vt_WORD
  vt_DWORD
  vt_FARPROC
  vt_LPBYTE
  vt_LRESULT
  vt_BYTE
  vt_SHORT
  vt_USHORT
  vt_UINT
  vt_ULONG
  vt_ULLONG
  vt_ULONGLONG = vt_ULLONG
  vt_HWND
  vt_HDC
  vt_COLORREF
  vt_HANDLE
  vt_HINSTANCE
  vt_WNDCLASSEX
  vt_HFONT
  vt_ConsDes
  vt_VARIANT_BOOL
  vt__VARIANT_BOOL
  vt_SCODE
  vt_CY
  vt_DATE
  vt_BSTR
  vt_IUnknown
  vt_IDispatch
  vt_SAFEARRAY
  vt_PVOID
  vt_DECIMAL
  vt_DOCINFO
  vt_LOGFONT
  vt_TEXTMETRIC
  vt_WINBOOL
  vt_VARIANT
  vt_BC9CHAR
END ENUM


'*********************************
CONST vt_VarMin    =  2
CONST vt_VarMax    =  vt_VARIANT
'*********************************
'jcfuller added from bcx 7.0.8
'*********************************
' return values for OSVersion
ENUM
  OSUnknown = -2
  OSError = -1
  OS_3x
  OS_95
  OS_98
  OS_ME
  OS_NT3
  OS_2000
  OS_XP
  OS_XP_Pro_x64
  OS_Server_2003
  OS_Home_Server
  OS_Server_2003_R2
  OS_Vista
  OS_Server_2008
  OS_Server_2008_R2
  OS_Win_7
  OS_Server_2012
  OS_Win_8
END ENUM

'*********************************


'jcfuller added from bcx 7.0.7
' infunc types
ENUM
  eNotInOne
  eFunctionType
  eSubType
  eDeclare
  eConstructorType
END ENUM

'*********************************
'enums for EmitIfCond subroutine

ENUM
  ePart
  eFull
  eStringPart
  eStringFull
END ENUM


ENUM
  mt_ProcessSetCommand
  mt_FuncSubDecC_Dec
  mt_FuncSubDecC_DecAParam
  mt_FuncSubDecC_DecNoParam
  mt_Opts
  mt_OptsAParam
  mt_OptsNoParam
  mt_OverLoad
  mt_OverLoadAParam
  mt_OverLoadNoParam
  mt_ConsDes
  mt_ConsDesAParam
  mt_ConsDesNoParam
END ENUM

'*****************************************
' Variable types for COM, OLE and VARIANT
ENUM
  comvt_BAD = -1
  comvt_TRUE
  comvt_FALSE
  comvt_BOOL
  comvt__VARIANT_BOOL
  comvt_BSTR
  comvt_STRVAR
  comvt_R4
  comvt_R8
  comvt_R8_LITERAL
  comvt_CY
  comvt_DATE
  comvt_DISPATCH
  comvt_PVOID
  comvt_ERROR
  comvt_VARIANT
  comvt_UNKNOWN
  comvt_DECIMAL
  comvt_I1
  comvt_UI1
  comvt_I2
  comvt_UI2
  comvt_I4
  comvt_I4_LITERAL
  comvt_UI4
  comvt_I8
  comvt_UI8
  comvt_INT
  comvt_UINT
  comvt_VOID
  comvt_OBJECT
  comvt_EMPTY
  comvt_NULL
  comvt_HRESULT
  comvt_PTR
  comvt_SAFEARRAY
  comvt_CARRAY
  comvt_USERDEFINED
  comvt_LPSTR
  comvt_LPWSTR
  comvt_RECORD
  comvt_INT_PTR
  comvt_UINT_PTR
  comvt_FILETIME
  comvt_BLOB
  comvt_STREAM
  comvt_STORAGE
  comvt_STREAMED_OBJECT
  comvt_STORED_OBJECT
  comvt_BLOB_OBJECT
  comvt_CF
  comvt_CLSID
  comvt_VERSIONED_STREAM
  comvt_BSTR_BLOB
  comvt_NAMED_ARGUMENT
  comvt_CAST
  comvt_DEFAULT
END ENUM

CONST comvt_VECTOR    = 0x1000
CONST comvt_ARRAY     = 0x2000
CONST comvt_BYREF     = 0x4000
CONST comvt_TYPEMASK  = 0x0FFF
CONST comvt_ILLEGAL   = 0xFFFF
'*****************************************

CONST fprintf = ReDirectFPrint

'******************************
'   User Defined Type Support
'******************************

CONST MaxElements   =  128
CONST MaxTypes      =  512
CONST MaxLocalVars  =  512
CONST MaxGlobalVars = 4096  'max size 233000

'******************************
'   Library Support
'******************************

CONST MaxLib        = 64    ' max no of libraries

'***********************
'  Bracket Handling
'***********************

CONST c_SglQt = 39
CONST c_DblQt = 34
CONST c_LPar  = 40
CONST c_RPar  = 41
CONST c_Komma = 44
CONST c_LtBkt = 91
CONST c_RtBkt = 93

'**************************************************************
' $PROJECT/Runtime Library support
' These are used to keep Modifiers of BCX source code
' from accidently changing certain output lines of
' code that are used by the $PROJECT/Library code
'**************************************************************
CONST BCX_STR_RUNTIME          = "Runtime Functions"
CONST BCX_STR_VBS_STRUCTS      = "VBSCRIPT SUPPORT STRUCTURES"
CONST BCX_STR_USR_CONST        = "User Defined Constants"
CONST BCX_STR_SYS_CONST        = "System Defined Constants"
CONST BCX_STR_STD_PROTOS       = "Standard Prototypes"
CONST BCX_STR_SYS_VARS         = "System Variables"
CONST BCX_STR_USR_VARS         = "User Global Variables"
CONST BCX_STR_STD_MACROS       = "Standard Macros"

CONST BCX_STR_MAIN_PROG        = "Main Program"
CONST BCX_STR_USR_PROCS        = "User Subs and Functions"
CONST BCX_STR_USR_PROTOS       = "User Prototypes"
CONST BCX_STR_USR_TYPES        = "User Defined Types And Unions"
'**************************************************************
CONST cCommaPos = 128
TYPE functionParse
  NumArgs
  CommaPos[cCommaPos]
END TYPE

'**************************************************************
'               These need to always stay in sync
'**************************************************************

CONST VarTypes$ = "%$#!@`"


'SET VarTypeLookup[] AS CONST CHAR PTR
SET VarTypeLookup[] AS const CHAR PTR
  "int", "int", "char *", "double", "float", "FILE *", "long double"
END SET

'**************************************************************
' Used to keep track of status of a SELECT structure
TYPE tagSelectInfo
  DIM CaseStk$
  DIM CaseElseFlag
  DIM CaseFlag
  DIM iStartCase
  DIM NoBreak
  DIM NoBreak2
  DIM iJumpTo
END TYPE

CONST cMaxNestedSelects = 16

GLOBAL SelectState[cMaxNestedSelects] AS tagSelectInfo

'**************************************************************
' Struture used in Emitter's findword - Lookup done on pszWord

TYPE tagWords
  DIM pszWord AS PCHAR
  DIM iType   AS Integer
  DIM FUNCTION Emitter(Lookup$, FuncRetnFlag AS PINT) AS INT
END TYPE

'**************************************************************

TYPE ARGTYPE
  DIM Arg$
  DIM ArgType AS INTEGER

END TYPE

CONST cMAXProtoType = 8192
CONST cSizeOfCondition = 512
TYPE tagProtoStore
  DIM Prototype$
  DIM Condition[cSizeOfCondition]   AS CHAR
  DIM CondLevel                     AS INTEGER
END TYPE

CONST cSizeOfElementName = 64
TYPE Element
  DIM ElementType                       AS INTEGER
  DIM ElementID                         AS INTEGER
  DIM ElementDynaPtr                    AS INTEGER
  DIM ElementName$[cSizeOfElementName]  AS CHAR
END TYPE

CONST cSizeOfVarName = 64
TYPE UserTypeDefs
  DIM TypeofDef                 AS INTEGER
  DIM EleCnt                    AS INTEGER
  DIM Elements[MaxElements]     AS Element
  DIM VarName[cSizeOfVarName]   AS CHAR
END TYPE



CONST cSizeOfVarDim = 128
CONST cSizeOfVarModule = 300
CONST cSizeOfVarCondDef = 128

TYPE VarInfo
  DIM VarLine                         AS INTEGER
  DIM VarType                         AS INTEGER
  DIM VarDef                          AS INTEGER
  DIM VarPntr                         AS INTEGER
  DIM VarSF                           AS INTEGER
  DIM VarExtn                         AS INTEGER
  DIM VarCondLevel                    AS INTEGER
  DIM VarEmitFlag                     AS INTEGER
  DIM VarConstant                     AS INTEGER
  DIM VarName[cSizeOfVarName]         AS CHAR
  DIM VarDim[cSizeOfVarDim]           AS CHAR
  DIM VarModule[cSizeOfVarModule]     AS CHAR
  DIM VarCondDef[cSizeOfVarCondDef]   AS CHAR
END TYPE


TYPE VARCODE
  DIM VarNo       AS INTEGER
  DIM Methd       AS INTEGER
  DIM IsPtrFlag   AS INTEGER
  DIM szFunctionName$					'jcfuller added from bcx 7.0.8
  DIM Header$
  DIM Proto$
  DIM Functype$
  DIM StaticOut$
  DIM Token$
  DIM AsToken$
  DIM IsExported  AS INTEGER
  DIM UseInLine   AS INTEGER
END TYPE


' Types used in LoopType
ENUM
  lt_DOLOOP = 1
  lt_DOWHILELOOP
  lt_DOUNTILLOOP
  lt_WHILEWEND
  lt_FORNEXT
  lt_SELECT
  lt_FORXNEXT
END ENUM

ENUM
  eExitingMoreThan1Loop = 1
END ENUM

CONST cSizeOfLabel = 10
TYPE tagLoopLoc
  DIM iLoopType                    AS INTEGER
  DIM iLoopLine                    AS INTEGER
  DIM iJumpTo                      AS INTEGER
  DIM szUseNeedLabel[cSizeOfLabel] AS CHAR
END TYPE


TYPE tagVVN
  DIM sNAME AS PCHAR
  DIM iTYPE AS INTEGER
  DIM iPTRS AS INTEGER
END TYPE

SET atVARIANTVALUENAMES[] AS tagVVN
  {(char*)"bVal"     , vt_BYTE         , 0},
  {(char*)"bool"     , vt__VARIANT_BOOL, 0},
  {(char*)"boolVal"  , vt_VARIANT_BOOL , 0},
  {(char*)"bstrVal"  , vt_BSTR         , 0},
  {(char*)"byref"    , vt_PVOID        , 0},
  {(char*)"cVal"     , vt_CHAR         , 0},
  {(char*)"cyVal"    , vt_CY           , 0},
  {(char*)"date"     , vt_DATE         , 0},
  {(char*)"dblVal"   , vt_DOUBLE       , 0},
  {(char*)"fltVal"   , vt_FLOAT        , 0},
  {(char*)"iVal"     , vt_SHORT        , 0},
  {(char*)"intVal"   , vt_INT          , 0},
  {(char*)"lVal"     , vt_LONG         , 0},
  {(char*)"llVal"    , vt_LLONG        , 0},
  {(char*)"parray"   , vt_SAFEARRAY    , 1},
  {(char*)"pbVal"    , vt_BYTE         , 1},
  {(char*)"pbool"    , vt__VARIANT_BOOL, 1},
  {(char*)"pboolVal" , vt_VARIANT_BOOL , 1},
  {(char*)"pbstrVal" , vt_BSTR         , 1},
  {(char*)"pcVal"    , vt_CHAR         , 1},
  {(char*)"pcyVal"   , vt_CY           , 1},
  {(char*)"pdate"    , vt_DATE         , 1},
  {(char*)"pdblVal"  , vt_DOUBLE       , 1},
  {(char*)"pdecVal"  , vt_DECIMAL      , 1},
  {(char*)"pdispVal" , vt_IDispatch    , 1},
  {(char*)"pfltVal"  , vt_FLOAT        , 1},
  {(char*)"piVal"    , vt_SHORT        , 1},
  {(char*)"pintVal"  , vt_INT          , 1},
  {(char*)"plVal"    , vt_LONG         , 1},
  {(char*)"pllVal"   , vt_LLONG        , 1},
  {(char*)"pparray"  , vt_SAFEARRAY    , 2},
  {(char*)"ppdispVal", vt_IDispatch    , 2},
  {(char*)"ppunkVal" , vt_IUnknown     , 2},
  {(char*)"pscode"   , vt_SCODE        , 1},
  {(char*)"puiVal"   , vt_USHORT       , 1},
  {(char*)"pulVal"   , vt_ULONG        , 1},
  {(char*)"pullVal"  , vt_ULONGLONG    , 1},
  {(char*)"punkVal"  , vt_IUnknown     , 1},
  {(char*)"pvarVal"  , vt_VARIANT      , 1},
  {(char*)"scode"    , vt_SCODE        , 0},
  {(char*)"uiVal"    , vt_USHORT       , 0},
  {(char*)"uintVal"  , vt_UINT         , 0},
  {(char*)"ulVal"    , vt_ULONG        , 0},
  {(char*)"ullVal"   , vt_ULONGLONG    , 0},
  {NULL       ,0                , 0}
END SET


'TYPE tagVTCASTS
  'DIM pszCAST AS PCHAR
  'DIM iCASTID AS Integer
'END TYPE

'SET ptVCasts[] AS tagVTCASTS
  '{(char*)"VT_BOOL"    ,comvt_BOOL},
  '{(char*)"VT_BSTR"    ,comvt_BSTR},
  '{(char*)"VT_CY"      ,comvt_CY},
  '{(char*)"VT_DATE"    ,comvt_DATE},
  '{(char*)"VT_DECIMAL" ,comvt_DECIMAL},
  '{(char*)"VT_DISPATCH",comvt_DISPATCH},
  '{(char*)"VT_ERROR"   ,comvt_ERROR},
  '{(char*)"VT_I1"      ,comvt_I1},
  '{(char*)"VT_I2"      ,comvt_I2},
  '{(char*)"VT_I4"      ,comvt_I4},
  '{(char*)"VT_I8"      ,comvt_I8},
  '{(char*)"VT_INT"     ,comvt_INT},
  '{(char*)"VT_R4"      ,comvt_R4},
  '{(char*)"VT_R8"      ,comvt_R8},
  '{(char*)"VT_UI1"     ,comvt_UI1},
  '{(char*)"VT_UI2"     ,comvt_UI2},
  '{(char*)"VT_UI4"     ,comvt_UI4},
  '{(char*)"VT_UI8"     ,comvt_UI8},
  '{(char*)"VT_UINT"    ,comvt_UINT},
  '{(char*)"VT_UNKNOWN" ,comvt_UNKNOWN},
  '{NULL         ,0}
'END SET

TYPE tagVTCASTS
  DIM pszCAST AS CCPTR
  DIM iCASTID AS Integer
END TYPE

SET ptVCasts[] AS tagVTCASTS
  {"VT_BOOL"    ,comvt_BOOL},
  {"VT_BSTR"    ,comvt_BSTR},
  {"VT_CY"      ,comvt_CY},
  {"VT_DATE"    ,comvt_DATE},
  {"VT_DECIMAL" ,comvt_DECIMAL},
  {"VT_DISPATCH",comvt_DISPATCH},
  {"VT_ERROR"   ,comvt_ERROR},
  {"VT_I1"      ,comvt_I1},
  {"VT_I2"      ,comvt_I2},
  {"VT_I4"      ,comvt_I4},
  {"VT_I8"      ,comvt_I8},
  {"VT_INT"     ,comvt_INT},
  {"VT_R4"      ,comvt_R4},
  {"VT_R8"      ,comvt_R8},
  {"VT_UI1"     ,comvt_UI1},
  {"VT_UI2"     ,comvt_UI2},
  {"VT_UI4"     ,comvt_UI4},
  {"VT_UI8"     ,comvt_UI8},
  {"VT_UINT"    ,comvt_UINT},
  {"VT_UNKNOWN" ,comvt_UNKNOWN},
  {NULL         ,0}
END SET

TYPE tagCCASTS
  DIM pszCAST AS const PCHAR
  DIM pszVAL AS const PCHAR
END TYPE

SET ptCCasts[] AS const tagCCASTS
  {(char*)"BYTE"     ,(char*)"bVal"},
  {(char*)"CHAR"     ,(char*)"cVal"},
  {(char*)"DOUBLE"   ,(char*)"dblVal"},
  {(char*)"FLOAT"    ,(char*)"fltVal"},
  {(char*)"IDispatch",(char*)"pdispVal"},
  {(char*)"INT"      ,(char*)"intVal"},
  {(char*)"IUnknown" ,(char*)"punkVal"},
  {(char*)"LONG"     ,(char*)"lVal"},
  {(char*)"LONGLONG" ,(char*)"llVal"},
  {(char*)"PVOID"    ,(char*)"byref"},
  {(char*)"SHORT"    ,(char*)"iVal"},
  {(char*)"UINT"     ,(char*)"uintVal"},
  {(char*)"ULONG"    ,(char*)"ulVal"},
  {(char*)"ULONGLONG",(char*)"ullVal"},
  {(char*)"USHORT"   ,(char*)"uiVal"},
  {NULL       ,NULL}
END SET


' Must be in lower case and in alphabetical order
SET tBcxWords[] AS tagWords
  {(char*)"abs"                ,vt_DOUBLE ,NULL},
  {(char*)"acos"               ,vt_DOUBLE  ,NULL},
  {(char*)"acosh"              ,vt_DOUBLE  ,NULL},
  {(char*)"acosl"              ,vt_LDOUBLE ,NULL},
  {(char*)"asin"               ,vt_DOUBLE  ,NULL},
  {(char*)"asinh"              ,vt_DOUBLE  ,NULL},
  {(char*)"asinl"              ,vt_LDOUBLE ,NULL},
  {(char*)"atan"               ,vt_DOUBLE  ,NULL},
  {(char*)"atanh"              ,vt_DOUBLE  ,NULL},
  {(char*)"atanl"              ,vt_DOUBLE  ,NULL},
  {(char*)"band"               ,vt_DECFUNC ,NULL},
  {(char*)"bin2dec"            ,vt_INTEGER ,NULL},
  {(char*)"bor"                ,vt_DECFUNC ,NULL},
  {(char*)"clipboardgettext"   ,vt_DECFUNC ,NULL},
  {(char*)"clipboardgettextsize"   ,vt_DECFUNC ,NULL},
  {(char*)"clipboardsettext"   ,vt_DECFUNC ,NULL},
  {(char*)"cos"                ,vt_DOUBLE  ,NULL},
  {(char*)"cosh"               ,vt_DOUBLE  ,NULL},
  {(char*)"cosl"               ,vt_LDOUBLE ,NULL},
  {(char*)"csrlin"             ,vt_DECFUNC ,NULL},
  {(char*)"cursorx"            ,vt_DECFUNC ,NULL},
  {(char*)"cursory"            ,vt_DECFUNC ,NULL},
  {(char*)"dsplit"             ,vt_DECFUNC ,NULL},
  {(char*)"exist"              ,vt_DECFUNC ,NULL},
  {(char*)"exp"                ,vt_DOUBLE  ,NULL},
  {(char*)"expl"               ,vt_LDOUBLE ,NULL},
  {(char*)"fabs"               ,vt_DOUBLE  ,NULL},
  {(char*)"fabsf"              ,vt_FLOAT   ,NULL},
  {(char*)"fabsl"              ,vt_LDOUBLE ,NULL},
  {(char*)"findfirstinstance"  ,vt_DECFUNC ,NULL},
  {(char*)"fint"               ,vt_INTEGER ,NULL},
  {(char*)"fix"                ,vt_DECFUNC ,NULL},
  {(char*)"frac"               ,vt_DOUBLE  ,NULL},
  {(char*)"fracl"              ,vt_LDOUBLE ,NULL},
  {(char*)"freefile"           ,vt_FILEPTR ,NULL},
  {(char*)"getattr"            ,vt_DECFUNC ,NULL},
  {(char*)"hex2dec"            ,vt_INTEGER ,NULL},
  {(char*)"hypot"              ,vt_DOUBLE  ,NULL},
  {(char*)"hypotl"             ,vt_LDOUBLE ,NULL},
  {(char*)"iabsl"              ,vt_INTEGER ,NULL},
  {(char*)"iif"                ,vt_DOUBLE  ,NULL},
  {(char*)"inchr"              ,vt_DECFUNC ,NULL},
  {(char*)"instr"              ,vt_DECFUNC ,NULL},
  {(char*)"instrrev"           ,vt_DECFUNC ,NULL},
  {(char*)"kbhit"              ,vt_DECFUNC ,NULL},
  {(char*)"keypress()"         ,vt_DECFUNC ,NULL},
  {(char*)"labs"               ,vt_LONG    ,NULL},
  {(char*)"llabs"              ,vt_LLONG   ,NULL},
  {(char*)"lof"                ,vt_DOUBLE  ,NULL},
  {(char*)"log"                ,vt_DOUBLE  ,NULL},
  {(char*)"log10"              ,vt_DOUBLE  ,NULL},
  {(char*)"log10l"             ,vt_LDOUBLE ,NULL},
  {(char*)"logl"               ,vt_LDOUBLE ,NULL},
  {(char*)"max"                ,vt_DOUBLE  ,NULL},
  {(char*)"min"                ,vt_DOUBLE  ,NULL},
  {(char*)"msgbox"             ,vt_DECFUNC ,NULL},
  {(char*)"pos"                ,vt_DECFUNC ,NULL},
  {(char*)"pow"                ,vt_DOUBLE  ,NULL},
  {(char*)"powl"               ,vt_LDOUBLE ,NULL},
  {(char*)"qbcolor"            ,vt_DECFUNC ,NULL},
  {(char*)"rnd"                ,vt_SINGLE  ,NULL},
  {(char*)"round"              ,vt_DOUBLE  ,NULL},
  {(char*)"screen"             ,vt_DECFUNC ,NULL},
  {(char*)"sgn"                ,vt_DECFUNC ,NULL},
  {(char*)"sin"                ,vt_DOUBLE  ,NULL},
  {(char*)"sinh"               ,vt_DOUBLE  ,NULL},
  {(char*)"sinl"               ,vt_LDOUBLE ,NULL},
  {(char*)"sizeof"             ,vt_DECFUNC ,NULL},
  {(char*)"split"              ,vt_DECFUNC ,NULL},
  {(char*)"sqrt"               ,vt_DOUBLE  ,NULL},
  {(char*)"sqrtl"              ,vt_LDOUBLE ,NULL},
  {(char*)"strlen"             ,vt_DECFUNC ,NULL},
  {(char*)"tally"              ,vt_DECFUNC ,NULL},
  {(char*)"tan"                ,vt_DOUBLE  ,NULL},
  {(char*)"tanh"               ,vt_DOUBLE  ,NULL},
  {(char*)"tanl"               ,vt_LDOUBLE ,NULL},
  {(char*)"textmode"           ,vt_DOUBLE  ,NULL},
  {(char*)"timer"              ,vt_SINGLE  ,NULL},
  {(char*)"val"                ,vt_DOUBLE  ,NULL},
  {(char*)"vall"               ,vt_LDOUBLE ,NULL}
END SET

SET tTypes[] AS tagWords
  {(char*)"_char"      ,vt_BC9CHAR     ,NULL},
  {(char*)"bc9char"    ,vt_BC9CHAR     ,NULL},
  {(char*)"bool"       ,vt_BOOL        ,NULL},
  {(char*)"boolean"    ,vt_BOOL        ,NULL},
  {(char*)"bstr"       ,vt_BSTR        ,NULL},
  {(char*)"byte"       ,vt_BYTE        ,NULL},
  {(char*)"cchar"       ,vt_BC9CHAR    ,NULL},
  {(char*)"char"       ,vt_CHAR        ,NULL},
  {(char*)"colorref"   ,vt_COLORREF    ,NULL},
  {(char*)"double"     ,vt_DOUBLE      ,NULL},
  {(char*)"dword"      ,vt_DWORD       ,NULL},
  {(char*)"farproc"    ,vt_FARPROC     ,NULL},
  {(char*)"file"       ,vt_FILEPTR     ,NULL},
  {(char*)"float"      ,vt_SINGLE      ,NULL},
  {(char*)"handle"     ,vt_HANDLE      ,NULL},
  {(char*)"hdc"        ,vt_HDC         ,NULL},
  {(char*)"hfont"      ,vt_HFONT       ,NULL},
  {(char*)"hwnd"       ,vt_HWND        ,NULL},
  {(char*)"int"        ,vt_INTEGER     ,NULL},
  {(char*)"ldouble"    ,vt_LDOUBLE     ,NULL},
  {(char*)"llong"      ,vt_LLONG       ,NULL},
  {(char*)"long"       ,vt_LONG        ,NULL},
  {(char*)"longlong"   ,vt_LLONG       ,NULL},
  {(char*)"lpbyte"     ,vt_LPBYTE      ,NULL},
  {(char*)"lpstr"      ,vt_LPSTR       ,NULL},
  {(char*)"lresult"    ,vt_LRESULT     ,NULL},
  {(char*)"pchar"      ,vt_PCHAR       ,NULL},
  {(char*)"short"      ,vt_SHORT       ,NULL},
  {(char*)"string"     ,vt_STRVAR      ,NULL},
  {(char*)"uint"       ,vt_UINT        ,NULL},
  {(char*)"ulong"      ,vt_ULONG       ,NULL},
  {(char*)"ulonglong"  ,vt_ULONGLONG   ,NULL},
  {(char*)"ushort"     ,vt_USHORT      ,NULL},
  {(char*)"variant"    ,vt_VARIANT     ,NULL},
  {(char*)"void"       ,vt_VOID        ,NULL},
  {(char*)"winbool"    ,vt_WINBOOL     ,NULL},
  {(char*)"wndclassex" ,vt_WNDCLASSEX  ,NULL}
END SET


SET atEmitWords[] AS tagWords
  {(char*)"$$repeat$"              ,0 ,Emit_StringProcs},           ' DONE
  {(char*)"_chdir"                 ,0 ,Emit_FolderDriveProcs},      ' DONE
  {(char*)"_mkdir"                 ,0 ,Emit_FolderDriveProcs},      ' DONE
  {(char*)"_rmdir"                 ,0 ,Emit_FolderDriveProcs},      ' DONE
  {(char*)"asm"                    ,0 ,Emit_CPP},                   ' DONE
'  {(char*)"auto"                   ,0 ,Emit_OtherProcs},            ' DONE
  {(char*)"bcx_set_edit_color"     ,0 ,Emit_GUIProcs},              ' DONE
  {(char*)"bcx_set_font"           ,0 ,Emit_GUIProcs},              ' DONE
  {(char*)"bcx_set_label_color"    ,0 ,Emit_GUIProcs},              ' DONE
  {(char*)"beginblock"             ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"call"                   ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"case"                   ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"caseelse"               ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"catch"                  ,0 ,Emit_CPP},                   ' DONE
  {(char*)"chdir"                  ,0 ,Emit_FolderDriveProcs},      ' DONE
  {(char*)"class"                  ,0 ,Emit_CPP},                   ' DONE
  {(char*)"clear"                  ,0 ,Emit_OtherProcs},            ' DONE
  {(char*)"close"                  ,0 ,Emit_FileIO},                ' DONE
  {(char*)"cls"                    ,0 ,Emit_ConsoleOnlyProcs},      ' DONE
  {(char*)"color"                  ,0 ,Emit_ConsoleOnlyProcs},      ' DONE
  {(char*)"const"                  ,0 ,Emit_OtherProcs},            ' DONE
  {(char*)"constexpr"              ,0 ,Emit_OtherProcs},            ' DONE
  {(char*)"constructor"            ,0 ,Emit_ConDes},                ' DONE
  {(char*)"continue"               ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"copyfile"               ,0 ,Emit_FileManagementProcs},   ' DONE
  {(char*)"data"                   ,0 ,Emit_OtherProcs},            ' DONE
  {(char*)"declare"                ,0 ,Emit_OtherProcs},            ' DONE
  {(char*)"decr"                   ,0 ,Emit_MathProcs},             ' DONE
  {(char*)"delay"                  ,0 ,Emit_ConsoleOnlyProcs},      ' DONE
  {(char*)"delete"                 ,0 ,Emit_CPP},                   ' DONE
  {(char*)"destructor"             ,0 ,Emit_ConDes},                ' DONE
  {(char*)"dialogbox"              ,0 ,Emit_DialogBox},             ' DONE
  {(char*)"dim"                    ,0 ,Emit_OtherProcs},            ' DONE
  {(char*)"do"                     ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"dynamic"                ,0 ,Emit_Dynamic},               ' DONE
  {(char*)"ejectpage"              ,0 ,Emit_PrinterProcs},          ' DONE
  {(char*)"else"                   ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"elseif"                 ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"end"                    ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"endblock"               ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"endclass"               ,0 ,Emit_CPP},                   ' DONE
  {(char*)"endconstructor"         ,0 ,Emit_ConDes},                ' DONE
  {(char*)"enddestructor"          ,0 ,Emit_ConDes},                ' DONE
  {(char*)"endfunction"            ,0 ,Emit_EndFuncSub},            ' DONE
  {(char*)"endif"                  ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"endinterface"           ,0 ,Emit_CPP},                   ' DONE
  {(char*)"endnamespace"           ,0 ,Emit_CPP},                   ' DONE
  {(char*)"endpptype"              ,0 ,Emit_PPType},                ' DONE
  {(char*)"endprepend"             ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"endprogram"             ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"endrepeat"              ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"endselect"              ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"endstruct"              ,0 ,Emit_CPP},                   ' DONE
  {(char*)"endsub"                 ,0 ,Emit_EndFuncSub},            ' DONE
  {(char*)"endtemplate"            ,0 ,Emit_template},              ' DONE
  {(char*)"endtry"                 ,0 ,Emit_CPP},                   ' DONE
  {(char*)"endtype"                ,0 ,Emit_Type},                  ' DONE
  {(char*)"endunion"               ,0 ,Emit_Union},                 ' DONE
  {(char*)"endwhile"               ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"endwith"                ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"exit"                   ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"extern"                 ,0 ,Emit_OtherProcs},            ' DONE
  {(char*)"fallthrough"            ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"finput"                 ,0 ,Emit_FileIOProcs},           ' DONE
  {(char*)"for"                    ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"fprint"                 ,0 ,Emit_FileIOProcs},           ' DONE
  {(char*)"free"                   ,0 ,Emit_Dynamic},               ' DONE
  {(char*)"function"               ,0 ,Emit_FuncSub},               ' DONE
  {(char*)"functionreturn"         ,0 ,Emit_FunctionReturn},        ' DONE
  {(char*)"fwrite"                 ,0 ,Emit_FileIOProcs},           ' DONE
  {(char*)"global"                 ,0 ,Emit_Shared_Global},         ' DONE
  {(char*)"gosub"                  ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"goto"                   ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"gui"                    ,0 ,Emit_GUIProcs},              ' DONE
  {(char*)"if"                     ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"impfunction"            ,0 ,Emit_Implied},               ' DONE
  {(char*)"incr"                   ,0 ,Emit_MathProcs},             ' DONE
  {(char*)"input"                  ,0 ,Emit_KeyboardProcs},         ' DONE
  {(char*)"insertmenu"             ,0 ,Emit_GUIProcs},              ' DONE
  {(char*)"interface"              ,0 ,Emit_CPP},                   ' DONE
  {(char*)"kill"                   ,0 ,Emit_FileManagementProcs},   ' DONE
  {(char*)"lineinput"              ,0 ,Emit_FileIOProcs},           ' DONE
  {(char*)"local"                  ,0 ,Emit_OtherProcs},            ' DONE
  {(char*)"locate"                 ,0 ,Emit_ConsoleOnlyProcs},      ' DONE
  {(char*)"loop"                   ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"lprint"                 ,0 ,Emit_PrinterProcs},          ' DONE
  {(char*)"mdigui"                 ,0 ,Emit_GUIProcs},              ' DONE
  {(char*)"midstr"                 ,0 ,Emit_StringProcs},           ' DONE
  {(char*)"mkdir"                  ,0 ,Emit_FolderDriveProcs},      ' DONE
  {(char*)"msgbox"                 ,0 ,Emit_GUIProcs},              ' DONE
  {(char*)"namespace"              ,0 ,Emit_CPP},                   ' DONE
  {(char*)"next"                   ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"open"                   ,0 ,Emit_FileIO},                ' DONE
  {(char*)"optfunction"            ,0 ,Emit_OptFuncSub},            ' DONE
  {(char*)"optsub"                 ,0 ,Emit_OptFuncSub},            ' DONE
  {(char*)"overloadedfunction"     ,0 ,Emit_OverLoadFuncSub},       ' DONE
  {(char*)"overloadedsub"          ,0 ,Emit_OverLoadFuncSub},       ' DONE
  {(char*)"panel"                  ,0 ,Emit_ConsoleOnlyProcs},      ' DONE
  {(char*)"pptype"                 ,0 ,Emit_PPType},                ' DONE
  {(char*)"prepend"                ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"print"                  ,0 ,Emit_ConsoleOnlyProcs},      ' DONE
  {(char*)"printerclose"           ,0 ,Emit_PrinterProcs},          ' DONE
  {(char*)"printeropen"            ,0 ,Emit_PrinterProcs},          ' DONE
  {(char*)"private"                ,0 ,Emit_CPP},                   ' DONE
  {(char*)"privatedim"             ,0 ,Emit_OtherProcs},            ' DONE
  {(char*)"privatefunction"        ,0 ,Emit_FuncSub},               ' DONE
  {(char*)"privatesub"             ,0 ,Emit_FuncSub},               ' DONE
  {(char*)"protected"              ,0 ,Emit_CPP},                   ' DONE
  {(char*)"public"                 ,0 ,Emit_CPP},                   ' DONE
  {(char*)"publicfunction"         ,0 ,Emit_FuncSub},               ' DONE
  {(char*)"publicsub"              ,0 ,Emit_FuncSub},               ' DONE
  {(char*)"qsort"                  ,0 ,Emit_ArrayProcs},            ' DONE
  {(char*)"qsortidx"               ,0 ,Emit_ArrayProcs},            ' DONE
  {(char*)"raw"                    ,0 ,Emit_OtherProcs},            ' DONE
  {(char*)"record"                 ,0 ,Emit_FileIO},                ' DONE
  {(char*)"redim"                  ,0 ,Emit_OtherProcs},            ' DONE
'  {(char*)"register"               ,0 ,Emit_OtherProcs},            ' DONE
  {(char*)"rename"                 ,0 ,Emit_FileManagementProcs},   ' DONE
  {(char*)"repeat"                 ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"return"                 ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"rmdir"                  ,0 ,Emit_FolderDriveProcs},      ' DONE
  {(char*)"run"                    ,0 ,Emit_OtherProcs},            ' DONE
  {(char*)"seek"                   ,0 ,Emit_FileIOProcs},           ' DONE
  {(char*)"select"                 ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"shared"                 ,0 ,Emit_Shared_Global},         ' DONE
  {(char*)"shell"                  ,0 ,Emit_OtherProcs},            ' DONE
  {(char*)"sprint"                 ,0 ,Emit_PrinterProcs},          ' DONE
  {(char*)"static"                 ,0 ,Emit_OtherProcs},            ' DONE
  {(char*)"struct"                 ,0 ,Emit_CPP},                   ' DONE
  {(char*)"sub"                    ,0 ,Emit_FuncSub},               ' DONE
  {(char*)"swap"                   ,0 ,Emit_OtherProcs},            ' DONE
  {(char*)"template"               ,0 ,Emit_template},              ' DONE
  {(char*)"textmode"               ,0 ,Emit_ConsoleOnlyProcs},      ' DONE
  {(char*)"throw"                  ,0 ,Emit_CPP},                   ' DONE
  {(char*)"try"                    ,0 ,Emit_CPP},                   ' DONE
  {(char*)"type"                   ,0 ,Emit_Type},                  ' DONE
  {(char*)"union"                  ,0 ,Emit_Union},                 ' DONE
  {(char*)"wend"                   ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"while"                  ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"with"                   ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"write"                  ,0 ,Emit_ConsoleOnlyProcs},      ' DONE
  {(char*)"xfor"                   ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"xnext"                  ,0 ,Emit_ControlFlow},           ' DONE
  {(char*)"~else"                  ,0 ,Emit_ConditionalCompilation},' DONE
  {(char*)"~elseif"                ,0 ,Emit_ConditionalCompilation},' DONE
  {(char*)"~endif"                 ,0 ,Emit_ConditionalCompilation},' DONE
  {(char*)"~get"                   ,0 ,Emit_FileIOProcs},           ' DONE
  {(char*)"~hscroll"               ,0 ,Emit_GUIProcs},              ' DONE
  {(char*)"~if"                    ,0 ,Emit_ConditionalCompilation},' DONE
  {(char*)"~ifndef"                ,0 ,Emit_ConditionalCompilation},' DONE
  {(char*)"~pragmaoptimizeoff"     ,0 ,Emit_ConditionalCompilation},' DONE
  {(char*)"~pragmaoptimizeon"      ,0 ,Emit_ConditionalCompilation},' DONE
  {(char*)"~put"                   ,0 ,Emit_FileIOProcs},           ' DONE
  {(char*)"~vscroll"               ,0 ,Emit_GUIProcs}               ' DONE
END SET



SET tDirectives[] AS tagWords
  {(char*)"#include"              , 0, Doinclude                 },
  {(char*)"$accelerator"          , 0, Doaccelerator             },
  {(char*)"$asm"                  , 0, Doasm                     },
  {(char*)"$bcx_resource"         , 0, Dobcx_resource            },
  {(char*)"$bcxversion"           , 0, Dobcxversion              },
  {(char*)"$catch"                , 0, Docatch                   },
  {(char*)"$ccode"                , 0, Doccode                   },
  {(char*)"$class"                , 0, Doclass                   },
  {(char*)"$com_off"              , 0, Docom_op                  },
  {(char*)"$com_on"               , 0, Docom_op                  },
  {(char*)"$com_trace"            , 0, Docom_op                  },
  {(char*)"$comment"              , 0, Docomment                 },
  {(char*)"$compiler"             , 0, Docompiler                },
  {(char*)"$cpp"                  , 0, Docpp                     },
  {(char*)"$cpphdr"               , 0, Docpphdr                  },
  {(char*)"$cproto"               , 0, Docproto                  },
  {(char*)"$debug"                , 0, Dodebug                   },
  {(char*)"$dll"                  , 0, Dodll                     },
  {(char*)"$endnamespace"         , 0, DoNameSpace               },
  {(char*)"$endtry"               , 0, DoTry                     },
  {(char*)"$exit"                 , 0, DoExitDirective            },
  {(char*)"$extc"              , 0, DoExternC                 },
  {(char*)"$filetest"             , 0, Dofiletest                },
  {(char*)"$fsstatic"             , 0, Dofsstatic                },
  {(char*)"$genfree"              , 0, Dogenfree                 },
  {(char*)"$header"               , 0, Doheader                  },
  {(char*)"$include"              , 0, Doinclude                 },
  {(char*)"$interface"            , 0, Dointerface               },
  {(char*)"$iprint_off"           , 0, Doiprint_offon            },
  {(char*)"$iprint_on"            , 0, Doiprint_offon            },
  {(char*)"$leanandmean"          , 0, Doleanandmean             },
  {(char*)"$liberror"             , 0, Doliberror                },
  {(char*)"$library"              , 0, Dolibrary                 },
  {(char*)"$linker"               , 0, Dolinker                  },
  {(char*)"$mingw"                , 0, Domingw                   },
  {(char*)"$mt"                   , 0, Domultithread             },
  {(char*)"$multi"                , 0, Domultithread             },
  {(char*)"$namespace"            , 0, DoNameSpace               },
  {(char*)"$noapi"                , 0, Donoapi                   },
  {(char*)"$nodllmain"            , 0, Dodll                     },
  {(char*)"$noinc"                , 0, Donoinc                   },
  {(char*)"$noini"                , 0, Donoini                   },
  {(char*)"$noio"                 , 0, Donoio                    },
  {(char*)"$nolibmain"            , 0, Donolibmain               },
  {(char*)"$nomain"               , 0, Donomain                  },
  {(char*)"$nowin"                , 0, Donowin                   },
  {(char*)"$onentry"              , 0, Doonentry                 },
  {(char*)"$onexit"               , 0, Doonexit                  },
  {(char*)"$optimizer"             , 0, Dooptimizer                },
  {(char*)"$pack"                 , 0, Dopack                    },
  {(char*)"$pp"                   , 0, Dopp                      },
  {(char*)"$prj"                  , 0, Doprj                     },
  {(char*)"$prjuse"               , 0, Doprj                     },
  {(char*)"$project"              , 0, Doproject                 },
  {(char*)"$props"                , 0, Doclassprops              },
  {(char*)"$rems"                 , 0, Dorems                    },
  {(char*)"$resource"             , 0, Doresource                },
  {(char*)"$source"               , 0, Dosource                  },
  {(char*)"$stdcall"              , 0, Dostdcall                 },
  {(char*)"$test"                 , 0, Dotest                    },
  {(char*)"$throw"                , 0, Dothrow                   },
  {(char*)"$trace"                , 0, Dotrace                   },
  {(char*)"$try"                  , 0, DoTry                     },
  {(char*)"$turbo"                , 0, Doturbo                   },
  {(char*)"$typedef"              , 0, Dotypedef                 },
  {(char*)"$usenamespace"         , 0, DoNameSpace               },
  {(char*)"$using"                , 0, DoCppUsing                },
  {(char*)"$wxc"                  , 0, DoWx               },
  {(char*)"$wxg"                  , 0, DoWx               }

END SET



$COMMENT
TYPE tagModuleInfo
  DIM Modules$                  ' store the current module name
  DIM ModuleLineNos AS INTEGER  ' current line number
END TYPE
$COMMENT
'*************************************************************************
'                            GLOBAL VARIABLES
'*************************************************************************
CONST MaxStk = 4096
CONST cMaxByref = 128
CONST cMaxDLLDecl = 1000
CONST cMaxLoopLocal = 256
GLOBAL  BCX_TmpStrSize
GLOBAL  sENDBCXRTLIB$
GLOBAL  sENDBCXRTLIB2$
GLOBAL  gLinesWritten
GLOBAL InternalDebugOff
'***************************************************
CONST cMaxConstMacros = 512
'***********************************************************************
CONST TWIN = 1
CONST TNIX = 2
GLOBAL TargetOS = TWIN
'***********************************************************************
GLOBAL AStyleDel = TRUE			'-xorig will not delete the ASTYLE backup file
GLOBAL  ConstMacro$[cMaxConstMacros]
GLOBAL ConstMacroCnt AS INT
CONST cMaxModules = 256
GLOBAL  ByrefVars$[cMaxByref]
GLOBAL  ByrefCnt
GLOBAL  LoopLocalVar[cMaxLoopLocal]
GLOBAL  LoopLocalCnt
GLOBAL  LoopType[cMaxLoopLocal] AS tagLoopLoc
GLOBAL  LoopTypeCnt
GLOBAL  Modules$[cMaxModules]                             ' array of source filenames
GLOBAL  ModuleLineNos[cMaxModules]                        ' line no in source files, uses ModuleNdx also
GLOBAL  FPtr             [cMaxModules] AS FILE            ' Controls $Include Files
GLOBAL  ModuleNdx                                 ' index of source files
'***************************************************
GLOBAL  iDoWhile
GLOBAL  iLoopCond
GLOBAL  GlobalVarCnt
CONST cMaxBaseTypeDefs = 16
GLOBAL  BaseTypeDefsCnt[cMaxBaseTypeDefs]
GLOBAL  TypeDefName$[cMaxBaseTypeDefs]
GLOBAL  TypeDefsCnt
GLOBAL  LocalVarCnt
GLOBAL  LocalDynArrCnt                            ' Local Dynamic String Array Stack Counter
GLOBAL  LocalDynaCnt                              ' Queue Stack Counter
GLOBAL  GlobalDynaCnt
GLOBAL  CombineRes                                ' Join generated rc file with existing rc file
GLOBAL  UserResFile$                              ' holds name of user *.rc file
GLOBAL  ResCompiler$                              ' resource compiler, lrc.exe
GLOBAL  FPtrNdx                                   ' Controls $Include Files
GLOBAL  Stk$            [MaxStk]                  ' Parse array
GLOBAL  ProtoType       [cMAXProtoType] AS tagProtoStore      ' C prototype declarations of user func's
CONST cMaxSingleLineIFLines = 128
GLOBAL  SrcStk$          [cMaxSingleLineIFLines]     ' used in parsing single line if-THEN-else
CONST cMaxSplitLines = 128
GLOBAL  SplitStk$        [cMaxSplitLines]         ' used in parsing ":" separated lines
GLOBAL  SplitCnt
GLOBAL  SplitCur
GLOBAL  SrcTmp$                                   ' used for storing string to use as parameter to Parse()
CONST cMaxOnEntry = 256
GLOBAL  Entry$           [cMaxOnEntry]            ' Controls the $OnEntry
CONST cMaxOnExit = 256
GLOBAL  Xit$             [cMaxOnExit]             ' Controls the $OnExit
CONST cMaxLocalDynArr = 256
GLOBAL  LocalDynArrName$ [cMaxLocalDynArr]        ' Queues LOCAL dynamic string arrays
CONST cMaxGlobalDyna = 256
GLOBAL  GlobalDynaStr$   [cMaxGlobalDyna]
CONST cMaxDynaStr = 256
GLOBAL  DynaStr$         [cMaxDynaStr]            ' Queues Dynamic strings in SUBS/FUNCTIONS
CONST cMaxStartSub = 32
GLOBAL  StartSub$        [cMaxStartSub]           ' user's startup code subs
GLOBAL  StartNdx                                  ' index for StartSub$
CONST cMaxExitSub = 32
GLOBAL  ExitSub$         [cMaxExitSub]            ' user's exit code subs
GLOBAL  ExitNdx                                   ' index for ExitSub$
GLOBAL  Library$         [MaxLib]                 ' stores libraries to used
GLOBAL  GlobalVarHash[MaxGlobalVars]
GLOBAL  GlobalVars[MaxGlobalVars] AS VarInfo      ' Holds global variables
GLOBAL  LocalVars[MaxLocalVars]   AS VarInfo      ' Holds local variables
GLOBAL  TypeDefs [MaxTypes]       AS UserTypeDefs ' Holds typedefs
GLOBAL  UmQt                                      'Handles quoted lines split with a contination _
'****** Globals for COM parsing ************
CONST cMaxComStk = 256
GLOBAL  ComNdx
GLOBAL  ComStk$[cMaxComStk]
CONST cMaxParamToken = 64
GLOBAL  ParamToken$[cMaxParamToken]

'****** Globals CPP parsing ************
GLOBAL  UseCpp
GLOBAL  UseCpphdr
GLOBAL  UseIO
GLOBAL  InNameSpace
GLOBAL  InClassModule
GLOBAL  InPPTypeModule
GLOBAL  InClassModuleName$

'------------------------------------------------------------------------------
'jcfuller -> these three added from bcx 7.0.8
CONST cMaxClassModuleNames = 1024
GLOBAL  iClassModuleCnt
GLOBAL  szClassModuleNames$[cMaxClassModuleNames]
'------------------------------------------------------------------------------
GLOBAL  InClassPP$
GLOBAL  IsVirtual
GLOBAL  szVirtual$

'jcfuller removed 08/11/2013
'GLOBAL  TemplateContainer$
GLOBAL  UsingTemplate

'jcfuller added 08/11/2013 from bcx 7.0.7
GLOBAL  WasAClassModule
'------------------------------------------------------------------------------
'jcfuller added 01/19/2015
GLOBAL DlgWin = 0
GLOBAL DlgWinProc$
'------------------------------------------------------------------------------
GLOBAL  HasVector
GLOBAL IsBiFile = 0
'************************************************************************************************
GLOBAL  UseInLine
GLOBAL  Accelerator$
GLOBAL  CallBackFlag
GLOBAL  CallType$         ' Calling convention cdecl, stdcall ...
GLOBAL  LabelGenerator = 1000
GLOBAL  CaseVar$
GLOBAL  Cmd$
GLOBAL  CmdPP$            ' preprocessor file
GLOBAL  Comma
GLOBAL  Compiler$
GLOBAL  CmdLineConst$
GLOBAL  CmdLineFileOut$
GLOBAL  CurrentFuncType
GLOBAL  DimType$
CONST cSizeOfDllDecl = 512
GLOBAL  DllDecl$  [cMaxDLLDecl][cSizeOfDllDecl] AS CHAR
GLOBAL  DllCnt
CONST cSizeOfLoadlibs = 512
CONST cMaxLoadlibs = 128
GLOBAL  Loadlibs$[cMaxLoadlibs][cSizeOfLoadlibs] AS CHAR
GLOBAL  LoadLibsCnt
GLOBAL  Elapsed AS SINGLE
GLOBAL  EndOfProgram
GLOBAL  EntryCnt
GLOBAL  ErrFile
GLOBAL  szFile$
GLOBAL  Filnam$
GLOBAL  ForceMainToFunc
GLOBAL  Funcname$
GLOBAL  Handle$
GLOBAL  HFileCnt
CONST cMaxHFiles = 128
GLOBAL  HFiles$[cMaxHFiles]
GLOBAL  HFile$
GLOBAL  InConditional
GLOBAL  InIfDef$
GLOBAL  Indent
GLOBAL  InfoBoxWarn
GLOBAL  InDialogEvt
GLOBAL  ModDialogEvt
GLOBAL  InFunc
GLOBAL  InMain
GLOBAL  InWinMain
GLOBAL  IsCallBack
'jcfuller changed 03/05/2015
'GLOBAL  UseFileTest = TRUE
GLOBAL  UseFileTest = FALSE
GLOBAL  UseCProto
GLOBAL  InBlock
CONST cMaxLocalInBlocks = 16
GLOBAL  LocalInBlock[cMaxLocalInBlocks]
GLOBAL  InTypeDef
GLOBAL  NoTypeDeclare
GLOBAL  InsertComments

GLOBAL As _bool  WxCon = _false
GLOBAL As _bool WxGui = _false


'******************* <> <Variable_Name> ****************************
GLOBAL  IsAuto
GLOBAL  IsDim
GLOBAL  IsLocal
GLOBAL  IsRaw
GLOBAL  IsRegister
GLOBAL  IsStatic
'******************* <> <Variable_Name> ****************************

GLOBAL  InDebug
GLOBAL  IsStdFunc
'GLOBAL  iStartCase
GLOBAL  KillCFile
GLOBAL  Keyword1$
GLOBAL  LastCmd
GLOBAL  LinesRead
GLOBAL  Linker$
GLOBAL  MakeDLL
GLOBAL  Ndx
GLOBAL  NoMain AS BOOL
GLOBAL  NoDllMain AS BOOL
GLOBAL  OkayToSend AS BOOL
GLOBAL  OptimizerEnabled AS BOOL
GLOBAL  OptimizerFirstSetting AS BOOL
GLOBAL  OptionBase
GLOBAL  OutfileClone$
GLOBAL  PassOne AS BOOL
GLOBAL  Project$
GLOBAL  ProtoCnt
GLOBAL  PusherSelectState
GLOBAL  PPFlag AS BOOL
GLOBAL  PPDLL_HANDLE AS HINSTANCE
GLOBAL  Use_LoadLibraryError        ' Use error routine when loading libraries
GLOBAL  LibraryErrorLog$            ' [Path\][Name] of error log for loading libraries
GLOBAL  Use_Library AS BOOL         ' Vic McClung for Building Runtime Library
GLOBAL  Use_Project AS BOOL         ' Vic McClung for $PROJECT Support
GLOBAL  szProject$
GLOBAL  Gen_Header AS BOOL          ' Vic McClung for $Project Support
GLOBAL  Use_Dll AS BOOL             ' Vic McClung for Building BCXRT.DLL
GLOBAL  Project_Main$               ' main file in project
GLOBAL  Project_List$               ' list of files in project
GLOBAL  Project_Path$               ' path for project output files, i.e. .h;.c;.cpp
GLOBAL  NoRT AS BOOL                ' No Runtime
GLOBAL  NoKill AS BOOL              ' don't erase BCXRT.C file - used for debugging runtime
GLOBAL  Quiet AS BOOL               ' no output to screen, for use with BCX Builder
GLOBAL  ReDirect AS BOOL
GLOBAL  SaveOutfileNum AS FILE
GLOBAL  Scoot$
GLOBAL  ShowStatus
GLOBAL  SrcCnt
GLOBAL  SrcFlag
GLOBAL  TrcFlag
GLOBAL  TestForBcxIni AS BOOL
GLOBAL  FileIn$
GLOBAL  FileOut$
GLOBAL  FileErr$
GLOBAL  T$
GLOBAL  Res_File$
GLOBAL  ResFileOut$
GLOBAL  Test
GLOBAL  Statements
GLOBAL  TestState
GLOBAL  Tipe$
GLOBAL  TranslateSlash
GLOBAL  UseFlag
GLOBAL  Use_EmptyTmpStr
GLOBAL  UseStdCall
GLOBAL  UseLCaseTbl
GLOBAL  WinHeaders
GLOBAL  UseWinApi
GLOBAL  NoIncludes
'GLOBAL  Winh = FALSE
GLOBAL  W1$
GLOBAL  W2$
GLOBAL  W3$
GLOBAL  Var$
GLOBAL  XitCount
GLOBAL  Z$
GLOBAL ConstLastDef$

'**********************
GLOBAL  Use_MFC
GLOBAL  Use_GUINoMain
GLOBAL  Use_MDIGUINoMain
GLOBAL  GUIIcon$
GLOBAL  GUIMenu$
GLOBAL  GUIMetric$
GLOBAL  Use_Wingui
GLOBAL  Use_MainEvent
GLOBAL  Use_Mdigui
GLOBAL  Use_ShowModal
GLOBAL  Use_EndModal
GLOBAL  Use_AndAlso
GLOBAL  Use_BCX_MsgPump
GLOBAL  Use_BC9_MsgPump
GLOBAL  Use_BC9_ResDlg
GLOBAL  Use_BC9_ResMDlg
GLOBAL  Use_BCX_MDI_MsgPump
GLOBAL  Use_BCX_Wnd
GLOBAL  Use_BCX_FrameWnd
GLOBAL  Use_BCX_SetBkGrdBrush
GLOBAL  Use_BCX_SetClassStyle
GLOBAL  Use_BCX_SetIcon
GLOBAL  Use_BCX_SetIconSm
GLOBAL  Use_BCX_SetMetric
GLOBAL  Use_BCX_InitGUI
GLOBAL  Use_BCX_RegWnd
GLOBAL  Use_BCX_SetCursor
GLOBAL  Use_AnsiToWide
GLOBAL  Use_Asinh
GLOBAL  Use_Acosh
GLOBAL  Use_AppActivate
GLOBAL  Use_Atanh
'GLOBAL  Use_Abs
GLOBAL  Use_Asc
GLOBAL  Use_AppExeName
GLOBAL  Use_AppExePath
GLOBAL  Use_Bff
GLOBAL  Use_Boolstr
GLOBAL  Use_Bor
GLOBAL  Use_Band
GLOBAL  Use_Bnot
GLOBAL  Use_BCX_BmpWidth
GLOBAL  Use_BCX_BmpHeight
GLOBAL  Use_BCX_Class_Info
GLOBAL  Use_BCX_LoadBMP
GLOBAL  Use_BCX_LoadImage
GLOBAL  Use_BCX_Control
GLOBAL  Use_BCX_Colordlg
GLOBAL  Use_BCX_Cursor
GLOBAL  Use_BCX_Fontdlg
GLOBAL  Use_BCX_Floodfill
GLOBAL  Use_BCX_Get
GLOBAL  Use_BcxSplitPath
GLOBAL  Use_BCX_Path
GLOBAL  Use_BCX_Put
GLOBAL  Use_BCX_Preset
GLOBAL  Use_BCX_Pset
GLOBAL  Use_BCX_Line
GLOBAL  Use_BCX_Lineto
GLOBAL  Use_BCX_Circle
GLOBAL  Use_BCX_Ellipse
GLOBAL  Use_BCX_Rectangle
GLOBAL  Use_BCX_Roundrect
GLOBAL  Use_BCX_Getpixel
GLOBAL  Use_BCX_Arc
GLOBAL  Use_BCX_OlePicture
GLOBAL  Use_BCX_Polygon
GLOBAL  Use_BCX_PolyBezier
GLOBAL  Use_BCX_Polyline
GLOBAL  Use_BCX_Print
GLOBAL  Use_BCX_Tile
GLOBAL  Use_BCX_Slider
GLOBAL  Use_BCX_Splitter
GLOBAL  Use_BCX_Tab
GLOBAL  Use_BCX_Toolbar
GLOBAL  Use_BCX_UpDown
GLOBAL  Use_BCX_Get_UpDown
GLOBAL  Use_Bin
GLOBAL  Use_Bit
GLOBAL  Use_Bin2dec
GLOBAL  Use_Cvd
GLOBAL  Use_Cvld
GLOBAL  Use_Cvi
GLOBAL  Use_Cvl
GLOBAL  Use_Cvs
GLOBAL  Use_Cdbl
GLOBAL  Use_Cldbl
GLOBAL  Use_Csng
GLOBAL  Use_Clear
GLOBAL  Use_Chr
GLOBAL  Use_Cbool
GLOBAL  Use_Cint
GLOBAL  Use_ClassProps
GLOBAL  Use_Clipboard
GLOBAL  Use_Clng
GLOBAL  Use_Cls
GLOBAL  Use_Color
GLOBAL  Use_Command
GLOBAL  Use_ComboBoxLoadFile
GLOBAL  Use_Console
GLOBAL  Use_ContainedIn
GLOBAL  Use_Static
GLOBAL  Use_ExternC
GLOBAL  Use_CreateRegInt
GLOBAL  Use_CreateRegString
GLOBAL  Use_Crlf
GLOBAL  Use_Csrlin
GLOBAL  Use_Curdir
GLOBAL Use_Choose
GLOBAL  Use_Date
GLOBAL  Use_Del
GLOBAL  Use_DeleteRegKey
GLOBAL  Use_Doevents
GLOBAL  Use_Download
GLOBAL  Use_Draw
GLOBAL  Use_Dynacall
GLOBAL  Use_DynacallA
GLOBAL  Use_DynacallCommon
GLOBAL  Use_DynamicA
GLOBAL  Use_DrawTransBMP
GLOBAL  Use_Elf
GLOBAL  Use_Enclose
GLOBAL  Use_Environ
GLOBAL  Use_EnumFile
GLOBAL  Use_Eof
GLOBAL  Use_EqualTo
GLOBAL  Use_Exist
GLOBAL  Use_ExitCode
GLOBAL  Use_Extract
GLOBAL  Use_LeanAndMean
GLOBAL  Use_LoadFile
GLOBAL  Use_FillArray
GLOBAL  Use_FirstInstance
GLOBAL  Use_Findfirst
GLOBAL  Use_Findnext
GLOBAL  Use_FindInType
GLOBAL  Use_Fint
GLOBAL  Use_Fix
GLOBAL  Use_FileLocked
GLOBAL  Use_Frac
GLOBAL  Use_Fracl
GLOBAL  Use_Freefile
GLOBAL  Use_FileScan
GLOBAL  Use_Get
GLOBAL  Use_FGet
GLOBAL  Use_FGetC
GLOBAL  Use_FPut
GLOBAL  Use_FSeek  
GLOBAL  Use_GetBmp
GLOBAL  Use_SetDimension
GLOBAL  Use_Getch
GLOBAL  Use_GetDimension
GLOBAL  Use_Getdrive
GLOBAL  Use_Getfilename
GLOBAL  Use_Getattr
GLOBAL  Use_GetResource
GLOBAL  Use_GetSpecialFolder
GLOBAL  Use_GetTextSize
GLOBAL  Use_GenFree
GLOBAL  Use_GoSub
GLOBAL  Use_Hex
GLOBAL  Use_Hex2Dec
GLOBAL  Use_Hook
GLOBAL  Use_Iif
GLOBAL  Use_Inputbuffer
GLOBAL  Use_Inkey
GLOBAL  Use_InkeyD
GLOBAL  Use_Inputbox
GLOBAL  Use_Infobox
GLOBAL  Use_BoxCommon     ' Set if Use_Inputbox or Use_Infobox set
GLOBAL  Use_Isptr
GLOBAL  Use_Inp
GLOBAL  Use_Inpw
GLOBAL  Use_Ins
GLOBAL  Use_Instr
GLOBAL  Use_Inchr
GLOBAL  Use_iReplace
GLOBAL  Use_IRemove
GLOBAL  Use_Instrrev
GLOBAL  Use_Imod
GLOBAL  Use_Instat
GLOBAL  Use_Join
GLOBAL  Use_Keypress
GLOBAL  Use_Lcase
GLOBAL  Use_LccPath
GLOBAL  Use_PellesPath
GLOBAL  Use_Ldouble
GLOBAL  Use_Left
GLOBAL  Use_Like
GLOBAL  Use_ListBoxLoadFile
GLOBAL  Use_Loc
GLOBAL  Use_Locate
GLOBAL  Use_Lof
GLOBAL  Use_Lpad
GLOBAL  Use_Ltrim
GLOBAL  Use_Mcase
GLOBAL  Use_Mid
GLOBAL  Use_Midstr
GLOBAL  Use_Msgbox
GLOBAL  Use_Mkd
GLOBAL  Use_Mkld
GLOBAL  Use_Mki
GLOBAL  Use_Mkl
GLOBAL  Use_Mks
GLOBAL  Use_Min
GLOBAL  Use_Modstyle
GLOBAL  Use_Max
GLOBAL  Use_Now
GLOBAL  Use_NotEqualTo
GLOBAL  Use_Numqsortdint
GLOBAL  Use_Numqsortaint
GLOBAL  Use_Numqsortdfloat
GLOBAL  Use_Numqsortafloat
GLOBAL  Use_Numqsortddouble
GLOBAL  Use_Numqsortadouble
GLOBAL  Use_Idxqsort
GLOBAL  Use_IdxqsortSt
GLOBAL  Use_PtrqsortSt
GLOBAL  Use_Oct
GLOBAL  Use_OrElse
GLOBAL  Use_Outp
GLOBAL  Use_Outpw
GLOBAL  Use_Overloaded
GLOBAL  Use_OSVersion
GLOBAL  Use_Panel
GLOBAL  Use_Pause
GLOBAL  Use_PeekStr
GLOBAL  Use_Pos
GLOBAL  Use_Printer
GLOBAL  Use_ProgressBar
GLOBAL  Use_Proto
GLOBAL  Use_Put
GLOBAL  Use_QBColor
GLOBAL  Use_Randomize
GLOBAL  Use_Rec
GLOBAL  Use_RecCount
GLOBAL  Use_Remain
GLOBAL  Use_Remove
GLOBAL  Use_Repeat
GLOBAL  Use_Replace
GLOBAL  Use_Reverse
GLOBAL  Use_Right
GLOBAL  Use_Rpad
GLOBAL  Use_Rnd
GLOBAL  Use_Exp
GLOBAL  Use_Retain
GLOBAL  Use_Round
GLOBAL  Use_Rtrim
GLOBAL  Use_Run
GLOBAL  Use_SaveBmp
GLOBAL  Use_Scan
GLOBAL  Use_Screen
GLOBAL  Use_Setattr
GLOBAL  Use_SearchPath
GLOBAL  Use_Set_BCX_Bitmap
GLOBAL  Use_Set_BCX_Bitmap2
GLOBAL  Use_Set_BCX_BmpButton
GLOBAL  Use_Set_BCX_Icon
GLOBAL  Use_Sgn
GLOBAL  Use_SingleFile AS BOOL
GLOBAL  Use_Sound
GLOBAL  Use_Space
GLOBAL  Use_Split
GLOBAL  Use_DSplit
GLOBAL  Use_StartupCode
GLOBAL  Use_Stristr
GLOBAL  Use_StrStr
GLOBAL  Use_Str
GLOBAL  Use_Sstr		'str$ for std::string -> sstr(Number)
GLOBAL  Use_Wstr		'str$ for std::wstring -> wstr(Number)
GLOBAL  Use_Sscvrt		'convert from to string <--> wstring
GLOBAL  Use_Strl
GLOBAL  Use_Str_Cmp
GLOBAL  Use_Strim
GLOBAL  Use_String
GLOBAL  Use_Strptr
GLOBAL  Use_Strqsorta
GLOBAL  Use_Strqsortd
GLOBAL  Use_Strtoken
GLOBAL  Use_DynStrqsorta
GLOBAL  Use_DynStrqsortd
GLOBAL  Use_DynAlphaNumericA
GLOBAL  Use_DynAlphaNumericD
GLOBAL  Use_AlphaNumericA
GLOBAL  Use_AlphaNumericD
GLOBAL  Use_AlphaNumeric
GLOBAL  Use_RegExist
GLOBAL  Use_RegInt
GLOBAL  Use_RegString
GLOBAL  Use_Resource
GLOBAL  Use_GenResFile
GLOBAL  Use_Swap
GLOBAL  Use_Sysdir
GLOBAL  Use_SysMacros
GLOBAL  Use_SysStr
GLOBAL  Use_sziif
GLOBAL  Use_Tally
GLOBAL  Use_Tempdir
GLOBAL  Use_TempFileName
GLOBAL  Use_Textmode
GLOBAL  Use_Threads
GLOBAL  Use_Time
GLOBAL  Use_Timer
GLOBAL  Use_Treeview
GLOBAL  Use_Trim
GLOBAL  Use_Ucase
GLOBAL  Use_Using
GLOBAL  Use_Ubound
GLOBAL  Use_VChr
GLOBAL  Use_VBS
GLOBAL  Use_Verify
GLOBAL  Use_Val
GLOBAL  Use_Vall
GLOBAL  Use_WideToAnsi
GLOBAL  Use_Vscroll
GLOBAL  Use_Hscroll
GLOBAL  Use_Windir
'jcfuller added
GLOBAL  Use_StrUpLow
GLOBAL  Use_DoCmdLine
GLOBAL  USE_ZTRACE = 0
'*******************

GLOBAL  Use_BCX_Input
GLOBAL  Use_Bitmap
GLOBAL  Use_Blackrect
GLOBAL  Use_BmpButton
GLOBAL  Use_Button
GLOBAL  Use_Center
GLOBAL  Use_Checkbox
GLOBAL  Use_Combobox
GLOBAL  Use_Datepick
GLOBAL  Use_Edit
GLOBAL  Use_BCXMDialog
GLOBAL  Use_BCXDialog
GLOBAL  Use_BCXDialogCommon' Set if Use_BCXDialog OR Use_BCXMDialog set
GLOBAL  Use_Form
GLOBAL  Use_GetText
GLOBAL  Use_Grayrect
GLOBAL  Use_Group
GLOBAL  Use_Hide
GLOBAL  Use_Icon
GLOBAL  Use_Label
GLOBAL  Use_Listbox
GLOBAL  Use_Listview
GLOBAL  Use_PlayWav
GLOBAL  Use_Radio
GLOBAL  Use_Refresh
GLOBAL  Use_Richedit
GLOBAL  Use_SetColor
GLOBAL  Use_SetFont
GLOBAL  Use_SetFormColor
GLOBAL  Use_SetText
GLOBAL  Use_Show
GLOBAL  Use_Status
GLOBAL  Use_Whiterect
GLOBAL  Use_RemoveExt
GLOBAL Use_DlgWin
'=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*

GLOBAL  Use_BC9Dialog
GLOBAL  Use_BC9Group
GLOBAL  Use_BC9Edit
GLOBAL  Use_BC9Input
GLOBAL  Use_BC9Button
GLOBAL  Use_BC9Checkbox
GLOBAL  Use_BC9Radio
GLOBAL  Use_BC9Label
GLOBAL  Use_BC9Combo
GLOBAL  Use_BC9Listbox
GLOBAL  Use_BC9DatePick
GLOBAL  Use_BC9BlackRect
GLOBAL  Use_BC9WhiteRect
GLOBAL  Use_BC9GrayRect
GLOBAL  Use_BC9RichEdit
GLOBAL  Use_BC9Bitmap
GLOBAL  Use_BC9Icon
GLOBAL  Use_BC9Listview
GLOBAL  Use_BC9Status
GLOBAL  Use_BC9DlgShow
GLOBAL  Use_BC9DlgShowModal
GLOBAL  Use_BC9Control
GLOBAL  Use_BC9Tab
GLOBAL  Use_BC9HCenterCtrlOnDialog
GLOBAL  Use_BC9VCenterCtrlOnDialog

GLOBAL  Use_LineInput = 0

GLOBAL  Use_TCLib = 0
GLOBAL  Use_Tcl_LineInput = 0
'GLOBAL  Use_Tcl_fprintS = 0
GLOBAL  Use_fprintS = 0
GLOBAL  Use_fstring = 1
'********************************
' PB Compatible String Constants
'********************************

GLOBAL  Use_BEL
GLOBAL  Use_BS
GLOBAL  Use_CR
GLOBAL  Use_DDQ
GLOBAL  Use_DQ
GLOBAL  Use_EOF
GLOBAL  Use_ESC
GLOBAL  Use_FF
GLOBAL  Use_LF
GLOBAL  Use_NUL
GLOBAL  Use_SPC
GLOBAL  Use_TAB
GLOBAL  Use_VT

'*********************

GLOBAL  O1$    '  "%o"
GLOBAL  S1$    '  "%s"
GLOBAL  S2$    '  "%s%s"
GLOBAL  D1$    '  "% .15G"
GLOBAL  D2$    '  "% .19LG"
GLOBAL  D3$	   ' VCHR$(15,15)
GLOBAL  X1$    '  "%X"
GLOBAL  T0$    '  "%H:%M:%S"
GLOBAL  T1$    '  "%H"
GLOBAL  T2$    '  "%M"
GLOBAL  T3$    '  "%S"
GLOBAL  T4$    '  "%p"
GLOBAL  T5$    '  "%Y"
GLOBAL  T6$    '  "%m"
GLOBAL  T7$    '  "%d"
GLOBAL  T8$    '  "%A"
GLOBAL  T9$    '  "%w"
GLOBAL  T10$   '  "%j"
GLOBAL  T11$   '  "%U"
GLOBAL  U1$

GLOBAL BC9PATH$

'**************************************************************
GLOBAL  ccodeFile$ ' $ccode file
GLOBAL  prcFile$   ' translated subs and functions
GLOBAL  udtFile$   ' translated User Defined Types
GLOBAL  datFile$   ' translated DATA statements
GLOBAL  UserConstFile$      ' user translated CONSTants
GLOBAL  SystemConstFile$    ' system translated CONSTants
GLOBAL  ovrFile$   ' translated overloaded subs and functions
GLOBAL  hdrFile$   ' user specified .h directives
GLOBAL  setFile$   ' translated GLOBAL set statements
GLOBAL  resFile$   ' user specified .rc directives
GLOBAL  enuFile$   ' user GLOBAL enum blocks

GLOBAL Compile64

'SET VarConst[2][8] AS CONST CHAR
SET VarConst[2][8] AS CHAR
  "",
  "const "
END SET

'SET VarStorage[6][18] AS CONST CHAR
SET VarStorage[6][18] AS CHAR
  "static ",
  "extern ",
  "",
  "static volatile ",
  "extern volatile ",
  "volatile "
END SET


'*************************************************************************
' For information on reserved words, currently how to translate
' Additional information may be added in the future.
'*************************************************************************
' Current information on reserved word, table is in alpabetical order
' Wayne Halsdorf
'*************************************************************************
ENUM
  eWI_CPPWord       = 0x0001
  eWI_ReplaceWord   = 0x0002
  eWI_NoFixup       = 0x0004
  eWI_Directive     = 0x0008
  eWI_Transform     = 0x0010
  eWI_Position1     = 0x0020
  eWI_Reserve10     = 0x0040
  eWI_Reserve09     = 0x0080
  eWI_Reserve08     = 0x0100
  eWI_Reserve07     = 0x0200
  eWI_Reserve06     = 0x0400
  eWI_Reserve05     = 0x0800
  eWI_Reserve04     = 0x1000
  eWI_Reserve03     = 0x2000
  eWI_Reserve02     = 0x4000
  eWI_Reserve01     = 0x8000
END ENUM

TYPE tagTokenSubFunctions
  DIM iTRAN_FLAG        AS INTEGER ' Where translations are legal
  DIM pszFunctionName   AS CONST PCHAR ' BCX word
  DIM pszFunctionXName  AS CONST PCHAR  ' if eWI_ReplaceWord set directly replace with this
  DIM iWordInfo         AS INTEGER  ' See ENUM above
  DIM iCOM              AS INTEGER    ' if can be used in directly with COM
END TYPE

GLOBAL iRIndex[97][2] AS Integer    'Low to High Lookup table for BCXWords[] - Reduces lookup size

SET BCXWords[] AS tagTokenSubFunctions
'  {1,(char*)"#const"                 ,(char*)"#Const"                        ,0,comvt_BAD},  ' VB Word
'  {1,(char*)"#externalsource"        ,(char*)"#ExternalSource"               ,0,comvt_BAD},  ' VB Word
'  {1,(char*)"#if"                    ,(char*)"#If"                           ,0,comvt_BAD},  ' VB Word
  {1,(char*)"#include"               ,(char*)"#include"                      ,8,comvt_BAD},   ' Directive
'  {1,(char*)"#then"                  ,(char*)"#Then"                         ,0,comvt_BAD},  ' VB Word
'  {1,(char*)"#else"                  ,(char*)"#Else"                         ,0,comvt_BAD},  ' VB Word
'  {1,(char*)"#region"                ,(char*)"#Region"                       ,0,comvt_BAD},  ' VB Word
  {1,(char*)"$accelerator"           ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$asm"                   ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$bcx_resource"          ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$bcxversion"            ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$catch"                 ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$ccode"                 ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$class"                 ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$com_off"               ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$com_on"                ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$com_trace"             ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$comment"               ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$compiler"              ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$cpp"                   ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$cpphdr"                ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$cproto"                ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$debug"                 ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$dll"                   ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$else"                  ,(char*)"~else"                         ,2,comvt_BAD},
  {1,(char*)"$elseif"                ,(char*)"~elseif"                       ,2,comvt_BAD},
  {1,(char*)"$endif"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"$endnamespace"          ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$endtry"                ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$exit"                  ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$extc"               ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$filetest"              ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$fsstatic"              ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$genfree"               ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$header"                ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$hscroll"               ,(char*)"~hscroll"                      ,2,comvt_BAD},
  {1,(char*)"$if"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"$ifdef"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"$ifndef"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"$include"               ,(char*)""                              ,8,comvt_BAD},
  {1,(char*)"$interface"             ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$iprint_off"            ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$iprint_on"             ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$lcc$"                  ,(char*)"$LCC$"                         ,2,comvt_BAD},
  {1,(char*)"$leanandmean"           ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$liberror"              ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$library"               ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$linker"                ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$mingw"                 ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$mt"                    ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$multi"                 ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$namespace"             ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$noapi"                 ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$nodllmain"             ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$noinc"                 ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$noini"                 ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$noio"                 ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$nolibmain"             ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$nomain"                ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$nowin"                 ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$onentry"               ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$onexit"                ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$optimizer"             ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$pack"                  ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$pp"                    ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$prj"                   ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$prjuse"                ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$project"               ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$props"                 ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$rems"                  ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$resource"              ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$source"                ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$stdcall"               ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$test"                  ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$throw"                 ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$trace"                 ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$try"                   ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$turbo"                 ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$typedef"               ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$usenamespace"          ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$using"                 ,(char*)""                              ,8,comvt_BAD},   ' Directive
  {1,(char*)"$vscroll"               ,(char*)"~vscroll"                      ,2,comvt_BAD},
  {1,(char*)"$wxc"                 ,(char*)""                                ,8,comvt_BAD},   ' Directive
  {1,(char*)"$wxg"                 ,(char*)""                                ,8,comvt_BAD},   ' Directive
  {1,(char*)"_asm"                   ,(char*)"_asm"                          ,2,comvt_BAD},
  {1,(char*)"abs"                    ,(char*)"fabs"                          ,2,comvt_R8 },
  {1,(char*)"acos"                   ,(char*)"acos"                          ,2,comvt_R8 },
  {1,(char*)"acosh"                  ,(char*)""                              ,0,comvt_R8 },
  {1,(char*)"acosl"                  ,(char*)"acosl"                         ,2,comvt_BAD},
'  {1,(char*)"addhandler"             ,(char*)"AddHandler"                    ,0,comvt_BAD},  ' VB Word
  {1,(char*)"addressof"              ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"alias"                  ,(char*)"alias"                         ,2,comvt_BAD},
  {1,(char*)"and"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"andalso"                ,(char*)""                              ,0,comvt_BAD},  ' VB Word
'  {1,(char*)"ansi"                   ,(char*)"Ansi"                          ,0,comvt_BAD},  ' VB Word
  {1,(char*)"ansitowide"             ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"appactivate"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"append"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"appexename$"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"appexepath$"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"argc"                   ,(char*)"argc"                          ,2,comvt_BAD},
  {1,(char*)"argv"                   ,(char*)"argv"                          ,2,comvt_BAD},
  {1,(char*)"argv$"                  ,(char*)"argv$"                         ,2,comvt_BAD},
  {1,(char*)"arraygetelement"        ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"arrayputelement"        ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"as"                     ,(char*)""                              ,0,comvt_BAD},
  {3,(char*)"asc"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"ascending"              ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"asin"                   ,(char*)"asin"                          ,2,comvt_R8 },
  {1,(char*)"asinh"                  ,(char*)""                              ,0,comvt_R8 },
  {1,(char*)"asinl"                  ,(char*)"asinl"                         ,2,comvt_BAD},
  {1,(char*)"asm"                    ,(char*)""                              ,1,comvt_BAD},  ' C++ Word
'  {1,(char*)"assembly"               ,(char*)"Assembly"                      ,0,comvt_BAD},  ' VB Word
  {1,(char*)"atan"                   ,(char*)"atan"                          ,2,comvt_R8 },
  {1,(char*)"atanh"                  ,(char*)""                              ,0,comvt_R8 },
  {1,(char*)"atanl"                  ,(char*)"atanl"                         ,2,comvt_R8 },
  {1,(char*)"atn"                    ,(char*)"atan"                          ,2,comvt_R8 },
  {1,(char*)"atnl"                   ,(char*)"atanl"                         ,2,comvt_R8 },
  {1,(char*)"auto"                   ,(char*)""                              ,0,comvt_BAD},
  {3,(char*)"band"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"base"                   ,(char*)"base"                          ,2,comvt_BAD},
  {1,(char*)"bc9_dialog"             ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bc9_msgpump"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bc9_resdlg"             ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bc9_resmdlg"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcopy"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_addtab"             ,(char*)"BCX_AddTab"                    ,2,comvt_BAD},
  {1,(char*)"bcx_arc"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_bitmap"             ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_blackrect"          ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_bmpbutton"          ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_bmpheight"          ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_bmpwidth"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_button"             ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_checkbox"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_circle"             ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_classname$"         ,(char*)"BCX_ClassName$"                ,2,comvt_BAD},
  {1,(char*)"bcx_colordlg"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_combobox"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_control"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_cursor"             ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_datepick"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_dialog"             ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_dispatchobject"     ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_dlgwin"             ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_edit"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_ellipse"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_floodfill"          ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_font"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_fontdlg"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_form"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_framewnd"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_get"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_get_com_error_code" ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_get_com_error_desc$",(char*)"BCX_GET_COM_ERROR_DESC()"      ,2,comvt_BAD},
  {1,(char*)"bcx_get_com_status"     ,(char*)"BCX_GET_COM_STATUS"            ,2,comvt_BAD},
  {1,(char*)"bcx_get_com_success"    ,(char*)"BCX_GET_COM_SUCCESS()"         ,2,comvt_BAD},
  {1,(char*)"bcx_get_text$"          ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_get_updown"         ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_getpixel"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_grayrect"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_group"              ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_hinstance"          ,(char*)"BCX_hInstance"                 ,2,comvt_BAD},
  {1,(char*)"bcx_icon"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_initgui"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_input"              ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_label"              ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_line"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_lineto"             ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_listbox"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_listview"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_loadbmp"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_loadimage"          ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_mdi_msgpump"        ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_mdialog"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_mdichild"           ,(char*)"BCX_MDICHILD"                  ,2,comvt_BAD},
  {1,(char*)"bcx_mdiclass"           ,(char*)"BCX_MDICLASS"                  ,2,comvt_BAD},
  {1,(char*)"bcx_mdiclient"          ,(char*)"BCX_MDICLIENT"                 ,2,comvt_BAD},
  {1,(char*)"bcx_msgpump"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_ole_height"         ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_ole_width"          ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_olepicture"         ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_polybezier"         ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_polygon"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_polyline"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_preset"             ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_print"              ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_progressbar"        ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_pset"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_put"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_radio"              ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_rectangle"          ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_regwnd"             ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_remtab"             ,(char*)"BCX_RemTab"                    ,2,comvt_BAD},
  {1,(char*)"bcx_resource"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_richedit"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_roundrect"          ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_scalex"             ,(char*)"BCX_ScaleX"                    ,2,comvt_BAD},
  {1,(char*)"bcx_scaley"             ,(char*)"BCX_ScaleY"                    ,2,comvt_BAD},
  {1,(char*)"bcx_set_edit_color"     ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_set_font"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_set_form_color"     ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_set_label_color"    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_set_text"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_setbkgrdbrush"      ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_setclassstyle"      ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_setcolor"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_setcursor"          ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_seticon"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_seticonsm"          ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_setmetric"          ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_setsplitpos"        ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_show_com_errors"    ,(char*)"BCX_SHOW_COM_ERRORS"           ,2,comvt_BAD},
  {1,(char*)"bcx_slider"             ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_splitter"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_status"             ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_tab"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_tabselect"          ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_thread"             ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_threadend"          ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_threadkill"         ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_threadresume"       ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_threadsuspend"      ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_threadwait"         ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_tile"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_toolbar"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_treeview"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_updown"             ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_version$"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_whiterect"          ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_wnd"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcx_wndclass"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcxfont"                ,(char*)"BcxFont"                       ,2,comvt_BAD},
  {1,(char*)"bcxlib"                 ,(char*)"BCXLIB"                        ,2,comvt_BAD},
  {1,(char*)"bcxpath$"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bcxsplitpath$"          ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"begin"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bel$"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bff$"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bfree"                  ,(char*)"SysFreeString"                 ,2,comvt_BAD},
  {1,(char*)"bin$"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bin2dec"                ,(char*)""                              ,0,comvt_I4 },
  {1,(char*)"binary"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bit"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"blen"                   ,(char*)"SysStringLen"                  ,2,comvt_BAD},
  {1,(char*)"bnew"                   ,(char*)"SysAllocString"                ,2,comvt_BAD},
  {3,(char*)"bnot"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bool"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bool$"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"boolean"                ,(char*)""                              ,0,comvt_BAD},
  {3,(char*)"bor"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"bs$"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"byref"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"byte"                   ,(char*)"BYTE"                          ,2,comvt_BAD},
'  {1,(char*)"byval"                  ,(char*)"ByVal"                         ,0,comvt_BAD},  ' VB Word
  {1,(char*)"c_declare"              ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"call"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"callback"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"callwindowproc"         ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"case"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"catch"                  ,(char*)"catch"                         ,3,comvt_BAD},  ' C++ Word
  {1,(char*)"cbctl"                  ,(char*)"LOWORD(wParam)"                ,2,comvt_BAD},
  {1,(char*)"cbctlmsg"               ,(char*)"HIWORD(wParam)"                ,2,comvt_BAD},
  {1,(char*)"cbhndl"                 ,(char*)"hWnd"                          ,2,comvt_BAD},
  {1,(char*)"cbhwnd"                 ,(char*)"hWnd"                          ,2,comvt_BAD},
  {1,(char*)"cblparam"               ,(char*)"lParam"                        ,2,comvt_BAD},
  {1,(char*)"cbmsg"                  ,(char*)"Msg"                           ,2,comvt_BAD},
  {1,(char*)"cbool"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"cbwparam"               ,(char*)"wParam"                        ,2,comvt_BAD},
'  {1,(char*)"cbyte"                  ,(char*)"CByte"                         ,0,comvt_BAD},  ' VB Word
'  {1,(char*)"cchar"                  ,(char*)"CChar"                         ,0,comvt_BAD},  ' VB Word
'  {1,(char*)"cdate"                  ,(char*)"CDate"                         ,0,comvt_BAD},  ' VB Word
  {1,(char*)"cdbl"                   ,(char*)""                              ,0,comvt_BAD},
'  {1,(char*)"cdec"                   ,(char*)"CDec"                          ,0,comvt_BAD},  ' VB Word
  {1,(char*)"center"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"char"                   ,(char*)"char"                          ,2,comvt_BAD},
  {1,(char*)"chdir"                  ,(char*)"chdir"                         ,2,comvt_BAD},
  {1,(char*)"chdrive"                ,(char*)"chdir"                         ,2,comvt_BAD},
  {1,(char*)"chr$"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"cint"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"class"                  ,(char*)"class"                         ,3,comvt_BAD},  ' C++ Word
  {1,(char*)"cldbl"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"clear"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"clng"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"close"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"close#"                 ,(char*)"close"                         ,2,comvt_BAD},
  {1,(char*)"closedialog"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"cls"                    ,(char*)""                              ,0,comvt_BAD},
'  {1,(char*)"cobj"                   ,(char*)"CObj"                          ,0,comvt_BAD},  ' VB Word
  {1,(char*)"color"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"color_bg"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"color_fg"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"colorref"               ,(char*)"COLORREF"                      ,2,comvt_BAD},
  {1,(char*)"comboboxloadfile"       ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"command$"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"concat"                 ,(char*)"strcat"                        ,2,comvt_BAD},
  {1,(char*)"const"                  ,(char*)"const"                         ,2,comvt_BAD},
  {1,(char*)"const_cast"             ,(char*)"const_cast"                    ,3,comvt_BAD},  ' C++ Word
  {1,(char*)"constexpr"              ,(char*)"constexpr"                     ,2,comvt_BAD},
  {1,(char*)"constructor"            ,(char*)""                              ,1,comvt_BAD},  ' C++ Word
  {1,(char*)"containedin"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"control"                ,(char*)"HWND"                          ,2,comvt_BAD},
  {1,(char*)"copyfile"               ,(char*)"copyfile"                      ,2,comvt_BAD},
  {1,(char*)"cos"                    ,(char*)"cos"                           ,2,comvt_R8 },
  {1,(char*)"cosh"                   ,(char*)"cosh"                          ,2,comvt_R8 },
  {1,(char*)"cosl"                   ,(char*)"cosl"                          ,2,comvt_BAD},
  {1,(char*)"cr$"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"createobject"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"createregint"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"createregstring"        ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"crlf$"                  ,(char*)""                              ,0,comvt_BAD},
'  {1,(char*)"cshort"                 ,(char*)"CShort"                        ,0,comvt_BAD},  ' VB Word
  {1,(char*)"csng"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"csrlin"                 ,(char*)""                              ,0,comvt_BAD},
'  {1,(char*)"cstr"                   ,(char*)"CStr"                          ,0,comvt_BAD},  ' VB Word
'  {1,(char*)"ctype"                  ,(char*)"CType"                         ,0,comvt_BAD},  ' VB Word
  {1,(char*)"curdir$"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"currency"               ,(char*)"CURRENCY"                      ,2,comvt_BAD},
  {1,(char*)"cursorx"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"cursory"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"cvd"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"cvi"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"cvl"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"cvld"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"cvs"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"data"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"data$"                  ,(char*)"DATA$"                         ,2,comvt_BAD},
  {1,(char*)"date$"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"ddq$"                   ,(char*)""                              ,0,comvt_BAD},
'  {1,(char*)"decimal"                ,(char*)"Decimal"                       ,0,comvt_BAD},  ' VB Word
  {1,(char*)"declare"                ,(char*)""                              ,16,comvt_BAD},
  {1,(char*)"decr"                   ,(char*)"decr"                          ,2,comvt_BAD},
'  {1,(char*)"default"                ,(char*)"default"                       ,0,comvt_BAD},  ' VB/C/C++ Word
  {1,(char*)"del$"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"delay"                  ,(char*)"delay"                         ,2,comvt_BAD},
'  {1,(char*)"delegate"               ,(char*)"Delegate"                      ,0,comvt_BAD},  ' VB Word
  {1,(char*)"delete"                 ,(char*)"delete"                        ,3,comvt_BAD},  ' C++ Word
  {1,(char*)"deleteregkey"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"descending"             ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"destroysafearray"       ,(char*)"DestroySafeArray"              ,0,comvt_BAD},
  {1,(char*)"destructor"             ,(char*)""                              ,1,comvt_BAD},
  {1,(char*)"dialog"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"dialogbox"              ,(char*)"DialogBox"                     ,2,comvt_BAD},
  {1,(char*)"dim"                    ,(char*)"dim"                           ,2,comvt_BAD},
'  {1,(char*)"directcast"             ,(char*)"DirectCast"                    ,0,comvt_BAD},  ' VB Word
  {1,(char*)"do"                     ,(char*)"do"                            ,2,comvt_BAD},
  {1,(char*)"doevents"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"double"                 ,(char*)"double"                        ,2,comvt_BAD},
  {1,(char*)"download"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"dq$"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"drawtransbmp"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"dsplit"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"dword"                  ,(char*)"DWORD"                         ,2,comvt_BAD},
  {1,(char*)"dynamic"                ,(char*)"dynamic"                       ,2,comvt_BAD},
  {1,(char*)"dynamic_cast"           ,(char*)"dynamic_cast"                  ,3,comvt_BAD},  ' C++ Word
'  {1,(char*)"each"                   ,(char*)"Each"                          ,0,comvt_BAD},  ' VB Word
  {1,(char*)"editloadfile"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"ejectpage"              ,(char*)"ejectpage"                     ,2,comvt_BAD},
  {1,(char*)"else"                   ,(char*)"else"                          ,2,comvt_BAD},
  {1,(char*)"elseif"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"emptytmpstr"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"enc$"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"end"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"enddraw"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"endif"                  ,(char*)"endif"                         ,2,comvt_BAD},
  {1,(char*)"endmodal"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"enum"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"environ$"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"eof"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"eof$"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"equalto"                ,(char*)""                              ,0,comvt_BAD},
'  {1,(char*)"erase"                  ,(char*)"Erase"                         ,0,comvt_BAD},  ' VB Word
'  {1,(char*)"error"                  ,(char*)"Error"                         ,0,comvt_BAD},  ' VB Word
  {1,(char*)"esc$"                   ,(char*)""                              ,0,comvt_BAD},
'  {1,(char*)"event"                  ,(char*)"Event"                         ,0,comvt_BAD},  ' VB Word
  {1,(char*)"events"                 ,(char*)"events"                        ,0,comvt_BAD},
  {1,(char*)"exist"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"exit"                   ,(char*)"exit"                          ,2,comvt_BAD},
  {1,(char*)"exp"                    ,(char*)""                              ,0,comvt_R8 },
  {1,(char*)"explicit"               ,(char*)"explicit"                      ,3,comvt_BAD},  ' C++ Word
  {1,(char*)"export"                 ,(char*)"export"                        ,2,comvt_BAD},
  {1,(char*)"extern"                 ,(char*)"extern"                        ,2,comvt_BAD},
  {1,(char*)"extract$"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"fabs"                   ,(char*)"fabs"                          ,2,comvt_BAD},
  {1,(char*)"fabsf"                  ,(char*)"fabsf"                         ,2,comvt_BAD},
  {1,(char*)"fabsl"                  ,(char*)"fabsl"                         ,2,comvt_BAD},
  {1,(char*)"fallthrough"            ,(char*)"fallthrough"                   ,2,comvt_BAD},
  {1,(char*)"false"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"farproc"                ,(char*)"FARPROC"                       ,2,comvt_BAD},
  {1,(char*)"ff$"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"fget"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"fgetc"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"file"                   ,(char*)"FILE"                          ,2,comvt_BAD},
  {1,(char*)"filelocked"             ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"fillarray"              ,(char*)""                              ,0,comvt_BAD},
'  {1,(char*)"finally"                ,(char*)"Finally"                       ,0,comvt_BAD},  ' VB Word
  {1,(char*)"findfirst$"             ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"findfirstinstance"      ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"findintype"             ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"findnext$"              ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"finput"                 ,(char*)"finput"                        ,0,comvt_BAD},
  {1,(char*)"fint"                   ,(char*)""                              ,0,comvt_INT},
  {1,(char*)"fix"                    ,(char*)""                              ,0,comvt_R4 },
  {1,(char*)"flush"                  ,(char*)"fflush"                        ,2,comvt_BAD},
  {1,(char*)"for"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"formload"               ,(char*)"FormLoad"                      ,2,comvt_BAD},
  {1,(char*)"fprint"                 ,(char*)"fprint"                        ,2,comvt_BAD},
  {1,(char*)"fput"                  ,(char*)""                              ,0,comvt_BAD},     
  {1,(char*)"frac"                   ,(char*)""                              ,0,comvt_R8 },
  {1,(char*)"fracl"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"free"                   ,(char*)"free"                          ,2,comvt_BAD},
  {1,(char*)"freefile"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"freeglobals"            ,(char*)"FreeGlobals"                   ,2,comvt_BAD},
  {1,(char*)"friend"                 ,(char*)""                              ,1,comvt_BAD},  ' C++ Word
  {1,(char*)"from"                   ,(char*)"from"                          ,2,comvt_BAD},
  {1,(char*)"fseek"                  ,(char*)""                              ,0,comvt_BAD},  
  {1,(char*)"function"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"fwrite"                 ,(char*)"fwrite"                        ,2,comvt_BAD},
'  {1,(char*)"get"                    ,(char*)"Get"                           ,0,comvt_BAD},  ' VB Word
  {1,(char*)"get$"                   ,(char*)"~get"                          ,2,comvt_BAD},
  {1,(char*)"get_rtl_version$"       ,(char*)"Get_RTL_Version$"              ,2,comvt_BAD},
  {1,(char*)"getattr"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"getbmp"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"getbvalue"              ,(char*)"GetBValue"                     ,2,comvt_BAD},
  {1,(char*)"getc"                   ,(char*)"getc"                          ,2,comvt_BAD},
  {1,(char*)"getdimension"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"getdrive"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"getfilename$"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"getgvalue"              ,(char*)"GetGValue"                     ,2,comvt_BAD},
  {1,(char*)"getobject"              ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"getprocaddress"         ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"getresource"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"getrvalue"              ,(char*)"GetRValue"                     ,2,comvt_BAD},
  {1,(char*)"getspecialfolder"       ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"getspecialfolder$"      ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"gettextsize"            ,(char*)""                              ,0,comvt_BAD},
'  {1,(char*)"gettype"                ,(char*)"GetType"                       ,0,comvt_BAD},  ' VB Word
  {1,(char*)"global"                 ,(char*)"global"                        ,2,comvt_BAD},
  {1,(char*)"gosub"                  ,(char*)"gosub"                         ,2,comvt_BAD},
  {1,(char*)"goto"                   ,(char*)"goto"                          ,2,comvt_BAD},
  {1,(char*)"gui"                    ,(char*)"gui"                           ,2,comvt_BAD},
'  {1,(char*)"handles"                ,(char*)"Handles"                       ,0,comvt_BAD},  ' VB Word
  {1,(char*)"hex$"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"hex2dec"                ,(char*)""                              ,0,comvt_I4 },
  {1,(char*)"hibyte"                 ,(char*)"HIBYTE"                        ,2,comvt_BAD},
  {1,(char*)"hide"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"hiword"                 ,(char*)"HIWORD"                        ,2,comvt_BAD},
  {1,(char*)"hypot"                  ,(char*)"hypot"                         ,2,comvt_R8 },
  {1,(char*)"iabs"                   ,(char*)"abs"                           ,2,comvt_BAD},
  {1,(char*)"icon"                   ,(char*)"icon"                          ,2,comvt_BAD},
  {1,(char*)"if"                     ,(char*)"if"                            ,16,comvt_BAD},
  {1,(char*)"iif"                    ,(char*)""                              ,0,comvt_R8 },
  {1,(char*)"iif$"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"imod"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"impfunction"            ,(char*)"impfunction"                   ,3,comvt_BAD},
'  {1,(char*)"implements"             ,(char*)"Implements"                    ,0,comvt_BAD},  ' VB Word
'  {1,(char*)"imports"                ,(char*)"Imports"                       ,0,comvt_BAD},  ' VB Word
  {1,(char*)"in"                     ,(char*)"in"                            ,0,comvt_BAD},
  {1,(char*)"inchr"                  ,(char*)""                              ,0,comvt_R4 },
  {1,(char*)"incr"                   ,(char*)"incr"                          ,2,comvt_BAD},
  {1,(char*)"infobox"                ,(char*)""                              ,0,comvt_BAD},
'  {1,(char*)"inherits"               ,(char*)"Inherits"                      ,0,comvt_BAD},  ' VB Word
  {1,(char*)"initsafearray"          ,(char*)"InitSafeArray"                 ,0,comvt_BAD},
  {1,(char*)"inkey"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"inkey$"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"inline"                 ,(char*)""                              ,1,comvt_BAD},  ' C++ Word
  {1,(char*)"inp"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"input"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"inputbox$"              ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"inputbuffer$"            ,(char*)"InputBuffer$"                 ,2,comvt_BAD},
  {1,(char*)"inputnumber"            ,(char*)"inputnumber"                   ,2,comvt_BAD},
  {1,(char*)"inpw"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"ins$"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"instat"                 ,(char*)""                              ,0,comvt_BAD},
  '{1,(char*)"instat"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"instr"                  ,(char*)""                              ,0,comvt_R4 },
  {1,(char*)"instrrev"               ,(char*)""                              ,0,comvt_R4 },
  {1,(char*)"int"                    ,(char*)"int"                           ,2,comvt_BAD},
  {1,(char*)"integer"                ,(char*)"int"                           ,2,comvt_BAD},
  {1,(char*)"interface"              ,(char*)"interface"                     ,3,comvt_BAD},  ' C++ word
  {1,(char*)"iremove"                ,(char*)""                              ,16,comvt_BAD},
  {1,(char*)"iremove$"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"ireplace"               ,(char*)""                              ,16,comvt_BAD},
  {1,(char*)"ireplace$"              ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"is"                     ,(char*)"is"                            ,2,comvt_BAD},
  {1,(char*)"isptr"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"iterate"                ,(char*)"continue"                      ,2,comvt_BAD},
  {1,(char*)"join$"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"keypress"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"kill"                   ,(char*)"kill"                          ,2,comvt_BAD},
  {1,(char*)"labs"                   ,(char*)"labs"                          ,2,comvt_BAD},
 {3,(char*)"lcase$"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"lccpath$"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"ldouble"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"left$"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"len"                    ,(char*)"strlen"                        ,2,comvt_R4 },
'  {1,(char*)"let"                    ,(char*)"Let"                           ,0,comvt_BAD},  ' VB Word
  {1,(char*)"lf$"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"lib"                    ,(char*)"lib"                           ,2,comvt_BAD},
  {1,(char*)"like"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"line"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"lineinput"              ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"listboxloadfile"        ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"llabs"                  ,(char*)"llabs"                         ,2,comvt_BAD},
  {1,(char*)"load_dll"               ,(char*)"LoadLibrary"                   ,2,comvt_BAD},
  {1,(char*)"loadfile$"              ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"loadlibrary"            ,(char*)"LoadLibrary"                   ,2,comvt_BAD},
  {1,(char*)"lobyte"                 ,(char*)"LOBYTE"                        ,2,comvt_BAD},
  {1,(char*)"loc"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"local"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"locate"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"lof"                    ,(char*)""                              ,0,comvt_R8 },
  {1,(char*)"log"                    ,(char*)"log"                           ,2,comvt_R8 },
  {1,(char*)"log10"                  ,(char*)"log10"                         ,2,comvt_R8 },
  {1,(char*)"log10l"                 ,(char*)"log10l"                        ,2,comvt_BAD},
  {1,(char*)"logl"                   ,(char*)"logl"                          ,2,comvt_BAD},
  {1,(char*)"long"                   ,(char*)"long"                          ,2,comvt_BAD},
  {1,(char*)"longlong"               ,(char*)"LONGLONG"                      ,2,comvt_BAD},
  {1,(char*)"loop"                   ,(char*)"loop"                          ,2,comvt_BAD},
  {1,(char*)"loword"                 ,(char*)"LOWORD"                        ,2,comvt_BAD},
  {1,(char*)"lpad$"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"lpbyte"                 ,(char*)"LPBYTE"                        ,2,comvt_BAD},
  {1,(char*)"lprint"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"lpstr"                  ,(char*)"LPSTR"                         ,2,comvt_BAD},
  {1,(char*)"ltrim$"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"main"                   ,(char*)"main"                          ,2,comvt_BAD},
  {1,(char*)"makeintresource"        ,(char*)"MAKEINTRESOURCE"               ,2,comvt_BAD},
  {1,(char*)"makelong"               ,(char*)"MAKELONG"                      ,2,comvt_BAD},
  {1,(char*)"makeword"               ,(char*)"MAKEWORD"                      ,2,comvt_BAD},
  {1,(char*)"max"                    ,(char*)""                              ,0,comvt_R8 },
  {3,(char*)"mcase$"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"mdigui"                 ,(char*)"mdigui"                        ,2,comvt_BAD},
  {1,(char*)"me"                     ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"mid$"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"min"                    ,(char*)""                              ,0,comvt_R8 },
  {1,(char*)"mkd$"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"mkdir"                  ,(char*)"mkdir"                         ,2,comvt_BAD},
  {1,(char*)"mki$"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"mkl$"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"mkld$"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"mks$"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"mod"                    ,(char*)"fmod"                          ,2,comvt_BAD},
  {1,(char*)"modstyle"               ,(char*)""                              ,0,comvt_BAD},
'  {1,(char*)"module"                 ,(char*)"Module"                        ,0,comvt_BAD},  ' VB Word
  {1,(char*)"msgbox"                 ,(char*)""                              ,0,comvt_BAD},
'  {1,(char*)"mustinherit"            ,(char*)"MustInherit"                   ,0,comvt_BAD},  ' VB Word
'  {1,(char*)"mustoverride"           ,(char*)"MustOverride"                  ,0,comvt_BAD},  ' VB Word
'  {1,(char*)"mutable"                ,(char*)""                              ,1,comvt_BAD},  ' C++ Word
'  {1,(char*)"mybase"                 ,(char*)"MyBase"                        ,0,comvt_BAD},  ' VB Word
'  {1,(char*)"myclass"                ,(char*)"MyClass"                       ,0,comvt_BAD},  ' VB Word
  {1,(char*)"name"                   ,(char*)"name"                          ,2,comvt_BAD},
  {1,(char*)"namespace"              ,(char*)"namespace"                     ,3,comvt_BAD},  ' C++ Word
  {1,(char*)"nest"                   ,(char*)"nest"                          ,2,comvt_BAD},
  {1,(char*)"new"                    ,(char*)""                              ,1,comvt_BAD},  ' C++ Word
  {1,(char*)"next"                   ,(char*)"next"                          ,34,comvt_BAD},
  {1,(char*)"nosort"                 ,(char*)"WS_CHILD|WS_VISIBLE|WS_VSCROLL",2,comvt_BAD},
  {1,(char*)"not"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"notequalto"             ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"nothing"                ,(char*)""                              ,0,comvt_BAD},
'  {1,(char*)"notinheritable"         ,(char*)"NotInheritable"                ,0,comvt_BAD},  ' VB Word
'  {1,(char*)"notoverridable"         ,(char*)"NotOverridable"                ,0,comvt_BAD},  ' VB Word
  {1,(char*)"now$"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"nul$"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"null"                   ,(char*)"NULL"                          ,2,comvt_BAD},
  {1,(char*)"object"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"oct$"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"on"                     ,(char*)"on"                            ,0,comvt_BAD},
  {1,(char*)"open"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"operator"               ,(char*)"operator"                      ,3,comvt_BAD},  ' C++ Word
  {1,(char*)"option"                 ,(char*)"option"                        ,2,comvt_BAD},
  {1,(char*)"optional"               ,(char*)"optional"                      ,2,comvt_BAD},
  {1,(char*)"or"                     ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"orelse"                 ,(char*)""                              ,0,comvt_BAD},  ' VB Word
  {1,(char*)"osversion"              ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"outp"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"output"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"outpw"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"overloaded"             ,(char*)""                              ,0,comvt_BAD},
'  {1,(char*)"overloads"              ,(char*)"Overloads"                     ,0,comvt_BAD},  ' VB Word
'  {1,(char*)"overridable"            ,(char*)"Overridable"                   ,0,comvt_BAD},  ' VB Word
'  {1,(char*)"overrides"              ,(char*)"Overrides"                     ,0,comvt_BAD},  ' VB Word
  {1,(char*)"panel"                  ,(char*)""                              ,0,comvt_BAD},
'  {1,(char*)"paramarray"             ,(char*)"ParamArray"                    ,0,comvt_BAD},  ' VB Word
  {1,(char*)"pause"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"pchar"                  ,(char*)"PCHAR"                         ,2,comvt_BAD},
  {1,(char*)"peek$"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"pellespath$"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"pixels"                 ,(char*)"pixels"                        ,2,comvt_BAD},
  {1,(char*)"playwav"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"poke"                   ,(char*)"memmove"                       ,2,comvt_BAD},
  {1,(char*)"pos"                    ,(char*)""                              ,0,comvt_R4 },
  {1,(char*)"pow"                    ,(char*)"pow"                           ,2,comvt_R8 },
  {1,(char*)"powl"                   ,(char*)"powl"                          ,2,comvt_BAD},
  {1,(char*)"pptype"                 ,(char*)"pptype"                        ,2,comvt_BAD},
  {1,(char*)"prepend"                ,(char*)"prepend"                       ,2,comvt_BAD},
  {1,(char*)"preserve"               ,(char*)"PRESERVE"                      ,2,comvt_BAD},
  {1,(char*)"print"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"print#"                 ,(char*)"fprint"                        ,2,comvt_BAD},
  {1,(char*)"printer"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"private"                ,(char*)""                              ,1,comvt_BAD},  ' C++ Word
  {1,(char*)"program"                ,(char*)"program"                       ,2,comvt_BAD},
  {1,(char*)"property"               ,(char*)"property"                      ,3,comvt_BAD},  ' C++ Word
  {1,(char*)"protected"              ,(char*)""                              ,1,comvt_BAD},  ' C++ Word
  {1,(char*)"ptr"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"public"                 ,(char*)""                              ,1,comvt_BAD},  ' C++ Word
  {1,(char*)"put$"                   ,(char*)"~put"                          ,2,comvt_BAD},
  {1,(char*)"qbcolor"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"qsort"                  ,(char*)"qsort"                         ,2,comvt_BAD},
  {1,(char*)"qsortidx"               ,(char*)"qsortidx"                      ,2,comvt_BAD},
'  {1,(char*)"raiseevent"             ,(char*)"RaiseEvent"                    ,0,comvt_BAD},  ' VB Word
  {1,(char*)"randomize"              ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"raw"                    ,(char*)"raw"                           ,2,comvt_BAD},
'  {1,(char*)"readonly"               ,(char*)"ReadOnly"                      ,0,comvt_BAD},  ' VB Word
  {1,(char*)"rec"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"reccount"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"reclen"                 ,(char*)"reclen"                        ,2,comvt_BAD},
  {1,(char*)"record"                 ,(char*)"record"                        ,2,comvt_BAD},
  {1,(char*)"redim"                  ,(char*)"redim"                         ,2,comvt_BAD},
  {1,(char*)"ref"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"refresh"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"regexist"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"regint"                 ,(char*)""                              ,0,comvt_BAD},
'  {1,(char*)"register"               ,(char*)"register"                      ,2,comvt_BAD},
  {1,(char*)"regstring$"             ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"reinterpret_cast"       ,(char*)"reinterpret_cast"              ,3,comvt_BAD},  ' C++ Word
  {1,(char*)"release"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"rem"                    ,(char*)"rem"                           ,0,comvt_BAD},
  {1,(char*)"remain$"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"remove"                 ,(char*)"remove"                        ,18,comvt_BAD},
  {1,(char*)"remove$"                ,(char*)""                              ,0,comvt_BAD},
'  {1,(char*)"removehandler"          ,(char*)"RemoveHandler"                 ,0,comvt_BAD},  ' VB Word
  {1,(char*)"rename"                 ,(char*)"rename"                        ,2,comvt_BAD},
  {1,(char*)"repeat"                 ,(char*)"repeat"                        ,0,comvt_BAD},
  {1,(char*)"repeat$"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"replace"                ,(char*)"replace"                       ,18,comvt_BAD},
  {1,(char*)"replace$"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"resume"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"retain$"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"return"                 ,(char*)"return"                        ,2,comvt_BAD},
  {1,(char*)"reverse$"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"rewind"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"rgb"                    ,(char*)"RGB"                           ,2,comvt_BAD},
  {1,(char*)"right$"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"rmdir"                  ,(char*)"rmdir"                         ,2,comvt_BAD},
  {1,(char*)"rnd"                    ,(char*)""                              ,0,comvt_R4 },
  {1,(char*)"round"                  ,(char*)""                              ,0,comvt_R8 },
  {1,(char*)"rpad$"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"rtrim$"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"run"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"savebmp"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"scanerror"              ,(char*)"ScanError"                     ,2,comvt_BAD},   ' For access to input Error Code
  {1,(char*)"screen"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"searchpath$"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"seek"                   ,(char*)"seek"                          ,2,comvt_BAD},
  {1,(char*)"select"                 ,(char*)"select"                        ,2,comvt_BAD},
  {1,(char*)"sendmessage"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"set"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"set_bcx_bitmap"         ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"set_bcx_bitmap2"        ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"set_bcx_bmpbutton"      ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"set_bcx_icon"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"setattr"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"setdimension"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"setwindowrtftext"       ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"sgn"                    ,(char*)""                              ,0,comvt_R4 },
'  {1,(char*)"shadows"                ,(char*)"Shadows"                       ,0,comvt_BAD},  ' VB Word
  {1,(char*)"shared"                 ,(char*)"shared"                        ,2,comvt_BAD},
  {1,(char*)"shell"                  ,(char*)"shell"                         ,2,comvt_BAD},
  {1,(char*)"shl"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"short"                  ,(char*)"short"                         ,2,comvt_BAD},
  {1,(char*)"show"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"showmodal"              ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"shr"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"sin"                    ,(char*)"sin"                           ,2,comvt_R8 },
  {1,(char*)"single"                 ,(char*)"float"                         ,2,comvt_BAD},
  {1,(char*)"sinh"                   ,(char*)"sinh"                          ,2,comvt_R8 },
  {1,(char*)"sinl"                   ,(char*)"sinl"                          ,2,comvt_BAD},
  {1,(char*)"sizeof"                 ,(char*)"sizeof"                        ,2,comvt_R4 },
  {1,(char*)"sleep"                  ,(char*)"Sleep"                         ,2,comvt_BAD},
  {1,(char*)"sndmsg"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"sound"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"space$"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"spc$"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"split"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"splitbarbg"             ,(char*)"SplitBarBG"                    ,2,comvt_BAD},
  {1,(char*)"splitbarfg"             ,(char*)"SplitBarFG"                    ,2,comvt_BAD},
  {1,(char*)"sprint"                 ,(char*)"sprint"                        ,2,comvt_BAD},
  {1,(char*)"sqr"                    ,(char*)"sqrt"                          ,2,comvt_R8 },
  {1,(char*)"sqrl"                   ,(char*)"sqrtl"                         ,2,comvt_BAD},
  {1,(char*)"sqrt"                   ,(char*)"sqrt"                          ,2,comvt_R8 },
  {1,(char*)"sqrtl"                  ,(char*)"sqrtl"                         ,2,comvt_BAD},
  {1,(char*)"sscvrt"                 ,(char*)"sscvrt"                        ,0,comvt_BAD},
  {1,(char*)"sstr"                   ,(char*)"sstr"                          ,0,comvt_BAD},
  {1,(char*)"startdraw"              ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"static"                 ,(char*)"static"                        ,2,comvt_BAD},
  {1,(char*)"static_cast"            ,(char*)"static_cast"                   ,3,comvt_BAD},  ' C++ Word
  {1,(char*)"stdcall"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"step"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"str$"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"str2variant"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"str_cmp"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"strarray"               ,(char*)"LPSTR*"                        ,2,comvt_BAD},
  {1,(char*)"strim$"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"string"                 ,(char*)"string"                        ,2,comvt_BAD},
  {1,(char*)"string$"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"strl$"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"strptr"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"strtoken$"              ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"struct"                ,(char*)"struct"                         ,3,comvt_BAD},  ' C++ Word
  {1,(char*)"sub"                    ,(char*)"sub"                           ,0,comvt_BAD},
  {1,(char*)"swap"                   ,(char*)""                              ,0,comvt_BAD},
'  {1,(char*)"synclock"               ,(char*)"SyncLock"                      ,0,comvt_BAD},  ' VB Word
  {1,(char*)"sysdir$"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"sysstr"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"tab$"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"tally"                  ,(char*)""                              ,0,comvt_R4 },
  {1,(char*)"tan"                    ,(char*)"tan"                           ,2,comvt_R8 },
  {1,(char*)"tanh"                   ,(char*)"tanh"                          ,2,comvt_R8 },
  {1,(char*)"tanl"                   ,(char*)"tanl"                          ,2,comvt_BAD},
  {1,(char*)"tempdir$"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"tempfilename$"          ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"template"               ,(char*)"template"                      ,3,comvt_BAD},  ' C++ Word
  {1,(char*)"textmode"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"then"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"this"                   ,(char*)"this"                          ,3,comvt_BAD},  ' C++ Word
  {1,(char*)"throw"                  ,(char*)"throw"                         ,3,comvt_BAD},  ' C++ Word
  {1,(char*)"time$"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"timer"                  ,(char*)""                              ,0,comvt_R4 },
  {1,(char*)"to"                     ,(char*)"to"                            ,0,comvt_BAD},
  {1,(char*)"trim$"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"true"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"try"                    ,(char*)"try"                           ,3,comvt_BAD},  ' C++ Word
  {1,(char*)"type"                   ,(char*)"type"                          ,2,comvt_BAD},
  {1,(char*)"typeid"                 ,(char*)"typeid$"                       ,3,comvt_BAD},  ' C++ Word
  {1,(char*)"typename"               ,(char*)""                              ,1,comvt_BAD},  ' C++ Word
'  {1,(char*)"typeof"                 ,(char*)"TypeOf"                        ,0,comvt_BAD},  ' VB Word
  {1,(char*)"ubound"                 ,(char*)""                              ,0,comvt_BAD},
  {3,(char*)"ucase$"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"uint"                   ,(char*)"UINT"                          ,2,comvt_BAD},
  {1,(char*)"ulong"                  ,(char*)"ULONG"                         ,2,comvt_BAD},
  {1,(char*)"ulonglong"              ,(char*)"ULONGLONG"                     ,2,comvt_BAD},
'  {1,(char*)"unicode"                ,(char*)"Unicode"                       ,0,comvt_BAD},  ' VB Word
  {1,(char*)"union"                  ,(char*)"union"                         ,2,comvt_BAD},
  {1,(char*)"until"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"ushort"                 ,(char*)"USHORT"                        ,2,comvt_BAD},
  {1,(char*)"using"                  ,(char*)"using"                         ,3,comvt_BAD},  ' C++ Word
  {1,(char*)"using$"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"val"                    ,(char*)""                              ,0,comvt_R8 },
  {1,(char*)"vall"                   ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"variant"                ,(char*)"VARIANT"                       ,2,comvt_BAD},
  {1,(char*)"variant2str"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"vbs_addcode"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"vbs_error$"             ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"vbs_eval_num"           ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"vbs_eval_num#"          ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"vbs_eval_str$"          ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"vbs_reset"              ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"vbs_run_script"         ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"vbs_start"              ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"vbs_stop"               ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"vchr$"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"vector"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"verify"                 ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"virtual"                ,(char*)""                              ,1,comvt_BAD},  ' C++ Word
  {1,(char*)"vt$"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"wend"                   ,(char*)"wend"                          ,2,comvt_BAD},
'  {1,(char*)"when"                   ,(char*)"When"                          ,0,comvt_BAD},  ' VB Word
  {1,(char*)"while"                  ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"widetoansi$"            ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"winbool"                ,(char*)"winbool"                       ,2,comvt_BAD},
  {1,(char*)"windir$"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"winmain"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"with"                   ,(char*)""                              ,0,comvt_BAD},
'  {1,(char*)"withevents"             ,(char*)"WithEvents"                    ,0,comvt_BAD},  ' VB Word
  {1,(char*)"wndproc"                ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"word"                   ,(char*)"WORD"                          ,2,comvt_BAD},
  {1,(char*)"write"                  ,(char*)"write"                         ,2,comvt_BAD},
'  {1,(char*)"writeonly"              ,(char*)"WriteOnly"                     ,0,comvt_BAD},  ' VB Word
  {1,(char*)"wstr"                   ,(char*)"wstr"                           ,0,comvt_BAD},
  {3,(char*)"xor"                    ,(char*)""                              ,0,comvt_BAD},
  {1,(char*)"zzzz"                   ,(char*)"zzzz"                          ,0,comvt_BAD}
END SET

'*************************************************************************
' GLOBAL VARIABLES FOR LATE BINDING COM SUPPORT
'*************************************************************************

DIM RAW ComSwitchON = TRUE   ' flag indicating use of COM in source
DIM RAW Use_COM = 0          ' COM is used in project, so emit com functions.
DIM RAW Use_MULTITHREADED_SW = 0 ' for multithreaded applications

CONST COM_STACK_SIZE = 64    ' number of chained dispatch objects.

CONST cSizeOfName = 66
TYPE COM_NAMES_STORAGE       ' used for recognition of Object - COM variables
  name[cSizeOfName] AS CHAR
  initialized     AS BOOL
END TYPE

CONST MAX_Global_COM_Objects   = 64 ' max number of Global Com objects that may be declared in program
CONST MAX_Local_COM_Objects    = 64 ' max number of Local Com objects that may be declared in Functions/Subs
CONST MAX_BCX_COM_NESTED_WITHS = 32 ' max number of nested (WITH - END WITH) constructions, used for COM objects

GLOBAL gl_COM_names_storage[MAX_Global_COM_Objects+1] AS COM_NAMES_STORAGE  ' variable that holds global names of COM objects
GLOBAL lc_COM_names_storage[MAX_Local_COM_Objects+1]  AS COM_NAMES_STORAGE  ' variable that holds names of COM objects defined in SUBs and FUNCs
GLOBAL gl_COM_names_index%  ' count of com objects used as global variables
GLOBAL lc_COM_names_index%  ' count of com objects used as locals (in SUBs and FUNCTIONs)
GLOBAL gl_COM_names_free_index% ' pointer to a free space in gl_COM_names_storage[]
GLOBAL lc_COM_names_free_index% ' pointer to a free space in lc_COM_names_storage[]

DIM RAW Use_SafeArrays              = FALSE
DIM RAW build_com_trace_code        = FALSE
DIM RAW ProcessingCOM_Set           = FALSE
DIM RAW bcx_com_open_with_statement = 0
DIM RAW bcx_get_com_enumerator      = 0 ' temp variable used in (for each ...) constructions

GLOBAL com_with_temp_str_name$

' Controls code emission for COM Parser (size optimizations)
DIM RAW Use_BCX_COM_CreateObject   = 0
DIM RAW Use_BCX_COM_GetObject      = 0
DIM RAW Use_BCX_COM_DispatchObject = 0
DIM RAW Use_BCX_COM_GetProperty    = 0
DIM RAW Use_BCX_COM_SetProperty    = 0
DIM RAW Use_BCX_COM_InvokeMethod   = 0
DIM RAW Use_BCX_COM_SafeArray      = 0
DIM RAW Use_BCX_COM_UsesConversion = 0 ' check if TRUE needed - quick fix this is really necessary!
DIM RAW Use_UNICODE_Switch         = 0 ' for unicode support
DIM RAW Use_COM_Collections        = 0 ' for unicode support

'*************************************************************************
' END OF: GLOBAL VARIABLES FOR LATE BINDING COM SUPPORT
'*************************************************************************
'jcfuller 1/29/2013
'to handle filenames with more than one period
Function RemoveExtension$(f$)
  LOCAL i AS Integer
  i = IIF(INSTR(f$,"."),INSTRREV(f$,".",0)-1,LEN(f$))
  Function = LEFT$(f$,i)
End Function
'==============================================================================
'jcfuller08/05/2015
Function ReplaceAny$(M As const char Ptr,MatchStr As const char Ptr ,Change As const char)
	Local As int i,k
	Dim s$
	Local MainStr$
	MainStr = M
	If Change = 0 Then
		Function = MainStr$
	EndIf
	While MainStr[k]
		i = 0
		While MatchStr[i]
			If MatchStr[i] = MainStr[k] Then
				MainStr[k] = Change
			EndIf
			i++
		Wend
		k++
	Wend
	Function = MainStr$
End Function

'==============================================================================
ENUM
  RE_COMMENT
  RE_PROPGETSET
  RE_PROPGETONLY
  RE_PROPSETONLY
  RE_CLASS
  RE_ENDCLASS
  RE_CTOR
  RE_DTOR
  RE_ENDCTOR
  RE_EXITFOR
  RE_DLGCB
  RE_ASM
  RE_WX
  RE_WXTRIM
  RE_AUTO
  RE_RBFOR
  RE_OPERDB
  RE_OPERDP
  RE_ENDFUNC
  RE_MAIN
  RE_FALSE
  RE_TRUE
  RE_REF
  RE_BIT
  RE_CHOOSE
  RE_CHOOSE_ELSE
  RE_OPENFILE
END ENUM
GLOBAL DLGCB_FLAG As Integer
GLOBAL Raw re[30] As pcrecpp::RE Ptr
'GLOBAL Raw sRules[30] As std::string

'GLOBAL Raw g_PropNames[1000] As std::string
GLOBAL Raw g_PropProcs As std::string
GLOBAL Raw g_PropImpl As std::string

GLOBAL g_ClassName$
GLOBAL g_swx$ '= "MyApp"
GLOBAL As vector<string> g_tempfiles
GLOBAL As vector<string> g_usevec
'CONST VECTOR_STD_STRING = vector<std::string>
'GLOBAL g_tempfiles  As VECTOR_STD_STRING
'not used?
CONST RE_MAX = 26 'For use with deleting re[]
CONST VECTOR_STRING_ITERATOR = std::vector<string>::iterator
'=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
'GLOBAL propflag AS Integer
GLOBAL g_EmitLibs = TRUE	'primarily for g++ and no ftool use -ne
'==============================================================================
Function bc9StrParseCount(szMainStr As const char Ptr,szDelim As const char Ptr = ",") As Long
    Raw As Long nCount=1,nPos=1
    Do
        nPos = Instr(szMainStr,szDelim,nPos)
        If nPos = 0 Then
            Exit Do
        EndIf
        nCount += 1
        nPos += Len(szDelim)
    Loop
    Function = nCount
End Function
'==============================================================================
Function DoJcfStuff() As Integer
	'static cmntflag As Integer
	'static PropCount As Integer
	static ppflag As Integer
	static InCtor As Integer
	static As Integer ClsMthdBlock
	
	static As Integer CtorCount = 0
	Raw As Integer i,DoPropProc=1,j=0,k=0
	Raw As std::string sS1,sS2,sS3,sS4,sS5,sS6,sS7,sS8,ssTemp
	Local As int ElseFlag,BitsFlag,ChooseFlag,pc
	Dim As int fsPtr
	DIM stemp$,s2$,s3$
	Raw As fstream f
	DIM zt$
	'jcfuller 2012-01-01
	'dynamic needed for properties
	DIM S$ * 2048
	static pp$
	static clsname$
	'Dim ppt$
     Local As _bool UseElseFlag,UseBitsFlag,UseSepFlag
     static As Integer IfUseFlag,IfUseOk,InUseBlock
'=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
	If iMatchLft(Src$,"$ENDUSE") Then
		InUseBlock = FALSE
		IfUseOk = TRUE
		Src$ = ""
		Exit Function
	End If

	If InUseBlock Then
		If IfUseOk = FALSE Then
			Src$ = ""
			Exit Function
		End If	
	End If
	If iMatchLft(Src$,"$USE ") Then
		pc = bc9StrParseCount(strim$(Src$)," ")
		For i = 2 To pc
			g_usevec.push_back(strtoken$(strim$(Src$)," ",i))
		Next i
		'xFor  auto it = g_usevec.begin() While it <> g_usevec.end() By it++
			'cout << it << endl
		'xNext	
		'! for(string it : g_usevec)
		'! cout << it << endl; 
		Src$ = ""
		
		Exit Function
	End If
	
	If iMatchLft(Src$,"$IFUSE") Then
		InUseBlock = TRUE
		IfUseOk = FALSE
		s2$ = strtoken$(strim$(Src$)," ",2)
		! for(string it : g_usevec)
		!{
		!  if (it == s2)
		!  {
		!    IfUseOk = TRUE;
		!    break;  
		!  }
		!}
		Src$ = ""
		Exit Function
	End If
	
	If iMatchLft(Src$,"Class_Methods_Start") Then
		ClsMthdBlock = TRUE
		clsname$ = Trim$(Remain$(Src$," "))
		Src$ = ""
		Exit Function
	End If

	If ClsMthdBlock Then
		If iMatchLft(Src$,"Class_Methods_End") Then
			ClsMthdBlock = FALSE
			clsname$ = ""
			Src$ = ""
			Exit Function
		End if
		If iMatchLft(Src$,"Constructor") Then
			stemp$ = clsname$ + "::" + clsname$
				Replace clsname$ With  stemp$ In Src$
				Exit Function
		ElseIf iMatchLft(Src$,"Destructor") Then 	
			stemp$ = clsname$ + "::~" + clsname$
				Replace clsname$ With  stemp$ In Src$
				Exit Function
		ElseIf iMatchLft(Src$,"Function") Then 	
			s2$ = STRIM$(Src$)
			If Strtoken$(s2$," ",2) = "="  Then
				Exit Function
			End If
			stemp$ = Right$(s2$,Len(s2$)-9)
			Src$ = "Function " + clsname$ + "::" + stemp$
			Exit Function
		ElseIf 	iMatchLft(Src$,"Sub") Then 	
			s2$ = STRIM$(Src$)
			stemp$ = Right$(s2$,Len(s2$)-4)
			Src$ = "Sub " + clsname$ + "::" + stemp$
			Exit Function
		End If
	End If


If iMatchLft(Src$,"$ztrace") Then
	USE_ZTRACE = TRUE
	Src$ = ""
	Exit Function
End If

If re[RE_OPENFILE]->FullMatch(Src$,&sS1,&sS2,&sS3) Then
	'cout << "sS1 = " << sS1 << endl
	'cout << "sS2 = " << sS2 << endl
	'cout << "sS3 = " << sS3 << endl
	sS4 = sS3
	'sS4 = "hFile = CreateFile("
	sS4.append(" = CreateFile(") 
	If iMatchRgt(sS1.c_str(),"*") Then
		fsPtr = TRUE
		sS1 = RTRIM$(sS1,"*")
	End If
	sS4.append(sS1)
	If lcase(sS2) = "output" Then
		If Use_TCLib Then
			If fsPtr Then
				sS4.append("->lpStr(), GENERIC_WRITE,0,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL)")
			Else	
				sS4.append(".lpStr(), GENERIC_WRITE,0,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL)")
			End If	
		Else	
			sS4.append(" , GENERIC_WRITE,0,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL)")
			
		End If	
	ElseIf 	lcase(sS2) = "input" Then
		If Use_TCLib Then
			If fsPtr Then
				sS4.append("->lpStr(),GENERIC_READ,0,NULL,OPEN_EXISTING,0,NULL)")
			Else	
				sS4.append(".lpStr(),GENERIC_READ,0,NULL,OPEN_EXISTING,0,NULL)")
			End If	
		Else
			sS4.append(",GENERIC_READ,0,NULL,OPEN_EXISTING,0,NULL)")
		End If	
		'sS4.append(".lpStr(),GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,NULL)")
	ElseIf lcase(sS2) = "append" Then
		If Use_TCLib Then
			If fsPtr Then
				sS4.append("->lpStr(),FILE_APPEND_DATA,FILE_SHARE_READ,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL)")
			Else	
				sS4.append(".lpStr(),FILE_APPEND_DATA,FILE_SHARE_READ,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL)")
			End If	
		Else
			sS4.append(",FILE_APPEND_DATA,FILE_SHARE_READ,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL)")
		End If	
	End If
	'Src$ = ""
	'cout << sS4 << endl
	Src$ = sS4.c_str()
	Exit Function
End If 
'If iMatchLft(Src$,"openfile") Then
	'cout << "OpenFile " << endl
	'Src$ = ""
	'Exit Function

'End If
'jcfuller 03/25/2016
If iMatchLft(Src$,"waitkey") Then
	If Use_TCLib Then
		Src$ = "getchar()"
		Exit Function
	End If
End If
'jcfuller 09/25/2015
  If iMatchLft(Src$,"bit ") Then
  'cout << "iMatchLft" << endl
  'cout << Src$ << endl
	If re[RE_BIT]->FullMatch(Src$,&sS1,&sS2,&sS3) Then
		sS4= "! "
		sS4+= sS2
		lcase$(sS1,1)
		If sS1 = "set" Then
			sS4.append(" |= 1 << ")
            sS4.append(sS3)
	     	sS4.append(";")
		ElseIf sS1 = "reset" Then
			sS4.append(" &= ~(1 << ")
            sS4.append(sS3)
	     	sS4.append(");")
		ElseIf sS1 = "toggle" Then
          sS4.append(" ^= 1 << ")
          sS4.append(sS3)
	      sS4.append(";")

		EndIf
		Src$ = sS4.c_str()
		Exit Function
	End If
  End If

  'If iMatchWrd(Src$,"choose") Then
  If Not IsBc9 Then
		If Instr(Src$,"choose",0,1)  Then
			If Instr(Src$," else ",0,1) Then
				If re[RE_CHOOSE_ELSE]->FullMatch(Src$,&sS1,&sS2,&sS3,&sS4,&sS5,&sS6,&sS7) Then
					ElseFlag = 1
					ChooseFlag = 0
				End If
			Else
				If re[RE_CHOOSE]->FullMatch(Src$,&sS1,&sS2,&sS3,&sS4,&sS5) Then
					ElseFlag = 0
					ChooseFlag = 1
				End If
			End if
			If (ElseFlag = 0) And (ChooseFlag = 0) Then
				Function = 0
			End If
			'If ElseFlag Then
				'cout << "sS1 -> " << sS1 << endl
				'cout << "sS2 -> " << sS2 << endl
				'cout << "sS3 -> " << sS3 << endl
				'cout << "sS4 -> " << sS4 << endl
				'cout << "sS5 -> " << sS5 << endl
				'cout << "sS6 -> " << sS6 << endl
				'cout << "sS7 -> " << sS7 << endl
			'ElseIf ChooseFlag Then
				'cout << "sS1 -> " << sS1 << endl
				'cout << "sS2 -> " << sS2 << endl
				'cout << "sS3 -> " << sS3 << endl
				'cout << "sS4-> " << sS4<< endl
				'cout << "sS5-> " << sS5<< endl
			'End If
'			cout << "ElseFlag = " << ElseFlag << endl
'			cout << "ChooseFlag = " << ChooseFlag << endl
		If sS2.length() Then
			If lcase$(sS2.c_str()) = "bit" Then
				sS2 = ",1"
			ElseIf lcase$(sS2.c_str()) = "bits" Then
				sS2 = ",2"
				BitsFlag = 1
			EndIf
		Else
			sS2 = ",0"
		End If
		If ElseFlag Then
			sS6 = ","
			sS6.append(sS7)
		Else
			If Instr(sS5,DQ$)  Then
				If Instr(sS5,"L"+DQ$) Then
					sS6 = ",L"
				Else
					sS6 = ","
				End If
				sS6.append(Enc$(""))
			ElseIf Instr(sS5,".") Then
				sS6 = ",0.0"
			Else
				sS6 = ",0"
			End If
		End If
		If BitsFlag Then
			If sS3.size() = 0 Then
				If Instr(sS5,"L"+DQ$) Then
					sS3 = "L"
					sS3.append(Enc$(""))
				Else
					sS3 = Enc$("")
				End If
			EndIf
			ssTemp = sS1 + " = choose(" + sS4 + ",{"+ sS5 + "}" + sS6  + sS2 + "," + sS3+")"
		Else
			ssTemp = sS1 + " = choose(" + sS4 + ",{"+ sS5 + "}" + sS6  + sS2 + ")"
		End If
		'cout << ssTemp << endl
		Src$ = ssTemp.c_str()
		Exit Function

		End If
  End If

'------------------------------------------------------------------------------
'jcf 1/31/2016
'If iMatchLft(Src$,"#include") Then
'	If instr(Src$,"windows.h") Then
'		Winh = TRUE
'	End If
'End If
'jcfuller 12/05/2013
	If iMatchLft(Src$,"sub ") Then
		If iMatchRgt(Src$,"const") Then
			If Instr(Src$,"()") Then
			    REPLACE "()" WITH "" IN Src$
			End If
		End If
	End If

	If iMatchLft(Src$,"$onexit") Then
		If Instr(Src$,"$A\\") Then
		  REPLACE "$A\\" WITH BC9PATH$ IN Src$
		End If
	End If
	If NOT IsBc9 Then

		If iMatchLft(Src$,"end") AND iMatchRgt(Src$,"prepend") Then
			ppflag = 0
			pp$ =""
			Src$ = ""
			Exit Function
		End If
		If iMatchLft(Src$,"prepend") Then
			ppflag = 1
			pp$ = Mid$(Src$,9,Len(Src$))
			Src$ = ""
			Exit Function
			'cout << "Found prepend" << endl
		End If
		If ppflag Then
			'ppt$ = pp$ + Src$
			Src$ = pp$ + Src$
			'cout << ppt$ << endl
			Exit Function
		End If
		'If _ZTRACE_ Then
		'	If iMatchLft(Src$,"SHAREDSET") Then
		'		ZPRINT(Src$)
		'	End If
		'End If
	End If

' I need to check to make sure more than one item cannot occur at a time as I'm
'using elseif
	If re[RE_CTOR]->FullMatch(Src$,&sS1) Then
		If Use_ClassProps Then
			'cout << "RE_CTOR" << endl
			'cout << "length of g_PropImpl = " << g_PropImpl.length()
			'Need to parse and write g_PropImpl.c_str$() to file
			'then append : $INCLUDE file to Src$
			'use g_ClassName$_PropImpl.bas
		'jcfuller 2012-01-01
			'dynamic needed
'			k = g_PropImpl.length()
'			k+=8
'			REDIM S$ * k
			REDIM S$ * (g_PropImpl.length()+8)
'If _ZTRACE_ Then
'	zt$= " RE_CTOR k = " + STR$(k)
'	ZPRINT(zt$)
'End If

			S$ = g_PropImpl.c_str$()
			'REPLACE " : " WITH "~" IN S$
			stemp$ = g_ClassName$+"__PropImpl.bas"
			'OPEN stemp$ FOR OUTPUT As hFile
			f.open(stemp$,ios::out)
			g_tempfiles.push_back(stemp$)
			'FPRINT hFile,S$
			f << "$CCODE" << endl
			DO
				's2$=STRTOKEN$(S$,(char*)"~",++j)
				If STRTOKEN$(S$,(char*)"~",++j) > (char*)"" Then
				'If LEN(s2$) THEN
					'FPRINT hFile,STRTOKEN$(S$,(char*)"~",j)
					'FPRINT hFile,s2$
				'	f << s2$ << endl
				'cout << STRTOKEN$(S$,(char*)"~",j) << endl
				f << "  "
				f << STRTOKEN$(S$,(char*)"~",j) '<< endl
				f << ";" << endl

					'!fprintf(hFile,(char*)"%s\n",s2);
				Else
					Exit Loop
				End If
			Loop
			'CLOSE hFile
			f << "$CCODE" << endl
			f.close()
		    'Src$ = Src$ + " : " + g_PropImpl.c_str$()
		    'Src$ = Src$ + " : $INCLUDE "+g_ClassName$+"__PropImpl.bas"
		    Src$ = Src$ + " : $INCLUDE "+ stemp$

		    'FREE S$
		End If

		InCtor = 1
'		propflag = 1
		CtorCount += 1
	Elseif re[RE_PROPGETSET]->FullMatch(Src$,&sS1,&sS2) Then

		i = sS1.find("_NOPP")
		'jcfuller changed 10/22/2013
		'If i > 0 Then
		If i <> std::string::npos Then
			DoPropProc = 0
			sS1.resize(i)
		End If


		sS3 = "Dim Function get"
		sS3.append(sS1)
		sS3.append("() As ")
		sS3.append(sS2)
		sS3.append(" : Dim Sub set")
		sS3.append(sS1)
		sS3.append("(a As ")
		sS3.append(sS2)
		sS3.append(")")
		sS3.append(" : ! property<")
		sS3.append(g_ClassName$)
		sS3.append(",")
		sS3.append(sS2)
		sS3.append(",READ_WRITE> ")
		sS3.append(sS1)
		sS3.append(";")
'		propflag = 1
		Src$=sS3.c_str()
		'cout << Src$ << endl
		WITH g_PropImpl
			.append(sS1)
			.append(".setContainer(this)~")
			.append(sS1)
			.append(".getter(&")
			.append(g_ClassName$)
			.append("::get")
			.append(sS1)
			.append(")~")
			.append(sS1)
			.append(".setter(&")
			.append(g_ClassName$)
			.append("::set")
			.append(sS1)
			.append(")~")
		END WITH
		'cout << g_PropImpl << endl
'jcfuller 2011-11-14
' emit "c" code instead of bcx basic for properties
		IF DoPropProc Then
			WITH g_PropProcs
				.append("~")
				.append(sS2)
				.append(" ")
				.append(g_ClassName$)
				.append("::get")
				.append(sS1)
				.append("(){return ")
				.append("m_")
				.append(sS1)
				.append(";}")
				.append("~void ")
				.append(g_ClassName$)
				.append("::set")
				.append(sS1)
				.append("(")
				.append(sS2)
				.append(" param){")
				.append("m_")
				.append(sS1)
				.append(" = param;}")
			END WITH
		End If

	Elseif re[RE_PROPGETONLY]->FullMatch(Src$,&sS1,&sS2) Then
		i = sS1.find("_NOPP")
		If i > 0 Then
			'NoPropProc = 1
			DoPropProc = 0
			'sS7 = sS1.substr(0,i)
			'sS1 = sS7
			sS1.resize(i)
		End If

		sS3 = "Function get"
		sS3.append(sS1)
		sS3.append("() As ")
		sS3.append(sS2)
		sS3.append(" :    !    property<")
		sS3.append(g_ClassName$)
		sS3.append(",")
		sS3.append(sS2)
		sS3.append(",READ_ONLY> ")
		sS3.append(sS1)
		sS3.append(";")
		Src$=sS3.c_str()
		WITH g_PropImpl
			.append(sS1)
			.append(".setContainer(this)~")
			.append(sS1)
			.append(".getter(&")
			.append(g_ClassName$)
			.append("::get")
			.append(sS1)
			.append(")~")
		END WITH
		'***************
		IF DoPropProc Then
			WITH g_PropProcs
				.append("~Function ")
				.append(g_ClassName$)
				.append("::get")
				.append(sS1)
				.append("() As ")
				.append(sS2)
				.append("~Function = m_")
				.append(sS1)
				.append("~End Function")
			END WITH
		End If
		'    println(g_PropProcs)
	Elseif re[RE_CLASS]->FullMatch(Src$,&sS1,&sS2,&sS3) THEN
		g_ClassName$ = sS2.c_str()
		'cout << endl << "g_ClassName$ -> " << g_ClassName$ << endl << endl
		InCtor = 0
'		propflag = 0
		g_PropProcs.clear()
		g_PropImpl.clear()
		CtorCount = 0
	'Elseif re[RE_ENDCLASS]->FullMatch(Src$) THEN
	'	CtorCount = 0
		'println("ENDCLASS")
		'g_ClassName$ = ""
	ElseIf re[RE_ENDCTOR]->FullMatch(Src$) THEN
		InCtor = 0
'		propflag = 0
		'println("ENDCTOR")

		If Use_ClassProps And CtorCount < 2 Then

		'jcfuller 2012-01-01
			'dynamic needed

'			k = g_PropImpl.length()
'			k+=8
'			REDIM S$ * k
'If _ZTRACE_ Then
'	zt$= " RE_ENDCTOR k = " + STR$(k)
'	ZPRINT(zt$)
'End If
			REDIM S$ * (g_PropProcs.length() + 8)
			S$ = g_PropProcs.c_str$()

			'REPLACE " : " WITH "~" IN S$
			S$ = LTRIM$(S$,ASC("~"))
			stemp$ = g_ClassName$+"__PropProcs.bas"
			g_tempfiles.push_back(stemp$)
			'OPEN g_ClassName$+"__PropProcs.bas" FOR OUTPUT As hFile

			'OPEN stemp$ FOR OUTPUT As hFile
			f.open(stemp$,ios::out)
			f << "$CCODE" << endl
			f << "//------------------------------------------------------------------------------" << endl
			f << "// property get/set procedures for class: " << g_ClassName$ << endl
			f << "//------------------------------------------------------------------------------" << endl

'			FPRINT hFile,"$CCODE"
'			FPRINT hFile,"//------------------------------------------------------------------------------"
'			FPRINT hFile,"// property get/set procedures for class: ",g_ClassName$
'			FPRINT hFile,"//------------------------------------------------------------------------------"
			DO
				If STRTOKEN$(S$,(char*)"~",++j) > (char*)"" Then
'					FPRINT hFile,STRTOKEN$(S$,"~",j)
					f << STRTOKEN$(S$,(char*)"~",j) << endl
				Else
					Exit Loop
				End If
			Loop
			'FPRINT hFile,"//------------------------------------------------------------------------------"
			'FPRINT hFile,"$CCODE"
			f << "//------------------------------------------------------------------------------" << endl
			f << "$CCODE" << endl
			f.close()
			'CLOSE hFile
		    'Src$ = Src$ + " : " + g_PropImpl.c_str$()
		    Src$ = Src$ + ":$INCLUDE "+g_ClassName$+"__PropProcs.bas"
		    'needed ??
		    'FREE S$
		End If

	ElseIf re[RE_DLGCB]->FullMatch(Src$,&sS1) THEN
		stemp$ = sS1.c_str()
		'Src$ = "FUNCTION " + stemp$ + "(hWnd As HWND,Msg As UINT,wParam As WPARAM,lParam As LPARAM) As WINBOOL CALLBACK"
		'jcfuller chamged 03/01/2016
		Src$ = "FUNCTION " + stemp$ + "(hWnd As HWND,Msg As UINT,wParam As WPARAM,lParam As LPARAM) As INT_PTR CALLBACK"
'        cout << Src$ << endl
		DLGCB_FLAG = -1
	End If

		'Src$ = Src$ + g_PropProcs.c_str$()
		'cout << g_PropProcs << endl
	'ElseIf re[RE_EXITFOR]->FullMatch(Src$) Then
		'i = INSTR(Src$,"e",0,1)
		'cout << "i = " << i << endl
		'Src$ = "break"
	'ElseIf Src$ = "$ASMX" Then
	'	cout << E"$ASMX\n"
	'	Src$=""
'C11 range-based for. this one was tricky because I wanted the parser to treat it just like a
'normal for loop. I could not use the colon trick for multiple source statements on a single
'line because the frist line was a c source line "!" so I resorted to creating a temp file
' and using $INCLUDE.
' also needed to check for _auto in the line
    If INSTR(Src$,"rbfor",0,1) Then
		Src$ = STRIM$(Src$)
		If LEFT$(LCASE$(Src$),5) = "rbfor" Then
			'cout << "RBFOR" << endl
			'cout << Src$ << endl
			'IF _ZTRACE_ Then
			'ZPRINT(Src$):ZPRINT(CRLF$)
			'END IF
			If INSTR(Src$,"_auto ") Then
			    'ZPRINT("we have _auto"):ZPRINT(CRLF$)
				REPLACE "_auto " WITH "_auto_" IN Src$
			End If

			If INSTR(Src$,"auto ") Then
			    'ZPRINT("we have _auto"):ZPRINT(CRLF$)
				REPLACE "auto " WITH "_auto_" IN Src$
			End If

			f.open("_rbfor_.bas",ios::out)
			MID$(Src$,1,5)="! for"
			'IF _ZTRACE_ Then
			'ZPRINT(Src$):ZPRINT(CRLF$)
			'END IF
			 f << Src$ << endl
			 f << "FOR _rb_ = 0 To 0" << endl
			 f.close()
			Src$ = "$INCLUDE " + ENC$("_rbfor_.bas")
		End If
	End If

	IF Instr(Src$,"operator[]") Then
		REPLACE "operator[]" WITH "operator__OPDB__" IN Src$
	End If
	IF Instr(Src$,"operator()") Then
		REPLACE "operator()" WITH "operator__OPDP__" IN Src$
	End If

	'C11 auto inference feature. attach it to the var so the normal parsing
	'will leave it alone. DoCppFixUp does the fix up.

	If re[RE_AUTO]->FullMatch(Src$) Then
		Src$ = STRIM$(Src$)
		If Instr (Src$,"_auto ") Then
			REPLACE "_auto " WITH "_auto_" IN Src$
		Else
		    REPLACE "auto " WITH "_auto_" IN Src$
		End If
	End If

	If re[RE_ENDFUNC]->FullMatch(Src$) Then
		If DLGCB_FLAG = -1 Then
			Src$ = "FUNCTION = 0 : END FUNCTION"
			DLGCB_FLAG = 0
		End If
	End If
If WxGui AND LEN(g_swx$) = 0 Then
	If re[RE_WX]->FullMatch(Src$,&sS1,&sS2) THEN
		g_swx$ = sS2.c_str()
	Else
		g_swx$ = "MyApp"
	End If
End If
	'If instr(Src$,"main()") Then
	'	cout << "we have a main()" << endl
	'	cout << Src$ << endl
	'End If
	If re[RE_MAIN]->FullMatch(Src$) Then
		'cout << "RE_MAIN" << endl
		'this is a fix for MinGW non-support of _tmain in console apps
		'If Use_UNICODE_Switch AND g_EmitLibs = FALSE Then
			'f.open("umain.bas",ios::out)
			'f << "$CCODE" << endl
			'f << "    struct Args" << endl
            'f << "    {" << endl
            'f << "        int n;" << endl
            'f << "        wchar_t** p;" << endl
            'f << "        ~Args() {  if( p != 0 ) { ::LocalFree( p ); } }" << endl
            'f << "        Args(): p(  ::CommandLineToArgvW( ::GetCommandLine(), &n ) ) {}" << endl
            'f << "    };" << endl
            'f << endl
            'f << "    Args    args;" << endl
            'f << endl
            'f << "    if( args.p == 0 )" << endl
            'f << "    {" << endl
            'f << "        return EXIT_FAILURE;" << endl
            'f << "    }" << endl
    		'f << endl
    		'f << "    g_argc = args.n;" << endl
    		'f << "    g_argv = args.p;" << endl
    		'f << endl
    		'f << "$CCODE" << endl
    		'f.close()
    		'Src$ = "Function main() As int : $INCLUDE "+ ENC$("umain.bas")
		'Else
		If WxCon OR WxGui OR Use_MFC Then
			Src$ = "Function main(argc As int,argv As PCHAR Ptr) As int"
		ElseIf Use_TCLib Then
			Src$ = "Function main() As int"
		Else
			Src$ = "Function main(argc As int,argv As PCHAR Ptr) As int:g_argc = argc :g_argv = argv :    "
		End If
'		End If
	End If
	If InClassModule Then
		If iMatchLft(Src$,"dim") Then
			stemp$ = STRIM$(Src$)
			If iMatchLft(stemp$,"dim function") Then
			'IF _ZTRACE_ Then
			'	ZPRINT(Src$)
			'	ZPRINT(stemp$)
			'	ZPRINT("-------")
			'END IF

			    'If iMatchRgt(stemp$,"const") Then
				'	stemp$ = LEFT$(stemp$,InstrRev(stemp$,"const")-1)
					'stemp$ = RTRIM$(stemp$,"const")
				If Instr(stemp$,") const") Then
				  Replace ") const" WITH ")" IN stemp$

					f.open("_CONSTFUNC_.BAS",ios::out)
					f << "$REMS" << endl
					f << "'NEED_CONST" << endl
					f << "$REMS" << endl
					f << stemp$ << endl
					f.close()

					Src$ = "$INCLUDE " + Enc$("_CONSTFUNC_.BAS")
				End If


			End If
		End If
	End if

'	If Left$(Src$,7)="template" Then
'		i =
	'	Src$ = "! " + Src$
'	End If
	Function = 0
End Function
'=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*


Sub CheckForDirectives(f$)
	Raw As fstream f1
	Raw As stdstr sLine,sMatch
	Raw As pcrecpp::RE ptr re
	Dim As Long flag
	'Dim sftmp$
	cout << "CheckForDirectives" << endl
	Local As Integer IoErr
	'$IPRINT_ON
	re = new pcrecpp::RE ("(?i)\\s*(\\$CPPHDR|\\$CPP|\\$NOWIN|\\$NOMAIN|\\$ZTRACE).*")
	'$IPRINT_OFF
	f1.open(f$,ios::in)
	If f1.is_open() Then
			While f1.good()
				getline(f1,sLine)
				If re->FullMatch(sLine,&sMatch) Then
					cout << sMatch << endl
				End If
			Wend
	End If
	f1.close()
	delete re
	
	'Raw As fstream f1
	'Raw As stdstr sLine,sMatch
	'Raw As pcrecpp::RE ptr re
	''Dim sftmp$
	''cout << "CheckForDirectives" << endl
	'Local As Integer IoErr
	''$IPRINT_ON
	're = new pcrecpp::RE ("(?i)\\s*(\\$CPPHDR|\\$CPP|\\$MINGW|\\$NOWIN|\\$NOMAIN|\\$EXIT).*")
	''$IPRINT_OFF
	'f1.open(f$,ios::in)
	'If f1.is_open() Then
			'While f1.good()
				'getline(f1,sLine)
				'If re->FullMatch(sLine,&sMatch) Then
					''cout << sMatch << endl
					'sMatch = TRIM$(UCASE$(sMatch))
					'If sMatch = "$CPPHDR" Then
                        'UseCpphdr = TRUE
                        'UseIO = TRUE
                        'UseCpp = TRUE
                    'ElseIf sMatch = "$CPP" Then
						'UseIO = UseCpp = TRUE
                    'ElseIf sMatch = "$NOMAIN" Then
						'NoMain = TRUE
                    'ElseIf sMatch = "$MINGW" Then
                        'g_EmitLibs = FALSE
                        ''cout << "$MINGW" << endl
                    'ElseIf sMatch = "$EXIT" Then
                        ''cout << "$EXIT" << endl
					    'break;
                    'End If
				'End If
				''sMatch.clear()
				''sLine.clear()
			'Wend
		'f1.close()
	'End If
	'delete re
End Sub

CONST cMaxSrcLen = 1048576
GLOBAL _ZTRACE_ As BOOL
'==============================================================================
Sub DoDllCompilerDefines()

End Sub
'*************************************************************************
'                              CODE BEGINS
'*************************************************************************
FUNCTION main(ARGC AS INTEGER, ARGV AS PCHAR PTR)
  GLOBAL  CurLine$  * 256*1024
  GLOBAL  szTmp$    * cMaxSrcLen
  GLOBAL  Src$      * cMaxSrcLen
  GLOBAL  AbortSrc$ * cMaxSrcLen
  GLOBAL  WarnMsg$  * 32767
  GLOBAL  RmLibs$   * 32767          ' libraries to remove
  GLOBAL IsBc9
  'jcfuller
  GLOBAL RemoveTypeDef = 0
'------------------------------------------------------------------------------
  Raw As Integer rv=0
  Raw As VECTOR_STRING_ITERATOR vsi_tempfile
  static bh As Integer
  Raw As stdstr sS1
  Dim stemp$
  Raw As fstream f
  Local As HMODULE  H_ZTRACE
  Local As int op_start,op_end,findex
'------------------------------------------------------------------------------

  InternalDebugOff = NOT InternalDebug
  sENDBCXRTLIB$     = "}\n\n"
  sENDBCXRTLIB2$    = ""
  CALL InitReservedWordsLookup()
  ProtoCnt               =   0       ' Prototypes counter
  WinHeaders             =  TRUE     ' Include Win specific headers (*.h)
  UseWinApi              =  TRUE
  NoIncludes             =  FALSE
  TranslateSlash         =  TRUE     ' Default TO changing "\" TO "\\"
  OkayToSend             =  TRUE
  OptimizerEnabled       =  TRUE
  OptimizerFirstSetting  =  TRUE
  Use_SingleFile         =  TRUE
  NoRT                   =  FALSE
  Use_StartupCode        =  FALSE
  StartNdx               =  0
  Use_ExitCode           =  FALSE
  Use_LeanAndMean        =  FALSE
  ExitNdx                =  0
  Gen_Header             =  FALSE
  Project_Main$          =  ""
  HFile$                 =  ""
  CmdLineFileOut$        =  ""
  RmLibs$                =  ""
  InMain                 =  TRUE
  TestState              =  FALSE
  CmdLineConst$          = ""
  Project_List$          = ""

  InsertComments         =  FALSE
  InNameSpace            =  0
  BCX_TmpStrSize         = 2048

  D1$  = VCHR$(8,34,37,32,46,49,53,71,34)
  D2$  = VCHR$(9,34,37,32,46,49,57,76,71,34)
  D3$ =  VCHR$(2,15,15)
  O1$  = VCHR$(4,34,37,111,34)

  S1$  = VCHR$(4,34,37,115,34)
  S2$  = VCHR$(6,34,37,115,37,115,34)

  T0$  = VCHR$(10,34,37,72,58,37,77,58,37,83,34)
  T1$  = VCHR$(4,34,37, 72,34)
  T2$  = VCHR$(4,34,37, 77,34)
  T3$  = VCHR$(4,34,37, 83,34)
  T4$  = VCHR$(4,34,37,112,34)
  T5$  = VCHR$(4,34,37, 89,34)
  T6$  = VCHR$(4,34,37,109,34)
  T7$  = VCHR$(4,34,37,100,34)
  T8$  = VCHR$(4,34,37, 65,34)
  T9$  = VCHR$(4,34,37,119,34)
  T10$ = VCHR$(4,34,37,106,34)
  T11$ = VCHR$(4,34,37, 85,34)

  X1$  = VCHR$(4,34,37,88,34)
  U1$  = VCHR$(7,37,39,42,46,42,32,102)

  W1$  = ENC$((char*)"%*.*s%*.*lf")
  W2$  = ENC$((char*)"%s%*.*s")
  W3$  = ENC$((char*)"%s%*.*s%s")

  'GetModuleFileName(NULL,BC9PATH$,2048)
  BC9PATH$ = APPEXEPATH$

  '**************************************************************************
  PPFlag = FALSE           ' Initialize User-Defined PreProcessor
  PPProc = NULL
  PPDLL_HANDLE = NULL
  '**************************************************************************

  IF COMMAND$ = "" THEN
    'PRINT "BCX-32: BASIC to C/C++ Translator by Kevin Diggins (c) 1999-2012"
    PRINT "bc9Basic: BASIC to C/C++ Translator "
    'CompilerVersion$ added in build batch file
    PRINT "Version ", Version$, "  Compiled with ";Trim$(CompilerVersion$)
    '$IF __BCPLUSPLUS__
      'PRINT "Borland C++"
    '$ELSEIF __BORLANDC__
      'PRINT "Borland C"
    '$ELSEIF __POCC__
      'PRINT "Pelles C"
    '$ELSEIF __LCC__
      'PRINT "LCCWin32 C"
    '$ELSEIF __WATCOM_CPLUSPLUS__
      'PRINT "Open Watcom C++"
    '$ELSEIF __MINGW64__
      'PRINT "MinGW64 C"
    '$ELSEIF __MINGW32__
      'PRINT "MinGW32 C++"
    '$ELSEIF __DMC__
      'PRINT "Digital Mars C/C++"
    '$ELSEIF _MSC_VER
      'PRINT "Microsoft Visual C++"
    '$ELSE
      'PRINT "Unknown"
    '$ENDIF

    PRINT " Usage: bc9 infile [.bas] [options]"
    PRINT " [-b] Build using user-defined bat file .. ex -b:c:\\bat\\pw.bat"
    PRINT " [-c] Generate C++ Compatible code"
    PRINT " [-d] DEFINE a constant ... ex. BC MyFile -D:MyConst[=SomeValue]"
    PRINT " [-e] Write ERRORS to BCX.ERR file"
    PRINT " [-f] Output FILENAME... ex. BC MyFile -f:C:\\MyFiles\\MyFile.c"
    PRINT " [-h] Generate HEADER file for use with $Projects"
    PRINT " [-i] Send Warnings and Errors to INFOBOX"
    PRINT " [-k] KILL the generated BCX generated 'C' file"
    'PRINT " [-l] Create Runtime LIBRARY source and header Files"
    PRINT " [-n] Enable NO RUNTIME Code Generation"
    PRINT " [-o] OUTPUT a copy of the generated C file to STDOUT"
    PRINT " [-q] QUIET - No output to screen during translation"
    'PRINT " [-r] Update BCX Path variable in the Windows REGISTRY"
    PRINT " [-s] Show STATUS of translation by line number"
    PRINT " [-w] Enable WARNINGS during translation"
    PRINT " [-x] EXCLUDE Win32 Headers from the resulting C file"
    PRINT " [-t] TURBO Mode ON w/optional size ... ex. BC MyFile -t[:1024]"
    PRINT " [-u] Turn UNICODE Support ON"

    'IF BCXPATH$ =  "Not Found" THEN
      'CREATEREGSTRING _
      '(HKEY_LOCAL_MACHINE,"Software\\Bcx-32\\Bcx\\Settings","Path",APPEXEPATH$)
      'CREATEREGSTRING _
      '(HKEY_CURRENT_USER,"Software\\Bcx-32\\Bcx\\Settings","Path",APPEXEPATH$)
      'PRINT "      BCX Path set to ", BCXPATH$
    'END IF
    CALL FREEGLOBALS
    END
  END IF
  'check for -v or -version

  'If szTmp$ = "-v" OR szTmp$  = "-version" Then
  If LCASE$(LEFT$(COMMAND$(1),2)) = "-v" Then
    PRINT "bc9Basic: BASIC to C/C++ Translator "
    PRINT "Version ", Version$, "  Compiled with ";
    $IF __BCPLUSPLUS__
      PRINT "Borland C++"
    $ELSEIF __BORLANDC__
      PRINT "Borland C"
    $ELSEIF __POCC__
      PRINT "Pelles C"
    $ELSEIF __LCC__
      PRINT "LCCWin32 C"
    $ELSEIF __WATCOM_CPLUSPLUS__
      PRINT "Open Watcom C++"
    $ELSEIF __MINGW64__
      PRINT "MinGW64 C"
    $ELSEIF __MINGW32__
      PRINT "MinGW32 C++"
    $ELSEIF __DMC__
      PRINT "Digital Mars C/C++"
    $ELSEIF _MSC_VER
      PRINT "Microsoft Visual C++"
    $ELSE
      PRINT "Unknown"
    $ENDIF
    CALL FREEGLOBALS
    END
  End If

  'IF BCXPATH$ = "Not Found" THEN
    'CREATEREGSTRING _
    '(HKEY_LOCAL_MACHINE,"Software\\Bcx-32\\Bcx\\Settings","Path",APPEXEPATH$)
    'CREATEREGSTRING _
    '(HKEY_CURRENT_USER,"Software\\Bcx-32\\Bcx\\Settings","Path",APPEXEPATH$)
    'PRINT "      BCX Path set to ", BCXPATH$
  'END IF

  'IF LCASE$(COMMAND$) = "-r" THEN
    'CREATEREGSTRING _
    '(HKEY_LOCAL_MACHINE,"Software\\Bcx-32\\Bcx\\Settings","Path",APPEXEPATH$)
    'CREATEREGSTRING _
    '(HKEY_CURRENT_USER,"Software\\Bcx-32\\Bcx\\Settings","Path",APPEXEPATH$)
    'PRINT "      BCX Path set to ", BCXPATH$
    'END
  'END IF

  ' build runtime library - no filename as first parameter
 'jcfuller changed 03/05/2015
 '
  IF LCASE$(LEFT$(COMMAND$(1),2)) = "-l" THEN
	PRINT "Runtime Library Creation  not available with Bc9Basic"
	CALL FREEGLOBALS
	END
  END IF
    'Use_Library = TRUE
    'sENDBCXRTLIB$     = "}\n// ENDBCXRTLIB"
    'sENDBCXRTLIB2$    = "\n// ENDBCXRTLIB"
    'Cmd$ = LCASE$(COMMAND$(1))
    'IF INCHR(Cmd$, "c") THEN UseIO = UseCpp  = TRUE
    'IF INCHR(Cmd$, "n") THEN NoKill  = TRUE
    'IF INCHR(Cmd$, "d") THEN Use_Dll = TRUE
    'IF INCHR(Cmd$, "q") THEN Quiet   = TRUE
  'ELSE
    NoKill      = FALSE
    Use_Project  =  FALSE
    szProject$ = "static "
    Use_Library  =  FALSE
    Use_Dll      =  FALSE
    Quiet        =  FALSE
  'END IF

' a little hacking to make compatible with FbEdit sending otions before file name

  IF LEFT$(COMMAND$(1),1) = "-" Then

	op_start = 1
    szTmp$ = LCASE$(ARGV$[ARGC-1])
    If INSTR(szTmp$,".bas") Then
      findex = ARGC-1
    Else
      findex = ARGC-2
    End If
    op_end = findex - 1
  Else
	op_start = 2
	op_end = ARGC-1
	findex = 1
  END IF
  'std::cout << "op_start = " << op_start << std::endl
  'std::cout << "op_end = " << op_end << std::endl
  'FOR INTEGER i = 2 TO ARGC-1
  FOR INTEGER i = op_start TO op_end
    szTmp$ = LCASE$(ARGV$[i])
    'PRINT szTmp$
    IF INSTR(szTmp$,"-b") THEN
      IF cMaxOnExit = XitCount THEN CALL Abort("Maximum $OnExit exceeded.")
      XitCount++
'jcfuller 1/29/2013
      'Xit$[XitCount]= MID$(ARGV$[i],4) + " " + ENC$(EXTRACT$(COMMAND$(1),"."))
      Xit$[XitCount]= MID$(ARGV$[i],4) + " " + ENC$(RemoveExtension$(COMMAND$(1)))
    END IF
    IF szTmp$ = "-c" THEN UseIO = UseCpp      = TRUE
    IF szTmp$ = "-e" THEN ErrFile     = TRUE
    IF szTmp$ = "-h" THEN Gen_Header  = TRUE
    IF szTmp$ = "-i" THEN InfoBoxWarn = TRUE
    IF szTmp$ = "-q" THEN Quiet       = TRUE
    IF szTmp$ = "-k" THEN KillCFile   = TRUE
    IF szTmp$ = "-n" THEN NoRT        = TRUE
    IF szTmp$ = "-o" THEN ReDirect    = TRUE
    IF szTmp$ = "-s" THEN ShowStatus  = TRUE
    IF szTmp$ = "-w" THEN TestState   = TRUE
    'IF szTmp$ = "-x" THEN WinHeaders  = FALSE
'jcfuller change 03/12/2016    
    ' Hopefully this will not break anything
    ' I cannot remember why I added -p. Maybe for support
    ' of $NOAPI directive which is really moot as these 
    ' values need to be set before any parsing of the source
    IF szTmp$ = "-x" THEN
    	UseWinApi = FALSE
    	WinHeaders = FALSE
    End If
    
    IF szTmp$ = "-u" THEN Use_UNICODE_Switch = TRUE
    IF szTmp$ = "-p" THEN
    	UseWinApi = FALSE
    	WinHeaders = FALSE
    End If
    IF iMatchLft(szTmp$,(char*)"-nix") THEN
    	TargetOS = TNIX
    	UseWinApi = FALSE
    	WinHeaders = FALSE
    End If
    IF iMatchLft(szTmp$,"-xinc") OR iMatchLft(szTmp$,"-noinc")Then
	'	Print "XINC"
    	WinHeaders = FALSE
    	UseWinApi = FALSE
    	NoIncludes = TRUE
    End If

    IF iMatchLft(szTmp$,"-ne") THEN
		g_EmitLibs = FALSE
    End If
    IF iMatchLft(szTmp$,"-dll") THEN
		MakeDLL = TRUE
    End If
    IF iMatchLft(szTmp$,"-stddll") THEN
		MakeDLL = TRUE
		UseStdCall = TRUE
    End If

    IF iMatchLft(szTmp$,"-zt") THEN
		_ZTRACE_ = TRUE
    End If
    
    IF iMatchLft(szTmp$,"-zzt") THEN
		USE_ZTRACE = TRUE
    End If


    If iMatchLft(szTmp$,"-xorig") Then
		AStyleDel = FALSE
    End If
'jcfuller added 11/15/2014 for mfc
    If iMatchLft(szTmp$,"-mfc") Then
		Use_MFC = TRUE
    	WinHeaders = FALSE
    	UseWinApi = FALSE
    	NoIncludes = TRUE
		Use_UNICODE_Switch = TRUE
    End If

'jcfuller added 03/10/2014 for wxWidgets console
    If iMatchLft(szTmp$,"-wxc") Then
		WxCon = _true
    	WinHeaders = FALSE
    	UseWinApi = FALSE
    	NoIncludes = TRUE
		g_EmitLibs = FALSE

	End If
'jcfuller added 03/10/2014 for wxWidgets gui
    If iMatchLft(szTmp$,"-wxg") Then
		'DoWx((char*)"-wxg",0)
		WxGui = _true
    	WinHeaders = FALSE
    	UseWinApi = FALSE
    	NoIncludes = TRUE
		g_EmitLibs = FALSE
	End If
    'If iMatchLft(szTmp$,"-xtcl") Then
		'Use_TCLib = TRUE
    	'WinHeaders = FALSE
    	'UseWinApi = FALSE
    	'NoIncludes = TRUE
		'Use_UNICODE_Switch = FALSE
    'End If
	
'jcfuller added 03/24/2016
    If iMatchLft(szTmp$,"-tcl") Then
		Use_TCLib = TRUE
    	WinHeaders = FALSE
    	UseWinApi = FALSE
    	NoIncludes = TRUE
		'Use_UNICODE_Switch = TRUE
    End If
    If iMatchLft(szTmp$,"-nfs") Then
		Use_fstring = FALSE
    End If
	'jcfuller added -m
	If iMatchLft(szTmp$,"-m") Then
		SrcFlag = TRUE
	End If

    IF iMatchLft(szTmp$,"-f:") THEN CmdLineFileOut$ = MID$(ARGV$[i],4)
    IF iMatchLft(szTmp$,"-d:") THEN CmdLineConst$ = CmdLineConst$ + MID$(ARGV$[i],4) + CHR$(1)
    IF iMatchLft(szTmp$,"-t:") THEN
      BCX_TmpStrSize = VAL(MID$(szTmp$,4))
      IF BCX_TmpStrSize <> 0 THEN
        IF (BCX_TmpStrSize & (BCX_TmpStrSize-1)) <> 0 THEN
          BCX_TmpStrSize = 512
          Warning("Invalid $Turbo size - defaulting to 512")
        END IF
      ELSE
        BCX_TmpStrSize = 512
      END IF
    END IF
  NEXT


  If _ZTRACE_ Then
	H_ZTRACE = LoadLibrary("zTrace32.dll")
	If H_ZTRACE Then
		zTrace=(BCXFPROT1)GetProcAddress(H_ZTRACE, "zTrace");
		cout << "zTrace Loaded" << endl
		zTrace(ANSITOWIDE((char*)"Hello From bc9Basic"))
		'zTrace(L"Hello From bc9Basic")
	Else
		cout << "No zTrace Library" << endl
	End if

  End if
  '****************************** [ Announce Program ] ********************************
  IF ShowStatus THEN CLS

  IF NOT Quiet THEN
    'PRINT "BCX-32: BASIC to C/C++ Translator by Kevin Diggins (c) 1999-2012"
    PRINT "bc9Basic: BASIC to C/C++ Translator"
    PRINT "bc9Basic Version ", Version$
  END IF
  '************************************************************************************
'jcfuller 1/29/2013
'must use a .bas extension for bc9
  'IF (LCASE$(RIGHT$(COMMAND$(1),4)) = ".bas") OR  (LCASE$(RIGHT$(COMMAND$(1),4)) = ".bcx")THEN
     'Cmd$ = COMMAND$(1)
  'ELSEIF ((LCASE$(RIGHT$(COMMAND$(1),3)) = ".bi")) Then
	'Cmd$ = COMMAND$(1)
	'IsBiFile = TRUE
  'ELSE
     'Cmd$ = COMMAND$(1) + ".bas"
  'END IF

'jcfuller changed 02/08/2015
  IF (LCASE$(RIGHT$(COMMAND$(findex),4)) = ".bas") OR  (LCASE$(RIGHT$(COMMAND$(findex),4)) = ".bcx")THEN
     Cmd$ = COMMAND$(findex)
  ELSEIF ((LCASE$(RIGHT$(COMMAND$(findex),3)) = ".bi")) Then
	Cmd$ = COMMAND$(findex)
	IsBiFile = TRUE
  ELSE
     Cmd$ = COMMAND$(findex) + ".bas"
  END IF

  'IF INCHR(COMMAND$(1),".") THEN
    'Cmd$ = COMMAND$(1)                                 ' Allow ANY extension
  'ELSE
  ''jcfuller changed.
    ''Cmd$ = UCASE$(EXTRACT$(COMMAND$(1),".")) + ".BAS"  ' Assume implicit .BAS
    ''Cmd$ = EXTRACT$(COMMAND$(1),".") + ".bas"  ' Assume implicit .BAS
    'Cmd$ = RemoveExt$(COMMAND$(1)) + ".bas"  ' Assume implicit .BAS
  'END IF

  IF Use_Library THEN
    'OPEN "bcxRT.bas" FOR OUTPUT AS hRT
    'FPRINT hRT,"$NOINI"
    'FPRINT hRT,"$NOMAIN"
    'CLOSE hRT
    f.open("bcxRT.bas",ios::out)
    f << "$NOINI" << endl
    f << "$NOMAIN" << endl
    f.close()
    Cmd$ = "BCXRT.BAS"
  END IF

  IF INCHR(Cmd$,"*") OR INCHR(Cmd$,"?") THEN Cmd$ = FINDFIRST$(Cmd$)

  CmdPP$ = "" 'quiet the warning

  $IF BCXPP   ' Invoke the BCX Standard Preprocessor - bcxpp.exe
    'CmdPP$ = EXTRACT$(Cmd$,".") + ".PPO"
    CmdPP$ = RemoveExtension$(Cmd$) + ".PPO"
    IF NOT Quiet THEN PRINT "Preproccessing ";Cmd$ + "..."
    SHELL "BCXPP.EXE " + Cmd$
    IF NOT Quiet THEN PRINT "Translating ";CmdPP$ + "..."
    FileIn$  = CmdPP$
  $ELSE
    FileIn$ = Cmd$
  $ENDIF

  IF CmdLineFileOut$ = "" THEN
    IF UseCpp Then
        FileOut$ = LEFT$(Cmd$, INSTRREV(Cmd$,".",0)-1) + ".cpp"
    Else
        FileOut$ = LEFT$(Cmd$, INSTRREV(Cmd$,".",0)-1) + ".c"
    End If
'jcfuller added 02/25/2015
'this does not help . need a new batch file for VS12
    'If Exist(FileOut$) Then
    '    KILL FileOut$
    'End If
  ELSE
    FileOut$ = CmdLineFileOut$
  END IF

  FileErr$ = LEFT$(Cmd$, INSTRREV(Cmd$,".",0)-1) + ".ERR"

  IF EXIST(FileErr$) THEN
    SHELL "DEL " + FileErr$
  END IF

  '*******************************************************
  IF InternalDebugOff THEN
    RAW szTMP$
    szTMP$ = TEMPDIR$
    ccodeFile$ = TEMPFILENAME$(szTMP$,"ccode")
    prcFile$ = TEMPFILENAME$(szTMP$,"prc")
    udtFile$ = TEMPFILENAME$(szTMP$,"udt")
    datFile$ = TEMPFILENAME$(szTMP$,"dat")
    UserConstFile$ = TEMPFILENAME$(szTMP$,"cst")
    SystemConstFile$ = TEMPFILENAME$(szTMP$,"syscst")
    ovrFile$ = TEMPFILENAME$(szTMP$,"ovr")
    hdrFile$ = TEMPFILENAME$(szTMP$,"hdr")
    setFile$ = TEMPFILENAME$(szTMP$,"set")
    resFile$ = TEMPFILENAME$(szTMP$,"res")
    enuFile$ = TEMPFILENAME$(szTMP$,"enu")
  ELSE
    RAW szTMP$
    szTMP$ = appexepath$
    ccodeFile$ = szTMP$ + "ccode_debug.txt"
    prcFile$ = szTMP$ + "prc_debug.txt"
    udtFile$ = szTMP$ + "udt_debug.txt"
    datFile$ = szTMP$ + "dat_debug.txt"
    UserConstFile$ = szTMP$ + "cst_debug.txt"
    SystemConstFile$ = szTMP$ + "syscst_debug.txt"
    ovrFile$ = szTMP$ + "ovr_debug.txt"
    hdrFile$ = szTMP$ + "hdr_debug.txt"
    setFile$ = szTMP$ + "set_debug.txt"
    resFile$ = szTMP$ + "res_debug.txt"
    enuFile$ = szTMP$ + "enu_debug.txt"
  END IF

  re[RE_CTOR] = new pcrecpp::RE("(?i)^\\s*constructor\\s+(\\w+)::.+")
  re[RE_DTOR] = new pcrecpp::RE("(?i)^\\s*(dtor_|destructor_)(\\w+[::\\w+]*)\\s*(.*)")
  re[RE_ENDCTOR]= new pcrecpp::RE("(?i)^\\s*end\\s+constructor")
  re[RE_PROPGETSET] = new pcrecpp::RE("(?i)^\\s*propgetset\\s+(\\w+)\\s+as\\s+(\\w+\\**)")
  re[RE_PROPGETONLY] = new pcrecpp::RE("(?i)^\\s*propgetonly\\s+(\\w+)\\s+as\\s+(\\w+[::\\w+]*)([\\s+ptr\\*]*)")
  re[RE_CLASS] = new pcrecpp::RE("(?i)^\\s*(class|struct|interface)\\s+(\\w+)\\s*[inherits]*\\s*(\\w+)*")
  're[RE_ENDCLASS]= new pcrecpp::RE("(?i)^\\s*end\\s+class|struct")
  re[RE_ENDCLASS]= new pcrecpp::RE("(?i)^\\s*end\\s+(class|struct|interface)\\s*(.+)")
  re[RE_EXITFOR] = new pcrecpp::RE("(?i)^\\s*exit\\s+for")
  re[RE_DLGCB] = new pcrecpp::RE("(?i)^\\s*dlgcallback\\s+(\\w+).+")
  re[RE_WX] = new pcrecpp::RE("(?i)^\\s*(\\$WXG|\\$WXC)\\s+\\x22(\\w+)\\x22")
  re[RE_WXTRIM] = new pcrecpp::RE("(?i)wxtrim\\s*\\(\\s*.+\\s*\\)\\s*")
  're[RE_AUTO] = new pcrecpp::RE("(?i)^.*\\s+_auto\\s+.+")
  're[RE_AUTO] = new pcrecpp::RE("(?i)^.*_auto\\s+.+")
  re[RE_AUTO] = new pcrecpp::RE("(?i)^.*(_auto|auto)\\s+.+")
  're[RE_RBFOR]= new pcrecpp::RE("(?i)^
  re[RE_ENDFUNC]= new pcrecpp::RE("(?i)^\\s*end\\s+function")
  're[RE_MAIN] = new pcrecpp::RE("(?i)^\\s*Function\\s+main\\s*\\(\\).*")
  re[RE_MAIN] = new pcrecpp::RE("(?i)^\\s*Function\\s+main\\s*\\(.*")
  re[RE_FALSE] = new pcrecpp::RE(".*\\b_false\\b.*")
  re[RE_TRUE] =  new pcrecpp::RE(".*\\b_true\\b.*")
  re[RE_REF] = new pcrecpp::RE(".*\\b_ref\\b.*")
  re[RE_BIT] = new pcrecpp::RE("(?i)^\\s*bit\\s+([set|reset|toggle]+)\\s+(\\w+)\\s*,\\s*(.+)")
  re[RE_CHOOSE_ELSE] = new pcrecpp::RE("(?i)^\\s*(\\w+)\\s*=\\s*choose\\s*\\(\\s*(BITS|BIT)*\\s*(L*\".?\")*\\s*(\\w+),(.+?(?= ELSE ))( ELSE )*(.*)\\)")
  re[RE_CHOOSE] = new pcrecpp::RE("(?i)^\\s*(\\w+)\\s*=\\s*choose\\s*\\(\\s*(BITS|BIT)*\\s*(L*\".?\")*\\s*(\\w+)\\s*,\\s*(.+)\\)")
  re[RE_OPENFILE] = new pcrecpp::RE("(?i)^\\s*openfile\\s+(\\w+\\**)\\$*\\s+for\\s+(input|output|append)\\s+as\\s+(.+)")
  '**************************************************************************
  If LCASE$(FileIn$) = "bc9.bas" Then
	IsBc9 = TRUE
  Else
     IsBc9 = FALSE
  End If
  'If IsBc9 = FALSE Then
	'CheckForDirectives(FileIn$)
  'End If

  OPEN FileIn$  FOR INPUT  AS SourceFile
  OPEN FileOut$ FOR OUTPUT AS FP2           ' THE FINAL C FILE <<<<<<<<

  '**************************************************************************
  Outfile = FP2                    ' Outfile = FP3 when in a SUB or FUNCTION
  '**************************************************************************
  OPEN ccodeFile$ FOR OUTPUT AS FP_CCODE  ' Temp file for CCODE
  OPEN prcFile$ FOR OUTPUT AS FP3  ' Temp File FOR Storing User Functions
  OPEN udtFile$ FOR OUTPUT AS FP_UDT  ' Temp File FOR Storing User Def Types
  OPEN datFile$ FOR OUTPUT AS FP_DAT  ' Temp File FOR Storing User "Data"
  OPEN UserConstFile$ FOR OUTPUT AS FP_CST  ' Temp File FOR Storing User CONST
  OPEN SystemConstFile$ FOR OUTPUT AS FP_SYSCST  ' Temp File FOR Storing User CONST
  OPEN hdrFile$ FOR OUTPUT AS FP_HDR  ' Temp File FOR Storing User .H files
  OPEN ovrFile$ FOR OUTPUT AS FP_OVR  ' Temp File FOR Storing overloaded funcs
  OPEN setFile$ FOR OUTPUT AS FP_SET  ' Temp File FOR Storing GLOBAL SET Vars
  OPEN resFile$ FOR OUTPUT AS FP_RES ' Temp File FOR Storing User .rc files
  OPEN enuFile$ FOR OUTPUT AS FP_ENU ' Temp File FOR Storing User global enums

  '*************************************************************************
  CALL ExportStringConst()
  ModuleNdx = 1
  Modules$[ModuleNdx] = FileIn$       ' store the current module name
  ModuleLineNos[ModuleNdx] = 0

  '**************************************************************************
  IF Use_Library THEN UseAll( UseCpp )

  'IF NoRT = TRUE THEN CALL EnableProject()
  IF NoRT THEN CALL EnableProject()

  CALL BeginMain()
'jcfuller 02/02/2014
'need PCHAR defined so trying here
If WxCon = _false AND WxGui = _false AND (UseWinApi = FALSE OR WinHeaders = FALSE) Then
  If NOT Use_MFC Then
      FPRINT FP_HDR,"// NO HEADERS START"
      'FPRINT FP_HDR,"#ifndef HANDLE"
      FPRINT FP_HDR,"#ifndef _WINDOWS_"
  	If Use_UNICODE_Switch Then
  	  FPRINT FP_HDR,"//<---UNICODE AWARE"
  	  FPRINT FP_HDR,"typedef _TCHAR *PCHAR,*LPCH,*PCH,*NPSTR,*LPSTR,*PSTR;"
  	  FPRINT FP_HDR,"typedef unsigned long DWORD, *PDWORD, *LPDWORD;"
  	  FPRINT FP_HDR,"typedef unsigned int UINT;"
  	  FPRINT FP_HDR,"//>---UNICODE AWARE"
  	Else
  	  FPRINT FP_HDR,"typedef char *PCHAR,*LPCH,*PCH,*NPSTR,*LPSTR,*PSTR;"
  	  FPRINT FP_HDR,"typedef unsigned long DWORD, *PDWORD, *LPDWORD;"
  	  FPRINT FP_HDR,"typedef unsigned int UINT;"
  	  FPRINT FP_HDR,"typedef unsigned char BYTE;"
  	  FPRINT FP_HDR,"typedef void *PVOID;"
	  FPRINT FP_HDR,"typedef PVOID HANDLE;"
	  FPRINT FP_HDR,"typedef HANDLE HINSTANCE;"
	  FPRINT FP_HDR,"typedef int BOOL;"
      FPRINT FP_HDR,"#define WINAPI __stdcall"
      FPRINT FP_HDR,"#define APIENTRY __stdcall"
      FPRINT FP_HDR,"#define TRUE 1"
      FPRINT FP_HDR,"#define FALSE 0"
	  FPRINT FP_HDR,"#define MAX_PATH 2048"
  	End If
  	FPRINT FP_HDR,"#endif"
  	FPRINT FP_HDR,"// NO HEADERS END"
  End If
End If
If WxCon OR WxGui Then
  	FPRINT FP_HDR,"#ifndef UNICODE"
	FPRINT FP_HDR,"    #define UNICODE"
	FPRINT FP_HDR,"#endif"
	FPRINT FP_HDR,"#ifndef _UNICODE"
	FPRINT FP_HDR,"    #define _UNICODE"
	FPRINT FP_HDR,"#endif"

End If
  'If UseWinApi  Then  put the decision in Sub
    CALL EmitCompilerDefines()
  'End If
  CALL ClearIfThenStacks()
  ' Treats -c command line switch as of $CPP directive
  'IF UseCpp = TRUE THEN RAW iTmp : Docpp((char*)"", &iTmp)
  IF UseCpp THEN
    RAW iTmp
    Docpp((char*)"", &iTmp)
  END IF
  'IF UseWinApi = FALSE Then
  IF MakeDLL = FALSE THEN
  	CALL AddGlobal("g_argv",vt_PCHAR, 0,"",1,0,0,0,0)
  	CALL AddGlobal("g_argc",vt_INTEGER, 0,"",0,0,0,0,0)
  END IF
  'END IF
  	'CALL AddTypeDefs("PCHAR",vt_CHARPTR)
  'ELSE
  '  PRINT "UseWinApi is TRUE?"
  'END IF

  '*****************
  '  The Main LOOP
  '*****************
GLOBAL ExitSubFunc
ReadSrcLine:
  '*****************
Local zzxx As int
  WHILE NOT EOF(SourceFile) OR SplitCnt
    IF SplitCnt = 0 THEN                                        'Process separated lines before
      LINE INPUT SourceFile,Src$                                'getting next line from file.



      ModuleLineNos[ModuleNdx]++
      '******************************
      ' Convert Basic remark line into a inline C code remark line

      IF InsertComments THEN
        'If zzxx = 0 Then
        '  cout << "InsertComments" << endl
        'End if
        Src$ = TRIM$(Src$)
        IF Src[0] = c_SglQt THEN
          'FPRINT Outfile,Scoot$;"//";(CHAR PTR)(Src+1)
          FPRINT Outfile,Scoot$;"//",(CHAR PTR)(Src+1)
          *Src = 0
          ITERATE
        END IF
        IF iMatchLft(Src$,"rem ") THEN
          FPRINT Outfile,Scoot$;"//";(CHAR PTR)(Src+3)
          *Src = 0
          ITERATE
        END IF
      END IF

      CALL StripCode(Src$)                                      'Remove spaces, tabs, comments
      IF *Src = 0 THEN ITERATE

      IF JoinLines(Src$) THEN ITERATE                       'Join continuation lines " _"

      IF INCHR(Src$,"[") THEN CALL BracketHandler(Src$,0)       'Fix Brackets

'=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
      rv = DoJcfStuff()			'jcfuller
'=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*


    IF MacroCheck() = FALSE THEN
        IF SplitLines(Src$) THEN Src$ = SplitStk$[++SplitCur]     'Split statements separated by
        END IF
    ELSE                                                         'colons and single line if/then
      Src$ = SplitStk$[++SplitCur]
    END IF


    IF SplitCur = SplitCnt THEN SplitCur = SplitCnt = 0

    IF PPFlag THEN           ' PreProcess the line
      GLOBAL ppret AS LONG
      ppret = PPProc(Src$)   ' Error in PP returns error message in Src$
      IF ppret = 0 THEN Abort(Src$)
    END IF

    ' The tokens produced when an error occurs may not resemble AbortSrc$ due to translation
    AbortSrc$ = Src$

    '******************************
    ' No testing on inline c
    ' If your doing inlince c then you should know what you are doing
    IF Src[0] = 33 THEN  'Test for ! symbol -- inline C
      'jcfuller fix per Ian
      'IF InFunc OR InClassModule OR InNameSpace THEN
      'IF InFunc OR InClassModule OR InNameSpace OR InTypeDef THEN

      'jcfuller added  > 0 08/11/2013 from bcx 7.0.7
      IF InFunc > 0 OR InClassModule OR InNameSpace OR InTypeDef THEN
        FPRINT Outfile,MID$(Src$,2)
      ELSE
'Wayne fix 06/29/2013
		IF InMain Then
		  FPRINT FP2, MID$(Src$,2)
		Else
          FPRINT FP_CST,MID$(Src$,2)
        End If
      END IF
      ITERATE
    END IF

    CALL CheckParQuotes()

    IF (TrcFlag AND InFunc > 0 ) OR SrcFlag OR ShowStatus THEN
      CALL ActivityFlags()
    END IF

    IF *Src = 0 THEN ITERATE

    CALL Translate(Src$)    ' Okay let's translate
  WEND

  FLUSH (Outfile)            '*************************************
  IF FPtrNdx THEN            '  Pop out the $Include File Handles
    CALL PopFileIO()         '  and close them in sequence until
    GOTO ReadSrcLine         '  we end up back in the main file
  END IF                     '*************************************

  '***************************************************
  ' END OF MAIN LOOP -- All Source code has been read
  '***************************************************
  ' everything from here below must be stopped from
  ' executing more than once

  IF FirstTime(TestForBcxIni) THEN
    TestForBcxIni = TRUE
    szFile$ = CURDIR$ + "\\bcx.ini"

    IF NOT EXIST(szFile$) THEN
      szFile$ = APPEXEPATH$ + "bcx.ini"
    END IF

    IF EXIST(szFile$) THEN
      CALL PushFileIO()
      OPEN szFile$ FOR INPUT AS SourceFile
      IF ModuleNdx = cMaxLoopLocal-1 THEN CALL Abort("Maximum Include Files exceeded.")
      Modules$[++ModuleNdx] = szFile$
      ModuleLineNos[ModuleNdx] = 0
      GOTO ReadSrcLine
    END IF
  END IF

  '***************************************************************************
  ' Last check for possible errors
  IF LoopTypeCnt THEN
    CALL LoopErrorMsg()
  END IF

  IF Indent THEN
    CALL Abort("Possible missing END IF before END of program")
  END IF
  '***************************************************************************

  IF Use_VBS THEN
    CALL Emit_VBSCRIPT_Support()    ' Writes to FP_HDR
  END IF

  IF Use_Project = FALSE THEN
    STATIC Pass_1
    IF FirstTime(Pass_1) THEN
      INCR Pass_1
      AddLibrary("kernel32.lib")
      AddLibrary("user32.lib")
      AddLibrary("gdi32.lib")
      AddLibrary("comctl32.lib")
      AddLibrary("advapi32.lib")
      AddLibrary("winspool.lib")
      AddLibrary("shell32.lib")
      AddLibrary("ole32.lib")
      AddLibrary("oleaut32.lib")
      AddLibrary("uuid.lib")
      AddLibrary("odbc32.lib")
      AddLibrary("odbccp32.lib")
      AddLibrary("winmm.lib")
      AddLibrary("comdlg32.lib")
      AddLibrary("imagehlp.lib")
      AddLibrary("version.lib")
'jcfuller added 3/21/2015
      AddLibrary("wininet.lib")
      AddLibrary("urlmon.lib")
'jcfuller added 08/23/2016
	  AddLibrary("uxTheme.lib")
	  AddLibrary("shlwapi.lib")
    END IF

    CALL Emit_Pragmas()
  END IF ' Use_Project = FALSE
  If UseWinApi AND g_EmitLibs Then
    CALL EmitLibs() ' Writes to FP_HDR
  End If

  IF Use_GenFree AND GlobalDynaCnt THEN
    CALL MakeFreeGlobals()  ' Writes to Outfile
  END IF

  CALL ExportInternalConst()  ' Writes to FP_CST

  CALL EmitEpilog() ' Writes to Outfile

  CALL CloseAll()

'jcfuller 1/12/2015
'Lets try creation of new // Compiler Defines here

  CALL AssembleParts()

  IF Use_Resource AND NOT Use_GenResFile THEN
    IF UserResFile$ <> "" THEN Res_File$ = UserResFile$
  END IF

  IF Use_GenResFile THEN

    CombineRes = FALSE

    IF EXIST(UserResFile$) THEN CombineRes = TRUE 'don't overwrite rc file
'jcfuller 1/29/2013
    'szTmp$ = EXTRACT$(UCASE$(FileOut$),".") + "__.rc"
    szTmp$ = RemoveExtension$(UCASE$(FileOut$)) + "__.rc"
    Res_File$ = szTmp$


    OPEN resFile$ FOR INPUT  AS ResIn
    OPEN szTmp$   FOR OUTPUT AS ResOut

    FPRINT ResOut,"//  BCX Generated Resource File"
    FPRINT ResOut,"//  Date: ",DATE$, " Time: ",TIME$
    FPRINT ResOut,""
    FPRINT ResOut,"#include <windows.h>"
    FPRINT ResOut,""

    IF CombineRes THEN
      OPEN UserResFile$ FOR INPUT AS UserResIn
      FPRINT ResOut,"// User *.rc file listing"
      FPRINT ResOut,""
      WHILE NOT EOF(UserResIn)
        LINE INPUT UserResIn,Z$    ' Read from user resource file
        IF INSTR(Z$,"windows.h",0,1) > 0 THEN
          Z$ = ""
        END IF
        FPRINT ResOut,Z$           ' Write to final *.rc file
      WEND
    END IF

    FPRINT ResOut,""
    FPRINT ResOut,"// BCX generated *.rc file listing"
    FPRINT ResOut,""

    WHILE NOT EOF(ResIn)
      LINE INPUT ResIn,Z$       ' Read from temp$
      IF INSTR(Z$,"include",0,1) > 0 THEN
        FPRINT ResOut,""
      END IF
      FPRINT ResOut,Z$          ' Write to final *.rc file
    WEND

    CLOSE ResOut
    CLOSE ResIn

    IF CombineRes THEN
      CLOSE UserResIn
    END IF

  END IF

  IF EXIST(resFile$) THEN
    KILL resFile$
  END IF

  '*******************************
  IF ShowStatus THEN LOCATE 2,1,1,12
  '*******************************
  IF NOT Quiet THEN

    INCR LinesRead, ModuleLineNos[1]

    Elapsed! = ROUND((float)clock()/(float)CLOCKS_PER_SEC,2)

    PRINT "[Lines In:" ; LinesRead ; "] [Lines Out:" ; gLinesWritten ; "] ";

    PRINT "[Statements:" ; Statements ; "] [Time:" ; Elapsed! ; " sec's]"

    IF Use_Library THEN
      Z$ = "bc9Baisc Created Runtime Library Files"
    ELSE
      'Z$ = "bc9 translated " + REMOVE$(FileIn$,SPC$) + " to " + REMOVE$(FileOut$,SPC$)
      Z$ = "bc9Basic translated " + ENC$(FileIn$) + " to " + ENC$(FileOut$)
    END IF

    IF NOT Use_Library THEN
      IF UseCpp THEN
		If Use_MFC Then
			Z$ = Z$ + " For Visual C++ using MFC"
		Else
			Z$ = Z$ + " For a C++ Compiler"
		End If
      ELSE
        Z$ = Z$ + " For a C Compiler"
      END IF
    END IF

    IF Use_Project THEN
      Z$ = Z$ + " With No Runtime"
    END IF

    PRINT Z$
  END IF

  IF Use_Project AND Gen_Header THEN
    CALL Project_Support()
  END IF

  IF Use_Library THEN
    CALL Library_Support()
  END IF

'jcfuller added 3/19/2013 to handle new C11 addtions
'PRINT "FileOut$ = *"; LCASE$(FileOut$);"*"
  If LCASE$(FileOut$) <> "bc9.cpp" Then
'	PRINT "Doing DoCppFixUps"
	DoCppFixUps(FileOut$)

'jcf added 11/04/2013 to pretty up the code
	If LEN(Project$) = 0 Then
		'If Exist("ASTYLE.EXE") Then
			'cout << "BC9PATH -> " << BC9PATH$ << endl
			cout << "Shelling to ASTYLE.EXE" << endl
			SHELL BC9PATH$ + "ASTYLE.EXE -p " + ENC$(FileOut$)
			'SHELL BC9PATH$ + "ASTYLE.EXE " + ENC$(FileOut$)
			If AStyleDel Then
				SHELL "del " + ENC$(FileOut$+".orig")
			End If
		'Else
		'    cout << "could not locate ASTYLE" << endl
		'End If
	End If
 ' ELSE
  '  PRINT "NO CPPFIXUPS"
  End If
  If Use_UNICODE_Switch Then
    'cout << FileOut$ << endl
    'SHELL "ULEX.EXE " + FileOut$
  End If

  CALL PostProcess()


  IF WarnMsg$ <> "" THEN
    IF InfoBoxWarn THEN
      INFOBOX("Warnings! :" , WarnMsg$, GetSystemMetrics(SM_CXSCREEN)/4, GetSystemMetrics(SM_CYSCREEN)/4)
    ELSE
      PRINT "Warnings! :", CRLF$, WarnMsg$
    END IF
  END IF

  IF KillCFile THEN KILL FileOut$   ' -k switch issued ?

  'jcfuller kill the temp prop files
  IF Use_ClassProps Then
  	For vsi_tempfile = g_tempfiles.begin() To g_tempfiles.end()
      If vsi_tempfile = g_tempfiles.end() Then
      	Exit For
      End If
      sS1 = *vsi_tempfile
      'cout << sS1 << endl
      KILL sS1.c_str()
  	Next
  END IF
  'delete the tmp file file used for range based for
  IF EXIST("_rbfor_.bas") THEN
	KILL "_rbfor_.bas"
  END IF
  'delete the tmp file used for unicode console main file
  IF EXIST("umain.bas") THEN
    KILL "umain.bas"
  END IF
  'delete file used for const hack
  IF EXIST("_CONSTFUNC_.BAS") Then
    KILL "_CONSTFUNC_.BAS"
  END IF
'=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
  'Delete re[]
  Raw As int i
  For i = 0 TO RE_MAX
  	If re[i] Then
  		delete re[i]
  	End If
  Next
  If LEN(Project$) Then
    CALL Dobc9Prj()
  End If
  If H_ZTRACE Then
	cout << "zTrace Active" << endl
	Pause
    FreeLibrary(H_ZTRACE)
  End If
  CALL KillFiles()
  CALL FREEGLOBALS
END FUNCTION  ' Function main  (END of BCX Translator)
'==============================================================================
'Might be able to do all this in the AssembleParts Sub
'==============================================================================
Function DoCppFixUps(f$) As Integer
	'PRINT "IN DoCppFixUps"

	Raw As fstream f1,f2
	Raw As stdstr sLine,sLast,sLeft1,sLeft2,sst
	Dim sftmp$
	static As Integer NeedConst,hStart
	Local As Integer IoErr,ProtoFlag,j ,start
	sftmp$ = f$ + "._tmp"
	Dim dctmp$
	Raw As char DQSQ[3] = {34,39,0}
	Raw As char SQDQ[3] = {39,34,0}
	Raw As char SQNLSQ[5]= {39,92,110,39,0}
	Raw As char PCNT[2]={(char)137,0}
	Dim s2$,s1$
	'cout << "UseStdCall = " << UseStdCall << endl
	'cout << "MakeDll    = " << MakeDLL << endl
	'cout << "UseCpp     = " << UseCpp << endl

	'cout << "UseStdCall = " << UseStdCall << endl
	'dctmp$ = CHR$(15) + CHR$(15)
	'dctmp$ = VCHR$(15,15)
	'cout << "***************" << endl
	'cout << sftmp$ << endl
	'cout << "***************" << endl

	f1.open(f$,ios::in)
	If f1.is_open() Then
		f2.open(sftmp$,ios::out)
		If f2.is_open() Then
			While f1.good()
				getline(f1,sLine)
				If RemoveTypeDef Then
					If hStart Then
						If sLine = "// NO HEADERS END" Then
							RemoveTypeDef = FALSE
						End If
						Iterate
					Else
						If sLine = "// NO HEADERS START" Then
							hStart = TRUE
							Iterate
						End If
					End If
				End If
				'If RemoveTypeDef Then
				'    If Instr(sLine,"*PCHAR,*LPCH") Then
				'		Iterate
						'cout << sLine << endl
				'    End If
				'End If
				'If Instr(sLine,"<<") Then
					'sLine = Replace(sLine,"<<"," << ")
				'End If
				'If Instr(sLine,">>") Then
					'sLine = Replace(sLine,">>"," >> ")
				'End If

'				If Instr(sLine,"+=") Then
'					sLine = Replace(sLine,"+="," += ")

If iMatchLft(ltrim$(sLine.c_str()),"printf") Then
	If Instr(sLine,"% d") Then
		sLine = Replace(sLine,"% d","%d")
	End If
End If
					If Instr(sLine,"L " + DQ$) Then
					  sLine = Replace(sLine,"L " + DQ$,"L"+DQ$)
					End If

					If Instr(sLine," ->") Then
					  sLine = Replace(sLine," ->","->")
					End If

					If Instr(sLine," .") Then
						sLine = Replace(sLine," .",".")
					End If
					If WxCon Then
						IF iMatchLft(sLine.c_str(),"int main") Then
						    sLine = "extern "
							sLine.append(DQ$)
							sLine.append("C")
							sLine.append(DQ$)
							sLine.append(" int wmain(int argc,wchar_t** argv)")
							f2 << sLine << endl
							iterate
						End If
						IF iMatchLft(sLine.c_str(),"int     main") AND iMatchRgt(sLine.c_str(),";") Then
							Iterate
						End If
					End If


					If Use_UNICODE_Switch Then
						If Instr(sLine,"_X (") Then
							sLine = Replace(sLine,"_X (","_X(")
						End If
						If Instr(sLine,"_tmain") Then
							If Instr(sLine,";") Then

								sLine = "extern "
								'sLine.append(DQ$)
								sLine.append("_X(")
								sLine.append(DQ$)
								sLine.append("C")
								sLine.append(DQ$)
								sLine.append(")")
								sLine.append(" int _tmain(int,_TCHAR**);")
								'std::cout << sLeft1 << std::endl
								'sLine = "extern "+DQ$+"C"+DQ$+" int _tmain(int,_TCHAR**);"
							'f2 << "//<---UNICODE AWARE" << endl
							f2 << sLine << endl
							'f2 << "//>---UNICODE AWARE" << endl
							iterate
							Else
								sLine = "extern "
								sLine.append("_X(")
								sLine.append(DQ$)
								sLine.append("C")
								sLine.append(DQ$)
								sLine.append(")")
								sLine.append(" int _tmain (int argc, _TCHAR** argv)")
								'f2 << "//<---UNICODE AWARE" << endl
								f2 << sLine << endl
								'f2 << "//>---UNICODE AWARE" << endl
								iterate

								'sLine = "extern "+DQ$+"C"+DQ$+" _tmain (int argc, _TCHAR** argv)"
							End If
						End If
'jcfuller added 03/03/2016						
						If iMatchLft(LTrim$(sLine.c_str()),"printf") Then
							'sLine = Replace(sLine,"% d","%d")
							sLine = Replace(sLine,"% ","%")
						End If
					End If
'				End If
				'If Instr(sLine,"=") Then
				  'If Not (Instr(sLine,"==")) Then
				    'If Not (Instr(sLine,"!=")) Then
				      'If Not (Instr(sLine,"+=")) Then
				        'sLine = Replace(sLine,"="," =")
				      'End If
				    'End If
				  'End If
				'End If
				'If Instr(sLine,"auto") Then
				'	PRINT "AUTO"
				'	std::cout << sLine << endl
				'End If
				'jcf added 12/02/2013
				'removed 12/10/2013 use STDCALL when needed
				'If Instr(sLine," _CALLBACK") Then
				'	sLine = Replace(sLine," _CALLBACK"," CALLBACK")
				'End If

				If Instr(sLine,D3$) Then
					sLine = Replace(sLine,D3$,"::")
				End If

				'If Instr(sLine,"(void)") Then
				'	sLine = Replace(sLine,"(void)","()")
				'End If

				If Instr(sLine,"_auto_") Then
				'	Print "_AUTO_"
				'	std::cout << sLine << endl
					sLine = Replace(sLine,"_auto_","auto ")
				End if
				If Instr(sLine,"_auto ") Then
				'	PRINT "_AUTO"
				'	std::cout << sLine << endl
					sLine = Replace$(sLine,"_auto ","auto ")
				'	std::cout << sLine << endl
				End if

				If Instr(sLine,"__RVR__") Then
					sLine = Replace(sLine,"__RVR__","&&")
				End If
				If InStr(sLine,"_rb_=0") Then
					'getline(f1,sLine)
					'sLine = TRIM$(sLine)
					'cout << sLine.size() << endl
					'If sLine.empty() Then
						Iterate
					'End If
				End If
				If Instr(sLine,"operator__OPDB__") Then
					sLine = Replace(sLine,"__OPDB__","[]")
				End If
				If Instr(sLine,"operator__OPDP__") Then
					sLine = Replace(sLine,"__OPDP__","()")
				End If
				If InStr(sLine,"_bool") Then
					If InStr(sLine,"#define") Then
						Iterate
					End If
				    sLine = Replace(sLine,"_bool","bool")
				End If
				If InStr(sLine,"_true") Then
					If InStr(sLine,"#define") Then
						Iterate
					End If
					If re[RE_TRUE]->FullMatch(sLine) Then
						sLine = Replace(sLine,"_true","true")
					End If
				End If
				If InStr(sLine,"_false") Then
					If InStr(sLine,"#define") Then
						Iterate
					End If
					If re[RE_FALSE]->FullMatch(sLine) Then
						sLine = Replace(sLine,"_false","false")
					End If
				End If
				If Instr(sLine,"_ref") Then
					If re[RE_REF]->FullMatch(sLine) Then
						sLine = Replace(sLine,"_ref","ref")
					End If
				End If
				If Instr(sLine,"[_PERCENT_]") Then
					sLine = Replace(sLine,"[_PERCENT_]","%")
				End If
				If Instr(sLine,PCNT) Then
					sLine = Replace(sLine,PCNT,"%")
				End If
'jcfuller added 05/10/2014
'for switch/case
'needed to swap sst.c_str() 09/06/2014
				If Instr(sLine,"_switch") Then
					sst = TRIM$(sLine)
					'If iMatchLft("_switch",sst.c_str()) Then
					If iMatchLft(sst.c_str(),"_switch") Then
						sLeft1 = ";"
						sLine = RTRIM$(sLine,sLeft1)
						sLine = Replace(sLine,"_switch","switch")
					End if
				End If
'jcfuller added 04/05/2015
				'If Instr(sLine,"switch") Then
					'sst = TRIM$(sLine)
					''If iMatchLft("_switch",sst.c_str()) Then
					'If iMatchLft(sst.c_str(),"switch") Then
						'sLeft1 = ";"
						'sLine = RTRIM$(sLine,sLeft1)
						''sLine = Replace(sLine,"_switch","switch")
						'f2 << sLine << endl
						'sLine = "{"
					'End if
				'End If


				If Instr(sLine,"_case") Then
					sst = TRIM$(sLine)
					If iMatchLft(sst.c_str(),"_case") Then
						sLine = Replace(sLine,"_case","case")
						sLine = Replace(sLine,";",":")
					End If
				End If

				If Instr(sLine,"_default") Then
					sst = TRIM$(sLine)
					If iMatchLft(sst.c_str(),"_default") Then
						sLine = Replace(sLine,"_default","default")
						sLine = Replace(sLine,";",":")
					End If
				End If
'I think I fixed this in DimSubFunc()
				'If Instr(sLine,"virtual void") Then
					'sst = TRIM$(sLine)
					'If iMatchRgt(sst.c_str(),"=0=0;") Then
						'sLine = Replace(sLine,"=0=0;","=0;")
					'End If
				'End If


				If Instr(sLine,"DECLARE_MESSAGE_MAP") Then
					sst = TRIM$(sLine)
					If iMatchLft(sst.c_str(),"DECLARE_MESSAGE_MAP") Then
					  sLeft1 = ";"
					  sLine = RTRIM$(sLine,sLeft1)
					  f2 << sLine << endl
					  sLast = sLine
					  Iterate
					End If
				End If
'added to fix translation of Function ZVectorBuffer::size(void)const As int
'To:
'int ZVectorBuffer::size (int void) const
'The (void) is needed with the trailing const in the basic source or we get 
'int ZVectorBuffer::size (int )) const
'From
'Function ZVectorBuffer::size()const As int
				'If Instr(sLine,"(int void)") Then
				'	sLine = Replace(sLine,"(int void)","()")
				'End If
				
				If Instr(sLine,"(int )) const") Then
					sst = TRIM$(sLine)
					If iMatchRgt(sLine.c_str(),"(int )) const") Then
						sLine = Replace(sLine,"(int ))","()")
					End If
				End If
				'If Instr(sLine,"END_MESSAGE_MAP") Then
					'sst = TRIM$(sLine)
					'If iMatchLft(sst.c_str(),"END_MESSAGE_MAP") Then
					  'sLeft1 = ";"
					  'sLine = RTRIM$(sLine,sLeft1)
					'End If
				'End If
				'If Instr(sLine,"IMPLEMENT_DYNAMIC") Then
					'sst = TRIM$(sLine)
					'If iMatchLft(sst.c_str(),"IMPLEMENT_DYNAMIC") Then
					  'sLeft1 = ";"
					  'sLine = RTRIM$(sLine,sLeft1)
					'End If
				'End If


'jcfuller added 06/21/2013
'remove g_argv and g_argc from a gui app
'updated 6/24/2013 to remove if NoMain is true

				If sLine = "static PCHAR   *g_argv;" Then
					If Use_Wingui OR LEN(Project$) OR WxCon OR WxGui OR Use_MFC  OR Use_TCLib Then

						Iterate
					End If
					'If NoMain Then
					'	Iterate
					'End If
				End If

				If sLine = "static int     g_argc;" Then
					If Use_Wingui OR LEN(Project$) OR WxCon OR WxGui OR Use_MFC OR Use_TCLib Then
						Iterate
					End If
					'If NoMain Then
					'	Iterate
					'End If
				End If
				If Instr(sLine,"//NEED_CONST") Then
					NeedConst = 1
					Iterate
				End if

				If NeedConst Then
					sLine = Replace(sLine,";"," const ;")
					NeedConst = 0
				End If

				If UseCpp Then
					If InStr(sLine,"// Tiny C support for LinkRes2Exe") Then
						getline(f1,sLine)
						getline(f1,sLine)
						getline(f1,sLine)
						getline(f1,sLine)
						Iterate
					End If
				End If
'------------------------------------------------------------------------------
'added 07/15/2015 for the purpose of using single quote chars 'c'
' in basic source use extended E literals E"\'{'\" for '{' to appear in translation
' 03/04/2016 it appears E"'{'" works just as well
				j = Instr(sLine,DQSQ)
				While j
					If Mid$(sLine.c_str(),j+3,2)=SQDQ Then
						s1$ = Mid$(sLine.c_str(),j,5)
						s2$ = Remove$(s1$, DQ$)
						sLine = Replace$(sLine,s1$,s2$)
					End if
					start = j+5
					j = Instr(sLine.c_str(),DQSQ,start)
				Wend

'related to above where we need literal translation
				If Instr(sLine,"SQNLSQ") Then
					sLine = Replace$(sLine,"SQNLSQ",SQNLSQ)
				End If


'jcfuler added 6/10/2013
'fixed it in AssembleParts() Sub
'================== strip out dead callback code ======================
' I thought this was fixed but ???
				If Instr(sLine,"DefWindowProc") Then
					If Instr(sLast,"return") OR _
						Instr(sLast,"CallWindowProc")  OR _
						INSTR(sLast,"DefWindowProc")   OR _
						INSTR(sLast,"DefMDIChildProc") OR _
						INSTR(sLast,"DefFrameProc") THEN
						sLast = ""
						ITERATE
					End If
				End If
'jcfuller 10/10/2013 remove extra return
'this breaks code where we have an if before sLast
				'If Instr(sLine,"return") Then
				  'sLeft1 = LTRIM$(sLine)
				  'sLeft2 = LTRIM$(sLast)
				  'If (LEFT$(sLeft1.c_str(),6) = "return") AND (LEFT$(sLeft2.c_str(),6) = "return") THEN
				    'sLast = ""
				    'ITERATE
				  'END IF
				'End If

AddTheLine:
				f2 << sLine << endl
				sLast = sLine
			Wend
			'getline(f1,sLine)
			'cout << "***************" << endl
			'cout << sLine << endl
			'cout << "***************" << endl
'jcfuller added 06/16/2014
			If WxGui Then
				f2 << "IMPLEMENT_APP(" << g_swx$ << ")" << endl
			End If
			f2.close()

		End If
		f1.close()
		IF EXIST(sftmp$) THEN
			KILL f$
			RENAME sftmp$,f$
		END IF
	End If
    Function = 0


End Function

'===================================================================================
' Internal helper functions
CONST GetBracketPairPosF(S,E) = GetBracketPair(S,E,1)
CONST GetBracketPairPosB(S,E) = GetBracketPair(S,E,-1)
FUNCTION GetBracketPair(iStart AS INT, iEnd AS INT, iDir AS INT)
  RAW i
  FOR i = iStart TO iEnd STEP iDir
    IF iMatchWrd(Stk$[i],"[") AND iMatchWrd(Stk$[i+1],"]") THEN
      FUNCTION = i
    END IF
  NEXT
  FUNCTION = 0
END FUNCTION ' GetBracketPairPos



'$COMMENT
'CONST GetCommaPosF(S,E) = GetCommaPos(S,E,1)
'CONST GetCommaPosB(S,E) = GetCommaPos(S,E,-1)
'FUNCTION GetCommaPos(iStart AS INT, iEnd AS INT, iDir AS INT)
  'RAW i
  'FOR i = iStart TO iEnd STEP iDir
    'IF iMatchWrd(Stk$[i],",") THEN
      'FUNCTION = i
    'END IF
  'NEXT
  'FUNCTION = 0
'END FUNCTION ' GetCommaPos
'$COMMENT


CONST GetAsPosF(S,E) = GetAsPos(S,E,1)
CONST GetAsPosB(S,E) = GetAsPos(S,E,-1)
FUNCTION GetAsPos(iStart AS INT, iEnd AS INT, iDir AS INT)
  RAW i
  FOR i = iStart TO iEnd STEP iDir
    IF iMatchWrd(Stk$[i],"as") THEN
      FUNCTION = i
    END IF
  NEXT
  FUNCTION = 0
END FUNCTION ' GetAsPos



'SUB BuildDelimStr(iStart, iEnd, szBuild$)
  'RAW pszStk AS PCHAR
  'szBuild$ = ""
  'FOR INT i = iStart TO iEnd
    'pszStk = (PCHAR)&Stk$[i]
    'IF *pszStk THEN
      'IF pszStk$ = "!" THEN
        'CONCAT (szBuild$, " ! ")
      'ELSE
        'IF *pszStk$ = ASC("_") THEN
          'CONCAT (szBuild$, " ")
          'CONCAT (szBuild$, pszStk$)
        'ELSE
          'CONCAT (szBuild$, pszStk$)
          'IF ispunct(*pszStk) THEN ITERATE
        'END IF
        'IF i < iEnd AND NOT ispunct(*Stk$[i+1]) THEN CONCAT (szBuild$, SPC$)
      'END IF
    'END IF
  'NEXT
'END SUB ' BuildDelimStr

'Wayne's fix 06/29/2013
SUB BuildDelimStr(iStart, iEnd, szBuild$)
  RAW pszStk AS PCHAR
  szBuild$ = ""
  FOR INT i = iStart TO iEnd
    pszStk = (PCHAR)&Stk$[i]
    IF *pszStk THEN
      IF pszStk$ = "!" THEN
        CONCAT (szBuild$, " ! ")
      ELSE
        IF *pszStk$ = ASC("_") THEN
          CONCAT (szBuild$, " ")
          CONCAT (szBuild$, pszStk$)
        ELSE
          CONCAT (szBuild$, pszStk$)
          IF ispunct(*pszStk) AND NOT *(pszStk+1) THEN ITERATE
        END IF
        IF i < iEnd AND (NOT ispunct(*Stk$[i+1]) OR Stk[i+1][1]) THEN CONCAT (szBuild$, SPC$)
      END IF
    END IF
  NEXT
END SUB ' BuildDelimStr

SUB BuildStr(iStart, iEnd, szBuild$)
  szBuild$ = ""
  FOR INT i = iStart TO iEnd
    CONCAT (szBuild$, Stk$[i])
  NEXT
END SUB ' BuildStr



SUB BuildCleanStr(iStart, iEnd, szBuild$)
  CALL BuildDelimStr(iStart, iEnd, szBuild$)
  szBuild$ = Clean$(szBuild$)
END SUB ' BuildCleanStr



SUB WriteCleanTokens(iStart, iEnd)
  RAW szTmp$
  CALL BuildCleanStr(iStart, iEnd, szTmp$)
  FPRINT Outfile,szTmp$
END SUB ' WriteCleanTokens



'FUNCTION HasThisToken(sToken$)
FUNCTION HasThisToken(sToken As const char Ptr)
  RAW ThisToken = 0
  XFOR INT j = 1 WHILE j <= Ndx AND IAmNot(ThisToken) BY j++
    ThisToken = iMatchWrd(Stk$[j], sToken$)
  XNEXT
  FUNCTION = ThisToken
END FUNCTION ' HasThisToken
' End Internal helper functions
'==================================================================================
' Expand Macros
'
FUNCTION MacroCheck()
  RAW szMacroCheck$
  RAW IsMacro = FALSE
  FastLexer(Src$," (","")
  szMacroCheck$ = LCASE$(Stk$[1])
  SELECT CASE szMacroCheck$
'conflict with windowsx.h HANDLE_MSG
    CASE "bcx_handle_msg","bc9_handle_msg"',"handle_msg"     ' handle_msg handler
      CALL CheckParQuotes()
      CALL ProcessMsgCracker()
      Src$ = ""
      IsMacro = TRUE

    CASE "handle_cmd","bcx_handle_cmd","bc9_handle_cmd"
      CALL CheckParQuotes()
      CALL ProcessCmdHandler()
      Src$ = ""
      IsMacro = TRUE

    CASE "bcx_resource","bc9_resource"
      Use_GenResFile = TRUE
      FPRINT FP_RES,MID$(Src$,14)
      Src$ = ""
      IsMacro = TRUE

    CASE "msghandler", "cmdhandler"
      CALL CheckParQuotes()
      CALL ProcessMsgHandler()
      Src$ = ""
      IsMacro = TRUE

    CASE "end"
      IF iMatchWrd(Stk$[2],"handler") THEN
        CALL CheckParQuotes()
        CALL ProcessMsgHandlerEnd()
        Src$ = ""
        IsMacro = TRUE
      END IF

  END SELECT
  FUNCTION = IsMacro
END FUNCTION



SUB ActivityFlags()
  IF TrcFlag AND InFunc > 0 THEN
    IF NOT iMatchLft(Src$,"$trace") THEN
      IF NOT iMatchLft(Src$,"end ") AND INSTR(Src$,"function",0,1) = 0 THEN
        FPRINT Outfile,"// [", TRIM$(Modules$[ModuleNdx]), " - ", TRIM$(STR$(ModuleLineNos[ModuleNdx])), "] ", Src$
        Z$ = TRIM$(Modules$[ModuleNdx])
        Z$ = REPLACE$(Z$,"\\","\\\\")
        Z$ = SPC$ + Z$ + " - " + STR$(ModuleLineNos[ModuleNdx]) + " \\n"
        Z$ = "printf(" + ENC$(Z$) + ");"
        FPRINT Outfile,Z$
      END IF
    END IF
  END IF

  '******************************

  IF SrcFlag THEN
    IF NOT iMatchLft(Src$,"$sourc") AND *Src <> 33 THEN  '33 = !
      FPRINT Outfile,"// [", TRIM$(Modules$[ModuleNdx]), " - ", TRIM$(STR$(ModuleLineNos[ModuleNdx])), "] ", Src$
    END IF
  END IF

  '******************************

  IF ShowStatus THEN
    LOCATE 2,1,0,12
    PRINT "Processing Module: ", TRIM$(Modules$[ModuleNdx]), " - Line:", ModuleLineNos[ModuleNdx]
  END IF
END SUB



SUB LoopErrorMsg()
  RAW sError$
  IF LoopTypeCnt > 1 THEN
    sError$ = "Multiple loop errors innermost starting at"
  ELSE
    sError$ = "Loop error starting at"
  END IF

  sError$ = sError$ + STR$(LoopType[LoopTypeCnt].iLoopLine) + " "

  SELECT CASE LoopType[LoopTypeCnt].iLoopType

    CASE lt_DOLOOP
      sError$ = sError$ + "DO without LOOP"

    CASE lt_DOWHILELOOP, lt_DOUNTILLOOP
      sError$ = sError$ + "DO CONDITION without LOOP"

    CASE lt_WHILEWEND
      sError$ = sError$ + "WHILE without WEND"

    CASE lt_FORNEXT
      sError$ = sError$ + "FOR without NEXT"

    CASE lt_SELECT
      sError$ = sError$ + "SELECT without END SELECT"

    CASE lt_FORXNEXT
      sError$ = sError$ + "XFOR without XNEXT"
  END SELECT
  Abort(sError$)
END SUB



'==============================================================================
' Used to get loop type for Error Message
FUNCTION LoopTypeName$(iLoopType AS INT)
  DIM sLoopType$
  sLoopType$ = ""
  SELECT CASE iLoopType

    CASE lt_DOLOOP
      sLoopType$ = "DO"

    CASE   lt_DOWHILELOOP, lt_DOUNTILLOOP
      sLoopType$ = "DO CONDITION"

    CASE lt_WHILEWEND
      sLoopType$ = "WHILE"

    CASE lt_FORNEXT
      sLoopType$ = "FOR"

    CASE lt_SELECT
      sLoopType$ = "SELECT"

    CASE lt_FORXNEXT
      sLoopType$ = "XFOR"
  END SELECT
  FUNCTION = sLoopType$
END FUNCTION



ENUM
  eDoNothing
  eStartSysVariables
  eDoSysVariables
  eStartUserVariables
  eDoUserVariables
  eStartMacros
  eDoMacros
  eStartStdProtos
  eDoStdProtos
  eStartUserProtos
  eDoUserProtos
  eStartUserConst
  eDoUserConst
  eStartSysConst
  eDoSysConst
  eDoMainProgram
  eDoUserProcs
  eStartUserTypes
  eDoUserTypes
END ENUM



SUB Project_Support()
  ' **************************************************************
  ' Added for $Project Support
  ' This reads the .c file created by BCX and creates the .h files
  ' from the information at the top of the .c file in sections such
  ' as '  User Defined Structs And Unions and User Prototyes, etc.
  ' I have instigated the BCX_STR_XXX_XXX MACROS to prevent changes
  ' being made unawares that will affect this code.
  ' **************************************************************
  RAW nPos1
  RAW nPos2
  RAW sExt$
  RAW cHFn$
  RAW iWork
IF _ZTRACE_ Then
	'zTrace(ANSITOWIDE((char*)"Project_Support"))
		ZPRINT("Project_Support")
END IF

  Z$ = ""
  IF EXIST( FileOut$ ) THEN
    CLOSE
    IF CmdLineFileOut$ = "" THEN
      Project_Path$ = CURDIR$
    ELSE
      Project_Path$ = MID$( CmdLineFileOut$, 1, INSTRREV(CmdLineFileOut$, "\", 0 ) - 1)
    END IF
    IF INCHR( COMMAND$(1), "\") THEN ' has a path
      cHFn$ = MID$( COMMAND$(1), INSTRREV( COMMAND$(1), "\", 0 ) + 1 )
    ELSE
      cHFn$ = COMMAND$(1)
    END IF
    IF INCHR( cHFn$, "." ) THEN ' has an extension
      cHFn$ = MID$( cHFn$, 1, INSTRREV( cHFn$, ".", 0 ) -1 )
    END IF
    HFile$ = Project_Path$ + "\" + cHFn$ + ".bh"

    OPEN FileOut$ FOR INPUT AS PJ1
    OPEN HFile$ FOR OUTPUT AS PJ2
    FPRINT PJ2,"#ifndef __BCX_HEADER_";UCASE$(cHFn$) + "__"
    iWork = eDoNothing

    WHILE NOT EOF(PJ1)
      LINE INPUT PJ1,Z$
      IF LEFT$( Z$, 4) = "// *" THEN
        LINE INPUT PJ1,Z$
        ITERATE
      END IF
      IF Z$ = "" THEN ITERATE
      IF LEFT$(TRIM$(Z$),2) = "//" THEN ITERATE
      IF INSTR(Z$, $BCX_STR_SYS_VARS)   THEN
        iWork = eStartSysVariables
      ELSEIF INSTR(Z$, $BCX_STR_USR_VARS)   THEN
        iWork = eStartUserVariables
      ELSEIF INSTR(Z$, $BCX_STR_STD_MACROS) THEN
        iWork = eStartMacros
      ELSEIF INSTR(Z$, $BCX_STR_STD_PROTOS) THEN
        iWork = eStartStdProtos
      ELSEIF INSTR(Z$, $BCX_STR_USR_PROTOS) THEN
        iWork = eStartUserProtos
      ELSEIF INSTR(Z$, $BCX_STR_USR_CONST)  THEN
        iWork = eStartUserConst
      ELSEIF INSTR(Z$, $BCX_STR_SYS_CONST)  THEN
        iWork = eStartSysConst
      ELSEIF INSTR(Z$, $BCX_STR_MAIN_PROG)  THEN
        iWork = eDoMainProgram
      ELSEIF INSTR(Z$, $BCX_STR_USR_PROCS)  THEN
        iWork = eDoUserProcs
      ELSEIF INSTR(Z$, $BCX_STR_USR_TYPES)  THEN
        iWork = eStartUserTypes
      ENDIF
      ' no CASE needed for these eDoMainProgram, eDoUserProcs so iterate
      IF iWork = eDoMainProgram OR iWork = eDoUserProcs THEN ITERATE
      SELECT CASE iWork

        CASE eStartSysVariables
          LINE INPUT PJ1,Z$ ' get rid of '// ***************
          FPRINT PJ2,"// *****************"
          FPRINT PJ2,"// ";$BCX_STR_SYS_VARS
          FPRINT PJ2,"// *****************"
          FPRINT PJ2,""
          iWork = eDoSysVariables

        CASE eDoSysVariables
          IF NOT LEFT$(Z$, 6) = "static" THEN
            IF INCHR(Z$, "=" ) THEN
              ' Get rid of = TO ;
              ' char    CRLF[3]={13,10,0}; // Carr Rtn & Line Feed
              nPos1 = INCHR(Z$, "=" )
              nPos2 = INCHR(Z$, ";" )
              sExt$ = MID$( Z$, nPos1, nPos2 - nPos1 )
              REPLACE sExt$ WITH "" IN Z$
            END IF
            FPRINT PJ2,"extern ";Z$
          END IF

        CASE eStartUserVariables
          LINE INPUT PJ1,Z$ ' get rid of '// ***************
          FPRINT PJ2,"// *****************"
          FPRINT PJ2,"// ";$BCX_STR_USR_VARS
          FPRINT PJ2,"// *****************"
          FPRINT PJ2,""
          iWork = eDoUserVariables

        CASE eDoUserVariables
          IF *TRIM$(Z$) = ASC("#") THEN
            FPRINT PJ2,Z$
          ELSE
            IF INCHR(Z$, "=" ) THEN
              ' Get rid of = TO ;
              nPos1 = INCHR(Z$, "=" )
              nPos2 = INCHR(Z$, ";" )
              sExt$ = MID$( Z$, nPos1, nPos2 - nPos1 )
              REPLACE sExt$ WITH "" IN Z$
            END IF
            IF LEFT$(Z$, 6) <> "extern" THEN
              FPRINT PJ2,"extern ";Z$
            ELSE
              FPRINT PJ2,Z$
            END IF
          END IF

        CASE eStartMacros
          LINE INPUT PJ1,Z$ ' get rid of '// ***************
          FPRINT PJ2,"// *****************"
          FPRINT PJ2,"// ";$BCX_STR_STD_MACROS
          FPRINT PJ2,"// *****************"
          FPRINT PJ2,""
          iWork = eDoMacros

        CASE eStartStdProtos
          LINE INPUT PJ1,Z$ ' get rid of '// ***************
          FPRINT PJ2,"// *****************"
          FPRINT PJ2,"// ";$BCX_STR_STD_PROTOS
          FPRINT PJ2,"// *****************"
          FPRINT PJ2,""
          iWork = eDoStdProtos

        CASE eDoStdProtos
          RAW p AS CHAR PTR
          ' added to get rid of assignment to optional parameters
          ' PellesC don't like them

          WHILE INCHR(Z$, "=" )
            ' remove = up to comma, space, right paren, semi-colon
            ' char*   mid (char*, int, int=-1);
            nPos1 = INCHR(Z$, "=" )
            p = Z$
            p = p + nPos1 - 1

            DO
              IF *p <> ASC(",") AND *p <> ASC(" ") AND *p <> ASC(")") THEN
                *p = 1
              ELSE
                EXIT DO
              END IF
              p++
            LOOP

            REPLACE CHR$(1) WITH ""  IN Z$
          WEND

          IF LEFT$(Z$, 6) <> "extern" THEN
            FPRINT PJ2,"extern ";Z$
          ELSE
            FPRINT PJ2,Z$
          END IF

        CASE eStartUserProtos

          LINE INPUT PJ1,Z$ ' get rid of '// ***************
          FPRINT PJ2,"// *****************"
          FPRINT PJ2,"// ";$BCX_STR_USR_PROTOS
          FPRINT PJ2,"// *****************"
          FPRINT PJ2,""
          iWork = eDoUserProtos

        CASE eDoUserProtos
          IF INSTR(Z$, " main") OR INSTR(Z$, " WinMain") THEN EXIT SELECT
          IF *Z$ = ASC(" ") THEN EXIT SELECT
          FPRINT PJ2,"extern ";Z$

        CASE eStartUserConst
          LINE INPUT PJ1,Z$ ' get rid of '// ***************
          FPRINT PJ2,"// *****************"
          FPRINT PJ2,"// ";$BCX_STR_USR_CONST
          FPRINT PJ2,"// *****************"
          FPRINT PJ2,""
          iWork = eDoUserConst

        CASE eStartSysConst
          LINE INPUT PJ1,Z$ ' get rid of '// ***************
          FPRINT PJ2,"// *****************"
          FPRINT PJ2,"// ";$BCX_STR_SYS_CONST
          FPRINT PJ2,"// *****************"
          FPRINT PJ2,""
          iWork = eDoSysConst

        CASE eStartUserTypes
          LINE INPUT PJ1,Z$ ' get rid of '// ***************
          FPRINT PJ2,"// *****************"
          FPRINT PJ2,"// ";$BCX_STR_USR_TYPES
          FPRINT PJ2,"// *****************"
          FPRINT PJ2,""
          iWork = eDoUserTypes

        CASE eDoUserTypes, eDoUserConst, eDoSysConst, eDoMacros
          FPRINT PJ2,Z$

        ' no CASE needed for these eDoMainProgram, eDoUserProcs
      END SELECT
    WEND

    FPRINT PJ2,"#endif // __BCX_HEADER_";UCASE$(cHFn$);"__"
    CLOSE PJ1
    CLOSE PJ2
  END IF

  ' **************************************************************
  ' End of $Project Support
  ' **************************************************************
END SUB ' Project_Support


ENUM
  eRT_EXIT
  eRT_BCXLIB_H
  eRT_EAT             ' From User_Global_Initialized_Arrays
  eRT_BCXRT_H         ' From StdProtos
  eRT_BCXBOTH_H       ' From System_Defined_Constants
END ENUM



' **************************************************************
' BCX Runtime Library Support
' **************************************************************
' NOTE: LCC-WIN32's MAKE.EXE REQUIRES TABS, 8 SPACES WON'T DO!!!
SUB Library_Support()
$COMMENT
  CONST MAX_C_FILES = 500

  LOCAL thisDir$
  LOCAL BCXDir$
  LOCAL SrcDir$
  LOCAL ObjDir$
  LOCAL LibDir$
  LOCAL DllDir$
  LOCAL Exprt$
  LOCAL IncLibFile$
  LOCAL IncDir$
  LOCAL IncFile$
  LOCAL RTFile$
  LOCAL RSPFile$
  LOCAL BuildBat$
  LOCAL nPos1
  LOCAL nPos2
  LOCAL sExt$
  LOCAL SrcF$
  LOCAL SrcExt$
  LOCAL TmpF$
  LOCAL TmpExt$
  LOCAL BraceCnt
  LOCAL typePos
  LOCAL pstr$
  LOCAL fstr$
  LOCAL DYNAMIC C_Files$[MAX_C_FILES]
  LOCAL cIdx
  LOCAL rspNdx
  LOCAL Z1$
  LOCAL i_
  DIM RAW NewSrc$ * 1024 * 25
  DIM RAW OldSrc$ * 1024 * 25
  ' ************************************************************

  IF UseCpp THEN
    SrcExt$ = ".cpp"
    RTFile$ = "BCXRT.CPP"
  ELSE
    SrcExt$ = ".c"
    RTFile$ = "BCXRT.C"
  END IF
  thisDir$ = CURDIR$
  BCXDir$  = LEFT$( BCXPATH$, LEN( BCXPATH$ ) - 4 )
  SrcDir$ = BCXDir$ + "rtlib\\source\\"
  ObjDir$ = BCXDir$ + "rtlib\\obj\\"
  LibDir$ = BCXDir$ + "rtlib\\lib\\"
  DllDir$ = BCXDir$ + "rtlib\\dll\\"
  IncDir$ = BCXDir$ + "rtlib\\include\\"
  RSPFile$ = BCXDir$ + "rtlib\\bcxrt.rsp"
  BuildBat$ = BCXDir$ + "rtlib\\BuildRTL.bat"
  IncLibFile$ = IncDir$ + "BCXLib.h"
  IncFile$ = IncDir$ + "bcxRT.h"

  ' Make Sure Directories exist
  ' and if not make them
  IF EXIST( "BCXRT.BAS" ) THEN KILL "BCXRT.BAS"
  RAW sRTlib$
  sRTlib$ = BCXDir$ + "rtlib"
  IF NOT EXIST(sRTlib$) THEN MKDIR sRTlib$

  CALL CreateRunTimeDirectory(SrcDir$)
  CALL CreateRunTimeDirectory(ObjDir$)
  CALL CreateRunTimeDirectory(IncDir$)
  CALL CreateRunTimeDirectory(LibDir$)
  CALL CreateRunTimeDirectory(DllDir$)
  sprintf(Z,"%sLC", ObjDir) : CALL CreateRunTimeDirectory(Z$)
  sprintf(Z,"%sPC", ObjDir) : CALL CreateRunTimeDirectory(Z$)
  sprintf(Z,"%sBC", ObjDir) : CALL CreateRunTimeDirectory(Z$)
  sprintf(Z,"%sMC", ObjDir) : CALL CreateRunTimeDirectory(Z$)
  sprintf(Z,"%sWC", ObjDir) : CALL CreateRunTimeDirectory(Z$)
  sprintf(Z,"%sGC", ObjDir) : CALL CreateRunTimeDirectory(Z$)
  sprintf(Z,"%sDC", ObjDir) : CALL CreateRunTimeDirectory(Z$)

  sprintf(Z,"%sLC", LibDir) : CALL CreateRunTimeDirectory(Z$)
  sprintf(Z,"%sPC", LibDir) : CALL CreateRunTimeDirectory(Z$)
  sprintf(Z,"%sBC", LibDir) : CALL CreateRunTimeDirectory(Z$)
  sprintf(Z,"%sMC", LibDir) : CALL CreateRunTimeDirectory(Z$)
  sprintf(Z,"%sWC", LibDir) : CALL CreateRunTimeDirectory(Z$)
  sprintf(Z,"%sGC", LibDir) : CALL CreateRunTimeDirectory(Z$)
  sprintf(Z,"%sDC", LibDir) : CALL CreateRunTimeDirectory(Z$)

  IF EXIST( RTFile$ ) THEN
    CLOSE
    IF Use_Dll THEN
      SrcF$ = SrcDir$ + "\\BCXRTDLL" + SrcExt$
      OPEN SrcF$ FOR OUTPUT AS LB5
      FPRINT LB5,"#include <bcxLib.h>\n\n"
'jcfuller 2/4/2013 DllMain is not exported
      'FPRINT LB5,"__declspec(dllexport) BOOL WINAPI DllMain (HINSTANCE hInst, DWORD Reason, LPVOID Reserved)"
      FPRINT LB5,"BOOL WINAPI DllMain (HINSTANCE hInst, DWORD Reason, LPVOID Reserved)"
      FPRINT LB5,"{"
      FPRINT LB5," switch (Reason)"
      FPRINT LB5," {"
      FPRINT LB5,"    case DLL_PROCESS_ATTACH:"
      FPRINT LB5,"      BCX_hInstance = hInst;"
      FPRINT LB5,"      break;"
      FPRINT LB5,"    case DLL_PROCESS_DETACH:"
      FPRINT LB5,"      break;"
      FPRINT LB5,"    case DLL_THREAD_ATTACH:"
      FPRINT LB5,"      break;"
      FPRINT LB5,"    case DLL_THREAD_DETACH:"
      FPRINT LB5,"      break;"
      FPRINT LB5," }"
      FPRINT LB5," return TRUE;"
      FPRINT LB5,"}\n\n"
    END IF
    OPEN IncFile$ FOR OUTPUT AS LB0
    OPEN RTFile$ FOR INPUT AS LB1
    OPEN IncLibFile$ FOR OUTPUT AS LB2
    Z$ = ""
    RAW iAction = eRT_BCXLIB_H
    WHILE iAction AND NOT EOF(LB1)
      IF INSTR( Z$, "// BCXRTHEADER: INCLUDE FILES" ) THEN
        iAction = eRT_BCXLIB_H      ' From EmitProlog
      ELSEIF INSTR( Z$, "// BCXRTHEADER: COMPILER DEFINES" ) THEN
        iAction = eRT_BCXLIB_H      ' From EmitCompilerDefines
      ELSEIF INSTR( Z$, "// BCXRTHEADER: VBSCRIPT SUPPORT STRUCTURES") THEN
          iAction = eRT_BCXLIB_H    ' From Emit_VBSCRIPT_Support
      ELSEIF INSTR( Z$, "// BCXRTHEADER: LINKER INSTRUCTIONS") THEN
          iAction = eRT_BCXLIB_H    ' From EmitLibs
      ELSEIF INSTR( Z$, "// BCXRTHEADER: USER DEFINED CONSTANTS") THEN
          iAction = eRT_BCXLIB_H    ' From User_Defined_Constants
      ELSEIF INSTR( Z$, "// BCXRTHEADER: SYSTEM DEFINED CONSTANTS") THEN
          iAction = eRT_BCXBOTH_H   ' From System_Defined_Constants
      ELSEIF INSTR( Z$, "// BCXRTHEADER: STANDARD PROTOTYPES" ) THEN
        iAction = eRT_BCXRT_H       ' From StdProtos
      ELSEIF INSTR( Z$, "// BCXRTHEADER: SYSTEM VARIABLES") THEN
        iAction = eRT_BCXLIB_H      ' From SYSTEM_VARIABLES
      ELSEIF INSTR( Z$, "// BCXRTHEADER: COM SUPPORT DATA") THEN
        iAction = eRT_BCXLIB_H      ' From EmitCOMSupportTypes
      ELSEIF INSTR( Z$, "// BCXRTHEADER: USER GLOBAL VARIABLES") THEN
        iAction = eRT_BCXLIB_H      ' From User_Global_Variables
      ELSEIF INSTR( Z$, "// BCXRTHEADER: STANDARD MACROS") THEN
        iAction = eRT_BCXLIB_H      ' From AddMacros
      ELSEIF INSTR( Z$, "// BCXRTHEADER: USER GLOBAL INITIALIZED ARRAYS") THEN
        iAction = eRT_EAT           ' From User_Global_Initialized_Arrays
      ELSEIF INSTR( Z$, "ENDBCXRTLIBHEADER" ) THEN
        iAction = eRT_EXIT
      ENDIF

      SELECT CASE iAction
        CASE eRT_BCXBOTH_H
          STATIC iWasHere = 0
          IF FirstTime(iWasHere) THEN
            iWasHere++
            FPRINT LB0, Z$
          END IF
          Z$ = Getline$()
          IF INSTR( Z$, "// END BCXRTHEADER" ) THEN FPRINT LB0, Z$ : FPRINT LB2, Z$ : EXIT SELECT
          Z1$ = Z$
          Z$ = TRIM$(Z$)
          IF LEFT$(Z$, 6)  = "static" THEN
            Z$ = TRIM$(MID$(Z$,7))
          END IF
          IF Z$ = "" OR LEFT$(Z$, 2)  = "//" OR _
            Z[0]  = ASC("{") OR Z[0]  = ASC("}") OR _
            Z[0]  = ASC("#") THEN
            FPRINT LB2,Z1$
            FPRINT LB0, Z$
          END IF

        CASE eRT_BCXLIB_H
          Z$ = Getline$()
          IF INSTR( Z$, "// END BCXRTHEADER" ) THEN FPRINT LB2, Z$ : EXIT SELECT
          Z1$ = Z$
          Z$ = TRIM$(Z$)
          IF LEFT$(Z$, 6)  = "static" THEN
            REPLACE "static " WITH "" IN Z$
          END IF
          ' check for structs
          IF LEFT$(Z$, 7) = "typedef" THEN
            IF INSTR(Z$, "struct") THEN
              BraceCnt = BraceCount( Z$ )
              FPRINT LB2, Z$
              WHILE BraceCnt = 0
                Z$ = Getline$()
                BraceCnt = BraceCnt + BraceCount( Z$ )
                FPRINT LB2, Z$
              WEND
              WHILE BraceCnt <> 0
                Z$ = Getline$()
                BraceCnt = BraceCnt + BraceCount( Z$ )
                FPRINT LB2, Z$
              WEND
            END IF
            EXIT SELECT
          END IF
          '----
          IF LEFT$(Z$,18) = "DECLARE_INTERFACE_" THEN
            FPRINT LB2, Z1$
            WHILE TRUE
              Z$ = Getline$()
              IF INSTR( Z$, "// END BCXRTHEADER" ) THEN FPRINT LB2, Z$ : EXIT WHILE
              FPRINT LB2,Z$
              IF INCHR(Z$, ";") AND INCHR(Z$, "}") THEN EXIT WHILE
            WEND
            EXIT SELECT
          END IF
          IF Z$ = "" OR LEFT$(Z$, 2)  = "//" OR Z[0]  = ASC(" ") OR _
            Z[0]  = ASC("{") OR Z[0]  = ASC("}") OR _
            LEFT$(Z$, 9)  = "STDMETHOD" OR LEFT$(Z$, 7)  = "DECLARE" OR _
            LEFT$(Z$, 9)  = "ITypeInfo" OR Z[0]  = ASC("#") THEN
            FPRINT LB2,Z1$
            EXIT SELECT
          END IF
          IF iMatchLft(Z$,"const") THEN
            REPLACE "=" WITH ";" IN Z1$
            FPRINT LB2,"extern ";Z1$
            WHILE NOT INCHR(Z$, ";")
              Z$ = Getline$()
              'FPRINT LB2,Z$
            WEND
            EXIT SELECT
          END IF
          IF iMatchLft(Z$,"enum") THEN
            FPRINT LB2,Z1$
            WHILE NOT INCHR(Z$, ";")
              Z$ = Getline$()
              IF INSTR( Z$, "// END BCXRTHEADER" ) THEN FPRINT LB2, Z$ : EXIT WHILE
              FPRINT LB2,Z$
            WEND
            EXIT SELECT
          END IF

          IF INCHR(Z$, "=" ) AND INCHR(Z$, ";" ) THEN
            ' Get rid of = TO ;
            nPos1 = INCHR(Z$, "=" )
            nPos2 = INCHR(Z$, ";" )
            sExt$ = MID$( Z$, nPos1, nPos2 - nPos1 )
            REPLACE sExt$ WITH "" IN Z$
            IF NOT Use_Dll THEN
              Z$ = "extern " + Z$
            END IF
            FPRINT LB2,Z$
          ELSEIF INCHR( Z$, "=") AND NOT INCHR(Z$, ";" ) THEN
            REPLACE "=" WITH ";" IN Z$
            IF NOT Use_Dll THEN
              FPRINT LB2,"extern ";Z$
            END IF
            Z$ = ""
            WHILE NOT INCHR(Z$, ";" )
              Z$ = Getline$()
              IF INSTR( Z$, "// END BCXRTHEADER" ) THEN FPRINT LB2, Z$ : EXIT WHILE
            WEND
          ELSE
            IF NOT Use_Dll THEN
              Z$ = "extern " + Z$
            END IF
            FPRINT LB2,Z$
          END IF

        CASE eRT_EAT
          'FPRINT LB2,Z$
          Z$ = Getline$()

        CASE eRT_BCXRT_H
          STATIC iWasHere = 0
          IF FirstTime(iWasHere) THEN
            iWasHere++
            ' Kludge solution to Ljubisas New Com Stuff
            CALL CommonCOMOutput(LB0)
            FPRINT LB0,""
            FPRINT LB0,"// *************************************************"
            FPRINT LB0,"// Standard Prototypes"
            FPRINT LB0,"// *************************************************"
            FPRINT LB0,""
          END IF
          FPRINT LB2,Z$
BYPASS:
          Z$ = Getline$()
          IF Z$ = "" THEN ITERATE
          IF LEFT$(Z$, 2)  = "//" THEN ITERATE
          IF Z[0] = ASC(" ") OR Z[0] = ASC("{") THEN ITERATE
          IF Z[0] = ASC("}") OR Z[0] = ASC("#") THEN ITERATE
          IF LEFT$(Z$, 6)  = "STDAPI" THEN ITERATE
          IF LEFT$(Z$, 7)  = "#define" THEN ITERATE
          IF LEFT$(Z$, 6)  = "static" THEN
            REPLACE "static " WITH "" IN Z$
          END IF

          IF LEFT$(Z$, 7) = "typedef" THEN
            IF INSTR(Z$, "struct") THEN
              BraceCnt = BraceCount( Z$ )
              FPRINT LB2,Z$
              WHILE BraceCnt = 0
                Z$ = Getline$()
                BraceCnt = BraceCnt + BraceCount( Z$ )
                FPRINT LB2,Z$
              WEND
              WHILE BraceCnt <> 0
                Z$ = Getline$()
                BraceCnt = BraceCnt + BraceCount( Z$ )
                FPRINT LB2,Z$
              WEND
              GOTO BYPASS
            END IF
            ITERATE
          END IF

          IF Use_Dll THEN
            typePos = INCHR( Z$, "(")
            typePos = INSTRREV( Z$,SPC$, typePos-2)
            pstr$   = LEFT$(Z$,typePos-1)
            fstr$   = MID$(Z$,typePos)
            FPRINT LB0,Z$ '"C_EXPORT ";Z$
            FPRINT LB2,"C_EXPORT ";Z$
            GOTO BYPASS
          ELSE
            Z$ = "extern " + Z$
            FPRINT LB0,Z$
          END IF
      END SELECT
    WEND

    FPRINT LB2,"//     End of bcxLIB.h Runtime Library Include File"
    FPRINT LB2,"// *************************************************"
    CLOSE LB2

    ' Create the .c source files

    cIdx = 0
    Z$ = Getline$()
    Z$ = Getline$()
    TmpExt$ = ".tmp"
    IF Use_Dll THEN

      WHILE NOT EOF(LB1)
        Z$ = Getline$()
        IF NOT INSTR(Z$, "BCXRTLIB:") THEN ITERATE
        Z$ = Getline$() ' get next line following "BCXRTLIB:"

        WHILE *TRIM$(Z$) = ASC("#")
          FPRINT LB5,Z$
          Z$ = Getline$()
        WEND

        WHILE NOT INCHR( Z$, "(")
          Z$ = Z$ + TRIM$(Getline$())
        WEND

        typePos = INCHR( Z$, "(")
        typePos = INSTRREV( Z$,SPC$, typePos-2)
        pstr$   = LEFT$(Z$,typePos-1)
        fstr$   = MID$(Z$,typePos)
        FPRINT LB5,"C_EXPORT ";Z$

        Z$ = Getline$()

        WHILE NOT INSTR( Z$, "ENDBCXRTLIB" )
          FPRINT LB5,Z$
          Z$ = Getline$()
        WEND

      WEND
      FPRINT LB5,""
      CLOSE LB5
    ELSE
      WHILE NOT EOF(LB1)

        Z$ = Getline$()

        IF NOT INSTR(Z$, "BCXRTLIB:") THEN ITERATE
        SrcF$ = TRIM$(MID$( Z$, INCHR(Z$, ":") + 1))

        Exprt$ = SrcF$
        IF cIdx >= MAX_C_FILES THEN MSGBOX "TOO MANY C FILES", "ERROR!" : END = 1
        C_Files$[cIdx++] = SrcF$
        TmpF$ = SrcDir$ + "\" + SrcF$ + TmpExt$
        SrcF$ = SrcDir$ + "\" + SrcF$ + SrcExt$

        ' First write to temp file for comparison if
        ' Source file exists
        IF EXIST ( SrcF$ ) THEN
          OPEN TmpF$ FOR OUTPUT AS LB2
        ELSE
          OPEN SrcF$ FOR OUTPUT AS LB2
        END IF

        FPRINT LB2,"#include <bcxLib.h>"
        FPRINT LB2,""

        Z$ = Getline$()

        WHILE NOT INSTR( Z$, "ENDBCXRTLIB" )
          FPRINT LB2,Z$
          Z$ = Getline$()
        WEND

        FPRINT LB2,""
        CLOSE LB2

        ' compare files and if new is same as what
        ' exist, don't replace it.  This will make
        ' it much quicker to rebuild the .lib if the .c/.cpp
        ' files are not changed from version to version
        ' All of this is in anticipation of using a make file
        ' or build.exe to build the runtime library only if
        ' needed.  Theoretically the same code will compile
        ' and link for all C and C++ compilers and if it won't
        ' we need to fix it.

        IF EXIST ( TmpF$ ) AND EXIST ( SrcF$ ) THEN
          ' Load them both into memory
          ' I have dim'ed both to be 100,000 bytes, as of this
          ' writing the largest .c/.cpp file is < 5KB so
          ' this should be good for a while
          NewSrc$ = LOADFILE$( TmpF$ )
          OldSrc$ = LOADFILE$( SrcF$ )
          ' compare them
          IF NewSrc$ = OldSrc$ THEN
            ' if same then kill the tmp and keep old one
            KILL TmpF$
          ELSE
            COPYFILE TmpF$, SrcF$
          END IF
        ELSE ' both don't exist, copy tmp to src
          COPYFILE TmpF$, SrcF$
          KILL TmpF$
        END IF

      WEND
    END IF
    CLOSE LB1
    ' add the libraries pragmas to bcxRT.h
    FPRINT LB0,"#if !defined ( __LCC__ )"
    FPRINT LB0,""
    FPRINT LB0,"// *************************************************"
    FPRINT LB0,"// Instruct Linker to Search Object/Import Libraries"
    FPRINT LB0,"// *************************************************"
    FPRINT LB0,"#pragma comment(lib,", ENC$("kernel32.lib"), ")"
    FPRINT LB0,"#pragma comment(lib,", ENC$("user32.lib"), ")"
    FPRINT LB0,"#pragma comment(lib,", ENC$("gdi32.lib"), ")"
    FPRINT LB0,"#pragma comment(lib,", ENC$("comctl32.lib"), ")"
    FPRINT LB0,"#pragma comment(lib,", ENC$("advapi32.lib"), ")"
    FPRINT LB0,"#pragma comment(lib,", ENC$("winspool.lib"), ")"
    FPRINT LB0,"#pragma comment(lib,", ENC$("shell32.lib"), ")"
    FPRINT LB0,"#pragma comment(lib,", ENC$("ole32.lib"), ")"
    FPRINT LB0,"#pragma comment(lib,", ENC$("oleaut32.lib"), ")"
    FPRINT LB0,"#pragma comment(lib,", ENC$("uuid.lib"), ")"
    FPRINT LB0,"#pragma comment(lib,", ENC$("odbc32.lib"), ")"
    FPRINT LB0,"#pragma comment(lib,", ENC$("odbccp32.lib"), ")"
    'FPRINT LB0,"#pragma comment(lib,", ENC$("delayimp.lib"), ")"
    'FPRINT LB0,"#pragma comment(lib,", ENC$("dxguid.lib"), ")"
    FPRINT LB0,"#pragma comment(lib,", ENC$("winmm.lib"), ")"
    FPRINT LB0,"#pragma comment(lib,", ENC$("comdlg32.lib"), ")"
    FPRINT LB0,"#pragma comment(lib,", ENC$("htmlhelp.lib"), ")"
    FPRINT LB0,"#pragma comment(lib,", ENC$("bcxRT.lib"), ")"
    FPRINT LB0,"// *************************************************"
    FPRINT LB0,"#else"
    FPRINT LB0,"// *************************************************"
    FPRINT LB0,"#pragma lib <winspool.lib>"
    FPRINT LB0,"#pragma lib <shell32.lib>"
    FPRINT LB0,"#pragma lib <ole32.lib>"
    FPRINT LB0,"#pragma lib <oleaut32.lib>"
    FPRINT LB0,"#pragma lib <uuid.lib>"
    FPRINT LB0,"#pragma lib <odbc32.lib>"
    FPRINT LB0,"#pragma lib <odbccp32.lib>"
    FPRINT LB0,"#pragma lib <winmm.lib>"
    FPRINT LB0,"#pragma lib <htmlhelp.lib>"
    FPRINT LB0,"#pragma lib <bcxRT.lib>"
    FPRINT LB0,"// *************************************************"
    FPRINT LB0,"// End of Object/Import Libraries To Search"
    FPRINT LB0,"// *************************************************"
    FPRINT LB0,"#endif"
    CLOSE LB0

    ' create response file for BCC55's TLib.exe

    OPEN RSPFile$ FOR OUTPUT AS LB3

    REDIM PRESERVE C_Files$[cIdx]

    QSORT DYNAMIC C_Files$, cIdx

    cIdx--

    FOR INTEGER i = 0 TO cIdx
      IF i < cIdx THEN
        FPRINT LB3," + ";ObjDir$;"BC\\";C_Files$[i];".obj &"
      ELSE
        FPRINT LB3," + ";ObjDir$;"BC\\";C_Files$[i];".obj"
      END IF
    NEXT

    CLOSE LB3

    ' emit BuildRTL.bat if it doesn't exist only
    IF NOT EXIST ( BuildBat$ ) THEN
      OPEN BuildBat$ FOR OUTPUT AS LB4
      ' This is a work in progress
      $IPRINT_ON
      FPRINT LB4,"@ECHO OFF"
      FPRINT LB4,""
      FPRINT LB4,":: IF EXIST .\obj\DC\*.obj ERASE .\obj\DC\*.obj"
      FPRINT LB4,""
      FPRINT LB4,":: IF EXIST .\obj\LC\*.obj ERASE .\obj\LC\*.obj"
      FPRINT LB4,""
      FPRINT LB4,":: IF EXIST .\obj\MC\*.obj ERASE .\obj\MC\*.obj"
      FPRINT LB4,""
      FPRINT LB4,":: IF EXIST .\obj\BC\*.obj ERASE .\obj\BC\*.obj"
      FPRINT LB4,""
      FPRINT LB4,":: IF EXIST .\obj\PC\*.obj ERASE .\obj\PC\*.obj"
      FPRINT LB4,""
      FPRINT LB4,":: IF EXIST .\obj\WC\*.obj ERASE .\obj\WC\*.obj"
      FPRINT LB4,""
      FPRINT LB4,":: IF EXIST .\obj\GC\*.o   ERASE .\obj\GC\*.o"
      FPRINT LB4,""
      FPRINT LB4,"IF EXIST .\source\*.err ERASE .\source\*.err"
      FPRINT LB4,""
      FPRINT LB4,":: IF EXIST .\source\*.c ERASE .\source\*.c"
      FPRINT LB4,""
      FPRINT LB4,":: IF EXIST .\source\*.cpp ERASE .\source\*.cpp"
      FPRINT LB4,""
      FPRINT LB4,"IF EXIST *.err ERASE *.err"
      FPRINT LB4,""
      FPRINT LB4,"IF EXIST bcxrt.rsp ERASE bcxrt.rsp"
      FPRINT LB4,""
      FPRINT LB4,"IF EXIST bcxRT.lib ERASE bcxRT.lib"
      FPRINT LB4,""
      FPRINT LB4,"REM NOTE You must change the location of your compiler installs here"
      FPRINT LB4,"REM ================================================================"
      FPRINT LB4,"SET BCX_INSTALL=C:\BCX"
      FPRINT LB4,""
      FPRINT LB4,"SET MC_INSTALL=", ENC$("C:\PROGRAM FILES\Microsoft Visual C++ Toolkit 2003")
      FPRINT LB4,""
      FPRINT LB4,"SET BC_INSTALL=C:\Borland\BCC55"
      FPRINT LB4,""
      FPRINT LB4,"SET LC_INSTALL=C:\LCC"
      FPRINT LB4,""
      FPRINT LB4,"SET PC_INSTALL=C:\PellesC"
      FPRINT LB4,""
      FPRINT LB4,"SET WC_INSTALL=C:\WATCOM"
      FPRINT LB4,""
      FPRINT LB4,"SET GC_INSTALL=C:\MINGW"
      FPRINT LB4,""
      FPRINT LB4,"SET DC_INSTALL=C:\DM"
      FPRINT LB4,""
      FPRINT LB4,"REM ================================================================"
      FPRINT LB4,"REM NOTE You must change the location of your compiler installs above"
      FPRINT LB4,""
      FPRINT LB4,"IF /i ", ENC$("%1"), " == ", ENC$("D"), " GOTO DMARS32"
      FPRINT LB4,""
      FPRINT LB4,"IF /i ", ENC$("%1"), " == ", ENC$("M"), " GOTO VCCPLUS"
      FPRINT LB4,""
      FPRINT LB4,"IF /i ", ENC$("%1"), " == ", ENC$("L"), " GOTO LCCWIN32"
      FPRINT LB4,""
      FPRINT LB4,"IF /i ", ENC$("%1"), " == ", ENC$("P"), " GOTO PELLESC"
      FPRINT LB4,""
      FPRINT LB4,"IF /i ", ENC$("%1"), " == ", ENC$("B"), " GOTO BCC55"
      FPRINT LB4,""
      FPRINT LB4,"IF /i ", ENC$("%1"), " == ", ENC$("W"), " GOTO WATCOM"
      FPRINT LB4,""
      FPRINT LB4,"IF /i ", ENC$("%1"), " == ", ENC$("G"), " GOTO GCC"
      FPRINT LB4,""
      FPRINT LB4,"IF /i ", ENC$("%1"), " == ", ENC$("A"), " GOTO LCCWIN32"
      FPRINT LB4,""
      FPRINT LB4,"ECHO Missing Parameter"
      FPRINT LB4,"ECHO D for Digial Mars"
      FPRINT LB4,"ECHO M for MSVC++"
      FPRINT LB4,"ECHO L for LCCWin32"
      FPRINT LB4,"ECHO P for Pelles C"
      FPRINT LB4,"ECHO B for Borland C++ 5.5"
      FPRINT LB4,"ECHO W for Open Watcom"
      FPRINT LB4,"ECHO G for MinGW GCC"
      FPRINT LB4,"ECHO A for ", ENC$("ALL"), " = Build Libraries For MCVC++, Borland C++ 5.5, MinGW GCC, Open Watcom, LccWin32, Digital Mars and Pelles C"
      FPRINT LB4,"GOTO FINISHED"
      FPRINT LB4,""
      FPRINT LB4,"REM ========= BUILD LIBRARY with MINGW GCC Compiler"
      FPRINT LB4,":GCC"
      FPRINT LB4,""
      FPRINT LB4,"ECHO Creating BCX Runtime Library for MinGW GCC..."
      FPRINT LB4,""
      FPRINT LB4,"%BCX_INSTALL%\BIN\BC.EXE -lcq"
      FPRINT LB4,""
      FPRINT LB4,"COPY .\include\bcxlib.h %GC_INSTALL%\include\bcxlib.h /Y"
      FPRINT LB4,""
      FPRINT LB4,"COPY .\include\bcxrt.h %GC_INSTALL%\include\bcxrt.h /Y"
      FPRINT LB4,""
      FPRINT LB4,"SET GCCFLAGS=-c -pipe -mconsole -mwin32 -w -s -O2 -D_WIN32_IE=0x0501"
      FPRINT LB4,""
      FPRINT LB4,"FOR %%I IN (.\source\*.cpp) DO %GC_INSTALL%\bin\gcc.exe %GCCFLAGS% %%I -o .\obj\GC\%%~nI.o"
      FPRINT LB4,""
      FPRINT LB4,"IF ERRORLEVEL 1 GOTO ERROR"
      FPRINT LB4,""
      FPRINT LB4,"FOR %%I IN (.\obj\GC\*.o ) DO %GC_INSTALL%\bin\ar.exe -rf %GC_INSTALL%\lib\libbcxrt.a .\obj\GC\%%~nI.o"
      FPRINT LB4,""
      FPRINT LB4,"IF EXIST %GC_INSTALL%\lib\libbcxrt.a COPY %GC_INSTALL%\lib\libbcxrt.a .\lib\GC\libbcxrt.a /Y"
      FPRINT LB4,""
      FPRINT LB4,"ERASE bcxrt.rsp"
      FPRINT LB4,""
      FPRINT LB4,"IF /i ", ENC$("%1"), " == ", ENC$("A"), " GOTO DMARS32"
      FPRINT LB4,""
      FPRINT LB4,"GOTO FINISHED"
      FPRINT LB4,""
      FPRINT LB4,"REM ========= BUILD LIBRARY with Digital Mars Compiler"
      FPRINT LB4,":DMARS32"
      FPRINT LB4,""
      FPRINT LB4,"ECHO Creating BCX Runtime Library for Digital Mars..."
      FPRINT LB4,""
      FPRINT LB4,"%BCX_INSTALL%\BIN\BC.EXE -lcq"
      FPRINT LB4,""
      FPRINT LB4,"COPY .\include\bcxlib.h %DC_INSTALL%\include\bcxlib.h /Y"
      FPRINT LB4,""
      FPRINT LB4,"COPY .\include\bcxrt.h %DC_INSTALL%\include\bcxrt.h /Y"
      FPRINT LB4,""
      FPRINT LB4,"SET DMARSFLAGS=-D_WIN32_WINNT=0x0400 -I", ENC$("C:\Program Files\Microsoft Platform SDK for Windows XP SP2\Include"), " -cpp -c -w7"
      FPRINT LB4,""
      FPRINT LB4,"FOR %%I IN (.\source\*.cpp) DO %DC_INSTALL%\bin\dmc.exe %%I %DMARSFLAGS% -o.\obj\DC\%%~nI.obj"
      FPRINT LB4,""
      FPRINT LB4,"IF ERRORLEVEL 1 GOTO ERROR"
      FPRINT LB4,""
      FPRINT LB4,"IF EXIST %DC_INSTALL%\lib\bcxRT.lib ERASE %DC_INSTALL%\lib\bcxRT.lib"
      FPRINT LB4,""
      FPRINT LB4,"%DC_INSTALL%\bin\lib.exe -c %DC_INSTALL%\lib\bcxRT.lib .\obj\DC\abs.obj"
      FPRINT LB4,""
      FPRINT LB4,"%DC_INSTALL%\bin\lib.exe -d %DC_INSTALL%\lib\bcxRT.lib abs"
      FPRINT LB4,""
      FPRINT LB4,"FOR %%I IN (.\obj\DC\*.obj ) DO %DC_INSTALL%\bin\lib.exe %DC_INSTALL%\lib\bcxRT.lib .\obj\DC\%%~nI.obj"
      FPRINT LB4,""
      FPRINT LB4,"IF EXIST %DC_INSTALL%\lib\bcxRT.lib COPY %DC_INSTALL%\lib\bcxRT.lib .\lib\DC\bcxRT.lib /Y"
      FPRINT LB4,""
      FPRINT LB4,"IF EXIST %DC_INSTALL%\lib\bcxRT.bak ERASE %DC_INSTALL%\lib\bcxRT.bak"
      FPRINT LB4,""
      FPRINT LB4,"IF EXIST bcxRT.rsp ERASE bcxrt.rsp"
      FPRINT LB4,""
      FPRINT LB4,"IF /i ", ENC$("%1"), " == ", ENC$("A"), " GOTO WATCOM"
      FPRINT LB4,""
      FPRINT LB4,""
      FPRINT LB4,"GOTO FINISHED"
      FPRINT LB4,""
      FPRINT LB4,"REM ========= BUILD LIBRARY with Open Watcom Compiler"
      FPRINT LB4,":WATCOM"
      FPRINT LB4,""
      FPRINT LB4,"ECHO Creating BCX Runtime Library for Open Watcom..."
      FPRINT LB4,""
      FPRINT LB4,"%BCX_INSTALL%\BIN\BC.EXE -lcq"
      FPRINT LB4,""
      FPRINT LB4,"COPY .\include\bcxlib.h %WC_INSTALL%\h\bcxlib.h /Y"
      FPRINT LB4,""
      FPRINT LB4,"COPY .\include\bcxrt.h %WC_INSTALL%\h\bcxrt.h /Y"
      FPRINT LB4,""
      FPRINT LB4,"CALL %WC_INSTALL%\setvars.bat"
      FPRINT LB4,""
      FPRINT LB4,"SET WPP386=/bt=nt /bc /os /vcap /zw /d0 /D__WIN32__ /zq /D_WIN32_WINNT=0x0400 /D_WIN32_IE=0x0300"
      FPRINT LB4,""
      FPRINT LB4,"FOR %%I IN (.\source\*.cpp) DO %WC_INSTALL%\binnt\WPP386.exe %%I /fo=.\obj\WC\%%~nI /fr=%%~nI.err"
      FPRINT LB4,""
      FPRINT LB4,"IF ERRORLEVEL 1 GOTO ERROR"
      FPRINT LB4,""
      FPRINT LB4,"FOR %%I IN (.\obj\WC\*.obj ) DO %WC_INSTALL%\binnt\WLIB.exe /b /q %WC_INSTALL%\lib386\nt\bcxRT.lib + .\obj\WC\%%~nI.obj"
      FPRINT LB4,""
      FPRINT LB4,"IF EXIST %WC_INSTALL%\lib386\nt\bcxRT.lib COPY %WC_INSTALL%\lib386\nt\bcxRT.lib .\lib\WC\bcxRT.lib /Y"
      FPRINT LB4,""
      FPRINT LB4,"ERASE bcxrt.rsp"
      FPRINT LB4,""
      FPRINT LB4,"GOTO FINISHED"
      FPRINT LB4,""
      FPRINT LB4,"REM ========= BUILD LIBRARY WITH Borland C++ 5.5 Free Commandline tools"
      FPRINT LB4,":BCC55"
      FPRINT LB4,""
      FPRINT LB4,"ECHO Creating BCX Runtime Library for Borland C++ 5.5..."
      FPRINT LB4,""
      FPRINT LB4,"SET BCCFLAGS=-c -a8 -D__WIN32__ -w-8012 -w-8004 -w-8066 -w-8057 -w-8002 -w-8060"
      FPRINT LB4,""
      FPRINT LB4,"%BCX_INSTALL%\BIN\BC.EXE -lcq"
      FPRINT LB4,""
      FPRINT LB4,"COPY .\include\bcxlib.h %BC_INSTALL%\include\bcxlib.h /Y"
      FPRINT LB4,""
      FPRINT LB4,"COPY .\include\bcxrt.h %BC_INSTALL%\include\bcxrt.h /Y"
      FPRINT LB4,""
      FPRINT LB4,"IF EXIST %BC_INSTALL%\lib\bcxRT.lib ERASE %BC_INSTALL%\lib\bcxRT.lib"
      FPRINT LB4,""
      FPRINT LB4,"FOR %%I IN (.\source\*.cpp) DO %BC_INSTALL%\bin\bcc32.exe %BCCFLAGS% -o.\obj\BC\%%~nI.obj %%I"
      FPRINT LB4,""
      FPRINT LB4,"%BC_INSTALL%\bin\tlib.exe %BC_INSTALL%\lib\bcxRT.lib @bcxrt.rsp /P32"
      FPRINT LB4,""
      FPRINT LB4,"IF EXIST %BC_INSTALL%\lib\bcxRT.lib COPY %BC_INSTALL%\lib\bcxRT.lib .\lib\BC\bcxRT.lib /Y"
      FPRINT LB4,""
      FPRINT LB4,"ERASE bcxrt.rsp"
      FPRINT LB4,""
      FPRINT LB4,"IF /i ", ENC$("%1"), " == ", ENC$("A"), " GOTO GCC"
      FPRINT LB4,""
      FPRINT LB4,"GOTO FINISHED"
      FPRINT LB4,""
      FPRINT LB4,"REM ========= BUILD LIBRARY WITH MSVC++ Free Visual C++ Toolkit 2003"
      FPRINT LB4,":VCCPLUS"
      FPRINT LB4,""
      FPRINT LB4,"ECHO Creating BCX Runtime Library for Microsoft Visual C++ Toolkit 2003..,"
      FPRINT LB4,""
      FPRINT LB4,"SET MSVCPPFLAGS=/c /O1 /Gd /W1 /Ze /MT /D_WIN32_IE=0x0501 /D_WIN32_WINNT=0x0400"
      FPRINT LB4,""
      FPRINT LB4,"%BCX_INSTALL%\BIN\BC.EXE -lcq"
      FPRINT LB4,""
      FPRINT LB4,"COPY .\include\bcxlib.h %MC_INSTALL%\include\bcxlib.h /Y"
      FPRINT LB4,""
      FPRINT LB4,"COPY .\include\bcxrt.h %MC_INSTALL%\include\bcxrt.h /Y"
      FPRINT LB4,""
      FPRINT LB4,"CALL %MC_INSTALL%\VCVARS32.BAT"
      FPRINT LB4,""
      FPRINT LB4,"FOR %%I IN (.\source\*.cpp) DO %MC_INSTALL%\bin\cl.exe %MSVCPPFLAGS% /Fo.\obj\MC\%%~nI.obj %%I"
      FPRINT LB4,""
      FPRINT LB4,"%MC_INSTALL%\bin\lib.exe .\obj\MC\*.obj"
      FPRINT LB4,"REM  bcxRT.lib  \LIBPATH:%MC_INSTALL%\lib"
      FPRINT LB4,"IF EXIST .\obj\MC\*.lib     REN   .\obj\MC\*.lib bcxRT.lib"
      FPRINT LB4,"IF EXIST .\obj\MC\bcxRT.lib COPY  .\obj\MC\bcxRT.lib %MC_INSTALL%\lib\bcxRT.lib /Y"
      FPRINT LB4,"IF EXIST .\obj\MC\bcxRT.lib COPY  .\obj\MC\bcxRT.lib .\lib\MC\bcxRT.lib /Y"
      FPRINT LB4,"IF EXIST .\obj\MC\bcxRT.lib ERASE .\obj\MC\bcxRT.lib"
      FPRINT LB4,""
      FPRINT LB4,"IF /i ", ENC$("%1"), " == ", ENC$("A"), " GOTO BCC55"
      FPRINT LB4,""
      FPRINT LB4,"GOTO FINISHED"
      FPRINT LB4,""
      FPRINT LB4,"REM ========= BUILD LIBRARY WITH PELLESC"
      FPRINT LB4,""
      FPRINT LB4,":PELLESC"
      FPRINT LB4,""
      FPRINT LB4,"ECHO Creating BCX Runtime Library for PellesC..."
      FPRINT LB4,""
      FPRINT LB4,"%BCX_INSTALL%\BIN\BC.EXE -lq"
      FPRINT LB4,""
      FPRINT LB4,"COPY .\include\bcxlib.h %PC_INSTALL%\include\bcxlib.h /Y"
      FPRINT LB4,""
      FPRINT LB4,"COPY .\include\bcxrt.h %PC_INSTALL%\include\bcxrt.h /Y"
      FPRINT LB4,""
      FPRINT LB4,"call %PC_INSTALL%\bin\povars32.bat"
      FPRINT LB4,""
      FPRINT LB4,"SET PELLESFLAGS=-W0 -Ot -Gd -Go -Ze -Zx -X -Tx86-coff"
      FPRINT LB4,""
      FPRINT LB4,"FOR %%f IN (.\source\*.c) DO %PC_INSTALL%\bin\pocc.exe %PELLESFLAGS% /Fo .\obj\PC\%%~nf.obj -I%PC_INSTALL%\include -I%PC_INSTALL%\include\sys -I%PC_INSTALL%\include\win -I%PC_INSTALL%\include\win\gl %%f"
      FPRINT LB4,""
      FPRINT LB4,"%PC_INSTALL%\BIN\POLIB.EXE /OUT:%PC_INSTALL%\lib\bcxRT.lib .\obj\PC\*.obj"
      FPRINT LB4,""
      FPRINT LB4,"IF EXIST %PC_INSTALL%\lib\bcxRT.lib COPY %PC_INSTALL%\lib\bcxRT.lib .\lib\PC\bcxRT.lib /Y"
      FPRINT LB4,""
      FPRINT LB4,"IF /i ", ENC$("%1"), " == ", ENC$("A"), " GOTO VCCPLUS"
      FPRINT LB4,""
      FPRINT LB4,"GOTO FINISHED"
      FPRINT LB4,""
      FPRINT LB4,"REM ========= BUILD LIBRARY WITH LCCWIN32"
      FPRINT LB4,""
      FPRINT LB4,":LCCWIN32"
      FPRINT LB4,""
      FPRINT LB4,"ECHO Creating BCX Runtime Library for LccWin32..."
      FPRINT LB4,""
      FPRINT LB4,"%BCX_INSTALL%\BIN\BC.EXE -lq"
      FPRINT LB4,""
      FPRINT LB4,"COPY .\include\bcxlib.h %LC_INSTALL%\include\bcxlib.h /Y"
      FPRINT LB4,""
      FPRINT LB4,"COPY .\include\bcxrt.h %LC_INSTALL%\include\bcxrt.h /Y"
      FPRINT LB4,""
      FPRINT LB4,":: FOR %%f IN (.\source\*.c) do %LC_INSTALL%\bin\lcc.exe -Zp1 .\source\%%~nf.c -Fo.\obj\LC\%%~nf.obj"
      FPRINT LB4,""
      FPRINT LB4,"%BCX_INSTALL%\BIN\BUILD.EXE .\obj\LC\*.obj .\source\*.c ", ENC$("%LC_INSTALL%\bin\lcc.exe -Zp1 .\source\$dn.c -Fo.\obj\LC\$dn.obj")
      FPRINT LB4,""
      FPRINT LB4,"IF EXIST bcxrt.rsp ERASE bcxrt.rsp"
      FPRINT LB4,""
      FPRINT LB4,"FOR %%I IN (.\obj\LC\*.obj) DO ECHO %%I >> bcxrt.rsp"
      FPRINT LB4,""
      FPRINT LB4,"%LC_INSTALL%\bin\lcclib.exe bcxRT.lib @bcxrt.rsp"
      FPRINT LB4,""
      FPRINT LB4,"ERASE bcxrt.rsp"
      FPRINT LB4,""
      FPRINT LB4,"COPY bcxRT.lib %LC_INSTALL%\lib\bcxRT.lib /Y"
      FPRINT LB4,""
      FPRINT LB4,"COPY bcxRT.lib .\lib\LC\bcxRT.lib /Y"
      FPRINT LB4,""
      FPRINT LB4,"ERASE bcxRT.lib"
      FPRINT LB4,""
      FPRINT LB4,"IF /i ", ENC$("%1"), " == ", ENC$("A"), " GOTO PELLESC"
      FPRINT LB4,""
      FPRINT LB4,"GOTO FINISHED"
      FPRINT LB4,""
      FPRINT LB4,":ERROR"
      FPRINT LB4,""
      FPRINT LB4,"ECHO ERROR!"
      FPRINT LB4,""
      FPRINT LB4,"GOTO OUTOFHERE"
      FPRINT LB4,""
      FPRINT LB4,":FINISHED"
      FPRINT LB4,""
      FPRINT LB4,"ECHO Finished!"
      FPRINT LB4,""
      FPRINT LB4,":OUTOFHERE"
      $IPRINT_OFF
      CLOSE LB4
    END IF

    IF NoKill = FALSE THEN
      KILL RTFile$  ' BCXRT.C(PP) is a file automatically created by BCX for
      ' use in building the BCXRT.LIB
    END IF
    ' *******************************************************
  END IF ' Exist( "BCXRT.C" ) THEN
  $COMMENT
END SUB ' Library_Support



SUB CreateRunTimeDirectory(sCreateMe$)
  IF NOT EXIST(sCreateMe$) THEN MKDIR sCreateMe$
  IF NOT EXIST(sCreateMe$) THEN MSGBOX( "Failed to Create " + sCreateMe$ ) : END = 1
END SUB



FUNCTION Getline$()
  DIM RAW cArg$
  LINE INPUT LB1, cArg$
  IF INSTR( cArg$, "/*" ) THEN REPLACE "/*" WITH "// " IN cArg$
  IF INSTR( cArg$, "*/" ) THEN REPLACE "*/" WITH "" IN cArg$
  FUNCTION = cArg$
END FUNCTION ' GetLine$

' **************************************************************
' End of BCX Runtime Library Support
' **************************************************************



SUB EmitCompilerDefines()
  IF UseWinApi  THEN 'AND g_EmitLibs Then
	  FPRINT FP_HDR,""
	  IF Use_Library THEN
	    FPRINT FP_HDR,"// BCXRTHEADER: COMPILER DEFINES"
	  ELSE
	    FPRINT FP_HDR,"// ***************************************************"
	    FPRINT FP_HDR,"// Compiler Defines"
	    FPRINT FP_HDR,"// ***************************************************"
	  END IF
	  FPRINT FP_HDR,""
	  FPRINT FP_HDR,"// C++"
	  FPRINT FP_HDR,"#if defined( __cplusplus )"
	  FPRINT FP_HDR,"  #define overloaded"
	  FPRINT FP_HDR,"  #define C_EXPORT EXTERN_C __declspec(dllexport)"
	  FPRINT FP_HDR,"  #define C_IMPORT EXTERN_C __declspec(dllimport)"
	  FPRINT FP_HDR,E"  #define BEGIN_EXTERN_C		extern \qC\q {"
	  FPRINT FP_HDR,"  #define END_EXTERN_C		}"
	  FPRINT FP_HDR,"#else"
	  FPRINT FP_HDR,"  #define C_EXPORT __declspec(dllexport)"
	  FPRINT FP_HDR,"  #define C_IMPORT __declspec(dllimport)"
	  FPRINT FP_HDR,"#endif"
	  FPRINT FP_HDR,""
	  IF g_EmitLibs Then
		  'FPRINT FP_HDR,"// Open Watcom defs"
		  'FPRINT FP_HDR,"#if defined( __WATCOM_CPLUSPLUS__ ) || defined( __TINYC__ )"
		  'FPRINT FP_HDR,"  #define atanl atan"
		  'FPRINT FP_HDR,"  #define sinl  sin"
		  'FPRINT FP_HDR,"  #define cosl  cos"
		  'FPRINT FP_HDR,"  #define tanl  tan"
		  'FPRINT FP_HDR,"  #define asinl asin"
		  'FPRINT FP_HDR,"  #define acosl acos"
		  'FPRINT FP_HDR,"  #define log10l log10"
		  'FPRINT FP_HDR,"  #define logl   log"
		  'FPRINT FP_HDR,"  #define _fcloseall fcloseall"
		  'FPRINT FP_HDR,"#endif"
		  'FPRINT FP_HDR,""
		  'FPRINT FP_HDR,"// Borland C++ 5.5.1 defs - bcc32.exe"
		  'FPRINT FP_HDR,"#if defined( __BCPLUSPLUS__ )"
		  'FPRINT FP_HDR,"  // ===== Borland Libraries =========="
		  'FPRINT FP_HDR,"  #include <dos.h>"
		  'FPRINT FP_HDR,"  #pragma comment(lib,", ENC$("import32.lib"), ")"
		  'FPRINT FP_HDR,"  #pragma comment(lib,", ENC$("cw32.lib"), ")"
'jcfuller added 4/1/2013
'note set_fpu_omf.obj must be in a directory listed in ilink32.cfg
' as of 4/3/2013 I've decide not to add set_fpu
		  ''FPRINT FP_HDR,"  #pragma comment(lib,", ENC$("set_fpu_omf.obj"), ")"
		  'FPRINT FP_HDR,"  extern ",ENC$("C")," {void set_fpu(unsigned int);}"
		  'FPRINT FP_HDR,"  // =================================="
		  'FPRINT FP_HDR,"#endif"
		  'FPRINT FP_HDR,"// MinGW"

		  FPRINT FP_HDR,""
		  FPRINT FP_HDR,"// Microsoft VC++"
		  ' this may need to be changed to work with all C++ compilers?????
		  FPRINT FP_HDR,"#ifndef DECLSPEC_UUID"
		  FPRINT FP_HDR,"  #if (_MSC_VER >= 1100) && defined ( __cplusplus )"
		  FPRINT FP_HDR,"    #define DECLSPEC_UUID(x)    __declspec(uuid(x))"
		  FPRINT FP_HDR,"  #else"
		  FPRINT FP_HDR,"    #define DECLSPEC_UUID(x)"
		  FPRINT FP_HDR,"  #endif"
		  FPRINT FP_HDR,"#endif"
		  FPRINT FP_HDR,""
		  'now added via cfix
		  'IF NOT UseCpp Then
			  'FPRINT FP_HDR,"// *************************************************"
			  'FPRINT FP_HDR,"// Tiny C support for LinkRes2Exe"
			  'FPRINT FP_HDR,"#ifdef __TINYC__"
			  'FPRINT FP_HDR,"  int dummy __attribute__ ((section(",ENC$(".rsrc"),")));"
			  'FPRINT FP_HDR,"#endif"
			  'FPRINT FP_HDR,"// *************************************************"
			  'FPRINT FP_HDR,""
		  'EndIf
	  End If
	  IF Use_Library THEN FPRINT FP_HDR,"// END BCXRTHEADER\n\n"
  END IF
'jcfuller added   09/05/2015
  IF (TargetOS = TNIX  OR UseWinApi = FALSE OR WinHeaders = FALSE) AND Use_MFC = FALSE Then
    FPRINT FP_HDR,"// ***************************************************"
    FPRINT FP_HDR,"// Compiler Defines"
    FPRINT FP_HDR,"// ***************************************************"

'    FPRINT FP_HDR,"#ifndef TRUE"
'    FPRINT FP_HDR,"  #define TRUE 1"
'    FPRINT FP_HDR,"#endif"
'    FPRINT FP_HDR,""
'    FPRINT FP_HDR,"#ifndef FALSE"
'    FPRINT FP_HDR,"  #define FALSE 0"
'    FPRINT FP_HDR,"#endif"
'    FPRINT FP_HDR,""
'	FPRINT FP_HDR,"#ifndef MAX_PATH"
'	FPRINT FP_HDR,"  #define MAX_PATH 2048"
'	FPRINT FP_HDR,"#endif"
'    FPRINT FP_HDR,""
  End if
  IF TargetOS = TNIX Then
	FPRINT FP_HDR,"#define stricmp strcasecmp"
  Else
  
	  If Not Use_UNICODE_Switch Then
		FPRINT FP_HDR,"#define stricmp _stricmp"
	  End If	
  End If
END SUB 'EmitCompilerDefines



SUB Emit_VBSCRIPT_Support()
  STATIC nTimes = 0
  IF nTimes > 0 THEN EXIT SUB
  INCR nTimes
  Use_AnsiToWide = Use_WideToAnsi = TRUE
  FPRINT FP_HDR,""
  IF Use_Library THEN
    FPRINT FP_HDR,"// BCXRTHEADER: VBSCRIPT SUPPORT STRUCTURES"
  ELSE
    FPRINT FP_HDR,"// ****************************************"
    FPRINT FP_HDR,"// ***** ";$BCX_STR_VBS_STRUCTS;"  *****"
    FPRINT FP_HDR,"// ****************************************"
    FPRINT FP_HDR,""
  END IF
  FPRINT FP_HDR,"const GUID IID_IScriptControl ="
  FPRINT FP_HDR,"{"
  FPRINT FP_HDR,"   0x0e59f1d3,0x1fbe,0x11d0,"
  FPRINT FP_HDR,"  {0x8f,0xf2,0x00,0xa0,0xd1,0x00,0x38,0xbc}"
  FPRINT FP_HDR,"};"
  FPRINT FP_HDR,""
  FPRINT FP_HDR,"enum ScriptControlStates"
  FPRINT FP_HDR,"{"
  FPRINT FP_HDR,"  SCRIPTSTATE_UNINITIALIZED0, SCRIPTSTATE_STARTED1, SCRIPTSTATE_CONNECTED2,"
  FPRINT FP_HDR,"  SCRIPTSTATE_DISCONNECTED3, SCRIPTSTATE_CLOSED4, SCRIPTSTATE_INITIALIZED5"
  FPRINT FP_HDR,"};"
  FPRINT FP_HDR,""
  FPRINT FP_HDR,"const GUID IID_IScriptError ="
  FPRINT FP_HDR,"{"
  FPRINT FP_HDR,"   0x70841C78, 0x67D, 0x11D0,"
  FPRINT FP_HDR,"  {0x95, 0xD8, 0x0, 0xA0, 0x24, 0x63, 0xAB, 0x28}"
  FPRINT FP_HDR,"};"
  FPRINT FP_HDR,""
  FPRINT FP_HDR,"// ------------------------------"
  FPRINT FP_HDR,"#undef  INTERFACE"
  FPRINT FP_HDR,"#define INTERFACE IScriptError"
  FPRINT FP_HDR,"// ------------------------------"
  FPRINT FP_HDR,"DECLARE_INTERFACE_(IScriptError, IDispatch) {"
  FPRINT FP_HDR,"STDMETHOD (QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;"
  FPRINT FP_HDR,"STDMETHOD_(ULONG, AddRef)(THIS)  PURE;"
  FPRINT FP_HDR,"STDMETHOD_(ULONG, Release)(THIS) PURE;"
  FPRINT FP_HDR,"STDMETHOD (GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;"
  FPRINT FP_HDR,"STDMETHOD (GetTypeInfo)(THIS_ UINT itinfo, LCID lcid,"
  FPRINT FP_HDR,"ITypeInfo  FAR* FAR* pptinfo) PURE;"
  FPRINT FP_HDR,"STDMETHOD (GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames,"
  FPRINT FP_HDR,"           UINT cNames, LCID lcid, DISPID FAR* rgdispid) PURE;"
  FPRINT FP_HDR,"STDMETHOD (Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid,"
  FPRINT FP_HDR,"           WORD wFlags, DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult,"
  FPRINT FP_HDR,"           EXCEPINFO FAR* pexcepinfo, UINT FAR* puArgErr) PURE;"
  FPRINT FP_HDR,"STDMETHOD (Get_Number)(THIS_  long* pNumber) PURE;"
  FPRINT FP_HDR,"STDMETHOD (Get_Source)(THIS_ BSTR* pbstrSource) PURE;"
  FPRINT FP_HDR,"STDMETHOD (Get_Description)(THIS_ BSTR* pbstrDescription) PURE;"
  FPRINT FP_HDR,"STDMETHOD (Get_HelpFile)(THIS_ BSTR* pbstrHelpFile) PURE;"
  FPRINT FP_HDR,"STDMETHOD (Get_HelpContext)(THIS_ long* pHelpContext) PURE;"
  FPRINT FP_HDR,"STDMETHOD (Get_Text)(THIS_ BSTR* pbstrText) PURE;"
  FPRINT FP_HDR,"STDMETHOD (Get_Line)(THIS_ long* pLine) PURE;"
  FPRINT FP_HDR,"STDMETHOD (Get_Column)(THIS_ long* pColumn) PURE;"
  FPRINT FP_HDR,"STDMETHOD (Clear)(THIS) PURE;};"
  FPRINT FP_HDR,""
  FPRINT FP_HDR,"// ------------------------------"
  FPRINT FP_HDR,"#undef  INTERFACE"
  FPRINT FP_HDR,"#define INTERFACE IScriptControl"
  FPRINT FP_HDR,"// ------------------------------"
  FPRINT FP_HDR,"DECLARE_INTERFACE_(IScriptControl, IDispatch) {"
  FPRINT FP_HDR,"STDMETHOD (QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;"
  FPRINT FP_HDR,"STDMETHOD_(ULONG, AddRef)(THIS)  PURE;"
  FPRINT FP_HDR,"STDMETHOD_(ULONG, Release)(THIS) PURE;"
  FPRINT FP_HDR,"STDMETHOD (GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;"
  FPRINT FP_HDR,"STDMETHOD (GetTypeInfo)(THIS_ UINT itinfo, LCID lcid,"
  FPRINT FP_HDR,"ITypeInfo  FAR* FAR* pptinfo) PURE;"
  FPRINT FP_HDR,"STDMETHOD (GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames,"
  FPRINT FP_HDR,"           UINT cNames, LCID lcid, DISPID FAR* rgdispid) PURE;"
  FPRINT FP_HDR,"STDMETHOD (Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid,"
  FPRINT FP_HDR,"           WORD wFlags, DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult,"
  FPRINT FP_HDR,"           EXCEPINFO FAR* pexcepinfo, UINT FAR* puArgErr) PURE;"
  FPRINT FP_HDR,"STDMETHOD (get_Language)(THIS_ BSTR* pbstrLanguage) PURE;"
  FPRINT FP_HDR,"STDMETHOD (put_Language)(THIS_ BSTR pbstrLanguage) PURE;"
  FPRINT FP_HDR,"STDMETHOD (get_State)(THIS_ enum ScriptControlStates* pssState) PURE;"
  FPRINT FP_HDR,"STDMETHOD (put_State)(THIS_ enum ScriptControlStates pssState ) PURE;"
  FPRINT FP_HDR,"STDMETHOD (put_SitehWnd)(THIS_ long phwnd) PURE;"
  FPRINT FP_HDR,"STDMETHOD (get_SitehWnd)(THIS_ long* phwnd) PURE;"
  FPRINT FP_HDR,"STDMETHOD (get_Timeout)(THIS_ long* plMilliseconds) PURE;"
  FPRINT FP_HDR,"STDMETHOD (put_Timeout)(THIS_ long plMilliseconds) PURE;"
  FPRINT FP_HDR,"STDMETHOD (get_AllowUI)(THIS_ VARIANT_BOOL* pfAllowUI) PURE;"
  FPRINT FP_HDR,"STDMETHOD (put_AllowUI)(THIS_ VARIANT_BOOL pfAllowUI) PURE;"
  FPRINT FP_HDR,"STDMETHOD (get_UseSafeSubset)(THIS_ VARIANT_BOOL* pfUseSafeSubset) PURE;"
  FPRINT FP_HDR,"STDMETHOD (put_UseSafeSubset)(THIS_ VARIANT_BOOL pfUseSafeSubset) PURE;"
  FPRINT FP_HDR,"STDMETHOD (get_Modules)(THIS_ interface"
  FPRINT FP_HDR,"           IScriptModuleCollection** ppmods) PURE;"
  FPRINT FP_HDR,"STDMETHOD (get_Error)(THIS_ interface IScriptError** ppse) PURE;"
  FPRINT FP_HDR,"STDMETHOD (get_CodeObject)(THIS_ IDispatch** ppdispObject) PURE;"
  FPRINT FP_HDR,"STDMETHOD (get_Procedures)(THIS_ interface"
  FPRINT FP_HDR,"           IScriptProcedureCollection** ppdispProcedures) PURE;"
  FPRINT FP_HDR,"STDMETHOD (_AboutBox)(THIS) PURE;"
  FPRINT FP_HDR,"STDMETHOD (AddObject)(THIS_ BSTR Name, IDispatch* Object,"
  FPRINT FP_HDR,"           VARIANT_BOOL AddMembers) PURE;"
  FPRINT FP_HDR,"STDMETHOD (Reset)(THIS) PURE;"
  FPRINT FP_HDR,"STDMETHOD (AddCode)(THIS_ BSTR Code) PURE;"
  FPRINT FP_HDR,"STDMETHOD (Eval)(THIS_ BSTR Expression, VARIANT* pvarResult) PURE;"
  FPRINT FP_HDR,"STDMETHOD (ExecuteStatement)(THIS_ BSTR Statement) PURE;"
  FPRINT FP_HDR,"STDMETHOD (Run)(THIS_ BSTR ProcedureName, SAFEARRAY** Parameters,"
  FPRINT FP_HDR,"           VARIANT* pvarResult) PURE;};"
  FPRINT FP_HDR,""
  IF Use_Project OR Use_Library THEN
    FPRINT FP_HDR,"BOOL OLE_ERROR_S;"
    FPRINT FP_HDR,"IScriptControl *pSC;"
  ELSE
    FPRINT FP_HDR,"static BOOL OLE_ERROR_S;"
    FPRINT FP_HDR,"static IScriptControl *pSC;"
  END IF

  AddLibrary("ole32.lib")
  AddLibrary("oleaut32.lib")
  IF Use_Library THEN FPRINT FP_HDR,"// END BCXRTHEADER\n\n"
END SUB 'Emit_VBSCRIPT_Support



SUB Emit_Pragmas()
  IF Use_BCX_OlePicture OR Use_BCX_LoadImage THEN
    AddLibrary("ole32.lib")
    AddLibrary("uuid.lib")
    'AddLibrary("olepro32.lib")
    AddLibrary("oleaut32.lib")
    AddLibrary("shell32.lib")
  END IF
  IF Use_Bff THEN
    AddLibrary("shell32.lib")
    AddLibrary("ole32.lib")
  END IF
  IF Use_Sound OR Use_PlayWav THEN
    AddLibrary("winmm.lib")
  END IF
END SUB ' Emit_Pragmas



SUB MakeFreeGlobals()
  Src$ = "SUB FreeGlobals"
  PassOne = TRUE
  CALL XFE(Src$)
  WHILE GlobalDynaCnt
    FPRINT Outfile,"  ", GlobalDynaStr$[GlobalDynaCnt]
    GlobalDynaCnt--
  WEND
  Src$ = "END SUB"
  PassOne = TRUE
  CALL XFE(Src$)
END SUB ' MakeFreeGlobals
'------------------------------------------------------------------------------
'jcfuller added 9/14/2013 from bcx 7.0.8
SUB ClearVARCODE(pv AS VARCODE PTR)
  pv->VarNo           = 0
  pv->Methd           = 0
  pv->IsPtrFlag       = 0
  pv->szFunctionName$ = ""
  pv->Header$         = ""
  pv->Proto$          = ""
  pv->Functype$       = ""
  pv->StaticOut$      = ""
  pv->Token$          = ""
  pv->AsToken$        = ""
  pv->IsExported      = FALSE
  pv->UseInLine       = UseInLine
END SUB
'------------------------------------------------------------------------------

SUB ProcessSetCommand(GS)
  DIM RAW iThisToken, iFoundEqual, SetString=0
  DIM RAW CVar$
  DIM RAW vt1
  DIM RAW lszTmp$
  LOCAL SaveFP AS FILE
  RAW VarCode AS VARCODE
  RAW szIsConst$

'IF _ZTRACE_ Then
'	ZPRINT(Src$)
'END IF

'------------------------------------------------------------------------------
'jcfuller added 9/14/2013 from bcx 7.0.8
CALL ClearVARCODE(&VarCode)
'------------------------------------------------------------------------------
'Wayne fix 07/14/2013
  VarCode.IsPtrFlag = 0
'------------------------------------------------------------------------------
'  VarCode.IsExported = FALSE
'  VarCode.UseInLine = UseInLine
'------------------------------------------------------------------------------
  SaveFP = Outfile
  IF InNameSpace or InClassModule THEN
    Outfile = FP_UDT     ' CPP context
  'ELSEIF NOT InFunc THEN
  ELSEIF InFunc = eNotInOne THEN
    Outfile = FP_SET     ' Global context
  ENDIF

  IF INCHR(Src$,"$") AND TALLY(Src$,"[") >1 THEN
    Src$ = STRIM$(Src$)
    IREMOVE "as string" FROM Src$
'    IREMOVE "as lpstr"  FROM Src$
    IREMOVE "as char"   FROM Src$
    CONCAT(Src$," AS char")
  END IF

  CONCAT(Src$,"=")
  PassOne = TRUE
  CALL XParse(Src$)
  CALL FixUps()
  Tipe$ = ""
  szIsConst$ = ""
  iThisToken = GetAsPosF(1,Ndx)
  IF iThisToken THEN
    Stk$[iThisToken++] = ""
    Tipe$ = Stk$[iThisToken]
    IF iMatchWrd(Tipe$, "const") THEN

      szIsConst$ = "const "
      Stk$[iThisToken++] = ""
      Tipe$ = Stk$[iThisToken]
    END IF
    Stk$[iThisToken] = ""
  END IF

  IF Tipe$ = "" THEN
    szTmp$ = Stk$[2]
    SetString = DataType(szTmp$)
    VarCode.Methd% = mt_ProcessSetCommand
    VarCode.Token$ = szTmp$
    VarCode.VarNo% = SetString
    CALL GetVarCode(&VarCode,"set command")
    IF GS THEN
      FPRINT Outfile, Scoot$;REMOVE$(VarCode.StaticOut$,"static ");
    ELSE
      FPRINT Outfile, Scoot$;VarCode.StaticOut$;
    END IF

    lszTmp$ = ""
    CVar$ = Clean$(Stk$[2])
    CALL ValidVar(CVar$)
    vt1 = DataType(Stk$[2]) 'WAS vt1 = DataType(CVar$)
    CALL BuildStr(3, Ndx, lszTmp$)
    IF vt1 = vt_STRVAR AND lszTmp$ <> "" THEN
      CONCAT (lszTmp$, cSizeOfADefaultString)
    END IF
    'IF NOT InFunc THEN
    IF InFunc = eNotInOne THEN
      CALL AddGlobal(CVar$, vt1, 0,lszTmp$,0,0,0,1,0)
    ELSE
      CALL AddLocal(CVar$, vt1, 0,lszTmp$,0,0,1,0)
    END IF
  ELSE
    CVar$ = Clean$(Stk$[2])
    IF GS THEN
      FPRINT Outfile,Scoot$;szIsConst$;Tipe$;SPC$;CVar$;
    ELSE
      FPRINT Outfile,Scoot$;"static ";szIsConst$;Tipe$;SPC$;CVar$;
    END IF

    DIM RAW DimType$
    DIM RAW IsPointer
    DIM RAW id
    RAW iIsConst
    IF *szIsConst$ THEN iIsConst = 1 ELSE iIsConst = 0

    DimType$ = REMOVE$(Tipe$,"*") ' *mh - 3/9/09
    CALL GetTypeInfo(Tipe$, &IsPointer, &id, &vt1)

    IF vt1 = vt_STRVAR THEN
      CONCAT(DimType$, cSizeOfADefaultString)
    END IF

    'IF NOT InFunc THEN
    IF InFunc = eNotInOne THEN
      CALL AddGlobal(CVar$, vt1, id, DimType$,IsPointer,0,0,1,iIsConst)
    ELSE
      CALL AddLocal(CVar$, vt1, id, DimType$,IsPointer,0,1,iIsConst)
    END IF
  END IF

  iThisToken = 2
  iFoundEqual = FALSE
  DO
    iThisToken++
    IF Stk$[iThisToken] = "=" THEN iFoundEqual = TRUE
    IF SetString = vt_STRVAR AND iFoundEqual THEN
      FPRINT Outfile,cSizeOfADefaultString$;"=";
    ELSE
      FPRINT Outfile,Stk$[iThisToken];
    END IF
    IF Stk$[iThisToken] = "=" THEN EXIT DO
    IF iThisToken = Ndx THEN EXIT DO
  LOOP

  FPRINT Outfile,""
  FPRINT Outfile,"  {"

  WHILE NOT EOF(SourceFile)
    LINE INPUT SourceFile,Src$
    ModuleLineNos[ModuleNdx]++
    CALL StripCode(Src$)
    IF JoinLines(Src$) THEN ITERATE
    PassOne = TRUE
    CALL XParse(Src$)
    PassOne = FALSE
    IF iMatchWrd(Src$,"endset") THEN EXIT WHILE
    CALL TokenSubstitutions(2)
    IF LEN (Src$) THEN
      FPRINT Outfile," ";
      FOR Integer ii = 1 TO Ndx
        FPRINT Outfile, Clean$(Stk$[ii]);
      NEXT
      FPRINT Outfile,""
    END IF
  WEND
  FPRINT Outfile,"};\n"
  Src$ = ""
  Outfile = SaveFP
END SUB 'ProcessSetCommand



SUB EmitOptimize OPTIONAL(Str1$,Str2$,Str3$=0)
  IF OptimizerEnabled THEN
    FPRINT Outfile,"#if defined ( __POCC__ ) && !defined( __cplusplus )"
    FPRINT Outfile,"#pragma optimize(",Str1$,")",Str3$
    FPRINT Outfile,"#elif !defined ( __cplusplus )"
    FPRINT Outfile,"#pragma optimize(",Str2$,")",Str3$
    FPRINT Outfile,"#endif"
  END IF
END SUB ' EmitOptimize



SUB EnableProject()
  STATIC iWasHere = 0

  IF FirstTime(iWasHere) THEN
    RAW cHFn$
    iWasHere++
    Project_Main$ = TRIM$(REMOVE$(MID$(Src$,9),DQ$))
    Project_Main$ = EXTRACT$(Project_Main$,"'")                  ' allow comments
'jcfuller 1/29/2013
    'Project_Main$ = EXTRACT$(Project_Main$, ".")
    Project_Main$ = RemoveExtension$(Project_Main$)
    Use_Project   = TRUE
    szProject$ = "static "
    FPRINT FP_HDR,""
    FPRINT FP_HDR,"// include BCX Runtime header file"
    FPRINT FP_HDR,"#include <bcxRT.h>"
    FPRINT FP_HDR,""
    IF INCHR( COMMAND$(1), "\") THEN ' has a path
      cHFn$ = MID$( COMMAND$(1), INSTRREV( COMMAND$(1), "\", 0 ) + 1 )
    ELSE
      cHFn$ = COMMAND$(1)
    END IF
    IF INCHR( cHFn$, "." ) THEN ' has an extension
      cHFn$ = MID$( cHFn$, 1, INSTRREV( cHFn$, ".", 0 ) -1 )
    END IF
    FPRINT FP_HDR,"#define __BCX_HEADER_";UCASE$(cHFn$);"__"
  END IF
END SUB ' EnableProject



FUNCTION SubVarType(TokenNum)
  RAW iVarType, j = 0

  iVarType = CheckLocal(Stk$[TokenNum], &j)
  IF iVarType = vt_CHAR THEN
    IF *LocalVars[j].VarDim$ <> ASC("[") AND LocalVars[j].VarPntr = 0 THEN
      iVarType = vt_INTEGER
    END IF
  ELSE
    IF iVarType = vt_UNKNOWN THEN
      iVarType = CheckGlobal(Stk$[TokenNum], &j)
      IF iVarType = vt_CHAR THEN
        IF *GlobalVars[j].VarDim$ <> ASC("[") AND GlobalVars[j].VarPntr = 0 THEN
          iVarType = vt_INTEGER
        END IF
      END IF
    END IF
  END IF

  j = ASC(RIGHT$(Stk$[TokenNum],1))

  SELECT CASE iVarType

    CASE vt_STRVAR, vt_CHAR
    IF j <> ASC("$") THEN
      CONCAT (Stk$[TokenNum], "$")
    END IF

    CASE vt_INTEGER
    IF j <> ASC("%") THEN
      CONCAT (Stk$[TokenNum], "%")
    END IF

    CASE vt_SINGLE
    IF j <> ASC("!") THEN
      CONCAT (Stk$[TokenNum], "!")
    END IF

    CASE vt_DOUBLE
    IF j <> ASC("#") THEN
      CONCAT (Stk$[TokenNum], "#")
    END IF

    CASE vt_LDOUBLE
    IF j <> ASC("`") THEN
      CONCAT (Stk$[TokenNum], "`")
    END IF

  END SELECT
  FUNCTION = iVarType
END FUNCTION ' SubVarType



FUNCTION PrintWriteFormat$(DoWrite)
  DIM RAW Stak[128] AS ARGTYPE
  DIM RAW Frmat$
  DIM RAW Arg$
  DIM RAW ZZ$
  DIM RAW Cast$
  DIM RAW TmpClean$
  DIM RAW NewLineFlag = 0
  RAW Argcount = 0
  RAW NextArgcount = 1
  RAW iThisToken
  RAW iVarType

  Frmat$ = ""
  Arg$   = ""
  ZZ$    = ""

  IF Stk$[Ndx]= ";" THEN
    NewLineFlag = TRUE
    Ndx--
  END IF

  IF Ndx = 1 THEN GOTO PrintWriteLabel

  Stak[1].ArgType = -1
  iThisToken = 2

  WHILE iThisToken <= Ndx
    TmpClean$ = Clean$(Stk$[iThisToken])
    IF TmpClean$ <> "BCX_DynaCallA" AND TmpClean$ <> "BCX_DynaCallB" THEN
      iVarType = SubVarType(iThisToken)
      IF Stak[NextArgcount].ArgType = -1 THEN
        IF iVarType = vt_CHAR OR iVarType = vt_STRVAR OR iVarType = vt_INTEGER OR iVarType = vt_SINGLE OR iVarType = vt_DOUBLE OR iVarType = vt_LDOUBLE THEN
          Stak[NextArgcount].ArgType = iVarType
        END IF
      END IF

      IF Stk$[iThisToken] = "(" THEN
        RAW iCnt = 0
        DO
          IF iCnt AND Stk$[iThisToken] <> ")" THEN CONCAT (Arg$,SPC$)
          IF Stk$[iThisToken] = "(" THEN iCnt++
          IF Stk$[iThisToken] = ")" THEN iCnt--
          CONCAT (Arg$,Stk$[iThisToken])
          iThisToken++
        LOOP UNTIL iCnt <= 0 OR iThisToken >= Ndx
      END IF

      IF Stk$[iThisToken] = "[" THEN
        RAW iCnt = 0
        DO
          IF Stk$[iThisToken] = "[" THEN iCnt++
          IF Stk$[iThisToken] = "]" THEN iCnt--
          CONCAT (Arg$,Stk$[iThisToken])
          iThisToken++
          IF Stk$[iThisToken] = "["  AND iCnt = 0 THEN ITERATE
        LOOP UNTIL iCnt <= 0 OR iThisToken >= Ndx
      END IF

      IF Stk$[iThisToken] = ";" OR Stk$[iThisToken] = "," OR Stk$[iThisToken] = "&" THEN
        Argcount++
        NextArgcount++
        Stak[Argcount].Arg$ = Arg$
        Stak[NextArgcount].ArgType = -1
        Arg$ = ""
        iThisToken++
      ELSE
        CONCAT (Arg$,Stk$[iThisToken])
        iThisToken++
      END IF
    ELSE
      CONCAT(Arg$,Stk$[iThisToken])
      iThisToken++
    END IF
  WEND

  Argcount++
  NextArgcount++
  Stak[Argcount].Arg$ = Arg$
  Arg$ = ""

  FOR iThisToken = 1 TO Argcount

    iVarType = Stak[iThisToken].ArgType
    IF iVarType = -1 THEN
      ZZ$ = EXTRACT$(Stak[iThisToken].Arg$,"(")
      iVarType = DataType(ZZ$)
    END IF

    IF iVarType = vt_INTEGER THEN
      RAW A, indx
      A = CheckLocal(ZZ$, &indx)
      IF A = vt_UNKNOWN THEN
        A = CheckGlobal(ZZ$, &indx)
        IF A <> vt_UNKNOWN THEN
          iVarType = GlobalVars[indx].VarType
        END IF
      ELSE
        iVarType = LocalVars[indx].VarType
      END IF
    END IF

    SELECT CASE iVarType

      CASE vt_STRLIT, vt_STRVAR, vt_CHAR
      IF DoWrite THEN
        Frmat$ = Frmat$ + "\\" + DQ$ + "%s" + "\\" + DQ$ + ","
      ELSE
    	CONCAT (Frmat$,"%s")
      END IF
      IF LEFT$(ZZ$, 12) = "BCX_DynaCall" THEN
        Arg$ = Arg$ + ",(char*)" + Stak[iThisToken].Arg$
      ELSE
        Arg$ = Arg$ + "," + Stak[iThisToken].Arg$
      END IF

      CASE vt_INTEGER, vt_DECFUNC
      IF DoWrite THEN
        Frmat$ = Frmat$ + "%d" + ","
      ELSE
        CONCAT (Frmat$,"% d")
      END IF
      Arg$ = Arg$ + ",(int)" + Stak[iThisToken].Arg$

      CASE vt_LLONG
      IF DoWrite THEN
        Frmat$ = Frmat$ + "%lli" + ","
      ELSE
        CONCAT (Frmat$,"% lli")
      END IF
      Arg$ = Arg$ + ",(long long)" + Stak[iThisToken].Arg$

      CASE vt_SINGLE
      IF DoWrite THEN
        Frmat$ = Frmat$ + "%.7G" + ","
      ELSE
        CONCAT (Frmat$,"% .7G")
      END IF
      Arg$ = Arg$ + ",(float)" + Stak[iThisToken].Arg$

      CASE vt_DOUBLE,vt_NUMBER
      IF DoWrite THEN
        Frmat$ = Frmat$ + "%.15G" + ","
      ELSE
        CONCAT (Frmat$,"% .15G")
      END IF
      Arg$ = Arg$ + ",(double)" + Stak[iThisToken].Arg$

      CASE vt_LDOUBLE
      IF DoWrite THEN
        Frmat$ = Frmat$ + "%.19LG" + ","
      ELSE
        CONCAT (Frmat$,"% .19LG")
      END IF
      Arg$ = Arg$ + ",(LDOUBLE)" + Stak[iThisToken].Arg$
	  CASE vt_BC9CHAR
'		cout << "vt_BC9CHAR = " << vt_BC9CHAR << endl
		CONCAT (Frmat$,"%c")
		Arg$ = Arg$ + ",(char)" + Stak[iThisToken].Arg$
      CASE ELSE
      IF ASC(Stak[iThisToken].Arg$) = ASC("(") THEN
        ZZ$ = ""
        CONCAT(Arg$,",")
        DO
          RAW iParentheses
          iParentheses = INSTR(Stak[iThisToken].Arg$,")")
          Cast$ = MID$(Stak[iThisToken].Arg$ ,1 ,iParentheses++)
          Stak[iThisToken].Arg$ = TRIM$(MID$(Stak[iThisToken].Arg$,iParentheses))
          IREPLACE "char*"   WITH "char *" IN Cast$
          IREPLACE "lpstr"   WITH "char *" IN Cast$
          IREPLACE "integer" WITH "int" IN Cast$
          IREPLACE "single"  WITH "float" IN Cast$
          IREPLACE "ldouble" WITH "LDOUBLE" IN Cast$
          IREPLACE "long long" WITH "long long" IN Cast$
          IREPLACE "longlong" WITH "long long" IN Cast$
          IREPLACE "llong" WITH "long long" IN Cast$
          '(long long)  longlong llong
          'Frmat$ = Frmat$ + "%lli" + ","

          IF ZZ$ = "" THEN
            IF Cast$ = "(char *)" OR Cast$ = "(int)" OR Cast$ = "(float)" OR Cast$ = "(double)" OR Cast$ = "(LDOUBLE)" OR Cast$ = "(long long)" THEN
              ZZ$ = Cast$
            ELSE
              ZZ$ = "(double)"
              Cast$ = ZZ$ + Cast$
            END IF
            RemoveAll(ZZ$,"()")
            IREPLACE "char *"     WITH "%s"      IN ZZ$
            IREPLACE "int"        WITH "% d"     IN ZZ$
            IREPLACE "float"      WITH "% .7G"   IN ZZ$
            IREPLACE "ldouble"    WITH "% .19LG" IN ZZ$
            IREPLACE "double"     WITH "% .15G"  IN ZZ$
            IREPLACE "long long"  WITH "% lli"   IN ZZ$
          END IF
          CONCAT(Arg$,Cast$)
        LOOP WHILE ASC(Stak[iThisToken].Arg$) = c_LPar

        CONCAT(Arg$, Stak[iThisToken].Arg$)
        CONCAT (Frmat$,ZZ$)

        IF DoWrite THEN CONCAT (Frmat$,",")
      ELSE
        IF DoWrite THEN
          Frmat$ = Frmat$ + "%G" + ","
        ELSE
          CONCAT (Frmat$,"% G")
          Arg$ = Arg$ + ",(float)" + Stak[iThisToken].Arg$
        END IF
      END IF

    END SELECT
  NEXT

  IF DoWrite THEN Frmat$ = LEFT$(Frmat$,LEN(Frmat$)-1)

  '*********************
  PrintWriteLabel:
  '*********************

  IF NewLineFlag = 0 THEN
    CONCAT (Frmat$,"\\n")
  END IF
  FUNCTION = "printf(" + ENC$(Frmat$) + Clean$(Arg$) + ");"
END FUNCTION ' PrintWriteFormat$



' ************************************
' Called by
'   "finput" - EmitFileInputCode - InputBufferFlags
'   "input"  - EmitInputCode     - CommonInputCode  - InputBufferFlags
SUB InputBufferFlags()
  IF NOT Use_Inputbuffer THEN
    Use_Inputbuffer = TRUE
    Use_Scan    = TRUE
    Use_Proto   = TRUE
    UseFlag     = TRUE
    Use_Split   = TRUE
    Use_Remove  = TRUE
    Use_StrStr  = TRUE
    Use_Mid     = TRUE
    Use_Left    = TRUE
    Use_Instr   = TRUE
    Use_Stristr = TRUE
    UseLCaseTbl = TRUE
  END IF
END SUB ' InputBufferFlags



SUB CommonInputCode(Frmat$, Arg$)
  DIM RAW Argcount = 0
  DIM Stak$[128]
  DIM RAW szParamToken$
  RAW iThisToken
  RAW iVarType

  CALL InputBufferFlags()

  Arg$   =  ""
  Frmat$ =  ""
  iThisToken = 1 '0

  WHILE iThisToken <= Ndx
    IF Stk$[iThisToken] = "," THEN
      Argcount++
      Stak$[Argcount]= Arg$
      Arg$ = ""
      iThisToken++
    ELSE
      CONCAT (Arg$, Stk$[iThisToken])
      iThisToken++
      IF iThisToken < Ndx THEN
        RAW iCnt = tally(Arg$,"[")-tally(Arg$,"]")
        WHILE iCnt
          CONCAT (Arg$,Stk$[iThisToken])
          iThisToken++
          iCnt = tally(Arg$,"[")-tally(Arg$,"]")
        WEND
      END IF
    END IF
  WEND

  Argcount++
  Stak$[Argcount] = Arg$
  Arg$ = ""

  FOR iThisToken = 1 TO Argcount
    szParamToken$ = Stak$[iThisToken]
    iVarType = CheckType(szParamToken$)
    IF iVarType = vt_UDT OR iVarType = vt_STRUCT OR iVarType = vt_UNION THEN
      iVarType  = DataType(szParamToken$)
    ELSE
      RAW iCnt = INSTR(szParamToken$,"[")
      IF iCnt THEN *(--iCnt+szParamToken) = 0
      iVarType  = DataType(szParamToken$)
    END IF
    szParamToken$ = Clean$(Stak$[iThisToken])

    SELECT CASE iVarType

      CASE vt_STRVAR
        CONCAT (Frmat$,"%s")
        Arg$ = Arg$ + "," + szParamToken$
        FPRINT Outfile, Scoot$;"*";TRIM$(szParamToken$);"=0;"

      CASE vt_INTEGER
        CONCAT (Frmat$,"%d")
        Arg$ = Arg$ + ",&" + szParamToken$
        FPRINT Outfile, Scoot$;szParamToken$;"=0;"

      CASE vt_SINGLE
        CONCAT (Frmat$,"%g")
        Arg$ = Arg$ + ",&" + szParamToken$
        FPRINT Outfile, Scoot$;szParamToken$;"=0;"

      CASE vt_DOUBLE
        CONCAT (Frmat$,"%lG")
        Arg$ = Arg$ + ",&" + szParamToken$
        FPRINT Outfile, Scoot$;szParamToken$;"=0;"

      CASE vt_LDOUBLE
        CONCAT (Frmat$,"%lG")
        Arg$ = Arg$ + ",&" + szParamToken$
        FPRINT Outfile, Scoot$;szParamToken$;"=0;"

      CASE ELSE
        CONCAT (Frmat$,"%d")
        Arg$ = Arg$ + ",&" + szParamToken$
        FPRINT Outfile, Scoot$;szParamToken$;"=0;"
    END SELECT
  NEXT
END SUB ' CommonInputCode



SUB EmitInputCode()
  RAW Frmat$, Arg$, szWrk$
  RAW iThisToken = 2
  IF DataType(Stk$[iThisToken]) = vt_STRLIT THEN
    FPRINT Outfile, Scoot$;"printf(" ; Clean$(Stk$[iThisToken]) ; ");"
    iThisToken = 4
  END IF

  CALL BuildStr(iThisToken, Ndx, szWrk$)

  FastLexer(szWrk$, "", ",")

  CALL CommonInputCode(Frmat$, Arg$)

  FPRINT Outfile, Scoot$;"fgets(InputBuffer, sizeof(InputBuffer), stdin);"
  FPRINT Outfile, Scoot$;"InputBuffer[strlen(InputBuffer)-1]=0;"
  FPRINT Outfile, Scoot$;"ScanError = scan(InputBuffer,";ENC$(Frmat$);Arg$;");\n"
  FPRINT Outfile, Scoot$;"*InputBuffer=0;"
END SUB ' EmitInputCode



SUB EmitFileInputCode()
  DIM RAW Arg$
  DIM RAW Frmat$
  DIM RAW szWrk$
  RAW iThisToken
  RAW FHandle$

  FHandle$ =  ""

  CALL InputBufferFlags()

  iThisToken = 4                      ' Extract the file handle
  FOR INT j = 2 TO Ndx
    IF *Stk$[j] = ASC(",") THEN iThisToken=j+1 : EXIT FOR
    FHandle$ = FHandle$ + Stk$[j]
  NEXT

  CALL BuildStr(iThisToken, Ndx, szWrk$) ' build the variable list

  FastLexer(szWrk$, "", ",")

  CALL CommonInputCode(Frmat$, Arg$)

  FPRINT Outfile, Scoot$;"fgets(InputBuffer,";cMaxSrcLen;"," ; FHandle$ ; ");"
  FPRINT Outfile, Scoot$;"if(InputBuffer[strlen(InputBuffer)-1]== 10)"
  FPRINT Outfile, Scoot$;"   InputBuffer[strlen(InputBuffer)-1]=0;"
  FPRINT Outfile, Scoot$;"ScanError = scan(InputBuffer,";ENC$(Frmat$);Arg$;");\n"
  FPRINT Outfile, Scoot$;"*InputBuffer=0;"
END SUB ' EmitFileInputCode



SUB FinishingTouches()
  IF Use_Project = FALSE THEN
    IF Use_BCXMDialog OR Use_BCXDialog OR Use_Form OR Use_Button OR Use_BmpButton OR Use_Edit  OR _
      Use_BCX_Input  OR Use_Label OR Use_Group OR Use_Checkbox OR Use_Radio OR Use_Combobox OR _
      Use_Listbox OR Use_Treeview OR Use_Blackrect OR Use_Whiterect OR Use_Grayrect OR Use_Datepick  OR _
      Use_Richedit OR Use_Bitmap OR Use_BCX_OlePicture OR Use_Icon OR Use_Listview OR Use_BCX_Control OR _
      Use_ProgressBar OR Use_BCX_Slider OR Use_BCX_Splitter OR Use_BCX_Tab OR Use_BCX_Toolbar OR _
      Use_BCX_UpDown OR Use_Set_BCX_Icon OR Use_BCX_FrameWnd OR Use_BCX_Wnd OR Use_BCX_SetIcon OR _
      Use_BCX_SetIconSm OR Use_BCX_SetCursor OR Use_BCX_RegWnd OR Use_BCX_InitGUI THEN

      CALL AddBCX_hInstance()
    END IF
  END IF
END SUB



SUB AssembleParts()
  RAW Z$
  GLOBAL DoCountLines
  DoCountLines = TRUE

  CALL FinishingTouches()

  IF EXIST("$WRK$.TXT") THEN KILL "$WRK$.TXT"
  RENAME FileOut$, "$WRK$.TXT"

  IF UseCpp AND CmdLineFileOut$ = "" THEN
'jcfuller 1/29/2013
    'szTmp$ = EXTRACT$(FileOut$,".") + ".cpp"
    szTmp$ = RemoveExtension$(FileOut$) + ".cpp"
    KILL szTmp$
    FileOut$ = szTmp$
    'If IsBiFile Then
	'	FileOut$ = "dummy.txt"
    'End If
  END IF

  OPEN FileOut$ FOR OUTPUT AS FP_W
  CALL EmitProlog(FP_W)   '#include <windows.h>    // Win32 Header File - rewrite sub
  CALL Commandline_Defines(FP_W)
  CALL EmitUserDirectives(FP_W)
  CALL User_GLOBAL_ENUM_Blocks(FP_W)
  CALL System_Defined_Constants(FP_W)
  CALL User_Defined_Constants(FP_W)

  IF Use_Project = FALSE THEN
    IF Use_SingleFile = FALSE THEN
      OPEN HFile$ FOR OUTPUT AS fpHFile
    END IF
  END IF
  'IF _ZTRACE_ Then
	'If IsBiFile Then
		'ZPRINT(HFile$)
	'End If
  'End If

  CALL StdProtos(FP_W)  ' '<Standard Prototypes>
'jcfuller 08/12/2015
'problem with classes using system variables because the classes appear before
'the system variables.
'going to swap and see what happens
'  CALL User_Defined_Types_And_Unions(FP_W)
'  CALL SYSTEM_VARIABLES(FP_W)
  CALL SYSTEM_VARIABLES(FP_W)
  CALL User_Defined_Types_And_Unions(FP_W)


  IF Use_COM THEN
    EmitCOMSupportTypes(FP_W)
  END IF

  CALL User_Global_Variables(FP_W)
  CALL User_Data_Statements(FP_W)     'datFile$   ' translated DATA statements
  CALL AddMacros(FP_W)                'Standard Macros
  CALL User_Prototypes(FP_W)
  CALL User_Global_Initialized_Arrays(FP_W)
  CALL User_Overloaded_SubsFunctions(FP_W)    ' translated overloaded subs and functions
  CALL User_GLOBAL_SET_Statements(FP_W)       ' User GLOBAL SET Statements
  IF Use_Library THEN
    FPRINT FP_W,"// END BCXRTHEADER\n\n"
    FPRINT FP_W,"// ENDBCXRTLIBHEADER: "
  END IF

  IF Use_SingleFile = FALSE THEN
    CLOSE fpHFile
  END IF

  IF Use_SingleFile AND Use_Project = FALSE THEN
    CALL RunTimeFunctions(FP_W)
  ELSE
    IF Use_Project = FALSE THEN
      CALL SetFlags()             ' Write to Project$
    END IF
  END IF

  RAW bMain = Use_Wingui ORELSE MakeDLL ORELSE NoMain AS BOOL
  RAW bMainOut = FALSE AS BOOL

  IF LOF(ccodeFile$) THEN
    FPRINT FP_W, ""
    FPRINT FP_W, "// ************************************"
    FPRINT FP_W, "//       User C code"
    FPRINT FP_W, "// ************************************"
    FPRINT FP_W, ""
    OPEN ccodeFile$ FOR INPUT AS FP_R
    WHILE NOT EOF(FP_R)
      LINE INPUT FP_R, Z$
      FPRINT FP_W, Z$
    WEND
    CLOSE FP_R
  END IF

  IF EXIST(prcFile$) THEN
	RAW Last$
    FPRINT FP_W, ""
    FPRINT FP_W, "// *************************************************"
    FPRINT FP_W, "//       User Subs, Functions and Class Methods"
    FPRINT FP_W, "// *************************************************"
    FPRINT FP_W, ""
    OPEN prcFile$ FOR INPUT AS FP_R       'prcFile$   ' translated subs and functions
    WHILE NOT EOF(FP_R)
      LINE INPUT FP_R, Z$
'jcfuller fix for CALLBACK FUNCTION 6/10/2013
'Revoked 6/14/2013
      'IF INSTR(Z$,"DefWindowProc") THEN
        'IF  INSTR(Last$,"return ")  OR  _
          'INSTR(Last$,"CallWindowProc")  OR _
          'INSTR(Last$,"DefWindowProc")   OR _
          'INSTR(Last$,"DefMDIChildProc") OR _
          'INSTR(Last$,"DefFrameProc") THEN
          'Last$ = ""
          'ITERATE
        'END IF
      'END IF
      FPRINT FP_W, Z$
      IF LEFT$(Z$,2) <> "//" THEN
        Last$ = Z$
      END IF

      IF bMainOut THEN ITERATE
      bMainOut = CheckForMain(Z$, bMain)
    WEND
    CLOSE FP_R
  END IF

  IF Use_Wingui = FALSE AND NoMain = FALSE THEN
    IF Use_Library THEN
      FPRINT FP_W,"// BCXRTHEADER: MAIN PROGRAM"
    ELSE
      FPRINT FP_W,"// *************************************************"
      FPRINT FP_W,"//                  ";BCX_STR_MAIN_PROG$
      FPRINT FP_W,"// *************************************************"
      FPRINT FP_W,""
    END IF
  END IF

  OPEN "$WRK$.TXT" FOR INPUT AS FP_R
  WHILE NOT EOF(FP_R)
    LINE INPUT FP_R,Z$

    IF INSTR(Z$,"int main") THEN
      'IF Use_Wingui OR NoMain THEN
      IF bMain THEN
        ITERATE
      END IF
    END IF

    FPRINT FP_W, Z$
    IF bMainOut THEN ITERATE
    bMainOut = CheckForMain(Z$, bMain)

  WEND
  CLOSE FP_R
  KILL "$WRK$.TXT"

  CLOSE FP_W
  DoCountLines = FALSE
END SUB ' AssembleParts



FUNCTION CheckForMain(Z$, bMain AS BOOL)
  RAW bMainOut = FALSE AS BOOL
  'IF LEFT$(LTRIM$(Z$),8)  = "int main" OR LEFT$(LTRIM$(Z$),18) = "int WINAPI WinMain" OR LEFT$(LTRIM$(Z$),41) = "__declspec(dllexport) BOOL WINAPI DllMain" THEN
  IF LEFT$(LTRIM$(Z$),8)  = "int main" OR LEFT$(LTRIM$(Z$),18) = "int WINAPI WinMain" _
     OR LEFT$(LTRIM$(Z$),19) = "BOOL WINAPI DllMain" THEN
'lets do some testing
    IF bMain = FALSE THEN
'      PRINT "bMain = FALSE"
      FPRINT FP_W,"{"        ' AND OPEN the main FUNCTION
    END IF


    IF bMain THEN
'      PRINT "bMain = TRUE"
      LINE INPUT FP_R,Z$
      FPRINT FP_W,Z$
    END IF

    'IF (bMain = FALSE) AND (Use_Console = TRUE) AND (UseWinApi = TRUE) THEN
    'IF (bMain = FALSE) AND (Use_Console = TRUE) THEN
    IF (bMain = FALSE) AND Use_Console THEN
      FPRINT FP_W, Scoot$;"hConsole = GetStdHandle (STD_OUTPUT_HANDLE);"
    END IF

'------------------------------------------------------------------------------
'Let's see if this works
	IF LEFT$(STRIM$(Z$),8)  = "int main" THEN
'jcf need to address this
	If WxGui = _false OR WxCon = _false OR Use_MFC = FALSE  Then
	  FPRINT FP_W,"  g_argc = argc;"
	  FPRINT FP_W,"  g_argv = argv;"
	End If
	END IF
'------------------------------------------------------------------------------
    IF Use_StartupCode THEN
      FPRINT FP_W, Scoot$;"int BCX_SUCode = BCX_StartupCode_();  // execute user's startup code"
    END IF

    IF Use_ExitCode THEN
      FPRINT FP_W, Scoot$;"int BCX_EXCode = BCX_ExitCode_();     // Prepare for user's exit code"
    END IF

    IF UseLCaseTbl THEN
      FPRINT FP_W, Scoot$;"LowCase = (char*)calloc(257,1);"
      FPRINT FP_W, Scoot$;"LowCase = MakeLCaseTbl();"
    END IF

    IF DllCnt THEN
      RAW i

      FPRINT FP_W,""
      FPRINT FP_W,"// **********[ DLL Declarations ]**********"
      FPRINT FP_W,""

      '------------------------------------------------------------------------
      ' Emit LoadLibrary assignments
      ' HMODULE  H_DLLNAME = LoadLibrary("DLLNAME.DLL");
      ' Todo: Add a check for H_DLLNAME = NULL in case of failure to load the DLL.
      ' done
      '------------------------------------------------------------------------
      RAW szLoadLibHandle$
      FOR i = 1 TO LoadLibsCnt
'jcfuller 03/30/2015
        szLoadLibHandle$ = "H_"+UCASE$(RemoveExtension$(Loadlibs$[i]))
        'If Instr(szLoadLibHandle$,"-")Then
			'Replace "-" With "_" In szLoadLibHandle$
        'End If
        'If Instr(szLoadLibHandle$,".")Then
			'Replace "." With "_" In szLoadLibHandle$
        'End If
        If (Instr(szLoadLibHandle$,"-")) OR (Instr(szLoadLibHandle$,".")) Then
				szLoadLibHandle$ = ReplaceAny$(szLoadLibHandle$,"-.",Asc("_"))
        End If
        FPRINT FP_W,Scoot$;"HMODULE  ",szLoadLibHandle$," = LoadLibrary(", ENC$(Loadlibs$[i]), ");"
        FPRINT FP_W, Scoot$;"if(";szLoadLibHandle$;"==NULL) {"
        FPRINT FP_W, Scoot$;"MessageBox (GetActiveWindow(), ";ENC$("Failed to load library \\n" + Loadlibs$[i]);",";ENC$("Load Library Error");", 0 );"
        FPRINT FP_W, Scoot$;"return 1;"
        FPRINT FP_W, Scoot$;"  }"
      NEXT

      FOR i = 1 TO DllCnt
        FPRINT FP_W, Scoot$;DllDecl$[i]    ' Emit the users DLL Declarations
        RAW iEQ
        RAW szProcAddress$
        iEQ = INSTR(DllDecl$[i],"=")-1
        szProcAddress$ = LEFT$(DllDecl$[i],iEQ)
        FPRINT FP_W, Scoot$;"if(";szProcAddress$;"==NULL) {"
        FPRINT FP_W, Scoot$;"MessageBox (GetActiveWindow(), ";ENC$("Failed to find process \\n" + szProcAddress$);",";ENC$("Find Process Error");", 0 );"
        FPRINT FP_W, Scoot$;"return 1;"
        FPRINT FP_W, Scoot$;"  }"
      NEXT
      FPRINT FP_W,""
      FPRINT FP_W,"// ****************************************"
      FPRINT FP_W,""
    END IF
    bMainOut = TRUE
  END IF

  FUNCTION = bMainOut
END FUNCTION  ' CheckForMain



FUNCTION CheckLocal(szVariable$, BYREF varidx)
  DIM RAW szWrk$

  IF LocalVarCnt THEN
    szWrk$ = Clean$(szVariable$)
    RAW iBrack = INSTR(szWrk$,"[")
    IF iBrack THEN *(--iBrack + szWrk) = 0
    RemoveAll(szWrk$, " &*()", 1)
    FOR INTEGER iTokenLoc = LocalVarCnt TO 1 STEP -1
      IF szWrk$ = LocalVars[iTokenLoc].VarName$ THEN
        varidx = iTokenLoc
        FUNCTION = LocalVars[iTokenLoc].VarType
      END IF
    NEXT
  END IF
  FUNCTION = vt_UNKNOWN
END FUNCTION ' CheckLocal



FUNCTION CheckGlobal(szVariable$, BYREF varidx)
  DIM RAW iHasValue
  DIM RAW iTokenLoc
  DIM RAW szWork$

  szWork$ = Clean$(szVariable$)
  RemoveAll(szWork$, " &*()", 1)
  RAW iBrack = INSTR(szWork$,"[")
  IF iBrack THEN *(--iBrack + szWork) = 0
  iHasValue  = HashNumber(szWork$)

  WHILE GlobalVarHash[iHasValue]
    iTokenLoc = GlobalVarHash[iHasValue]
    IF szWork$ = GlobalVars[iTokenLoc].VarName$ THEN
      varidx = iTokenLoc
      FUNCTION = GlobalVars[iTokenLoc].VarType
    END IF
    iHasValue++
    iHasValue = IMOD(iHasValue,MaxGlobalVars)
  WEND
  FUNCTION = vt_UNKNOWN
END FUNCTION ' CheckGlobal



FUNCTION CheckType(ZZ$)
  DIM RAW Keyword$
  DIM RAW varid = 0
  DIM RAW i

  Keyword$ = TRIM$(LCASE$(ZZ$))

  i = FindWord(Keyword$, tTypes, WordsInTable(tTypes))
  IF i <> -1 THEN FUNCTION = tTypes[i].iType
  i = CheckLocal(ZZ$, &varid)
  IF i = vt_UNKNOWN THEN
    i = CheckGlobal(ZZ$, &varid)
    IF i = vt_UNKNOWN THEN
      i = DefsID(ZZ$)
      IF i THEN i = TypeDefs[i].TypeofDef
    END IF
  END IF
  FUNCTION = i
END FUNCTION ' CheckType



SUB ExportStringConst()
  RAW FP_SAVE AS FILE
  FP_SAVE = FP_CST
  FP_CST = FP_SYSCST
  Src$="CONST cSizeOfDefaultString = "+csSizeOfDefaultString$
  PassOne = TRUE
  CALL XFE(Src$)
  FP_CST = FP_SAVE
END SUB



SUB ExportInternalConst()
  IF Use_FillArray THEN
    RAW FP_SAVE AS FILE
    FP_SAVE = FP_CST
    FP_CST = FP_SYSCST
    Src$="CONST vt_INTEGER =  2"
    PassOne = TRUE
    CALL XFE(Src$)
    Src$="CONST vt_SINGLE  =  3"
    PassOne = TRUE
    CALL XFE(Src$)
    Src$="CONST vt_DOUBLE  =  4"
    PassOne = TRUE
    CALL XFE(Src$)
    Src$="CONST vt_LDOUBLE  =  5"
    PassOne = TRUE
    CALL XFE(Src$)
    FP_CST = FP_SAVE
  END IF
END SUB ' ExportInternalConst



FUNCTION RestrictedWords(ZZ$)
  IF ZZ$ = "CmdLine"    THEN FUNCTION = 1
  IF ZZ$ = "CmdShow"    THEN FUNCTION = 1
  IF ZZ$ = "hInst"      THEN FUNCTION = 1
  IF ZZ$ = "hPrev"      THEN FUNCTION = 1
  IF ZZ$ = "hWnd"       THEN FUNCTION = 1
  IF ZZ$ = "lParam"     THEN FUNCTION = 1
  IF ZZ$ = "Msg"        THEN FUNCTION = 1
  IF ZZ$ = "wParam"     THEN FUNCTION = 1
  IF ZZ$ = "vt_INTEGER" THEN FUNCTION = 1
  IF ZZ$ = "vt_SINGLE"  THEN FUNCTION = 1
  IF ZZ$ = "vt_DOUBLE"  THEN FUNCTION = 1
  IF ZZ$ = "vt_LDOUBLE" THEN FUNCTION = 1
  FUNCTION = 0
END FUNCTION ' RestrictedWords



FUNCTION DataType(ZZ$)
  DIM RAW Keyword$
  DIM RAW i

  IF ZZ[0] = c_DblQt THEN
    FUNCTION = vt_STRLIT
  END IF

  IF INCHR(ZZ$,"$") THEN
    FUNCTION = vt_STRVAR
  END IF

  IF IsNumber(ZZ$) THEN
    FUNCTION = vt_NUMBER
  END IF

  i = DefsID(ZZ$)
  IF i THEN
    FUNCTION = TypeDefs[i].TypeofDef
  END IF

  '****************
  '   Functions
  '****************

  Keyword$ = LCASE$(ZZ$)
  i = FindWord(Keyword$,tBcxWords,WordsInTable(tBcxWords))
  IF i <> -1 THEN FUNCTION = tBcxWords[i].iType

  IF INCHR(ZZ$,"%") THEN
    FUNCTION = vt_INTEGER
  END IF

  IF INCHR(ZZ$,"!") THEN
    FUNCTION = vt_SINGLE
  END IF

  IF INCHR(ZZ$,"#") THEN
    FUNCTION = vt_DOUBLE
  END IF

  IF INCHR(ZZ$,"^") THEN
    FUNCTION = vt_DOUBLE
  END IF

  IF INCHR(ZZ$,"`") THEN
    FUNCTION = vt_LDOUBLE
  END IF

  IF iMatchRgt(ZZ$,"@") THEN
    FUNCTION = vt_FILEPTR
  END IF

  IF INCHR(ZZ$," ") THEN
    FUNCTION = vt_UDT
  END IF

  IF isalpha(*ZZ$) THEN
    FUNCTION = vt_INTEGER
  END IF

  FUNCTION = vt_UNKNOWN
END FUNCTION ' DataType



SUB CloseAll()
  IF PPDLL_HANDLE THEN
    FreeLibrary(PPDLL_HANDLE)
    PPDLL_HANDLE = NULL
    PPProc = NULL
  END IF
  CLOSE   ' Flush and Close all open files
END SUB ' CloseAll



FUNCTION Clean$(ZZ$)
  DIM RAW Tmp$

  IF INCHR(ZZ$,"%") THEN
    IF TRIM$(ZZ$) = "%" THEN FUNCTION = " % "
  END IF

  IF iMatchNQ(ZZ$,"!=") THEN FUNCTION = ZZ$

  Tmp$ = ZZ$
  RemoveAll(Tmp$,VarTypes$,1)   '1 = ignore anything in quotes

  FUNCTION = Tmp$
END FUNCTION ' Clean$



'SUB RemoveAll OPTIONAL(Arg$, MatchChars$, qtflag=0)
SUB RemoveAll OPTIONAL(Arg$ , M As const char Ptr, qtflag=0)
  DIM RAW C = Arg AS PCHAR
  DIM RAW pmc AS PCHAR
  DIM MatchChars$
  MatchChars$ = M

  WHILE *Arg
    IF qtflag THEN
      IF *Arg = c_DblQt THEN
        *(C++) = *Arg
        WHILE *(++Arg) <> c_DblQt
          *(C++) = *Arg
          IF *Arg = 0 THEN EXIT SUB
        WEND
        *(C++) = *(Arg++)
        ITERATE
      END IF
    END IF

    pmc = MatchChars
    WHILE *pmc
      IF *(pmc++) = *Arg THEN GOTO SKIP
    WEND
    *(C++) = *Arg

SKIP:
    INCR Arg
  WEND
  *C = 0
END SUB



SUB WarningID OPTIONAL(iWarning, WarnLvl=0)
  SELECT CASE iWarning
    CASE eExitingMoreThan1Loop
      CALL Warning("Exiting more than one loop", WarnLvl)
  END SELECT
END SUB



'SUB Warning OPTIONAL(ZZ$, WarnLvl=0)
SUB Warning OPTIONAL(ZZZ As const char Ptr, WarnLvl=0)
  LOCAL fErr AS FILE
  DIM ZZ$
  ZZ$ = ZZZ
  IF WarnLvl THEN
    WarnMsg$ = WarnMsg$ + " Line" + STR$(ModuleLineNos[ModuleNdx]) + " in Module: " + TRIM$(Modules$[ModuleNdx]) + " - " + ZZ$
  ELSE
    WarnMsg$ = WarnMsg$ + ZZ$
  END IF

  WarnMsg$ = WarnMsg$ + CRLF$

  IF ErrFile THEN
    OPEN FileErr$ FOR APPEND AS fErr
    FPRINT fErr,"WARNING ";ZZ$
    CLOSE fErr
  END IF
END SUB ' Warnings



FUNCTION GetVarTypeName(i) AS LPSTR
  DIM STATIC A$
  SELECT CASE i
    CASE vt_INTEGER    :    A$ = "int"
    CASE vt_STRVAR     :    A$ = "char *"
    CASE vt_STRLIT     :    A$ = "STRLIT"
    CASE vt_UNKNOWN    :    A$ = "UNKNOWN"
    CASE vt_SINGLE     :    A$ = "float"
    CASE vt_DOUBLE     :    A$ = "double"
    CASE vt_LDOUBLE    :    A$ = "LDOUBLE"
    CASE vt_DECFUNC    :    A$ = "DECFUNC"
    CASE vt_NUMBER     :    A$ = "NUMBER"
    CASE vt_FILEPTR    :    A$ = "FILE*"
    CASE vt_UDT        :    A$ = "struct"
    CASE vt_STRUCT     :    A$ = "struct"
    CASE vt_UNION      :    A$ = "union"
    CASE vt_LPSTR      :    A$ = "LPSTR"
    CASE vt_BSTR       :    A$ = "BSTR"
'   CASE vt_BOOL       :    IF UseCpp THEN A$ = "bool" ELSE    A$ = "BOOL"
    CASE vt_BOOL       :    A$ = "BOOL"
    CASE vt_CHAR       :    A$ = "char"
    CASE vt_LPSTRPTR   :    A$ = "LPSTR *"
    CASE vt_CHARPTR    :    A$ = "char" ' Default String - 2048
    CASE vt_PCHAR      :    A$ = "PCHAR"
    CASE vt_VOID       :    A$ = "void"
    CASE vt_LONG       :    A$ = "long"
    CASE vt_DWORD      :    A$ = "DWORD"
    CASE vt_FARPROC    :    A$ = "FARPROC"
    CASE vt_LPBYTE     :    A$ = "LPBYTE"
    CASE vt_LRESULT    :    A$ = "LRESULT"
    CASE vt_BYTE       :    A$ = "BYTE"
    CASE vt_SHORT      :    A$ = "short"
    CASE vt_USHORT     :    A$ = "USHORT"
    CASE vt_COLORREF   :    A$ = "COLORREF"
    CASE vt_UINT       :    A$ = "UINT"
    CASE vt_ULONG      :    A$ = "ULONG"
    'CASE vt_ULLONG     :    A$ = "ULLONG"
    'per Wayne
    CASE vt_ULLONG     :    A$ = "ULONGLONG"
    CASE vt_LLONG      :    A$ = "long long"
    CASE vt_HWND       :    A$ = "HWND"
    CASE vt_HANDLE     :    A$ = "HANDLE"
    CASE vt_HINSTANCE  :    A$ = "HINSTANCE"
    CASE vt_HDC        :    A$ = "HDC"
    CASE vt_SAFEARRAY  :    A$ = "SAFEARRAY"
    CASE vt_VARIANT    :    A$ = "VARIANT"
    CASE vt_WNDCLASSEX :    A$ = "WNDCLASSEX"
    CASE vt_HFONT      :    A$ = "HFONT"
    CASE vt_DOCINFO    :    A$ = "DOCINFO"
    CASE vt_LOGFONT    :    A$ = "LOGFONT"
    CASE vt_TEXTMETRIC :    A$ = "TEXTMETRIC"
    CASE vt_WINBOOL    :    A$ = "BOOL"
    CASE ELSE          :    A$ = ""  'Assume the programmer has a brain
  END SELECT
  FUNCTION = A
END FUNCTION ' GetVarTypeName$



FUNCTION HashNumber(HT$)
  DIM RAW TT AS CHAR PTR
  DIM RAW i = 0 AS ULONG
  TT = HT
  WHILE *TT
    i <<= 1
    ! i ^= *TT;
    TT++
  WEND
  FUNCTION = IMOD(i,MaxGlobalVars)
END FUNCTION 'HashNumber



'SUB AddLibrary (LibName$)
SUB AddLibrary (LibName As const char Ptr)
  STATIC nTimes
  LOCAL nLibNdx
  DIM RAW TempLibName$
  'TempLibName$ = LCASE$(LibName$)
  TempLibName$ = LCASE$((char*)LibName)

  IF NOT INCHR(TempLibName$,DQ$) AND NOT INCHR(TempLibName$,"<") THEN
    TempLibName$ = ENC$(TempLibName$,60,62)
  END IF

  IF nTimes = 0 THEN
    FOR INTEGER i = 0 TO MaxLib - 1
      Library$[i] = ""
    NEXT
    nTimes++
    Library$[0] = TempLibName$
    EXIT SUB
  END IF

  nLibNdx = 0
  WHILE Library$[nLibNdx] <> ""
    IF Library$[nLibNdx] = TempLibName$ THEN EXIT SUB
    INCR nLibNdx
  WEND

  IF nLibNdx < MaxLib - 1 THEN
    Library$[nLibNdx] = TempLibName$
  ELSE
    CALL Abort("Maximum number of libraries exceeded. Currently MaxLib set to" & STR$(MaxLib))
  END IF
END SUB ' AddLibrary



SUB RemoveLibrary( LibName$ )
  IF NOT INSTR( RmLibs$, LibName$, 1, 1 ) THEN
    RmLibs$ = RmLibs$ + "," + LCASE$(LibName$)
  END IF
END SUB ' RemoveLibrary



SUB EmitLibs()
  STATIC IWasHere = 0
  STATIC nCount
  DIM RAW ltmp$
  IF NOT FirstTime(IWasHere) THEN EXIT SUB
  INCR IWasHere
  IF Library$[0] = "" THEN EXIT SUB
  XFOR INTEGER i = 0 WHILE i < MaxLib AND Library[i][0] BY i++
    ltmp$ = Library$[i]
    RemoveAll(ltmp$,"<>" & DQ$)
    IF INSTR( RmLibs$, ltmp$ ) THEN ITERATE ' skip libraries that have been removed
    IF nCount = 0 THEN
      INCR nCount
      FPRINT FP_HDR,""
      IF Use_Library THEN
        FPRINT FP_HDR,"// BCXRTHEADER: LINKER INSTRUCTIONS"
      ELSE
        FPRINT FP_HDR,"// *************************************************"
        FPRINT FP_HDR,"// Instruct Linker to Search Object/Import Libraries"
        FPRINT FP_HDR,"// *************************************************"
      END IF
'jcfuller changed
'removed LCC info
'      FPRINT FP_HDR,"#if !defined( __LCC__ )"
    END IF
    FPRINT FP_HDR,"#pragma comment(lib,",ENC$(ltmp$), ")"
  XNEXT

  If Use_BC9Dialog Then
    FPRINT FP_HDR,"#if defined( __POCC__ )"
    FPRINT FP_HDR,"#pragma comment(lib,",ENC$("pellescmem.lib"),")"
    FPRINT FP_HDR,"#endif"
  End If
  'FPRINT FP_HDR,"#else"
  '' add lccwin32's default libraries to the remove library list so they won't be emitted
  'RmLibs$ = RmLibs$ + ",<libc.lib>,<kernel32.lib>,<comdlg32.lib>,<user32.lib>,<gdi32.lib>,<advapi32.lib>,<comctl32.lib>,<crtdll.lib>"
  'XFOR INTEGER i = 0 WHILE i < MaxLib AND Library[i][0] BY i++
    'IF INSTR( RmLibs$, Library$[i] ) THEN ITERATE ' skip libraries that have been removed
    'IF nCount = 0 THEN
      'INCR nCount
      'IF Use_Library THEN
        'FPRINT FP_HDR,"// BCXRTHEADER: LINKER INSTRUCTIONS"
      'ELSE
        'FPRINT FP_HDR,"// *************************************************"
        'FPRINT FP_HDR,"// Instruct Linker to Search Object/Import Libraries"
        'FPRINT FP_HDR,"// *************************************************"
      'END IF
      'FPRINT FP_HDR,"#if !defined( __LCC__ )"
    'END IF
    'FPRINT FP_HDR,"#pragma lib ",Library$[i]
  'XNEXT

  IF nCount > 0 THEN
    'FPRINT FP_HDR,"#endif"
    IF Use_Library THEN
      FPRINT FP_HDR,"// END BCXRTHEADER\n\n"
    ELSE
      FPRINT FP_HDR,"// *************************************************"
      FPRINT FP_HDR,"// End of Object/Import Libraries To Search"
      FPRINT FP_HDR,"// *************************************************"
    END IF
  END IF

END SUB ' EmitLibs



'SUB AddGlobal(GlobalName$, GlobalType, GlobalDef, GlobalDim$, GlobalPtr, GlobalFS, GlobalExtn, iEmitted, iConst)
SUB AddGlobal(GName As const char Ptr, GlobalType, GlobalDef, GDim As const char Ptr, GlobalPtr, GlobalFS, GlobalExtn, iEmitted, iConst)
  DIM RAW FirstVar$
  DIM RAW SecondVar$
  DIM RAW Warn$
  DIM RAW GlobalNameHash
  DIM RAW s
  RAW ptGlobal AS VarInfo PTR
  DIM GlobalName$,GlobalDim$
  GlobalName$ = GName
  GlobalDim$ = GDim
  'IF Use_Project = TRUE THEN
  IF Use_Project THEN
    IF GlobalExtn = 0 THEN
      GlobalExtn = 2
    END IF
  END IF

  IF RestrictedWords(GlobalName$) AND TestState THEN
    Warn$ = "Restricted Word " + GlobalName$ + " on Line"
    Warn$ = Warn$ + STR$(ModuleLineNos[ModuleNdx]) + " in Module: " + TRIM$(Modules$[ModuleNdx])
    CALL Warning(Warn$)
  END IF

  GlobalNameHash = HashNumber(GlobalName$)


  WHILE GlobalVarHash[GlobalNameHash]
    s = GlobalVarHash[GlobalNameHash]
    ptGlobal = &GlobalVars[s]
    IF GlobalName$ = ptGlobal->VarName$ THEN
      IF InConditional = 0 OR (InConditional > 0 AND InIfDef$ = ptGlobal->VarCondDef$) THEN
        IF ptGlobal->VarType <> GlobalType OR _
          GlobalDim$ <> ptGlobal->VarDim$ OR _
          ptGlobal->VarDef <> GlobalDef THEN
          FirstVar$ = "Line" + STR$(ModuleLineNos[ModuleNdx]) + " in Module: " + TRIM$(Modules$[ModuleNdx]) + " : " + GlobalName$ + GlobalDim$ + " as " + GetVarTypeName$(GlobalType) + SPC$ + TypeDefs[GlobalDef].VarName$
          SecondVar$ = "Line" + STR$(ptGlobal->VarLine) + " in Module: " + ptGlobal->VarModule$ + " : " + GlobalName$ + ptGlobal->VarDim$ + " as " + GetVarTypeName$(ptGlobal->VarType) + SPC$ + TypeDefs[ptGlobal->VarDef].VarName$
          Warn$ = "Two Variables " + FirstVar$ + " previously defined at " + SecondVar$
          CALL Warning(Warn$)
        END IF
        EXIT SUB
      END IF
    END IF
    GlobalNameHash = IMOD(GlobalNameHash + 1,MaxGlobalVars)
  WEND

  GlobalVarCnt++
  IF GlobalVarCnt = MaxGlobalVars THEN Abort("Maximum Global Variables reached.")
  ptGlobal = &GlobalVars[GlobalVarCnt]
  ptGlobal->VarName$     =  GlobalName$
  ptGlobal->VarType      =  GlobalType
  ptGlobal->VarDef       =  GlobalDef
  ptGlobal->VarDim$      =  GlobalDim$
  ptGlobal->VarLine      =  ModuleLineNos[ModuleNdx]
  ptGlobal->VarPntr      =  GlobalPtr
  ptGlobal->VarSF        =  GlobalFS
  ptGlobal->VarEmitFlag  =  iEmitted
  ptGlobal->VarModule$   =  TRIM$(Modules$[ModuleNdx])
  ptGlobal->VarExtn      =  GlobalExtn
  ptGlobal->VarCondLevel =  InConditional
  ptGlobal->VarConstant  =  iConst
  ptGlobal->VarCondDef$  =  InIfDef$
  GlobalVarHash[GlobalNameHash] = GlobalVarCnt
  
  'If Not IsBc9 Then
	'If _ZTRACE_ Then
        'ZPRINT("ptGlobal->VarName$     =  " + GlobalName$)
        'ZPRINT("ptGlobal->VarType      =  " + Str$(GlobalType))
		'ZPRINT("ptGlobal->VarDef       =  " + Str$(GlobalDef))
        'ZPRINT("ptGlobal->VarDim$      =  " + GlobalDim$)
		'ZPRINT("ptGlobal->VarLine      =  " + Str$(ModuleLineNos[ModuleNdx]))
		'ZPRINT("ptGlobal->VarPntr      =  " + Str$(GlobalPtr))
		'ZPRINT("ptGlobal->VarSF        =  " + Str$(GlobalFS))
		'ZPRINT("ptGlobal->VarEmitFlag  =  " + Str$(iEmitted))
		'ZPRINT("ptGlobal->VarModule$   =  " + TRIM$(Modules$[ModuleNdx]))
		'ZPRINT("ptGlobal->VarExtn      =  " + Str$(GlobalExtn))
		'ZPRINT("ptGlobal->VarCondLevel =  " + Str$(InConditional))
		'ZPRINT("ptGlobal->VarConstant  =  " + Str$(iConst))
		'ZPRINT("ptGlobal->VarCondDef$  =  " + InIfDef$)
		'ZPRINT("*************************************")
    'End If
  'End If
END SUB ' AddGlobal



'SUB AddLocal(LocalName$, LocalType, LocalDef, LocalDim$, LocalPtr, LocalFS, iEmitted, iConst)
SUB AddLocal(LocalName$, LocalType, LocalDef, LDim As const char Ptr, LocalPtr, LocalFS, iEmitted, iConst)
  DIM RAW varid = 0
  DIM RAW FirstVar$
  DIM RAW SecondVar$
  DIM RAW Warn$
  DIM RAW s
  DIM RAW LocalDim$
  LocalDim$ = LDim
  IF LocalVarCnt AND TestState THEN
    IF CheckGlobal(LocalName$, &varid) <> vt_UNKNOWN THEN

      IF LocalDef THEN
        FirstVar$ = "Line" + STR$(ModuleLineNos[ModuleNdx]) + " in Module: " + TRIM$(Modules$[ModuleNdx]) + " : " + LocalName$ + LocalDim$ + " as " + TypeDefs[LocalDef].VarName$
      ELSE
        FirstVar$ = "Line" + STR$(ModuleLineNos[ModuleNdx]) + " in Module: " + TRIM$(Modules$[ModuleNdx])  + " : " + LocalName$ + LocalDim$ + " as " + GetVarTypeName$(LocalType)
      END IF

      IF GlobalVars[varid].VarDef THEN
        SecondVar$ = "Line" + STR$(GlobalVars[varid].VarLine) + " in Module: " + GlobalVars[varid].VarModule$ + " : " + LocalName$ + GlobalVars[varid].VarDim$ + " as " + TypeDefs[GlobalVars[varid].VarDef].VarName$
      ELSE
        SecondVar$ = "Line" + STR$(GlobalVars[varid].VarLine) + " in Module: " + GlobalVars[varid].VarModule$ + " : " + LocalName$ + GlobalVars[varid].VarDim$ + " as " + GetVarTypeName$(GlobalVars[varid].VarType)
      END IF
      Warn$ = "Local Variable " + FirstVar$ + CRLF$ + "Has Same Name as Global " + SecondVar$
      CALL Warning(Warn$)
    END IF

    FOR s = 1 TO LocalVarCnt
      IF LocalName$ = LocalVars[s].VarName$ THEN
        IF LocalVars[s].VarType <> LocalType OR LocalDim$ <> LocalVars[s].VarDim$ OR LocalVars[s].VarDef <> LocalDef THEN
          FirstVar$ = "Line" + STR$(ModuleLineNos[ModuleNdx]) + " in Module: " + TRIM$(Modules$[ModuleNdx]) + " : " + LocalName$ + LocalDim$ + " as " + GetVarTypeName$(LocalType) + SPC$ + TypeDefs[LocalDef].VarName$
          SecondVar$ = "Line" + STR$(LocalVars[s].VarLine) + " in Module: " + LocalVars[s].VarModule$ + " : " + LocalName$ + LocalVars[s].VarDim$ + " as " + GetVarTypeName$(LocalVars[s].VarType) + SPC$ + TypeDefs[LocalVars[s].VarDef].VarName$
          Warn$ = "Two Variables " + FirstVar$ + " previously defined at " + SecondVar$
          CALL Warning(Warn$)
        END IF
        EXIT SUB
      END IF
    NEXT
  END IF

  LocalVarCnt++

  IF LocalVarCnt = MaxLocalVars THEN
    Warn$ = "Maximum Local Variables reached."
    Abort(Warn$)
  END IF

  LocalVars[LocalVarCnt].VarName$  =  LocalName$
  LocalVars[LocalVarCnt].VarType   =  LocalType
  LocalVars[LocalVarCnt].VarDef    =  LocalDef
  LocalVars[LocalVarCnt].VarDim$   =  LocalDim$
  LocalVars[LocalVarCnt].VarLine   =  ModuleLineNos[ModuleNdx]
  LocalVars[LocalVarCnt].VarPntr   =  LocalPtr
  LocalVars[LocalVarCnt].VarSF     =  LocalFS
  LocalVars[LocalVarCnt].VarEmitFlag  =  iEmitted
  LocalVars[LocalVarCnt].VarConstant  =  iConst
  LocalVars[LocalVarCnt].VarModule$=  TRIM$(Modules$[ModuleNdx])
END SUB ' AddLocal


$comment
FUNCTION IsHexNumber(a$)
  DIM szA AS CHAR PTR
  szA = a
  IF NOT iMatchLft(szA$,"&h") THEN FUNCTION = FALSE
  szA += 2
  WHILE *szA
    ' Test for 0123456789A-F
    IF NOT isxdigit(*szA) THEN
      FUNCTION = FALSE
    END IF
    szA++
  WEND
  FUNCTION = TRUE
END FUNCTION ' IsHexNumber
$comment


FUNCTION IsNumber(szToken$)
  IF NOT szToken THEN FUNCTION = FALSE      ' Handle null arguments
  RAW pszToken = szToken AS PCHAR
  WHILE *pszToken                           ' While NOT null terminator
    IF *pszToken>47 AND *pszToken<58 THEN   ' Test for 0123456789
      pszToken++                          ' bump our index
    ELSE
      FUNCTION = FALSE                      ' szToken$ is not a number
    END IF
  WEND
  FUNCTION = TRUE                           ' szToken$ is a number
END FUNCTION ' IsNumber



FUNCTION IsNumberEx(szToken$)
  IF NOT szToken THEN FUNCTION = FALSE      ' Handle null arguments
  RAW pszToken = szToken AS PCHAR
  RAW iDecpt AS INT
  RAW iExp AS INT
  iExp = iDecpt = 0
  IF *pszToken = 43 OR *pszToken = 45 THEN
    pszToken++
  END IF
  IF *pszToken = 46 THEN iDecpt++
  WHILE *pszToken                           ' While NOT null terminator
    IF ((*pszToken>47 AND *pszToken<58) OR *pszToken = 46 OR *pszToken = 69 OR *pszToken = 101) AND iDecpt < 2 AND iExp < 2 THEN   ' Test FOR -+.0123456789  43 45 46 69 101
      IF *pszToken = 46 THEN iDecpt++
      IF *pszToken = 69 OR *pszToken = 101 THEN iExp++
      pszToken++                          ' bump our index
    ELSE
      FUNCTION = FALSE                        ' szToken$ is not a number
    END IF
  WEND
  FUNCTION = TRUE                             ' szToken$ is a number
END FUNCTION ' IsNumberEx



SUB StripTabs()
  RAW pszSrc = Src AS PCHAR
  RAW iQuoteFlag = 0
  WHILE *pszSrc
    IF *pszSrc = c_DblQt THEN iQuoteFlag = iQuoteFlag XOR 1
    IF *pszSrc = 9 AND NOT iQuoteFlag THEN *pszSrc = 32
    pszSrc++
  WEND
END SUB ' StripTabs



SUB PushFileIO()
  FPtr[++FPtrNdx] = SourceFile
END SUB 'PushFileIO



SUB PopFileIO()
  IF FPtrNdx > 0 THEN
    CLOSE SourceFile
    INCR LinesRead, ModuleLineNos[ModuleNdx--]
    SourceFile = FPtr[FPtrNdx--]
  END IF
END SUB ' PopFileIO



'FUNCTION Inset(Mane$,Match$)
FUNCTION Inset(Mane As const char Ptr,Match As const char Ptr)
  DIM RAW i = -1, j = -1
  WHILE Match[++i]
    WHILE Mane[++j]
      IF Match[i] = Mane[j] THEN FUNCTION = TRUE
    WEND
    j = -1
  WEND
  FUNCTION = FALSE
END FUNCTION 'Inset



SUB CheckParQuotes()
  DIM RAW CountR=0 'Round bracket counter
  DIM RAW CountS=0 'Square bracket counter
  DIM RAW DoCount=TRUE AS BOOL
  RAW pszSrc AS PCHAR
  pszSrc = Src
  WHILE *pszSrc
    IF *pszSrc = c_DblQt THEN
        DoCount = NOT DoCount
    END IF
    IF DoCount THEN
      SELECT CASE *pszSrc
        CASE c_LPar : CountR++
        CASE c_RPar : CountR--
        CASE c_LtBkt : CountS++
        CASE c_RtBkt : CountS--
      END SELECT
    END IF
    pszSrc++
  WEND
  IF NOT DoCount THEN CALL Abort ("Unmatched Quotes")
  IF CountS THEN CALL Abort ("Unmatched []")
  IF CountR THEN CALL Abort ("Unmatched ()")
END SUB ' CheckParQuotes



SUB ClearIfThenStacks()
  XFOR INTEGER i = 0 WHILE i < cMaxSingleLineIFLines BY i++
    SrcStk$[i] = ""
  XNEXT
  SrcCnt = 0
END SUB ' ClearIfThenStacks



'SUB AddExpressionToStack(szAssembledExpression$)
SUB AddExpressionToStack(szAssembledExpression As const char Ptr)
  IF SrcCnt = cMaxSingleLineIFLines-1 THEN CALL Abort("Single line conversion to multi-line stack exceeds limit.")
  SrcStk$[++SrcCnt] = szAssembledExpression$        'Assemble our expression
END SUB ' AddExpressionToStack



'SUB Add2SplitLines(szSplitLine$)
SUB Add2SplitLines(szSplitLine As const char Ptr)
  IF SplitCnt = cMaxSplitLines-1 THEN CALL Abort("Maximum line splitting exceeded.")
  SplitStk$[++SplitCnt] = szSplitLine$
END SUB



FUNCTION IsQuoted(ZZ$)
  IF NOT iMatchLft(LTRIM$(ZZ$),DQ$) THEN FUNCTION = FALSE
  IF NOT iMatchRgt(RTRIM$(ZZ$),DQ$) THEN FUNCTION = FALSE
  FUNCTION = TRUE
END FUNCTION ' IsQuoted
'==============================================================================
'Function to quote $FILE$ and $FILE$.xxx
'Cmd$ is string with $FILE$
'f$ = $FILE$ replacement
'------------------------------------------------------------------------------
Function QtFile$(c$,f$)
	DIM c2$,t2$
	DIM jt AS Integer
	
    jt = 0

    DO
      t2$ = STRTOKEN$(c$," ",++jt)
      IF LEN(t2$) THEN

        IF INSTR(t2$,"$FILE$",0,1) THEN
          IREPLACE "$FILE$" WITH f$ IN t2$
          c2$ = c2$ & " " & DQ$ & t2$ & DQ$
        ELSE
          c2$ = c2$ & " " & t2$
        END IF

      ELSE
        EXIT LOOP
      END IF
    LOOP
    Function = c2$
End Function
'==============================================================================

'Have the same problem with linker$,compiler$,resource$ and DQ$'s around $FILE$.xxx as
'was the case with $ONEXIT.
SUB PostProcess()
  'IF ReDirect = TRUE THEN
  IF ReDirect THEN
    RAW Z$, FP1 AS FILE
    OPEN FileOut$ FOR INPUT AS FP1
    WHILE NOT EOF(FP1)
      LINE INPUT FP1,Z$
      PRINT Z$
    WEND
    CALL CloseAll()
  END IF
  '**************************
  'PRINT "PostProcess Start"
  OutfileClone$ = FileOut$
  FOR INTEGER A = 1 TO EntryCnt
'jcfuller 1/29/2013
    'OutfileClone$ = EXTRACT$(OutfileClone$,".")
    OutfileClone$ = RemoveExtension$(OutfileClone$)
    Cmd$ = REMOVE$(Entry$[A],DQ$)
    REPLACE "\\\\" WITH "\\" IN Cmd$
    'IREPLACE "$file$"  WITH EXTRACT$(OutfileClone$,".") IN Cmd$
    IREPLACE "$file$"  WITH RemoveExtension$(OutfileClone$) IN Cmd$

    IREPLACE "$PELLES$\\" WITH PELLESPATH$ IN Cmd$
    IREPLACE "$PELLES$"   WITH PELLESPATH$ IN Cmd$

    IREPLACE "$LCC$\\" WITH LCCPATH$ IN Cmd$
    IREPLACE "$LCC$"   WITH LCCPATH$ IN Cmd$

    IREPLACE "$BCX$\\" WITH BCXPATH$ IN Cmd$
    IREPLACE "$BCX$"   WITH BCXPATH$ IN Cmd$
    PRINT "Shelling Out To:", Cmd$
    SHELL Cmd$
  NEXT

  IF Compiler$ <> "" THEN
    OutfileClone$ = RemoveExtension$(FileOut$)
    Compiler$ = TRIM$(REMOVE$(Compiler$,DQ$))

    IF INCHR(Compiler$, SPC$) THEN
      Compiler$ = EXTRACT$(Compiler$,SPC$) + SPC$ +  REMAIN$(Compiler$,SPC$)
'jcfuller 1/31/2013
    'ELSE
    '  Compiler$ = ENC$(Compiler$)
    END IF

    IREPLACE "$PELLES$\\" WITH PELLESPATH$ IN Compiler$
    IREPLACE "$PELLES$"   WITH PELLESPATH$ IN Compiler$

    IREPLACE "$LCC$\\" WITH LCCPATH$ IN Compiler$
    IREPLACE "$LCC$"   WITH LCCPATH$ IN Compiler$
'jcfuller 1/31/2013
    Compiler$ = QtFile$(Compiler$,OutfileClone$)

    REPLACE "\\\\" WITH "\\" IN Compiler$
    REPLACE DDQ$   WITH DQ$  IN Compiler$
    PRINT "Shelling Out To:", Compiler$
    SHELL Compiler$
  END IF

  '**************************

  IF ResCompiler$ <> "" THEN
  OutfileClone$ = RemoveExtension$(FileOut$)
  ResCompiler$ = TRIM$(REMOVE$(ResCompiler$,DQ$))
'jcfuller 1/31/2013
ResCompiler$ = ResCompiler$ + SPC$ + ENC$(Res_File$)

    IREPLACE "$PELLES$\\" WITH PELLESPATH$ IN ResCompiler$
    IREPLACE "$PELLES$"   WITH PELLESPATH$ IN ResCompiler$

    IREPLACE "$LCC$\\" WITH LCCPATH$ IN ResCompiler$
    IREPLACE "$LCC$"   WITH LCCPATH$ IN ResCompiler$
'jcfuller 1/31/2013
    ResCompiler$ = QtFile$(ResCompiler$,OutfileClone$)
    REPLACE "\\\\" WITH "\\" IN ResCompiler$
    REPLACE DDQ$   WITH DQ$  IN ResCompiler$
    PRINT "Shelling Out To:", ResCompiler$
    SHELL ResCompiler$
  END IF

  '**************************

  IF Linker$ <> "" THEN
    OutfileClone$ = RemoveExtension$(FileOut$)
    Linker$ = TRIM$(REMOVE$(Linker$,DQ$))

    IF INCHR(Linker$, SPC$) THEN
'jcfuller 1/31/2013
      'Linker$ = DQ$ + EXTRACT$(Linker$,SPC$) + DQ$ + SPC$ + REMAIN$(Linker$,SPC$)
      Linker$ = EXTRACT$(Linker$,SPC$) + SPC$ + REMAIN$(Linker$,SPC$)
    'ELSE
    '  Linker$ = ENC$(Linker$)
    END IF

    IREPLACE "$PELLES$\\" WITH PELLESPATH$ IN Linker$
    IREPLACE "$PELLES$"   WITH PELLESPATH$ IN Linker$

    IREPLACE "$LCC$\\" WITH LCCPATH$ IN Linker$
    IREPLACE "$LCC$"   WITH LCCPATH$ IN Linker$
'jcfuller 1/31/2013
    Linker$ = QtFile$(Linker$,OutfileClone)
    REPLACE "\\\\" WITH "\\" IN Linker$
    REPLACE DDQ$   WITH DQ$  IN Linker$

    IF Use_Resource THEN
      ResFileOut$ = RemoveExtension$(Res_File$) + ".res"
      Linker$ = Linker$ + SPC$ + ENC$(ResFileOut$)
    END IF

    PRINT "Shelling Out To:", Linker$
    SHELL Linker$
  END IF
  '**************************
  'need to enclose $FILE$ plus any addon chars in Double quotes
  FOR INTEGER A = 1 TO XitCount
    OutfileClone$ = RemoveExtension$(FileOut$)
    Cmd$ = REMOVE$(Xit$[A],DQ$)
    Cmd$ = QtFile$(Cmd$,OutfileClone$)

    IREPLACE "$PELLES$\\" WITH PELLESPATH$ IN Cmd$
    IREPLACE "$PELLES$"   WITH PELLESPATH$ IN Cmd$
    IREPLACE "$LCC$\\" WITH LCCPATH$ IN Cmd$
    IREPLACE "$LCC$"   WITH LCCPATH$ IN Cmd$
    IREPLACE "$BCX$\\" WITH BCXPATH$ IN Cmd$
    IREPLACE "$BCX$"   WITH BCXPATH$ IN Cmd$
    REPLACE "\\\\" WITH "\\" IN Cmd$
    REPLACE DDQ$ WITH DQ$ IN Cmd$
'jcf added 2/1/2016
    REPLACE "\\q" WITH Chr$(34) IN Cmd$
    PRINT "Shelling Out To:", Cmd$
    SHELL Cmd$
  NEXT
END SUB ' PostProcess


SUB XT1E(szLine$)
  CALL XParse(szLine$)
  CALL TokenSubstitutions(1)
  CALL EmitMain()
END SUB



SUB XFE(szLine$)
  CALL XParse(szLine$)
  CALL FixUps()
  CALL EmitMain()
END SUB ' XFE



FUNCTION Convert2SimpleFunction(Tmp AS INT)
  RAW iNextToken = (++Tmp + 1)
  RAW iRetVal = 0
  IF Stk$[Tmp]= "(" AND Stk$[iNextToken]= ")" THEN
    Stk$[Tmp] = ""
    Stk$[iNextToken] = ""
    iRetVal++
  END IF
  FUNCTION = iRetVal
END FUNCTION



SUB XParse(Arg$)
  DIM RAW lszTmp$
  DIM RAW j, i = 0, Gapflag = FALSE
  DIM RAW InIF = 0
  RAW InXFOR = 0

  IF TRIM$(Arg$) = "" THEN
    Ndx = 0
    EXIT SUB
  END IF

  '-----------------------------------------------
  ' A temporary cure to allow the C '&&' operator
  '-----------------------------------------------
  i = iMatchNQ(Arg$, "&&")
  WHILE i

    Arg$ = DEL$(Arg$, i, 2)
    'Arg$ = INS$(Arg$, i, " and ")
'jcfuller 5-19-2013
    Arg$ = INS$(Arg$, i, " __RVR__ ")
    i = iMatchNQ(Arg$, "&&")

  WEND
  '-----------------------------------------------

  FastLexer(Arg$, SPC$, "=&()[]{}',+-*/<>?;.|:^")

  '****************************************
  '              Pre Parse
  '****************************************
  WHILE ++i < 17
    Stk$[i+Ndx] = ""
  WEND

  ' Transform "end with" to endwith
  IF iMatchWrd(Stk$[1],"end") THEN
    RAW szTmp$
    szTmp$ = ENC$(LCASE$(Stk$[2]),ASC(" "))
    IF iMatchNQ(" events , mdievents , mdichildevents ", szTmp$) THEN
      Stk$[1] = "end"+LCASE$(Stk$[2])
      IF iMatchWrd(Stk$[3], "main" ) THEN Use_MainEvent = TRUE
      Ndx=1
      Src$ = Stk$[1]
      EXIT SUB
    END IF
    IF Stk$[2] <> "=" AND Ndx = 2 THEN
      IF iMatchWrd(Stk$[2],"dialog") THEN Stk$[2] = "function"
      Stk$[1] = "end"+LCASE$(Stk$[2])
      Ndx=1
      Src$ = Stk$[1]
      EXIT SUB
    END IF
  END IF

  IF iMatchWrd(Stk$[1],"end") AND iMatchWrd(Stk$[2],"prepend") THEN
    Stk$[1] = "endprepend"
    Src$ = Stk$[1]
    Ndx=1
    EXIT SUB
  END IF

  IF iMatchWrd(Stk$[1],"end") AND iMatchWrd(Stk$[2],"with") THEN
    Stk$[1] = "endwith"
    Src$ = Stk$[1]
    Ndx=1
    EXIT SUB
  END IF

  RAW iP = 1
  IF iMatchWrd(Stk$[iP],"public") OR iMatchWrd(Stk$[iP],"private") THEN iP++
  IF (iMatchWrd(Stk$[iP],"function") OR iMatchWrd(Stk$[iP],"catch") OR iMatchWrd(Stk$[iP],"sub")) AND INSTR(Arg$,"*") THEN
    XFOR INT i = 2, INT j = 1 WHILE i < Ndx-1 AND j BY i++
      j = GetAsPosF(i, Ndx-2)
      IF j THEN
        i = j
        IF iMatchWrd(Stk$[i+1],"const") THEN i++

        WHILE *Stk$[i+2] = ASC("*")
          Stk$[i+2] = "PTR"
          i++
        WEND
      END IF
    XNEXT
    CALL BuildDelimStr(1,Ndx,Src$)
    FastLexer(Src$, SPC$, "=&()[]{}',+-*/<>?;.|:^")
    Arg$ = Src$
  END IF

  Gapflag = FALSE
  FOR i = 1 TO Ndx
    IF IsNumberEx(Stk$[i]) AND Stk[i][1] THEN
      Keyword1$ = UCASE$(RIGHT$(Stk$[i],1))
      IF Keyword1$ = "E" THEN
        CONCAT(Stk$[i], Stk$[i+1]) : Stk$[i+1] = ""
        CONCAT(Stk$[i], Stk$[i+2]) : Stk$[i+2] = ""
        IF Stk$[i-1] = "-" THEN CONCAT(Stk$[i-1], Stk$[i]) : Stk$[i] = ""
        Gapflag = TRUE
      END IF
    END IF
  NEXT

  'IF Gapflag = TRUE THEN CALL RemEmptyTokens()
  IF Gapflag THEN CALL RemEmptyTokens()

  FOR i = 1 TO Ndx
    Keyword1$ = LCASE$(Stk$[i])

    IF Keyword1[1] <> 0 THEN
      SELECT CASE Keyword1$
        CASE "not"  : Stk$[i] = "!"
        CASE "is"   : Stk$[i] = "="
        CASE "xor"  : Stk$[i] = "xor"

        CASE "if","iif","iif$","case","elseif","while"
        InIF = 1
        IF Keyword1$ = "case" AND iMatchWrd(Stk$[i+1],"else") THEN
          Stk$[i] = "caseelse" : Stk$[i+1] = "" : Gapflag = TRUE
        ELSE
          Stk$[i] = Keyword1$
        END IF

        CASE "xfor"
        InXFOR = 1

        CASE "until"
        InIF = InXFOR
        InXFOR = 0

        CASE "by"
        InIF = 0

        CASE "then"
        InIF = 0

        CASE "byval", "let"
        Stk$[i] = ""
        Gapflag = TRUE

        CASE "shl"
        Stk$[i] = "<<"

        CASE "shr"
        Stk$[i] = ">>"

        CASE "byref"
        IF NOT iMatchWrd(Stk$[1], "declare") AND _
          NOT iMatchWrd(Stk$[1], "c_declare") THEN
          IF ByrefCnt = cMaxByref-1 THEN CALL Abort("Maxium number of BYREFs reached.")
          ByrefVars$[++ByrefCnt] = Stk$[i+1]
        END IF

        RAW iDontHaveAs = 1

        FOR j = i TO Ndx
          IF iMatchWrd(Stk$[j],"as") THEN iDontHaveAs = 0
          IF Stk$[j+1] = "," OR Stk$[j+1] = ")" THEN
            Stk$[j] = "PTR"
            IF iDontHaveAs THEN
              InsertTokens(j-1, 2, "as", VarTypeLookup$[ INCHR(VarTypes$, RIGHT$(ByrefVars$[ByrefCnt],1)) ])
            END IF
            EXIT FOR
          END IF
          Stk$[j] = Stk$[j+1]
        NEXT

        CASE "and"
          Stk$[i] = "&&"

        CASE "or"
          Stk$[i] = "||"

        CASE "procedure"
          Stk$[i] = "sub"

        CASE ELSE
        IF PassOne THEN
          IF Keyword1$ = ENC$(CHR$(92)) THEN
            IF *Stk$[i+1] <> c_DblQt THEN
              Stk$[i] = "chr$"
              InsertTokens(i, 3, "(", "92", ")")
              INCR i,3
            ELSE
              CONCAT(Stk$[i],Stk$[i+1])
              Stk$[i+1] = ""
              Gapflag = TRUE
            END IF
          ELSE
            IF  TranslateSlash THEN
              REPLACE "\\" WITH "\\\\" IN Stk$[i]
            END IF
          END IF
        END IF
      END SELECT

      '*******************************************************************
      '  Allow logical 'OR/AND' to be used as 'binary BOR/BAND'
      '*******************************************************************
      IF NOT InIF THEN
        IF Stk$[i] = "&&" THEN

          Stk$[i] = "BAND"
        ELSE
          IF Stk$[i] = "||" THEN
            Stk$[i] = "BOR"
          END IF
        END IF
      END IF

    ELSE
      SELECT CASE ASC(Keyword1$)
        ' --------------------------------
        ' Connect (&)addressof operator.
        ' --------------------------------
        CASE ASC("&")
        'IF i < 3 OR INCHR("+&,(=", Stk$[i-1]) THEN
        IF INCHR("+&,(=", Stk$[i-1]) AND *Stk$[i+1] <> ASC(".") THEN
          Stk$[i+1] = " &" + Stk$[i+1]
          Stk$[i] = "" : Gapflag=TRUE
        END IF

        CASE ASC("?")
          IF i = 1 OR (i > 1 AND Stk$[i-1] = ":") THEN
            Stk$[i] = "print"
          END IF

        CASE ASC("-")
        IF ASC(Stk$[i+1]) = ASC(">") THEN
          Stk$[i] = "->" & Stk$[i+2]
          Stk$[++i] = "" : Stk$[++i] = ""
          Gapflag=TRUE
        END IF

        CASE ASC(".")
        IF ASC(Stk$[i+1]) = 46 AND ASC(Stk$[i+2]) = 46 THEN   ' ...
          Stk$[i] = "..."
          Stk$[i+1] = ""
          Stk$[i+2] = ""
          Gapflag=TRUE
        END IF
        IF IsNumber(Stk$[i-1]) THEN
          Stk$[i] = Stk$[i-1] & "."
          Stk$[i-1] = "" : Gapflag=TRUE
        END IF

        IF NOT INCHR( ",)=<>*/+-^" , Stk[i+1]) THEN
          Stk$[i] = Stk$[i] & Stk$[i+1]
          Stk$[++i] = "" : Gapflag=TRUE
        END IF

      END SELECT
    END IF
  NEXT

  'IF Gapflag = TRUE THEN CALL RemEmptyTokens()
  IF Gapflag THEN CALL RemEmptyTokens()

  ' *******************************************************************
  ' Special Case Handler: BYREF - BCX prepends * to BYREF'd Variables
  ' *******************************************************************
  'IF PassOne = TRUE THEN
  IF PassOne THEN
    'IF InFunc THEN                      ' Must be in a SUB or FUNCTION
     IF InFunc <> eNotInOne THEN         ' Must be in a SUB or FUNCTION
      FOR i = 1 TO Ndx
        FOR j = 1 TO ByrefCnt
          IF iMatchLft(Stk$[i], " &") THEN lszTmp$ = Stk$[i] + 2 ELSE lszTmp$ = Stk$[i]
          IF Clean$(lszTmp$) = Clean$(ByrefVars[j]) THEN

            IF i > 2 THEN
              IF INCHR("+-^%*/|&<=>,", Stk$[i-2]) AND Stk$[i-1] = "*" THEN
                Stk$[i-1] = ""
                Gapflag = TRUE
              END IF

              IF iMatchLft(Stk$[i], " &") THEN
                Stk$[i] = Stk$[i] + 2
                EXIT FOR
              END IF

            ELSEIF i = 2 THEN
              IF Stk$[i-1] = "*" THEN Stk$[i-1] = "" : Gapflag = 1
            END IF

            Stk$[i] = "*" & Stk$[i]
            IF Stk$[i-1] <> "(" OR Stk$[i+1] <> ")" THEN
              Stk$[i] = ENC$(Stk$[i], ASC("("), ASC(")"))
            END IF
            EXIT FOR
          END IF
        NEXT
      NEXT
    END IF
    IF Gapflag THEN CALL RemEmptyTokens()
  END IF

  ' *******************************************************************
  ' Special Case Handler: DIM BLAHBLAH[22][33] AS STATIC INTEGER
  ' *******************************************************************

  IF iMatchWrd(Stk$[1],"dim") THEN
    IF iMatchWrd(Stk$[Ndx-1],"static") THEN
      Stk$[1] = "static"
      Stk$[Ndx-1] = Stk$[Ndx]
      Ndx--
    END IF
  END IF

  ' ***********************************
  ' Used in special case hanflers.
  ' ***********************************
  Keyword1$ = LCASE$(Stk$[1])


  ' ***************************************************************************
  ' Special Case Handler: In the contexts of UDT,s this handler transforms:
  ' FUNCTION Foo (a as integer) AS INTEGER         to:
  ' DIM FUNCTION Foo (a as integer) AS INTEGER
  '
  ' Change "as string" to "as char *" for UDTs and Declarations
  ' ***************************************************************************

  IF InTypeDef AND NOT InClassModule THEN
    DIM RAW lsz$
    lsz$ =  ENC$(Keyword1$,ASC(" "))
    IF iMatchNQ(" end ,  dim , declare , type , union ", lsz$) = 0 THEN
      RAW iCnt, iFnd
      iFnd = FALSE
      IF ConstMacroCnt THEN
        XFOR iCnt = 0 WHILE iCnt < ConstMacroCnt BY iCnt++
          IF Stk$[1] = ConstMacro$[iCnt] THEN iFnd = TRUE
        XNEXT
      END IF
      IF iFnd = FALSE THEN InsertTokens(0, 1, "dim")
    END IF
  END IF

  '******************************

  'IF NOT InTypeDef THEN
  IF NOT InTypeDef AND NOT InPPTypeModule THEN
    DIM RAW lsz$
    DIM RAW Res = 0
    lsz$ =  ENC$(Keyword1$,ASC(" "))
'jcfuller 11/15/2013 remove auto
    'IF iMatchNQ(" dim , local , global , raw , static , shared , dynamic , auto , register , extern ", lsz$) THEN
    'IF iMatchNQ(" dim , local , global , raw , static , shared , dynamic , register , extern ", lsz$) THEN
'jcfuller 02/04/2017 remove register    
    IF iMatchNQ(" dim , local , global , raw , static , shared , dynamic , extern ", lsz$) THEN
      Res = 1
    END IF
    lsz$ =  ENC$(LCASE$(Stk$[2]),ASC(" "))
    'IF iMatchNQ(" dim , local , global , raw , static , shared , dynamic , auto , register , extern ", lsz$) THEN
    'IF iMatchNQ(" dim , local , global , raw , static , shared , dynamic , register , extern ", lsz$) THEN
    IF iMatchNQ(" dim , local , global , raw , static , shared , dynamic , extern ", lsz$) THEN
      Res = 2
    END IF

    IF Res > 0 THEN
      i = Ndx
      WHILE i > 1 AND Stk$[i] <> ")"
        IF iMatchWrd(Stk$[i], "as") THEN
          IF iMatchWrd(Stk$[i+1], "function") THEN
            IF i+1 = Ndx THEN Stk$[i] = ""  ' remove "as"
            Stk$[i+1] = ""
            InsertTokens(Res, 1, "function")
          ELSEIF iMatchWrd(Stk$[i+1], "sub") THEN
            IF i+1 = Ndx THEN Stk$[i] = ""  ' remove "as"
            Stk$[i+1] = ""
            InsertTokens(Res, 1, "sub")
          END IF
          CALL RemEmptyTokens
          EXIT WHILE
        END IF
        DECR i
      WEND
    END IF
  END IF

  IF InTypeDef OR iMatchWrd(Stk$[1], "declare") OR iMatchWrd(Stk$[1], "c_declare") THEN
    IF iMatchWrd(Stk$[2],"sub") OR iMatchWrd(Stk$[2],"function") THEN
      FOR INTEGER i = 2 TO Ndx
        IF iMatchLft(Stk$[i],"as") AND iMatchWrd(Stk$[i+1],"string") THEN
          IF *Stk$[i+2] <> ASC("*") THEN Stk$[i+1] = "char *"
        END IF
      NEXT
    END IF
  END IF

END SUB 'XParse

'jcfuller added 08/11/2013 from bcx 7.0.7
SUB FuncSubTemplate(Tmp AS INT)
  RAW iConc = ++Tmp AS INT
  IF Stk$[++Tmp] <> "<" THEN EXIT SUB

  'XFOR INT i = Tmp, WINBOOL notfnd = TRUE WHILE notfnd = TRUE AND i<= Ndx BY i++
  XFOR INT i = Tmp, INT notfnd = 1 WHILE notfnd  AND i<= Ndx BY i++
    IF Stk$[i] = "(" THEN
      notfnd = FALSE
    ELSE
      IF Stk$[i] = "," THEN Stk$[i] = CHR$(18)
      CONCAT(Stk$[iConc], Stk$[i])
      Stk$[i] = ""
    END IF
  XNEXT

  CALL RemEmptyTokens()
END SUB

SUB TokenSubstitutions(iSubLoc AS INT)
  '*****************************
  ' Start Doing Text Substitutions
  '*****************************
  DIM RAW A
  DIM RAW CompPtr       ' flag indicating that there are empty tokens in Stk$[]
  DIM RAW CompToken     ' flag so that STRUCT, UDT, OR UNION can be handled
  DIM RAW Keyword$
  DIM RAW a, i, j, Tmp
  DIM RAW NoTrans       ' flag ot indicate don't substitute tokens in DATA statements
  RAW tpBCX AS tagTokenSubFunctions PTR  ' points to structure holding information
                                        ' about any word in the BCXWords dictionary

  '******************************************************************************************
  ' Following block added in 4.13 --  Dim XXX as string * 12345
  ' Works in  UDT, GLOBALS, LOCALS, and RAW
  '******************************************************************************************

  i = GetAsPosF(1, Ndx)
  IF i THEN
    IF iMatchWrd(Stk$[i+1],"string") THEN
      IF Stk$[i+2] = "*" THEN
        Stk$[i]   = "["
        Stk$[i+1] = Stk$[i+3]
        Stk$[i+2] = "]"
        Stk$[i+3] = "as"
        INCR Ndx
        Stk$[Ndx] = "char"
      END IF
    END IF
  END IF
  'jcf test 0 not stripped here

  '******************************************************************************************
  ' check is this needed transform needed.
  'IF NOT InFunc THEN
  IF InFunc = eNotInOne THEN
    FOR i = 1 TO Ndx
      IF iMatchWrd(Stk$[i],"global") THEN Stk$[i] = "dim"
    NEXT
  END IF

  A = FALSE
  IF iMatchWrd(Stk$[1],"pptype") = 0 THEN
    FOR Tmp = 1 TO Ndx
      'IF *Stk[Tmp] = ASC("0") AND NOT iMatchWrd(MID$(Stk$[Tmp],2,1),"x") AND NOT iMatchWrd(MID$(Stk$[Tmp],2,1),"l") THEN
      'IF *Stk[Tmp] = ASC("0") AND NOT iMatchWrd(MID$(Stk$[Tmp],2,1),"x") AND NOT iMatchWrd(MID$(Stk$[Tmp],2,1),".") AND NOT iMatchWrd(MID$(Stk$[Tmp],2,1),"l") THEN
'jcfuller changed 09/25/2015 to allow binary "b"
IF *Stk[Tmp] = ASC("0") AND NOT iMatchWrd(MID$(Stk$[Tmp],2,1),"b") AND NOT iMatchWrd(MID$(Stk$[Tmp],2,1),"x") AND NOT iMatchWrd(MID$(Stk$[Tmp],2,1),".") AND NOT iMatchWrd(MID$(Stk$[Tmp],2,1),"l") THEN
        Stk$[Tmp] = LTRIM$(Stk$[Tmp],48)   'allow leading zero's in numbers
        IF Stk$[Tmp] = "" THEN Stk$[Tmp] = "0"
      END IF

      IF iMatchWrd(Stk$[Tmp],"xor") THEN
        Stk$[Tmp] = "^"
      ELSE
        SELECT CASE Stk$[Tmp]
          CASE "="
            IF Stk$[Tmp+1]= ">" THEN
              Stk$[Tmp] = ">"
              Stk$[Tmp+1]= "="
            END IF
            IF Stk$[Tmp+1]= "<" THEN
              Stk$[Tmp] = "<"
              Stk$[Tmp+1] = "="
            END IF
          CASE "<"
            IF Stk$[Tmp+1]= ">"  THEN
              Stk$[Tmp]  = "!="
              Stk$[Tmp+1] = ""
              A = TRUE
            END IF
          CASE ">"
            IF Stk$[Tmp+1]= "<" THEN
              Stk$[Tmp]   = "!="
              Stk$[Tmp+1] = ""
              A = TRUE
            END IF
          CASE "!"
            IF Stk$[Tmp+1]= "=" THEN
              Stk$[Tmp] = "!="
              Stk$[Tmp+1] = ""
              A = TRUE
            END IF
        END SELECT
      END IF
    NEXT
 END IF
 'jcf test 0 still stripped here

  'IF A = TRUE THEN CALL RemEmptyTokens
  IF A THEN CALL RemEmptyTokens

  '*************************************************************************
  ' needed when recursively calling parse() after <> has already translated
  ' to != Otherwise, on pass 2, it emits as !== which is NOT desired.
  '*************************************************************************

  CompToken = 0

  FOR Tmp = 1 TO Ndx
    A = CheckLocal(Stk$[Tmp], &i)
    IF A = vt_UNKNOWN THEN A = CheckGlobal(Stk$[Tmp], &i)
    IF A = vt_STRUCT OR A = vt_UDT OR A = vt_UNION THEN
      CompToken = 1
    END IF
    IF iMatchWrd(Stk$[Tmp],"int") AND Stk$[Tmp+1] = "(" THEN
      Stk$[Tmp] = "fint"
    ELSEIF iMatchWrd(Stk$[Tmp],"integer") THEN
      Stk$[Tmp] = "int"
    ELSE
      IF iMatchWrd(Stk$[Tmp],"fint") AND Stk$[Tmp+1]= ")" THEN
        Stk$[Tmp] = "int"
      END IF
    END IF
  NEXT
'jcf test 0 still stripped here



  '*****************************
  CompPtr = 0
  NoTrans = 0
  FOR Tmp = 1 TO Ndx
    IF NoTrans = 1 THEN EXIT FOR
    Keyword$ = LCASE$(Stk$[Tmp])
    tpBCX = GetWordInfo(Keyword$)
    IF tpBCX THEN
      IF (tpBCX->iWordInfo BAND eWI_CPPWord) AND UseCpp = 0 AND Keyword$ <> "new" THEN
        CALL Abort(ENC$(Keyword$,ASC("'"))+" can only be used with C++.")
      END IF
      IF (tpBCX->iTRAN_FLAG BAND iSubLoc) <> iSubLoc THEN
        ITERATE
      END IF
      IF (tpBCX->iWordInfo BAND eWI_ReplaceWord) THEN ' just substitue
        IF (tpBCX->iWordInfo BAND eWI_Position1) = 0 THEN
          Stk$[Tmp] = tpBCX->pszFunctionXName$
          ITERATE
        ELSEIF Tmp = 1 THEN
          Stk$[Tmp] = tpBCX->pszFunctionXName$
          ITERATE
        END IF
      END IF
    END IF

'jcf 0 striped here

    a = INCHR("abcdefghijklmnopqrstuvwxyz$", Keyword$)

    SELECT CASE a
      CASE 1
      SELECT CASE Keyword$
'        CASE "abs"
'        Stk$[Tmp] = "abs"
'        Use_Abs = Use_Proto = TRUE
'Pelles
'int __cdecl abs(int);
'long __cdecl labs(long);
'long long __cdecl llabs(long long);
'double __cdecl fabs(double);
'float __cdecl fabsf(float);
'long double __cdecl fabsl(long double);
'MWING
'_CRTIMP int __cdecl __MINGW_NOTHROW  abs (int) __MINGW_ATTRIB_CONST;
'_CRTIMP long __cdecl __MINGW_NOTHROW  labs  (long) __MINGW_ATTRIB_CONST;
'long long __cdecl __MINGW_NOTHROW llabs(long long);
'_CRTIMP double __cdecl fabs (double);
'extern  float __cdecl fabsf (float x);
'extern long double __cdecl fabsl (long double x);

        CASE "acosh"
        Stk$[Tmp] = "acosh"
        Use_Acosh = Use_Proto = TRUE

        CASE "addressof"
        Stk$[Tmp+1] = "&" + Stk$[Tmp+1]
        Stk$[Tmp] = ""
        INCR CompPtr

        CASE "appactivate"
        Stk$[Tmp] = "AppActivate"
        Use_AppActivate = UseFlag = Use_Instr = Use_Stristr = TRUE
        Use_Lcase = Use_Left = Use_StrStr = TRUE
        UseLCaseTbl = TRUE
        Use_StrUpLow = TRUE				        'jcfuller added
        CASE "appexename$"
        Stk$[Tmp] = "AppExeName$()"
        Use_AppExeName = UseFlag = TRUE

        CASE "appexepath$"
        Stk$[Tmp] = "AppExePath$()"
        CompPtr += Convert2SimpleFunction(Tmp)
        Use_AppExePath = UseFlag = TRUE

        CASE "ansitowide"
        Stk$[Tmp] = "AnsiToWide"
        Use_AnsiToWide = UseFlag = TRUE

        CASE "andalso"
        Stk$[Tmp] = " AndAlso "
        Use_AndAlso = Use_SysMacros = TRUE

        CASE "asc"
        i=0
        j=GetNumArgs(Tmp+2,&i)
        IF *Stk[Tmp+2] = *DQ$ THEN
          IF j > 0 OR *Stk[Tmp+3] <> ASC(")") THEN
            Stk$[Tmp] = "asc"
            Use_Asc = Use_Proto = TRUE
          ELSE
            IF Stk$[Tmp+2] = DDQ$ THEN
              Stk$[Tmp] = "0"
            ELSE
              Stk$[Tmp] = LTRIM$(STR$(ASC(Stk$[Tmp+2],1)))
            END IF
            Stk$[Tmp+1] = "" : Stk$[Tmp+2] = "" : Stk$[Tmp+3] = ""
            INCR CompPtr
          END IF
        ELSE
          IF j > 0 THEN Stk$[i] = "+"
          Stk$[Tmp] = "(UCHAR)*"
        END IF

        CASE "arrayputelement"
        'INPUT:
        ' ArrayPutElement(psA,lComVariant,2,0,iCol)
        'TRANSFORMS TO:
        ' BEGINBLOCK
        ' RAW indicies[2] = {0,iCol} AS long
        ' SafeArrayPutElement(psA,indicies, (void *)&lComVariant)
        ' ENDBLOCK
        RAW sTmp$
        CALL Add2SplitLines("BEGINBLOCK")   ' EMITS {
        sTmp$ = "RAW lIndex["+Stk$[Tmp+6]+"] = {"
        FOR i = Tmp+8 TO Ndx-1
          sTmp$ = sTmp$ + Stk$[i]
        NEXT
        CALL Add2SplitLines(sTmp$ + "} AS long")
        Stk$[Tmp] = "SafeArrayPutElement"
        sTmp$ = ""
        FOR i = 1 TO Tmp+3
          sTmp$ = sTmp$ + Stk$[i]
        NEXT
        CALL Add2SplitLines(sTmp$ + "lIndex,(void *)&"+Stk$[Tmp+4]+")")
        CALL Add2SplitLines("ENDBLOCK")      ' EMITS }
        Ndx = 0

        CASE "arraygetelement"
        RAW sTmp$
        CALL Add2SplitLines("BEGINBLOCK")
        sTmp$ = "RAW lIndex["+Stk$[Tmp+6]+"] = {"
        FOR i = Tmp+8 TO Ndx-1
          sTmp$ = sTmp$ + Clean$(Stk$[i])
        NEXT
        CALL Add2SplitLines(sTmp$ + "} AS long")
        Stk$[Tmp] = "SafeArrayGetElement"
        sTmp$ = ""
        FOR i = 1 TO Tmp+3
          sTmp$ = sTmp$ + Clean$(Stk$[i])
        NEXT
        CALL Add2SplitLines(sTmp$ + "lIndex,(void *)&"+Clean$(Stk$[Tmp+4])+")")
        CALL Add2SplitLines("ENDBLOCK")
        Ndx = 0

        CASE "asinh"
        Stk$[Tmp] = "asinh"
        Use_Asinh = Use_Proto = TRUE

        CASE "atanh"
        Stk$[Tmp] = "atanh"
        Use_Atanh = Use_Proto = TRUE

        CASE "auto"
'        IF iMatchWrd(Stk$[Tmp+1],"local") THEN
'          Stk$[Tmp] = "dim" : Stk$[Tmp+1] = "raw"
'        ELSE
'          Stk$[Tmp] = "auto"
'        END IF
      END SELECT

      CASE  2
      SELECT CASE Keyword$
'jcfuller added 01/27/2015
		CASE "bc9_msgpump"
		  Stk$[Tmp] ="BC9_MsgPump"
		  Use_BC9_MsgPump = Use_Proto = TRUE
'jcfuller 02/02/2015
		CASE "bc9_resdlg"
			Stk$[Tmp] = "BC9_ResDlg"
			Use_BC9_ResDlg = Use_Proto = TRUE

		CASE "bc9_resmdlg"
			Stk$[Tmp] = "BC9_ResMDlg"
			Use_BC9_ResMDlg = Use_Proto = TRUE

		CASE "bc9_dialog"
			Stk$[Tmp] = "BC9_Dialog"
			Use_BC9Dialog = Use_Proto = TRUE
		CASE "bc9_control"
			Stk$[Tmp] = "BC9_Control"
			Use_BC9Control = Use_Proto = TRUE
		CASE "bc9_dlgshow"
				Stk$[Tmp] = "BC9_DlgShow"
				Use_BC9DlgShow = Use_Proto = TRUE
		CASE "bc9_dlgshowmodal"
				Stk$[Tmp] = "BC9_DlgShowModal"
				Use_BC9DlgShowModal = Use_Proto = TRUE
		CASE "bc9_button"
		        Stk$[Tmp] = "BC9_Button"
		        Use_BC9Button = Use_Proto = TRUE
		CASE "bc9_checkbox"
			Stk$[Tmp] = "BC9_Checkbox"
			Use_BC9Checkbox = Use_Proto = TRUE
		CASE "bc9_group"
		    Stk$[Tmp] = "BC9_Group"
		    Use_BC9Group = Use_Proto = TRUE
        CASE "bc9_combobox"
			Stk$[Tmp] = "BC9_Combobox"
			Use_BC9Combo = Use_Proto = TRUE
        CASE "bc9_blackrect"
            Stk$[Tmp] = "BC9_BlackRect"
            Use_BC9BlackRect = Use_Proto = TRUE
        CASE "bc9_grayrect"
			Stk$[Tmp] = "BC9_GrayRect"
			Use_BC9GrayRect = Use_Proto = TRUE
		CASE "bc9_whiterect"
		    Stk$[Tmp] = "BC9_WhiteRect"
		    Use_BC9WhiteRect = Use_Proto = TRUE
        CASE "bc9_datepick"
			Stk$[Tmp] = "BC9_DatePick"
			Use_BC9DatePick = Use_Proto = TRUE
        CASE "bc9_edit"
			Stk$[Tmp] = "BC9_Edit"
			Use_BC9Edit = Use_Proto = TRUE
		CASE "bc9_input"
			Stk$[Tmp] = "BC9_Input"
		    Use_BC9Input = Use_Proto = TRUE
		CASE "bc9_label"
		    Stk$[Tmp] = "BC9_Label"
		    Use_BC9Label = Use_Proto = TRUE
		CASE "bc9_listbox"
		    Stk$[Tmp] = "BC9_Listbox"
		    Use_BC9Listbox = Use_Proto = TRUE
        CASE "bc9_listview"
			Stk$[Tmp] = "BC9_Listview"
			Use_BC9Listview = Use_Proto = TRUE
		CASE "bc9_bitmap"
			Stk$[Tmp] = "BC9_Bitmap"
			Use_BC9Bitmap = Use_Proto = TRUE
		CASE "bc9_icon"
			Stk$[Tmp] = "BC9_Icon"
			Use_BC9Icon = Use_Proto = TRUE
		CASE "bc9_radio"
			Stk$[Tmp] = "BC9_Radio"
			Use_BC9Radio = Use_Proto = TRUE
		CASE "bc9_richedit"
		    Stk$[Tmp] = "BC9_RichEdit"
		    Use_BC9RichEdit = Use_Proto = TRUE
		CASE "bc9_status"
			Stk$[Tmp] = "BC9_Status"
			Use_BC9Status = Use_Proto = TRUE
		CASE "bc9_setsbparts"
			Stk$[Tmp] = "BC9_SetSbParts"
			Use_BC9Status = Use_Proto = TRUE
		CASE "bc9_tab"
		    Stk$[Tmp] = "BC9_Tab"
		    Use_BC9Tab = Use_Proto = TRUE
		CASE "bc9_tabpage"
		    Stk$[Tmp] = "BC9_TabPage"
		    Use_BC9Tab = Use_Proto = TRUE
		CASE "bc9_hcenterctrlondialog"
		    Stk$[Tmp] = "BC9_HCenterCtrlOnDialog"
		    Use_BC9HCenterCtrlOnDialog = Use_Proto = TRUE
		CASE "bc9_vcenterctrlondialog"
		    Stk$[Tmp] = "BC9_VCenterCtrlOnDialog"
		    Use_BC9VCenterCtrlOnDialog = Use_Proto = TRUE

        CASE "bcopy"
        *Stk[1] = 0
        FOR i = Tmp+1 TO Ndx
          IF iMatchWrd(Stk$[i],"to") THEN EXIT FOR
          CONCAT(Stk$[1], Stk$[i]) 'Source
          CONCAT(Stk$[1], CHR$(1))
        NEXT
        *Stk[2] = 0
        FOR i = i+1 TO Ndx
          CONCAT(Stk$[2], Stk$[i]) 'Destination
          CONCAT(Stk$[2], CHR$(1))
        NEXT
        Src$ = "memmove" + CHR$(1) + "(" + CHR$(1) + "&" + CHR$(1) + Stk$[2] + "," + CHR$(1) + "&" + CHR$(1) +  Stk$[1] + "," + CHR$(1) + "sizeof" + CHR$(1) + "(" + CHR$(1) + Stk$[2] + ")" + CHR$(1) + ")"
        REMOVE "&*" FROM Src$
        CALL FastLexer(Src$,CHR$(1),"",-1)

        CASE "begin"
        IF iMatchWrd(Stk$[Tmp+1],"events") OR iMatchWrd(Stk$[Tmp+1],"mdievents") OR iMatchWrd(Stk$[Tmp+1],"mdichildevents") THEN
          IF Indent THEN
            CALL Abort("Possible missing END IF before start of BEGIN")
          END IF
          IF Ndx = 3 THEN
            Src$ = "FUNCTION|"+Stk$[Tmp+2]+"(hWnd|AS|HWND,Msg|AS|UINT,wParam|AS|WPARAM,lParam|AS|LPARAM)|AS|LRESULT|CALLBACK "
            'Src$ = "FUNCTION|LRESULT CALLBACK "+Stk$[Tmp+2]+"(hWnd|AS|HWND,Msg|AS|UINT,wParam|AS|WPARAM,lParam|AS|LPARAM)"
          ELSE
            Src$ = "FUNCTION|WndProc(hWnd|AS|HWND,Msg|AS|UINT,wParam|AS|WPARAM,lParam|AS|LPARAM)|AS|LRESULT|CALLBACK"
            'Src$ = "FUNCTION|LRESULT CALLBACK WndProc(hWnd|AS|HWND,Msg|AS|UINT,wParam|AS|WPARAM,lParam|AS|LPARAM)"
          END IF
          FastLexer(Src$,"|", ",()")
          Use_Wingui = TRUE 'Use_Str_Cmp = Use_Ucase = TRUE
          'CALL EmitMain()
          'Ndx = 0
          EXIT SUB
        END IF

        CASE "bel$"
        Stk$[Tmp] = "BEL$"
        Use_BEL = UseFlag = TRUE

        CASE "bs$"
        Stk$[Tmp] = "BS$"
        Use_BS = UseFlag = TRUE

        CASE "bcx_dynacall"
        Stk$[Tmp] = "BCX_DynaCallA"
        Use_DynacallCommon = Use_DynacallA = TRUE

        ' *******************************************************************
        ' Special Case Handler: Maintain case sensitivity for this structure
        ' *******************************************************************

        CASE "bcx_font"
        Stk$[Tmp]   = UCASE$(Stk$[Tmp])
        DIM RAW tmp$
        RAW iNextToken = Tmp+1
        Stk$[iNextToken] = Clean$(Stk$[iNextToken])
        tmp$ = UCASE$(Stk$[iNextToken])

        SELECT CASE tmp$
          CASE ".NAME"         : Stk$[iNextToken] = ".lf.lfFaceName$"
          CASE ".BOLD"         : Stk$[iNextToken] = ".lf.lfWeight"
          CASE ".UNDERLINE"    : Stk$[iNextToken] = ".lf.lfUnderline"
          CASE ".STRIKEOUT"    : Stk$[iNextToken] = ".lf.lfStrikeOut"
          CASE ".ITALIC"       : Stk$[iNextToken] = ".lf.lfItalic"
          CASE ".CHARSET"      : Stk$[iNextToken] = ".lf.lfCharSet"
          CASE ".SIZE", ".RGB" : Stk$[iNextToken] = tmp$
        END SELECT

        CASE "bcx_setcursor"
        Stk$[Tmp] = "BCX_SetCursor"
        Use_BCX_SetCursor = Use_BCX_InitGUI = TRUE
        CALL AddGUIGlobals

        CASE "bcx_msgpump"
        Stk$[Tmp] = "BCX_MsgPump"
        Use_BCX_MsgPump = TRUE
        CALL AddGUIGlobals

        CASE "bcx_wnd"
        Stk$[Tmp] = "BCX_Wnd"
        Use_BCX_Wnd = Use_BCX_InitGUI = Use_BCX_SetMetric = Use_BCX_RegWnd = TRUE
        CALL AddGUIGlobals

        CASE "bcx_framewnd"
        Stk$[Tmp] = "BCX_FrameWnd"
        Use_BCX_FrameWnd = Use_BCX_RegWnd = Use_BCX_InitGUI = Use_BCX_SetMetric = TRUE
        CALL AddGUIGlobals

        CASE "bcx_setbkgrdbrush"
        Stk$[Tmp] = "BCX_SetBkGrdBrush"
        Use_BCX_SetBkGrdBrush = Use_BCX_InitGUI = TRUE
        CALL AddGUIGlobals

        CASE "bcx_setclassstyle"
        Stk$[Tmp] = "BCX_SetClassStyle"
        Use_BCX_SetClassStyle = Use_BCX_InitGUI = TRUE
        CALL AddGUIGlobals

        CASE "bcx_seticon"
        Stk$[Tmp] = "BCX_SetIcon"
        Use_BCX_SetIcon = Use_BCX_InitGUI = TRUE
        CALL AddGUIGlobals

        CASE "bcx_seticonsm"
        Stk$[Tmp] = "BCX_SetIconSm"
        Use_BCX_SetIconSm = Use_BCX_InitGUI = TRUE
        CALL AddGUIGlobals

        CASE "bcx_setmetric"
        Stk$[Tmp] = "BCX_SetMetric"
        Use_BCX_SetMetric = Use_BCX_InitGUI = TRUE
        CALL AddGUIGlobals

        CASE "bcx_initgui"
        Stk$[Tmp] = "BCX_InitGUI"
        Use_BCX_InitGUI = TRUE
        CALL AddGUIGlobals

        CASE "bcx_regwnd"
        Stk$[Tmp] = "BCX_RegWnd"
        Use_BCX_RegWnd = Use_BCX_InitGUI = Use_BCX_SetMetric = TRUE
        CALL AddGUIGlobals

        CASE "bcx_mdi_msgpump"
        Stk$[Tmp] = "BCX_MDI_MsgPump"
        Use_BCX_MDI_MsgPump = TRUE
        CALL AddGUIGlobals

        CASE "bcx_bcx_wndclass"
        Stk$[Tmp] = "BCX_WndClass"
        CALL AddGUIGlobals

        CASE "bcxsplitpath$"
        Stk$[Tmp] = "$$BcxSplitPath$"
        Use_BcxSplitPath = UseFlag = TRUE
        Use_SysMacros = Use_Proto = TRUE

        CASE "bcxpath$"
        Stk$[Tmp] = "BcxPath$()"
        CompPtr += Convert2SimpleFunction(Tmp)
        Use_BCX_Path = Use_RegString = TRUE
        UseFlag = TRUE

        CASE "bcx_arc"
        Stk$[Tmp] = "BCX_Arc"
        Use_BCX_Arc = Use_Proto = TRUE

        CASE "bcx_bitmap"
        Stk$[Tmp] = "BCX_Bitmap"
        Use_Bitmap = Use_Proto = TRUE

        CASE "bcx_olepicture"
        Stk$[Tmp] = "BCX_OlePicture"
        Use_BCX_OlePicture = Use_GetResource = Use_Proto = TRUE

        CASE "bcx_ole_width"
        Stk$[Tmp] = "BCX_OLE_WIDTH"
        Use_SysMacros = TRUE

        CASE "bcx_ole_height"
        Stk$[Tmp] = "BCX_OLE_HEIGHT"
        Use_SysMacros = TRUE

        CASE "bcx_blackrect"
        Stk$[Tmp] = "BCX_BlackRect"
        Use_Blackrect = Use_Proto = TRUE

        CASE "bcx_button"
        Stk$[Tmp] = "BCX_Button"
        Use_Button = Use_GetTextSize = Use_Proto = TRUE

        CASE "bcx_bmpbutton"
        Stk$[Tmp] = "BCX_BmpButton"
        Use_BmpButton = Use_Proto = TRUE

        CASE "bcx_bmpwidth"
        Stk$[Tmp] = "BCX_BmpWidth"
        Use_BCX_BmpWidth = Use_Proto = TRUE

        CASE "bcx_bmpheight"
        Stk$[Tmp] = "BCX_BmpHeight"
        Use_BCX_BmpHeight = Use_Proto = TRUE

        CASE "bcx_checkbox"
        Stk$[Tmp] = "BCX_Checkbox"
        Use_Checkbox = Use_GetTextSize = Use_Proto = TRUE

        CASE "bcx_combobox"
        Stk$[Tmp] = "BCX_Combobox"
        Use_Combobox = Use_Proto = TRUE

        CASE "bcx_control"
        Stk$[Tmp] = "BCX_Control"
        Use_BCX_Control = Use_Proto = TRUE

        CASE "bcx_colordlg"
        Stk$[Tmp] = "BCX_ColorDlg"
        IF NOT INCHR(Src$,"(") THEN Stk$[Tmp] = Stk$[Tmp] + "()"
        Use_BCX_Colordlg = Use_Hook = UseFlag = Use_Proto = TRUE

        CASE "bcx_cursor"
        Stk$[Tmp] = "BCX_Cursor"
        Use_BCX_Cursor = Use_SysMacros = TRUE

        CASE "bcx_datepick"
        Stk$[Tmp] = "BCX_DatePick"
        Use_Datepick = Use_Proto = TRUE

        CASE "bcx_edit"
        Stk$[Tmp] = "BCX_Edit"
        Use_Edit = Use_Proto = TRUE

        CASE "bcx_circle"
        Stk$[Tmp] = "BCX_Circle"
        Use_BCX_Circle = Use_Proto = TRUE

        CASE "bcx_ellipse"
        Stk$[Tmp] = "BCX_Ellipse"
        Use_BCX_Ellipse = Use_Proto = TRUE

        CASE "bcx_mdialog"
        IF InWinMain AND NOT Use_BCXMDialog THEN
          FPRINT Outfile, Scoot$;"BCX_hInstance    =  hInst;"
          iEmitVariableGroup = iEmitVariableGroup BOR (eFontGroup BOR eBCX_hInstance)
        END IF
        Stk$[Tmp] = "BCX_MDialog"
        Use_BCXDialogCommon = Use_BCXMDialog = Use_Proto = TRUE

        CASE "bcx_dialog"
        Stk$[Tmp] = "BCX_Dialog"
        Use_BCXDialogCommon = Use_BCXDialog = Use_Proto = TRUE

        CASE "bc9_dlgwin"
        Stk$[Tmp] = "BC9_DlgWin"
        Use_DlgWin = TRUE

        CASE "bcx_form"
        Stk$[Tmp] = "BCX_Form"
        Use_Form = Use_Proto = Use_MainEvent = TRUE

        IF NOT Use_BCX_Class_Info THEN
          Use_BCX_Class_Info = TRUE
          iEmitVariableGroup = iEmitVariableGroup BOR (eFontGroup BOR eClassName)
        END IF

        CASE "bcx_fontdlg"
        Stk$[Tmp] = "BCX_FontDlg"
        IF Tmp = Ndx THEN CONCAT(Stk$[Tmp],"()")
        Use_BCX_Fontdlg = TRUE
        Use_Hook = UseFlag = Use_Proto = TRUE

        CASE "bcx_floodfill"
        Stk$[Tmp] = "BCX_FloodFill"
        Use_BCX_Floodfill = Use_Proto = TRUE

        CASE "bcx_get"
        Stk$[Tmp] = "BCX_Get"
        Use_BCX_Get = Use_Proto = TRUE

        CASE "bcx_get_text$"
        Stk$[Tmp] = "$$BCX_Get_Text$"
        Use_GetText = UseFlag = TRUE

        CASE "bcx_getpixel"
        Stk$[Tmp] = "BCX_Getpixel"
        Use_BCX_Getpixel = UseFlag = TRUE

        CASE "bcx_grayrect"
        Stk$[Tmp] = "BCX_GrayRect"
        Use_Grayrect = Use_Proto = TRUE

        CASE "bcx_group"
        Stk$[Tmp] = "BCX_Group"
        Use_Group = Use_Proto = TRUE

        CASE "bcx_icon"
        Stk$[Tmp] = "BCX_Icon"
        Use_Icon = Use_GetResource = Use_Proto = TRUE

        CASE "bcx_input"
        Stk$[Tmp] = "BCX_Input"
        Use_BCX_Input = Use_Proto = TRUE

        CASE "bcx_label"
        Stk$[Tmp] = "BCX_Label"
        Use_Label = Use_GetTextSize = Use_Proto = TRUE

        CASE "bcx_line"
        Stk$[Tmp] = "BCX_Line"
        Use_BCX_Line = Use_Proto = TRUE

        CASE "bcx_lineto"
        Stk$[Tmp] = "BCX_Lineto"
        Use_BCX_Lineto = Use_Proto = TRUE

        CASE "bcx_listbox"
        Stk$[Tmp] = "BCX_Listbox"
        Use_Listbox = Use_Proto = TRUE

        CASE "bcx_listview"
        Stk$[Tmp] = "BCX_ListView"
        Use_Listview = Use_Proto = TRUE

        CASE  "bcx_loadbmp"
        Stk$[Tmp] = "BCX_LoadBMP"
        Use_BCX_LoadBMP = Use_Proto = TRUE

        CASE  "bcx_loadimage"
        Stk$[Tmp] = "BCX_LoadImage"
        Use_BCX_LoadImage = Use_GetResource = Use_Proto = TRUE

        CASE "bcx_print"
        Stk$[Tmp] = "BCX_Print"
        Use_BCX_Print = Use_Proto = TRUE

        CASE "bcx_polygon"
        Stk$[Tmp] = "BCX_Polygon"
        Use_BCX_Polygon = Use_Proto = TRUE

        CASE "bcx_polybezier"
        Stk$[Tmp] = "BCX_PolyBezier"
        Use_BCX_PolyBezier = Use_Proto = TRUE

        CASE "bcx_polyline"
        Stk$[Tmp] = "BCX_Polyline"
        Use_BCX_Polyline = Use_Proto = TRUE

        CASE "bcx_preset"
        Stk$[Tmp] = "BCX_Preset"
        Use_BCX_Preset = Use_Proto = TRUE

        CASE "bcx_pset"
        Stk$[Tmp] = "BCX_Pset"
        Use_BCX_Pset = Use_Proto = TRUE

        CASE "bcx_progressbar"
        Stk$[Tmp] = "BCX_ProgressBar"
        Use_ProgressBar = Use_Proto = TRUE

        CASE "bcx_put"
        Stk$[Tmp] = "BCX_Put"
        Use_BCX_Put = Use_Proto = TRUE

        CASE "bcx_radio"
        Stk$[Tmp] = "BCX_Radio"
        Use_Radio = Use_GetTextSize = Use_Proto = TRUE

        CASE "bcx_rectangle"
        Stk$[Tmp] = "BCX_Rectangle"
        Use_BCX_Rectangle = UseFlag = TRUE

        CASE "bcx_richedit"
        Stk$[Tmp] = "BCX_RichEdit"
        Use_Richedit = Use_Proto = TRUE

        CASE "bcx_roundrect"
        Stk$[Tmp] = "BCX_Roundrect"
        Use_BCX_Roundrect = Use_Proto = TRUE

        CASE "bcx_slider"
        Stk$[Tmp] = "BCX_Slider"
        Use_BCX_Slider = Use_Label = Use_GetTextSize = Use_Proto = TRUE

        CASE "bcx_splitter"
        Stk$[Tmp] = "BCX_Splitter"
        Use_BCX_Splitter = Use_Proto = Use_Modstyle = TRUE

        CASE "bcx_setsplitpos"
        Stk$[Tmp] = "BCX_SetSplitPos"
        Use_BCX_Splitter = Use_Proto = Use_Modstyle = TRUE

        CASE "bcx_tab"
        Stk$[Tmp] = "BCX_Tab"
        Use_BCX_Tab = Use_Proto = TRUE

        CASE "bcx_toolbar"
        Stk$[Tmp] = "BCX_Toolbar"
        Use_BCX_Toolbar = Use_Proto = TRUE

        CASE "bcx_updown"
        Stk$[Tmp] = "BCX_UpDown"
        Use_BCX_UpDown = Use_Proto = TRUE

        CASE "bcx_version$"
        Stk$[Tmp] = ENC$(Version$)

        CASE "bcx_get_updown"
        Stk$[Tmp] = "BCX_Get_UpDown"
        Use_BCX_Get_UpDown = Use_Proto = UseFlag = TRUE

        CASE "bcx_set_form_color"
        Use_SetFormColor = Use_Proto = TRUE
        Stk$[Tmp] = "BCX_Set_Form_Color"
        IF Stk$[Tmp+1] <> "(" THEN
          InsertTokens(Tmp,1,"(")
          Stk$[++Ndx] = ")"
        END IF

        CASE "bcx_set_font"
        Stk$[Tmp] = "BCX_Set_Font"
        Use_SetFont = Use_Proto = TRUE
        IF Stk$[Tmp+1] <> "(" THEN
          InsertTokens(Tmp,1,"(")
          Stk$[++Ndx] = ")"
        END IF

        CASE "bcx_setcolor"
        Stk$[Tmp] = "Set_Color"
        RAW iPCnt = GetNumArgs(Tmp+2)

        IF iPCnt = 1 THEN
          InsertTokens(Ndx-1, 4, ",", "(HDC)wParam", ",", "(HWND)lParam")
        ELSEIF iPCnt = 2 THEN
          InsertTokens(Ndx-1, 2, ",", "(HWND)lParam")
        END IF
        Use_SetColor = Use_Proto = TRUE

        CASE "bcx_set_text","bc9_set_text"
        Stk$[Tmp] = "BCX_Set_Text"
        Use_SetText = Use_Proto = TRUE
        IF Stk$[Tmp+1] <> "(" THEN
          InsertTokens(Tmp,1,"(")
          Stk$[++Ndx] = ")"
        END IF

        CASE "bcx_status"
        Stk$[Tmp] = "BCX_Status"
        Use_Status = Use_Proto = TRUE

        CASE "bcx_tabselect"
        Stk$[Tmp] = "BCX_TabSelect(hWnd, lParam)"
        Use_BCX_Tab = Use_Proto = TRUE

        CASE "bcx_tile"
        Use_BCX_Tile = Use_Proto = TRUE
        Stk$[Tmp] = "BCX_Tile"
        IF Stk$[Tmp+1] <> "(" THEN
          InsertTokens(Tmp,1,"(")
          Stk$[++Ndx] = ")"
        END IF

        CASE "bcx_thread", "bcx_threadwait", "bcx_threadsuspend","bcx_threadresume","bcx_threadkill","bcx_threadend"
        Stk$[Tmp] = UCASE$(Stk$[Tmp])
'        Use_Threads = Use_SysMacros = Use_DynacallCommon = Use_Dynacall = TRUE
        Use_Threads = Use_SysMacros

        CASE "bcx_treeview"
        Stk$[Tmp] = "BCX_Treeview"
        Use_Treeview = Use_Proto = TRUE

        CASE "bcx_whiterect"
        Stk$[Tmp] = "BCX_WhiteRect"
        Use_Whiterect = Use_Proto = TRUE

        CASE "bcx_dispatchobject"
'jcfuller added 08/06/2013
        Raw As stdstr ss1,ss2,ss3
        Raw As pcrecpp::RE rex = "(?i)^\\s*(\\w+)\\s*=\\s*BCX_DispatchObject\\s*\\(\\s*(\\w+)\\s*,\\s*(\\w+).+"

        Use_BCX_COM_DispatchObject = Use_COM = TRUE
        If rex.FullMatch(Src$,&ss1,&ss2,&ss3) Then
            Stk$[1] = "BCX_DispatchObject"
            Stk$[2] = "("
            Stk$[3] = ss2.c_str()
            Stk$[4] = ","
            Stk$[5] = "&"
            CONCAT(Stk$[5],ss1.c_str())
            Stk$[6] = ","
            Stk$[7] = ss3.c_str()
            Stk$[8] = ")"
            Ndx = 8

        End If

        CASE "bff$"
        Stk$[Tmp] = "$$BFF$"
        Use_Bff = UseFlag = TRUE

        CASE "bin$"
        Stk$[Tmp] = "$$Bin$"
        Use_Bin = UseFlag = TRUE

        CASE "bin2dec"
        Stk$[Tmp] = "Bin2Dec"
        Use_Bin2dec = Use_Proto = TRUE
'jcfuller added 9/25/2015
		CASE "bit"
		If Stk$[Tmp+1] = "(" Then
			Stk$[Tmp] = "bc9_bit"
			Use_Bit = Use_Proto = TRUE
		End If

        CASE "bool$"
        Stk$[Tmp] = "$$BoolStr$"
        Use_Boolstr = UseFlag = TRUE

        CASE "bool"
'       IF UseCpp THEN Stk$[Tmp] = "bool" ELSE Stk$[Tmp] = "BOOL"
        Stk$[Tmp] = "BOOL"

        CASE "boolean"
        Stk$[Tmp] = "BOOLEAN"

        CASE "band"
        IF Stk[Tmp+1][0] = ASC("=") THEN
          Stk$[Tmp+1] = "&="
          Stk$[Tmp] = ""
          INCR CompPtr
        ELSE
          Stk$[Tmp] = " BAND "
          Use_Band = Use_SysMacros = TRUE
        END IF

        CASE "bnot"
        Stk$[Tmp] = " BNOT "
        Use_Bnot  = Use_SysMacros = TRUE

        CASE "bor"
        IF Stk[Tmp+1][0] = ASC("=") THEN
          Stk$[Tmp+1] = "|="
          Stk$[Tmp] = ""
          INCR CompPtr
        ELSE
          Stk$[Tmp] = " BOR "
          Use_Bor = Use_SysMacros = TRUE
        END IF

      END SELECT

      CASE 3
      SELECT CASE Keyword$

        CASE "case"
          DIM RAW nBrace
          DIM RAW CntMarker

          nBrace = 0
          CntMarker = 2
          j = 0
          FOR i = 2 TO Ndx
            IF INCHR("([",Stk$[i]) THEN nBrace++
            IF INCHR(")]",Stk$[i]) THEN nBrace--
            IF Stk$[i] = ","  THEN
              IF nBrace=0 THEN CntMarker = i + 1
            END IF
            IF iMatchWrd(Stk$[i],"to") THEN
              j = 1
              Stk$[i] = "&&" + CHR$(1) + "<="
              Stk$[CntMarker] = ">=" + CHR$(1) + Stk$[CntMarker]
            END IF
          NEXT

          IF j=1 THEN
            Src$ = ""
            FOR i = 1 TO Ndx
              Src$ = Src$ + Stk$[i] + CHR$(1)
            NEXT
            CALL FastLexer(Src$,CHR$(1),"",-1)
          END IF

        CASE "callback"
        IF Tmp = 1 THEN
          IF Ndx > 5 THEN Warning("Extra Callback code truncated",1)
          Src$ = "FUNCTION|" & Stk$[3] & _
          "(hWnd|AS|HWND,Msg|AS|UINT,wParam|AS|WPARAM,lParam|AS|LPARAM)|AS|LRESULT|CALLBACK"
          FastLexer(Src$,"|",",()")
          CallBackFlag = TRUE
        END IF

        CASE "callwindowproc"
        '*****************************
        '    CallWindowProc HELPER
        '*****************************
        Stk$[Tmp] = "CallWindowProc"
        IF Stk$[Tmp+3] <> "WNDPROC" THEN InsertTokens(Tmp+1,3,"(","WNDPROC",")")

        CASE "createobject"
        IF ComSwitchON THEN
          'Use_BCX_COM_CreateObject = Use_COM = TRUE
'jcfuller changed 08/06/2013
          'Wayne addition for bcx 7.0.5
          Use_BCX_COM_UsesConversion = Use_BCX_COM_CreateObject = Use_COM = TRUE
          IF Stk$[2] = "[" THEN ' object from an array of objects
            'SET oObj [ i ] = createobject ( "Excel.Application" )
            'BCX_CreateObject ( "Excel.Application" , & oTmp [ i ] );
            RAW i
            i = 2
            WHILE Stk$[i] <> "="
              CONCAT(Stk$[1],Stk$[i])
              Stk[i][0] = 0
              INCR CompPtr
              i++
            WEND
            CALL RemEmptyTokens
          END IF
          Stk$[3] = Stk$[5]
          sprintf(Stk[5],"&%s", Stk[1])
          Stk$[1] = "BCX_CreateObject"
          Stk$[2] = "("
          Stk$[4] = ","
        END IF

		CASE "choose"
			Stk$[Tmp] = "choose"
			Use_Choose = Use_Bit = Use_Rtrim = UseFlag = Use_Proto = TRUE
        CASE "containedin"
        Stk$[Tmp] = "containedin"
        Use_ContainedIn = TRUE

        CASE "cr$"
        Stk$[Tmp] = "CR$"
        Use_CR = UseFlag = TRUE

        CASE "close"
        RAW iNextToken = Tmp+1
        IF *Stk$[iNextToken] = ASC("#") THEN
          Stk$[iNextToken] = MID$(Stk$[iNextToken],2)
        END IF

        CASE "closedialog"
        Ndx = 1
        IF ModDialogEvt THEN
          Stk$[Ndx] = "EndDialog(hWnd,0)"
        ELSE
          Stk$[Ndx] = "DestroyWindow(hWnd)"
        END IF

        CASE "cvd"
        Stk$[Tmp] ="CVD"
        Use_Cvd = Use_Proto = TRUE

        CASE "cvi"
        Stk$[Tmp] ="CVI"
        Use_Cvi = Use_Proto = TRUE

        CASE "cvl"
        Stk$[Tmp] ="CVL"
        Use_Cvl = Use_Proto = TRUE

        CASE "cvld"
        Stk$[Tmp] ="CVLD"
        Use_Cvld = Use_Proto = TRUE

        CASE "cvs"
        Stk$[Tmp] ="CVS"
        Use_Cvs = Use_Proto = TRUE

        CASE "chr$"
        Stk$[Tmp] = "$$chr$"
        Use_Chr = UseFlag = TRUE

        CASE "crlf$"
        Stk$[Tmp] = "CRLF$"
        Use_Crlf = UseFlag = TRUE

        CASE "createregstring"
        Stk$[Tmp] = "CreateRegString"
        Use_CreateRegString = UseFlag = TRUE

        CASE "createregint"
        Stk$[Tmp] = "CreateRegInt"
        Use_CreateRegInt = UseFlag = TRUE

        CASE "cdbl"
        Stk$[Tmp] = "CDBL"
        Use_Cdbl = Use_SysMacros = TRUE

        CASE "center"
        Stk$[Tmp] = "Center"
        'cout << "center -> " << Stk$[Tmp-1] << endl
        'cout << Src$ << endl
        If iMatchLft(Src$,"center") Then
			Use_Center = Use_Proto = TRUE
		End If	

        CASE "cint"
        Stk$[Tmp] = "Cint"
        Use_Cint = Use_Proto = TRUE

        CASE "cldbl"
        Stk$[Tmp] = "CLDBL"
        Use_Cldbl = Use_SysMacros = TRUE

'jcfuller added 08/13/2013
		CASE "clipboardgettext"
		Stk$[Tmp] = "ClipboardGetText"
		Use_Clipboard = Use_Proto = TRUE

		CASE "clipboardgettextsize"
		Stk$[Tmp] = "ClipboardGetTextSize"
		Use_Clipboard = Use_Proto = TRUE

		CASE "clipboardsettext"
		Stk$[Tmp] = "ClipboardSetText"
		Use_Clipboard = Use_Proto = TRUE

        CASE "clng"
        Stk$[Tmp] = "CLNG"
        Use_Clng = Use_Proto = TRUE

        CASE "cls"
        Stk$[Tmp] = "cls"
        Use_Cls = TRUE
        'Use_Locate = Use_Console = Use_Proto = TRUE
          Use_Proto = TRUE
        CASE "color", "color_fg", "color_bg"
        Stk$[Tmp] = LCASE$(Stk$[Tmp])
        Use_Color = Use_Console = Use_Proto = TRUE

        CASE "command$"
        Use_Command = UseFlag = Use_SPC =TRUE
        IF UseWinApi = FALSE AND Use_TCLib = FALSE Then
        	Use_VChr = TRUE
        End If
        Stk$[Tmp] = "command$(-1)"
        IF Stk$ [Tmp+1] = "(" THEN
          Stk$ [Tmp]= "command$"
        END IF

        CASE "comboboxloadfile"
        Stk$[Tmp] = "ComboBoxLoadFile"
        Use_ComboBoxLoadFile = TRUE
        Use_Proto   = TRUE
        Use_Trim    = TRUE
        UseFlag     = TRUE

        CASE "cbool"
        Stk$[Tmp] = "CBOOL"
        Use_Cbool = Use_SysMacros = TRUE
        'DIM AUTO fp AS functionParse, i, t, expos = 0
        Raw fp AS functionParse, i, t, expos = 0

        IF SepFuncArgs(Tmp+1, &fp, TRUE) = 0 THEN Abort("No argument specified in CBOOL")
        FOR i = fp.CommaPos[0] TO fp.CommaPos[1]
          t = INCHR("!<>=", Stk$[i])
          IF t THEN
            IF t < 4 THEN
              IF Stk$[i+1] = "=" THEN
                Stk$[i] = Stk$[i] + Stk$[i+1]
                Stk$[i+1] = ""
                INCR CompPtr
              ELSEIF t = 1 AND Stk$[i] <> "!=" THEN
                ITERATE
              END IF
            ELSE
              IF Stk$[i+1] <> "=" THEN Stk$[i] = "=="
            END IF
            expos = i
            EXIT FOR
          END IF
        NEXT

        t = DataType(Stk$[expos-1])
        IF t = vt_STRLIT OR t = vt_STRVAR THEN
          IF expos THEN
            CONCAT(Stk$[Tmp+1],"strcmp(")
            Stk$[fp.CommaPos[1]] = ")" + Stk$[expos] + "0)"
            Stk$[expos] = ","
            Src$ = ""
            FOR i = 1 TO Ndx
              CONCAT(Src$, Stk$[i])
              CONCAT(Src$, SPC$)
            NEXT
            FastLexer(Src$,SPC$,"(),")
          END IF
        END IF

        CASE "csng"
        Stk$[Tmp] = "CSNG"
        Use_Csng = Use_SysMacros = TRUE

        CASE "cursorx"
        Stk$[Tmp] = "Pos()"
        Use_Pos  = Use_Proto = TRUE

        CASE "csrlin","cursory"
        Stk$[Tmp]  = "Csrlin()"
        Use_Csrlin = Use_Proto  = TRUE

        CASE "curdir$"
        Stk$[Tmp] = "curdir$()"
        CompPtr += Convert2SimpleFunction(Tmp)
        Use_Curdir = UseFlag = TRUE

        CASE "c_declare"
        If TargetOS = TWIN THEN
          CallType$ = "__cdecl "
        Else
          CallType$ = ""
        End If
        Stk$[Tmp] = "declare"
        IF iMatchWrd(Stk$[4], "lib") THEN
          NoTypeDeclare = FALSE
        ELSE
          NoTypeDeclare = TRUE
        END IF

      END SELECT

      CASE 4
      SELECT CASE Keyword$

        CASE "declare"
        CallType$ = "__stdcall "
        Stk$[Tmp] = "declare"
        IF NOT iMatchWrd(Stk$[4], "lib") THEN
          NoTypeDeclare = TRUE
        ELSE
          NoTypeDeclare = FALSE
        END IF

        CASE "dq$"
        Stk$[Tmp] = "DQ$"
        Use_DQ = UseFlag = TRUE

        CASE "ddq$"
        Stk$[Tmp] = "DDQ$"
        Use_DDQ = UseFlag = TRUE

        CASE "data"
          NoTrans = 1

        CASE "date$"
        IF Stk$[Tmp+1] <> "(" THEN
          Stk$[Tmp] = "date$()"
        ELSE
          Stk$[Tmp] = "date$"
        END IF
        Use_Date = UseFlag = TRUE

        CASE "del$"
        Stk$[Tmp] = "del$"
        Use_Del = UseFlag = Use_Proto = TRUE

        CASE "deleteregkey"
        Stk$[Tmp] = "DeleteRegKey"
        Use_DeleteRegKey = UseFlag = TRUE

        CASE "dialog"
        IF iMatchWrd(Stk$[1],"begin") THEN
          IF Ndx = 4 AND iMatchWrd(Stk$[3],"as") THEN
            InDialogEvt = TRUE
          ELSEIF Ndx = 5 AND iMatchWrd(Stk$[4],"as") THEN
            'BEGIN MODAL DIALOG AS DialogOne
            'function 'Stk$[Ndx]' ( hWnd AS HWND , Msg AS UINT , wParam AS WPARAM , lParam AS LPARAM ) AS BOOL CALLBACK
            'BOOL CALLBACK DialogOne (HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
            ModDialogEvt = TRUE
          ELSE
            CALL Abort("Malformed Begin Dialog")
          END IF
          'jcfuller 03/12/2016 changed from BOOL CALLBACK to INT_PTR CALLBACK
          Src$ = "function " & Stk$[Ndx] & _
          "(hWnd AS HWND,Msg AS UINT,wParam AS WPARAM,lParam AS LPARAM) AS INT_PTR CALLBACK"
          FastLexer(Src$, SPC$, "(),")
          'cout << Src$ << endl
        'ELSEIF Ndx = 2 AND iMatchWrd(Stk$[Tmp-1],"end") THEN
        '  Stk$[2] = "function"

'jcfuller changed 01/24/2015
        'Use_BCXDialogCommon = TRUE

        END IF

        CASE "destroysafearray"
        Stk$[Tmp] = "DestroySafeArray"
        Use_SafeArrays = TRUE

        CASE "doevents"
        Stk$[Tmp] = "DoEvents()"
        CompPtr += Convert2SimpleFunction(Tmp)
        Use_Doevents = Use_Proto = TRUE

        CASE "drawtransbmp"
        Stk$[Tmp] = "DrawTransBMP"
        Use_DrawTransBMP = Use_Proto = TRUE

        CASE "download"
        Stk$[Tmp] = "Download"
'jcfuller changed 3/21/2015
        'Use_Download = Use_DynacallCommon = Use_Dynacall = Use_Proto = TRUE
        Use_Download = Use_Proto = TRUE

        CASE "dsplit"
        Stk$[Tmp] = "DSplit"
        Use_Proto  = TRUE
        UseFlag    = TRUE
        Use_DSplit = TRUE
        Use_Remove = TRUE
        Use_StrStr = TRUE
        Use_Mid    = TRUE
        Use_Left   = TRUE
        Use_Instr  = TRUE
        Use_Stristr = TRUE
        UseLCaseTbl = TRUE
		Use_StrUpLow = TRUE
      END SELECT

      CASE  5
      SELECT CASE Keyword$

        CASE "enddraw"
        Stk$[Tmp] = "EndDraw"
        Use_Draw = TRUE

        CASE "endmodal"
        Stk$[Tmp] = "EndModal"
        Use_Show = Use_SysMacros = Use_ShowModal = Use_EndModal = TRUE

        CASE "editloadfile"
        Stk$[Tmp] = "EditLoadFile"
        Use_Elf     = TRUE
        Use_Exist   = TRUE
        Use_Get     = TRUE
        Use_Lof     = TRUE
        Use_Proto   = TRUE
        Use_Join    = TRUE
        UseFlag     = TRUE
        Use_SysMacros = TRUE

        CASE "emptytmpstr"
          Stk$[Tmp] = "EmptyTmpStr"
          Use_EmptyTmpStr = TRUE

        CASE "enc$"
        Stk$[Tmp] = "$$enc$"
        Use_Enclose = UseFlag = TRUE

        CASE "extract$"
        Stk$[Tmp] = "$$extract$"
        Use_Extract = Use_StrStr = UseFlag = TRUE

        CASE "eof$"
        Stk$[Tmp] = "EF$"
        Use_EOF = UseFlag = TRUE

        CASE "eof"
        Stk$[Tmp] = "EoF"
        Use_Eof = UseFlag = TRUE
        RAW Tmp2 = Tmp + 2
        IF DataType(Stk$[Tmp2]) = vt_NUMBER THEN
          Stk$[Tmp2] = "FP" + Stk$[Tmp2]
        END IF

        CASE "equalto"
        Stk$[Tmp] = " EqualTo "
        Use_EqualTo = Use_SysMacros = TRUE


        CASE "esc$"
        Stk$[Tmp] = "ESC$"
        Use_ESC = UseFlag = TRUE

        CASE "enum"
        RAW iNamedEnum = 0
        IF Tmp = 3 THEN
          iNamedEnum = iMatchWrd(Stk$[Tmp-1],"as")
        ELSE
          IF Ndx = 3 THEN
            iNamedEnum = iMatchWrd(Stk$[Tmp+1],"as")
          END IF
        END IF
        IF Ndx = 1 OR iNamedEnum THEN
          Use_EnumFile = TRUE
          RAW szNameOfEnum$
          '******************************************************
          '     We're dealing with a ENUM - END ENUM block
          '******************************************************
          DIM RAW EnumFlag = FALSE
          FPRINT FP_ENU,""
          IF iNamedEnum THEN
            IF Tmp = 3 THEN
              szNameOfEnum$ = Stk$[Tmp-2]
              FPRINT FP_ENU,"typedef enum _";szNameOfEnum$
            ELSE
              szNameOfEnum$ = Stk$[Tmp+2]
              FPRINT FP_ENU,"typedef enum _";szNameOfEnum$
            END IF
            szNameOfEnum$ = " " + szNameOfEnum$
          ELSE
            szNameOfEnum$ = ""
            FPRINT FP_ENU,"enum"
          END IF
          FPRINT FP_ENU,"  {"
          Src$ = ""
          WHILE NOT iMatchLft(Src$,"end ")
            IF EOF(SourceFile) THEN Abort ("Unbalanced ENUM")
            LINE INPUT SourceFile,Src$
            ModuleLineNos[ModuleNdx]++
            CALL StripCode(Src$)
            IF iMatchLft(Src$,"$comme") THEN
              RAW i
              CALL Docomment(Src$, &i)
              ITERATE
            END IF
            Src$ = TRIM$(Src$)
            IF Src$ = "" THEN ITERATE ' line starts with comment
            IF LCASE$(LEFT$(Src$ + " ",4)) = "end " THEN
              EXIT WHILE
            ELSE
              IF EnumFlag = FALSE THEN
                EnumFlag = TRUE
              ELSE
                FPRINT FP_ENU,","
              END IF
            END IF
            FPRINT FP_ENU,"    ",RTRIM$(Src$);
          WEND
          Src$ = ""
          Ndx = 0
          FPRINT FP_ENU,""
          FPRINT FP_ENU,"  }";szNameOfEnum$;";\n"
          EXIT SUB
        END IF
        RAW iEquallLoc = Tmp+2
        IF Stk$[iEquallLoc] = "=" THEN
          'enum ONE=3
          'enum ONE{ONE=3};
          Stk$[Tmp] = "enum "
          CALL InsertTokens(iEquallLoc-1,2,"{",Stk$[Tmp+1])
          Stk$[++Ndx] = "}"
          EXIT SUB
        END IF

        '*************************************************************
        '  We're dealing with a smaller, single line ENUM statement
        '*************************************************************

        Stk$[1] = "enum {"
        FOR j = 2 TO Ndx
          CONCAT (Stk$[1], Stk$[j])
        NEXT
        CONCAT (Stk$[1], "}")
        Ndx = 1

        CASE "environ$"
        Stk$[Tmp] = "Environ$"
        Use_Environ = UseFlag = TRUE

        CASE "exist"
        Stk$[Tmp] = "Exist"
'jcfuller I don't know why we have UseFlag. No BCX_TMPSTR        
        'Use_Exist = Use_Proto = UseFlag = TRUE
        Use_Exist = Use_Proto  = TRUE

        CASE "exp"
        Stk$[Tmp] = "Exp"
        Use_Exp = Use_Proto = TRUE

      END SELECT

      CASE  6
      SELECT CASE Keyword$

        CASE "ff$"
        Stk$[Tmp] = "FF$"
        Use_FF = UseFlag = TRUE

        CASE "function"
          IF Stk$[Tmp+1] = "=" THEN
            IF Stk$[Tmp+2] = DDQ$ THEN Stk$[Tmp+2] = "NUL$"
            Stk$[Tmp] = "functionreturn"
          ELSE
            Stk$[Tmp] = "function"
            'jcfuller added 08/11/2013 from bcx 7.0.7
            IF UseCpp OR UseCpphdr THEN CALL FuncSubTemplate(Tmp)
          END IF

        CASE "false"
'jcfuller changed 07/01/2013
'        IF UseCpp THEN
'          Stk$[Tmp] = "false"
'        ELSE
          Stk$[Tmp] = "FALSE"
'        END IF
		CASE "fget"
		  Use_FGet = Use_Proto = TRUE
		  Stk$[Tmp] = "FGet"
        CASE "fgetc"
          Use_FGetC = Use_Proto = TRUE
          Stk$[Tmp] = "FGetC"
          
        CASE "findintype"
        'Convert this :FindInType(char *Token, Type.member, int c)
        'To this      :FindInType(char *Token, Stptr + offsetof(Type,member), sizeof(Type), int c)

        Stk$[Tmp] = "FindInType"
        Use_FindInType = Use_Proto = TRUE

        DIM RAW StMem$, StName$, VarName$
        DIM fp AS functionParse
        CALL SepFuncArgs(Tmp, &fp, TRUE)

        StMem$   = REMAIN$(Clean$(GetArg$(2, &fp)),".")
        VarName$ = EXTRACT$(Clean$(GetArg$(2, &fp)),".")

        FOR j = fp.CommaPos[1] + 1 TO fp.CommaPos[2] - 1
          Stk$[j] = ""
          INCR CompPtr
        NEXT

        IF CheckLocal(VarName$,&i) <> vt_UNKNOWN THEN
          StName$ = TypeDefs[LocalVars[i].VarDef].VarName$
        ELSEIF CheckGlobal(VarName$,&i) <> vt_UNKNOWN THEN
          StName$ = TypeDefs[GlobalVars[i].VarDef].VarName$
        END IF

        j = fp.CommaPos[1] + 1
        Stk$[j] =  "(char*)" & VarName$ & " + offsetof(" & StName$ & "," & StMem$ & ")/sizeof(char), sizeof(" & StName$ & ")/sizeof(char)"
        'If Use_UNICODE_Switch Then
			'Stk$[j] =  "(char*)" & VarName$ & " + offsetof(" & StName$ & "," & StMem$ & ")/2, sizeof(" & StName$ & ")/2"
        'Else
			'Stk$[j] =  "(char*)" & VarName$ & " + offsetof(" & StName$ & "," & StMem$ & "), sizeof(" & StName$ & ")"
        'End If
        CASE "fillarray"
        Stk$[Tmp] = "fillarray"
        Use_FillArray = TRUE
        Use_Proto = TRUE

        CASE "findfirst$"
        Stk$[Tmp] = "findfirst$"
        Use_Findfirst = UseFlag = TRUE

        CASE "findfirstinstance"
        Stk$[Tmp] = "FindFirstInstance"
        Use_FirstInstance = TRUE

        CASE "findnext$"
        Stk$[Tmp] = "findnext$()"
        CompPtr += Convert2SimpleFunction(Tmp)
        Use_Findnext = UseFlag = TRUE
'jcfuller added 09/03/2015
        CASE "filescan"
            Stk$[Tmp] = "FileScan"
            Use_FileScan = Use_Proto = TRUE
            Use_LoadFile = Use_Get = UseFlag = TRUE
            Use_SysMacros = Use_Exist = Use_Lof = TRUE

        CASE "fint"
        Stk$[Tmp] = "FINT"
        Use_Fint = Use_SysMacros = TRUE

        CASE "fix"
        Stk$[Tmp] = "FIX"
        Use_Fix = Use_SysMacros = TRUE

        CASE "filelocked"
        Stk$[Tmp] = "FileLocked"
        Use_FileLocked = Use_Proto = TRUE
		
		CASE "fprints"
		  Stk$[Tmp] = "fPrintS"
		  Use_fprintS = Use_Proto = TRUE	

		CASE "fput"
		  Use_FPut = Use_Proto = TRUE
		  Stk$[Tmp] = "FPut"
		  
        CASE "frac"
        Stk$[Tmp] = "FRAC"
        Use_Fix = Use_Frac = Use_SysMacros = TRUE

        CASE "fracl"
        Stk$[Tmp] = "FRACL"
        Use_Fix = Use_Fracl = Use_SysMacros = TRUE

        CASE "freefile"
        Stk$[Tmp] = "FreeFile()"
        Use_Freefile = Use_Proto = TRUE
        
		CASE "fseek"
		  Use_FSeek = Use_Proto = TRUE
		  Stk$[Tmp] = "FSeek"
        
      END SELECT

      CASE  7
      SELECT CASE Keyword$
        CASE "getdimension"
        Stk$[Tmp] = "GetDimension"
        Use_GetDimension = Use_Proto = TRUE

        CASE "getobject"
        IF ComSwitchON THEN
          IF Ndx < 7 THEN ' COM version of getobject uses only one param, while Windows API has three params - Ndx > 6.
            Use_BCX_COM_GetObject = Use_COM = TRUE
            Stk$[3] = Stk$[5]
            sprintf(Stk[5],"&%s", Stk[1])
            Stk$[1] = "BCX_GetObject"
            Stk$[2] = "("
            Stk$[4] = ","
          END IF
        END IF

        CASE "getprocaddress"
        LOCAL GlobalName$, s, GlobalNameHash, tempA$
        GlobalName$ = Stk$[Tmp-2]
        GlobalNameHash = HashNumber(GlobalName$)
        WHILE GlobalVarHash[GlobalNameHash]
          s = GlobalVarHash[GlobalNameHash]
          RAW ptGlobal AS VarInfo PTR
          ptGlobal = &GlobalVars[s]
          IF GlobalName$ = ptGlobal->VarName$ THEN
            tempA$ = TypeDefs[ptGlobal->VarDef].VarName$
            IF ptGlobal->VarPntr THEN
              tempA$=tempA$+" *"
            END IF
          END IF
          GlobalNameHash = IMOD(GlobalNameHash + 1,MaxGlobalVars)
        WEND
        IF tempA$ = "" THEN
          LOCAL LocalName$
          LocalName$ = Stk$[Tmp-2]
          IF LocalVarCnt THEN
            FOR INTEGER i = 1 TO LocalVarCnt
              IF LocalName$ = LocalVars[i].VarName$ THEN
                tempA$ = TypeDefs[LocalVars[i].VarDef].VarName$
                IF LocalVars[i].VarPntr THEN
                  tempA$ = tempA$ + " *"
                END IF
                EXIT FOR
              END IF
            NEXT
          END IF
        END IF
        IF tempA$ <> "" THEN
          Stk$[Tmp] = "(" + tempA$ + ")GetProcAddress"
        ELSE
          Stk$[Tmp] = "GetProcAddress"
        END IF

        CASE "getattr"
        Stk$[Tmp] = "GETATTR"
        Use_Getattr = Use_SysMacros = TRUE

        CASE "gettextsize"
        Stk$[Tmp] = "GetTextSize"
        Use_GetTextSize = Use_Proto = TRUE

        CASE "getbmp"
        Stk$[Tmp] = "GetBmp"
        Use_GetBmp = Use_Proto = UseFlag = TRUE

        CASE "getdrive"
        Stk$[Tmp] = "_getdrive()"
        CompPtr += Convert2SimpleFunction(Tmp)
        Use_Getdrive = Use_Proto = TRUE

        CASE "getfilename$"
        Stk$[Tmp] = "$$GetFileName$"
        Use_Getfilename = Use_Hook = TRUE

        CASE "getresource"
        Stk$[Tmp] = "GetResource"
        Use_GetResource = Use_Proto = TRUE

        CASE "getspecialfolder$", "getspecialfolder"
        Stk$[Tmp] = "$$GetSpecialFolder$"
        Use_GetSpecialFolder = TRUE
        Use_Proto = UseFlag  = TRUE

      END SELECT

      CASE  8
      SELECT CASE Keyword$

        CASE "hex$"
        Stk$[Tmp] = "hex$"
        Use_Hex = UseFlag = TRUE

        CASE "hex2dec"
        Stk$[Tmp] = "Hex2Dec"
        Use_Hex2Dec = UseLCaseTbl = Use_Proto = Use_Lcase = UseFlag = Use_StrUpLow = TRUE

        CASE "hide"
        Stk$[Tmp] = "Hide"
        Use_Hide = Use_SysMacros = TRUE

      END SELECT

      CASE  9
      SELECT CASE Keyword$

        CASE "instr"
        Stk$[Tmp] = "instr"
        Use_Instr = Use_StrStr = Use_Proto = TRUE
        Use_Stristr = UseLCaseTbl = Use_Lcase = Use_StrUpLow = UseFlag = TRUE

        CASE "inchr"
        Stk$[Tmp] = "inchr"
        Use_Inchr = Use_Proto = TRUE

        CASE "imod"
        Stk$[Tmp] = "imod"
        Use_Imod = Use_SysMacros = TRUE

        CASE "iif"
        Stk$[Tmp] = "iif"
        Use_Iif = Use_Proto = TRUE
        FOR i = Tmp+1 TO Ndx
          IF Stk$[i] = "=" THEN
            IF Stk$[i-1] <> "<" AND Stk$[i-1] <> ">" THEN
              Stk$[i] = "=="
            END IF
          END IF
        NEXT

        CASE "iif$"
        Stk$[Tmp] = "sziif$"
        Use_sziif = Use_Proto = TRUE
        FOR i = Tmp+1 TO Ndx
          IF Stk$[i] = "=" THEN
            IF Stk$[i-1] <> "<" AND Stk$[i-1] <> ">" THEN
              Stk$[i] = "=="
            END IF
          END IF
        NEXT

        CASE "initsafearray"
        Stk$[Tmp] = "InitSafeArray"
        Use_SafeArrays = TRUE
        Stk$[Tmp+2] = "&"+Stk$[Tmp+2]


        CASE "inkey"
        UseFlag = Use_Proto = Use_InkeyD = Use_Getch = TRUE
        Stk$[Tmp] = "inkeyd()"
        CompPtr += Convert2SimpleFunction(Tmp)

        CASE "inkey$"
        UseFlag = Use_Proto = Use_Inkey = Use_Getch = TRUE
        Stk$[Tmp] = "inkey$()"
        CompPtr += Convert2SimpleFunction(Tmp)

        CASE "inline"
          IF Tmp = 1 THEN
            Stk$[1] = ""
            UseInLine = TRUE
            CALL RemEmptyTokens()
            Tmp--
          END IF

        CASE "inp"
        Stk$[Tmp] = "Inp"
        Use_Inp = Use_SysMacros = TRUE

        CASE "inputbox$"
        Stk$[Tmp] = "InputBox$"
        Use_BoxCommon = Use_Inputbox = UseFlag = TRUE


        CASE "infobox"
        Stk$[Tmp] = "InfoBox"
        Use_BoxCommon = Use_Infobox = UseFlag = TRUE

        CASE "inpw"
        Stk$[Tmp] = "Inpw"
        Use_Inpw = Use_SysMacros = TRUE

        CASE "ins$"
        Stk$[Tmp] = "ins$"
        Use_Ins = Use_Proto = UseFlag = TRUE

		CASE "instat"
		Stk$[Tmp]="instat()"
		Use_Instat = Use_Proto = TRUE

        CASE "instrrev"
        Stk$[Tmp] = "InstrRev"
        Use_Instrrev = Use_Proto = TRUE

        CASE "isptr"
        Stk$[Tmp] = "IsPtr"
        Use_Isptr = Use_SysMacros = TRUE

        CASE "ireplace$"
        Stk$[Tmp] = "iReplace$"
        Use_iReplace = Use_Stristr = UseFlag = TRUE
        UseLCaseTbl = Use_Lcase = Use_StrUpLow = TRUE

        CASE "iremove$"
        Stk$[Tmp] = "IRemoveStr$"
        Use_IRemove = UseFlag = TRUE
        Use_Stristr = UseLCaseTbl = Use_Lcase = Use_StrUpLow = UseFlag =  TRUE

      END SELECT

      CASE  10
      SELECT CASE Keyword$
        CASE "join$"
        Stk$[Tmp] = "$$join$"
        Use_Join = UseFlag = TRUE
      END SELECT

      CASE  11
      SELECT CASE Keyword$
        CASE "keypress"
        Stk$[Tmp] = "keypress()"
        CompPtr += Convert2SimpleFunction(Tmp)
        Use_Keypress = Use_Proto = Use_Getch = TRUE
      END SELECT

      CASE  12
      SELECT CASE Keyword$
        CASE "local"
          RAW iNextWrd = Tmp + 1
          IF iMatchWrd(Stk$[iNextWrd],"dynamic") THEN
            Stk$[Tmp] = "dim"
          END IF

        CASE "lccpath$"
        Stk$[Tmp] = "LccPath$()"
        CompPtr += Convert2SimpleFunction(Tmp)

        Use_LccPath = Use_RegString = Use_Instrrev = TRUE
        Use_Left = UseFlag = TRUE

        CASE "loadfile$"
        Stk$[Tmp] = "$$LoadFile$"
        Use_LoadFile = Use_Get = UseFlag = TRUE
        Use_SysMacros = Use_Exist = Use_Lof = TRUE

        CASE "listboxloadfile"
        Stk$[Tmp] = "ListBoxLoadFile"
        Use_ListBoxLoadFile = TRUE
        Use_GetTextSize     = TRUE
        Use_Proto   = TRUE
        Use_Trim    = TRUE
        Use_String  = TRUE
        UseFlag     = TRUE

        CASE "lf$"
        Stk$[Tmp] = "LF$"
        Use_LF = UseFlag = TRUE

        CASE "line"
'jcfuller changed 7/20/2013
        IF iMatchWrd(Stk$[Tmp+1],"input") THEN
          Stk$[Tmp] = "lineinput"
          Stk$[Tmp+1]=""
          For j = 3 To Ndx
            IF *Stk$[j] = ASC(",") Then
              Stk$[j]=""
            END IF
          Next j
          INCR CompPtr
        END IF
'==============================================================================
'original
        'IF iMatchWrd(Stk$[Tmp+1],"input") THEN
          'Stk$[Tmp] = "lineinput"
          'j = Tmp + 4
          'Stk$[Tmp+1] = ""      ' Extract the file handle
          'INCR CompPtr
          'FOR i = Tmp+2 TO Ndx
            'IF *Stk$[i] = ASC(",") THEN j=i+1 : EXIT FOR
            'Stk$[Tmp+1] = Stk$[Tmp+1] + Stk$[i]
            'Stk$[i] = ""
          'NEXT j

          'FOR i = j TO Ndx
            'Stk$[Tmp+2]= Stk$[Tmp+2] & Stk$[i]
          'NEXT
        'END IF
'==============================================================================
        CASE "lcase$"
        IF iSubLoc = 2 THEN
          IF Stk$[Tmp+1] = "(" THEN
            Abort( "'lcase' can only be used as a Function Pointer when in a SET")
          END IF
          Stk$[Tmp] = "lcase"
        ELSE
          Stk$[Tmp] = "$$lcase$"
        END IF
        Use_Lcase = UseFlag = TRUE
        Use_StrUpLow = TRUE				        'jcfuller added
        CASE "ldouble"
        Stk$[Tmp] = "LDOUBLE"
        Use_Ldouble = UseFlag = TRUE

        CASE "left$"
        Stk$[Tmp] = "$$left$"
        Use_Left = UseFlag = TRUE

		CASE "lineinput"
		  Stk$[Tmp] = "LineInput"
		  If Use_TCLib Then
			Use_Tcl_LineInput = Use_Proto = TRUE
		  Else
		    Use_LineInput = Use_Proto = TRUE
		  End If	

        CASE "lprint"
        Stk$[Tmp] = "lprint"
        IF Tmp = Ndx THEN
          Ndx++
          Stk$[Ndx] = ENC$ ("")  ' Allow LPRINT with no args
        END IF

        CASE "lpad$"
        Stk$[Tmp] = "$$lpad$"
        Use_Lpad = UseFlag = TRUE

        CASE "ltrim$"
        Stk$[Tmp] = "$$ltrim$"
        Use_Ltrim = UseFlag = TRUE

        CASE "lof"
        Stk$[Tmp] = "lof"
        RAW Tmp2 = Tmp + 2
        IF DataType(Stk$[Tmp2]) = vt_NUMBER THEN
          Stk$[Tmp2] = "FP" + Stk$[Tmp2]
        END IF
        Use_Lof = Use_Proto = TRUE

        CASE "like"
        Stk$[Tmp] = "like"
        Use_Like  = Use_Proto = TRUE

        CASE "loc"
        RAW Tmp2 = Tmp + 2
        IF DataType(Stk$[Tmp2]) = vt_NUMBER THEN
          Stk$[Tmp2] = "FP" + Stk$[Tmp2]
        END IF
        Stk$[Tmp] = "loc(" + Stk$[Tmp2] + "," + Stk$[Tmp2] + "len)"
        Stk$[Tmp + 1] = ""
        Stk$[Tmp2] = ""
        Stk$[Tmp + 3] = ""
        INCR CompPtr
        Use_Loc = TRUE

        CASE "locate"
        Stk$[Tmp] = "locate"
        Use_Locate = Use_Console = Use_Proto = TRUE
	
	
      END SELECT

      CASE  13
      SELECT CASE Keyword$

        ' *********************************************************
        ' Special Case Handler: Substitute "Me." with "Me->"
        ' *********************************************************

        CASE "me"
        Stk$[Tmp] = "Me"
        RAW Tmp1 = Tmp + 1
        IF *Stk[Tmp1] = ASC(".") THEN
          Stk$[Tmp1] = "->" & MID$(Stk$[Tmp1],2)
        END IF

        CASE "mkd$"
        IF Tmp > 2 THEN
          IF INCHR(Stk$[Tmp-2],"$") AND *Stk$[Tmp-1] = ASC("=") THEN
            Stk$[1] = "memcpy(" + Stk$[1]
            Stk$[Tmp-1] = ","
            Stk$[++Ndx] = ",9)"
          END IF
        END IF
        Stk$[Tmp] ="MKD"
        Use_Mkd = UseFlag = TRUE

        CASE "mki$"
        IF Tmp > 2 THEN
          IF INCHR(Stk$[Tmp-2],"$") AND *Stk$[Tmp-1] = ASC("=") THEN
            Stk$[1] = "memcpy(" + Stk$[1]
            Stk$[Tmp-1] = ","
            Stk$[++Ndx] = ",3)"
          END IF
        END IF
        Stk$[Tmp] ="MKI"
        Use_Mki = UseFlag = TRUE

        CASE "mkl$"
        IF Tmp > 2 THEN
          IF INCHR(Stk$[Tmp-2],"$") AND *Stk$[Tmp-1] = ASC("=") THEN
            Stk$[1] = "memcpy(" + Stk$[1]
            Stk$[Tmp-1] = ","
            Stk$[++Ndx] = ",5)"
          END IF
        END IF
        Stk$[Tmp] ="MKL"
        Use_Mkl = UseFlag = TRUE

        CASE "mkld$"
        IF Tmp > 2 THEN
          IF INCHR(Stk$[Tmp-2],"$") AND *Stk$[Tmp-1] = ASC("=") THEN
            Stk$[1] = "memcpy(" + Stk$[1]
            Stk$[Tmp-1] = ","
            Stk$[++Ndx] = ",11)"
          END IF
        END IF
        Stk$[Tmp] ="MKLD"
        Use_Mkld = UseFlag = TRUE

        CASE "mks$"
        IF Tmp > 2 THEN
          IF INCHR(Stk$[Tmp-2],"$") AND *Stk$[Tmp-1] = ASC("=") THEN
            Stk$[1] = "memcpy(" + Stk$[1]
            Stk$[Tmp-1] = ","
            Stk$[++Ndx] = ",5)"
          END IF
        END IF
        Stk$[Tmp] ="MKS"
        Use_Mks = UseFlag = TRUE

        CASE "mid$"
        IF Tmp > 1 THEN
          Stk$[Tmp] = "$$mid$"
          Use_Mid = UseFlag = TRUE
        ELSE
          Stk$[Tmp] = "midstr"
          Use_Midstr = TRUE
        END IF

        CASE "min"
          If UseCpp = FALSE Then
            Stk$[Tmp] = "MIN"
            Use_Min = Use_Proto = TRUE
          End If

        CASE "max"
          If UseCpp = FALSE Then
            Stk$[Tmp] = "MAX"
            Use_Max = Use_Proto = TRUE
          End If
        CASE "mcase$"
        IF iSubLoc = 2 THEN
          IF Stk$[Tmp+1] = "(" THEN
            Abort( "'mcase' can only be used as a Function Pointer when in a SET")
          END IF
          Stk$[Tmp] = "mcase"
        ELSE
          Stk$[Tmp] = "$$mcase$"
        END IF
        Use_Mcase = UseFlag = Use_StrUpLow = TRUE

        CASE "modstyle"
        Stk$[Tmp] = "ModStyle"
        Use_Modstyle = Use_Proto = TRUE

        CASE "msgbox"
        RAW Tmm1 = Tmp - 1
        IF Stk$[Tmm1]= "=" OR iMatchWrd(Stk$[Tmm1], "if") OR iMatchWrd(Stk$[Tmm1], "elseif") THEN
          Stk$[Tmp] = "MsgBox"
          Use_Msgbox = Use_Proto = TRUE
        END IF
      END SELECT

      CASE  14
      SELECT CASE Keyword$

        CASE "new"
        IF iMatchWrd(Stk$[Tmp-1],"binary") THEN EXIT SELECT
        IF UseCpp = FALSE THEN Abort( "'NEW' can only be used with C++" )
        Stk$[Tmp] = "new "

        ' For compatibility with VB code, See CreateObject for more details what I'm doin' here
        CASE "nothing"
        Use_COM = TRUE

        ' Next line should be called only if NOT inside (IF...END IF)
        ' BCX_Remove_COM_Object(Stk$[1]) ' temporary disbled until I figure out is it called from (IF...END IF)

        RAW sObj$
        RAW i = 2
        sObj$ = "&" & Stk$[1]
        WHILE Stk$[i] <> "="
          CONCAT(sObj$, Stk$[i])
          i++
        WEND

        Stk$[1] = "BCX_SetNothing"
        Stk$[2] = "("
        Stk$[3] = sObj$
        Stk$[4] = ")"
        Ndx = 4

        CASE "notequalto"
        Stk$[Tmp] = " NotEqualTo "
        Use_NotEqualTo = Use_SysMacros = TRUE

        CASE "nul$"
        Stk$[Tmp] = "NUL$"
        Use_NUL = UseFlag = TRUE

        CASE "now$"
        IF Stk$[Tmp+1]<> "(" THEN
          Stk$[Tmp] = "now$()"
        ELSE
          Stk$[Tmp] = "now$"
        END IF
        Use_Now = UseFlag = TRUE
      END SELECT

      CASE  15
      SELECT CASE Keyword$

        CASE "object"
        IF ComSwitchON THEN
          Stk$[Tmp] = "OBJECT"
          Use_COM = UseFlag = TRUE
        END IF

        CASE "open"
        FOR A = Tmp+1 TO Ndx
          IF *Stk$[A] = ASC("#") THEN
            Stk$[A] = MID$(Stk$[A],2)
            EXIT FOR
          END IF
        NEXT

        CASE "oct$"
        Stk$[Tmp] = "oct$"
        Use_Oct = UseFlag = TRUE

        CASE "orelse"
        Stk$[Tmp] = " OrElse "
        Use_OrElse = Use_SysMacros = TRUE

        CASE "outp"
        Stk$[Tmp] = "Outp"
        Use_Outp = Use_SysMacros = TRUE

        CASE "outpw"
        Stk$[Tmp] = "Outpw"
        Use_Outpw = Use_SysMacros = TRUE

        CASE "osversion"
        Stk$[Tmp] = "OSVersion()"
        CompPtr += Convert2SimpleFunction(Tmp)
        '------------------------------------------------------------------------------
        'jcfuller added 9/14/2013 from bcx 7.0.8
        IF Use_OSVersion = FALSE THEN
          CALL EmitOSVersionEnum()
        END IF
        '------------------------------------------------------------------------------
        Use_OSVersion = Use_Proto = TRUE

      END SELECT

      CASE  16
      SELECT CASE Keyword$

        CASE "pellespath$"
        Stk$[Tmp] = "PellesPath$()"
        CompPtr += Convert2SimpleFunction(Tmp)
        Use_PellesPath = Use_RegString = Use_Instrrev = TRUE
        Use_Left = UseFlag = TRUE

        CASE "printer"
          RAW Tmp1 = Tmp+1
          IF *Stk[Tmp1] THEN
            IF iMatchWrd(Stk$[Tmp1],"open")      THEN Stk$[Tmp] = "printeropen"
            IF iMatchWrd(Stk$[Tmp1],"ejectpage") THEN Stk$[Tmp] = "ejectpage"
            IF iMatchWrd(Stk$[Tmp1],"close")     THEN Stk$[Tmp] = "printerclose"
            IF iMatchWrd(Stk$[Tmp],"printer")    THEN CALL Abort("Unkown word '"+Stk$[Tmp1]+"' with printer")
            CALL DeleteTokens(Tmp1,1)
          ELSE
            Ndx = 0
          END IF
          Use_Printer = Use_Proto = TRUE
          iEmitVariableGroup = iEmitVariableGroup BOR ePrinterGroup
          Use_Mid = Use_Left = Use_StrStr = TRUE
          Use_Extract = Use_Str = UseFlag = TRUE

        CASE "print"
        IF *Stk$[Tmp+1] = ASC("#") THEN
          Stk$[Tmp] = "fprint"
          Stk$[Tmp+1] = MID$(Stk$[Tmp+1],2)
        END IF

        CASE "ptr"
        CompPtr = 1
        CONCAT(Stk$[Tmp-1], "*")
        Stk$[Tmp] = ""
        IF Tmp = Ndx THEN
          Ndx--
          WHILE TALLY(Stk$[Ndx],"*") = (int)(LEN(Stk$[Ndx]))
            CONCAT(Stk$[Ndx-1], Stk$[Ndx])
            Stk$[Ndx] = ""
            Ndx--
          WEND
        ELSE
          i = Tmp-1
          WHILE TALLY(Stk$[i],"*") = (int)(LEN(Stk$[i]))
            CONCAT(Stk$[i-1],Stk$[i])
            Stk$[i--] = ""
          WEND
        END IF

        CASE "panel"
        Stk$[Tmp] = "panel"
        Use_Panel = Use_Console = Use_Proto = TRUE

        CASE "pause"
        Stk$[Tmp] = "Pause()"
        CompPtr += Convert2SimpleFunction(Tmp)
        'IF UseCpp = FALSE THEN Use_Keypress = TRUE
        Use_Pause = Use_Proto = Use_Getch = TRUE

        CASE "peek$"
        Stk$[Tmp] = "$$peekstr$"
        Use_PeekStr = UseFlag = TRUE

        CASE "playwav"
        Stk$[Tmp] = "PlayWav"
        Use_PlayWav = Use_GetResource = Use_Proto = TRUE

        CASE "pos"
        Stk$[Tmp] = "Pos()"
        Use_Pos   = Use_Proto = TRUE

        CASE "private"
        IF iMatchWrd(Stk$[Tmp+1],"const") THEN



          Stk$[Tmp] = "enum "
          Stk$[Tmp+1]= Stk$[Tmp+2] + "{"
          Ndx++
          Stk$[Ndx]= "}"
        ELSE
          Stk$[1] = "private"
        END IF
      END SELECT

      CASE  17
      SELECT CASE Keyword$
        CASE "qbcolor"
        Stk$[Tmp] = "qbcolor"
        Use_QBColor = Use_Proto = TRUE
      END SELECT

      CASE  18
      SELECT CASE Keyword$

        CASE "rewind"
        Stk$[Tmp] = "rewind"
        RAW Tmp2 = Tmp + 2
        IF DataType(Stk$[Tmp2]) = vt_NUMBER THEN
          Stk$[Tmp2] = "FP" + Stk$[Tmp2]
        END IF

        CASE "remove$"
        Stk$[Tmp] = "$$RemoveStr$"
        Use_Remove = Use_StrStr = UseFlag = TRUE

        CASE "replace$"
        Stk$[Tmp] = "$$replace$"
        Use_Replace = Use_StrStr = UseFlag = TRUE

        CASE "right$"
        Stk$[Tmp] = "$$right$"
        Use_Right = UseFlag = TRUE

        CASE "randomize"
        Stk$[Tmp] = "randomize"
        Use_Randomize = TRUE
        Use_Rnd   = TRUE
        Use_Proto = TRUE
        IF Ndx = 1 THEN
          Use_Timer = TRUE
          Stk$[1] ="randomize(timer())"
        END IF

        CASE "rec"
        RAW Tmp2 = Tmp + 2
        IF DataType(Stk$[Tmp2]) = vt_NUMBER THEN
          Stk$[Tmp2] = "FP" + Stk$[Tmp2]
        END IF
        Stk$[Tmp] = "rec(" + Stk$[Tmp2] + "," + Stk$[Tmp2] + "len)"
        Stk$[Tmp + 1] = ""
        Stk$[Tmp2] = ""
        Stk$[Tmp + 3] = ""
        INCR CompPtr
        Use_Rec = Use_Proto = TRUE

        CASE "reccount"
        DIM RAW length$
        RAW Tmp2 = Tmp + 2
        IF DataType(Stk$[Tmp2]) = vt_NUMBER THEN
          Stk$[Tmp2] = "FP" + Stk$[Tmp2]
        END IF

        Stk$[Tmp] = "reccount"
        length$ = Stk$[Tmp2] + "len)"

        FOR i = Tmp+1 TO Ndx
          IF *Stk$[i] = ASC(")") THEN
            Stk$[i] = ""
            INCR CompPtr
            EXIT FOR
          END IF
          Stk$[Tmp] = Stk$[Tmp] + Stk$[i]
          Stk$[i] = ""
          INCR CompPtr
        NEXT

        Stk$[Tmp] = Stk$[Tmp] + "," + length$
        Use_RecCount = Use_Proto = TRUE

        CASE "refresh"
        Stk$[Tmp] = "Refresh"
        Use_Refresh = Use_SysMacros = TRUE

        CASE "regstring$"
        Stk$[Tmp] = "$$RegString$"
        CompPtr += Convert2SimpleFunction(Tmp)
        Use_RegString = UseFlag = TRUE

        CASE "regexist"
        Stk$[Tmp] = "RegExist"
        CompPtr += Convert2SimpleFunction(Tmp)
        Use_RegExist = UseFlag = TRUE

        CASE "regint"
        Stk$[Tmp] = "RegInt"
        CompPtr += Convert2SimpleFunction(Tmp)
        Use_RegInt = UseFlag = TRUE

        CASE "remain$"
        Stk$[Tmp] = "$$remain$"
        Use_Remain = UseFlag = TRUE

        CASE "retain$"
        Stk$[Tmp] = "$$Retain$"
        Use_Retain = UseFlag = TRUE

        CASE "repeat$"
        Stk$[Tmp] = "$$repeat$"
        Use_Repeat = UseFlag = TRUE

        CASE "reverse$"
        Stk$[Tmp] = "$$reverse$"
        Use_Reverse = UseFlag = TRUE

        CASE "rnd"
        Stk$[Tmp] = "rnd()"
        CompPtr += Convert2SimpleFunction(Tmp)

        Use_Rnd = Use_Proto = TRUE

        CASE "round"
        Stk$[Tmp] = "Round"
        Use_Round = Use_Proto = TRUE

        CASE "rpad$"
        Stk$[Tmp] = "$$rpad$"
        Use_Rpad = UseFlag = TRUE

        CASE "rtrim$"
        Stk$[Tmp] = "$$rtrim$"
        Use_Rtrim = UseFlag = TRUE

        CASE "run"
        If Tmp > 1 Then
          If Stk$[Tmp-2] <> ":" AND Stk$[Tmp-1] <> ":" Then
            Stk$[Tmp] = "Run"
            Use_Run = Use_Proto = TRUE
          End If
        Else
            Stk$[Tmp] = "Run"
            Use_Run = Use_Proto = TRUE
        End If
'IF _ZTRACE_ Then
'	ZPRINT(Stk$[Tmp-2])
'	ZPRINT(Stk$[Tmp-1])
'END IF

'jcfuller added
        CASE "ref"
        'CASE "ptr"
        CompPtr = 1
        CONCAT(Stk$[Tmp-1], "&")
        Stk$[Tmp] = ""
        IF Tmp = Ndx THEN
          Ndx--
          WHILE TALLY(Stk$[Ndx],"&") = (int)(LEN(Stk$[Ndx]))
            CONCAT(Stk$[Ndx-1], Stk$[Ndx])
            Stk$[Ndx] = ""
            Ndx--
          WEND
        ELSE
          i = Tmp-1
          WHILE TALLY(Stk$[i],"&") = (int)(LEN(Stk$[i]))
            CONCAT(Stk$[i-1],Stk$[i])
            Stk$[i--] = ""
          WEND
        END IF

      END SELECT

      CASE  19
      SELECT CASE Keyword$

        CASE "setdimension"
        Stk$[Tmp] = "SetDimension"
        Use_SetDimension = Use_Proto = TRUE

        CASE "spc$"
        Stk$[Tmp] = "SPC$"
        Use_SPC = UseFlag = TRUE

        CASE "startdraw"
        Stk$[Tmp] = "StartDraw"
        Use_Draw = TRUE

        CASE "str_cmp"
          Stk$[Tmp] = "str_cmp"
          Use_Str_Cmp = TRUE

        CASE "str$"
        Stk$[Tmp] = "$$str$"
        Use_Str = UseFlag = TRUE
'jcf added 11/02/2013
		CASE "sstr"
		  Stk$[Tmp] = "sstr"
		  Use_Sstr = UseFlag =TRUE
'jcf added 11/03/2013
		CASE "sscvrt"
		  Stk$[Tmp] = "sscvrt"
		  Use_Sscvrt = TRUE
        CASE "str2variant"
        'INPUT:
        ' str2variant(string,variant)
        'TRANSFORMS TO
        ' BCX_COM_AS2WS(sBuf)
        ' lComVariant.vt = VT_BSTR
        ' lComVariant.bstrVal = SysAllocString(bcx_temp_wide_string_pointer)
        CALL Add2SplitLines("BCX_COM_AS2WS("+Stk$[Tmp+2]+")")
        CALL Add2SplitLines(Stk$[Tmp+4] + ".vt = VT_BSTR")
        CALL Add2SplitLines(Stk$[Tmp+4] + ".bstrVal = SysAllocString(bcx_temp_wide_string_pointer)")
        Ndx = 0

        CASE "strl$"
        Stk$[Tmp] = "$$strl$"
        Use_Strl = UseFlag = TRUE

        CASE "searchpath$"
        Stk$[Tmp] = "$$SEARCHPATH$"
        Use_SearchPath = UseFlag  = TRUE

        CASE "sendmessage", "sndmsg"
        '*****************************
        '    SendMessage HELPER
        '*****************************
        IF NOT iMatchWrd(Stk$[1],"const") THEN
          Stk$[Tmp] = "SendMessage"
          Comma = i = 0
          A = Tmp+1

          DO
            IF A > Ndx THEN Abort("Malformed SendMessage")
            A++
            IF INCHR("([{",Stk$[A]) THEN INCR i
            IF INCHR(")]}",Stk$[A]) THEN DECR i
            IF i <> 0 THEN ITERATE

            IF *Stk$[A] = ASC(",") THEN
              IF Comma = 0 THEN
                IF NOT iMatchWrd(Stk$[A+2],"UINT") THEN
                  InsertTokens(A,3,"(","UINT",")")
                END IF
              ELSEIF Comma = 1 THEN
                IF NOT iMatchWrd(Stk$[A+2],"WPARAM") THEN
                  InsertTokens(A,3,"(","WPARAM",")")
                END IF
              ELSEIF Comma = 2 THEN
                IF NOT iMatchWrd(Stk$[A+2],"LPARAM") THEN
                  InsertTokens(A,3,"(","LPARAM",")")
                END IF
                EXIT DO
              END IF
              Comma++
            END IF    'Is a comma
          LOOP
        END IF

        CASE "savebmp"
        Stk$[Tmp] = "SaveBmp"
        Use_SaveBmp = Use_Proto = UseFlag = TRUE

        CASE "set_bcx_bitmap"
        Stk$[Tmp] = "Set_BCX_Bitmap"
        Use_Set_BCX_Bitmap = UseFlag = TRUE

        CASE "set_bcx_bitmap2"
        Stk$[Tmp] = "Set_BCX_Bitmap2"
        Use_Set_BCX_Bitmap2 = UseFlag = TRUE

        CASE "set_bcx_bmpbutton"
        Stk$[Tmp] = "Set_BCX_BmpButton"
        Use_Set_BCX_BmpButton = UseFlag = TRUE

        CASE "set_bcx_icon"
        Stk$[Tmp] = "Set_BCX_Icon"
        Use_Proto = TRUE
        Use_Set_BCX_Icon = Use_GetResource = TRUE

        CASE "screen"
        Stk$[Tmp] = "Screen"
        Use_Screen = Use_Proto = TRUE

        CASE "setattr"
        Stk$[Tmp] = "SETATTR"
        Use_Setattr = Use_SysMacros = TRUE

        CASE "setwindowrtftext"
        Stk$[Tmp] = "SetWindowRTFText"
        Use_Richedit = UseFlag = TRUE

        CASE "sgn"
        Stk$[Tmp] = "sgn"
        Use_Sgn = Use_Proto = TRUE

        CASE "show"
        Stk$[Tmp] = "Show"
        Use_Show = Use_SysMacros = TRUE

        CASE "showmodal"
        Stk$[Tmp] = "ShowModal"
        Use_Show = Use_SysMacros = Use_ShowModal = Use_EndModal = TRUE

        CASE "space$"
        Stk$[Tmp] = "$$space$"
        Use_Space = UseFlag = TRUE

        CASE "sound"
        Stk$[Tmp] = "Sound"
        Use_Sound = Use_Round = Use_Str = UseFlag = TRUE ' Use_Abs = TRUE

        CASE "split"
        Stk$[Tmp] = "Split"
        Use_Proto = TRUE
        UseFlag   = TRUE
        Use_Split = TRUE
        Use_Remove= TRUE
        Use_StrStr= TRUE
        Use_Mid   = TRUE
        Use_Left  = TRUE
        Use_Instr = TRUE
        Use_Stristr = TRUE
        UseLCaseTbl = TRUE
        Use_StrUpLow = TRUE
        Use_Lcase = TRUE
        CASE "strim$"
        Stk$[Tmp] = "$$strim$"
        Use_Strim = UseFlag = TRUE

        CASE "string$"
        Stk$[Tmp] = "$$stringx$"
        Use_String = UseFlag = TRUE

        CASE "strptr"
        Stk$[Tmp] = "STRPTR"
        Use_Strptr = Use_SysMacros = TRUE

        CASE "strtoken$"
        Stk$[Tmp] = "StrToken$"
        Use_Strtoken = UseFlag = Use_Mid = Use_Left = Use_Extract = TRUE
        Use_Instr =Use_Instrrev = Use_Stristr = Use_Tally = Use_Remove = TRUE
        Use_StrStr = UseLCaseTbl = Use_Lcase = Use_StrUpLow = TRUE

        CASE "swap"
        Stk$[Tmp] = "swap"
        Use_Swap = Use_Proto = TRUE

        CASE "sysdir$"
        Stk$[Tmp] = "$$sysdir$()"
        CompPtr += Convert2SimpleFunction(Tmp)
        Use_Sysdir = UseFlag = TRUE

        CASE "sysstr"
        Stk$[Tmp] = "SysStr"
        Use_SysStr = Use_Proto = TRUE

      END SELECT

      CASE  20
      SELECT CASE Keyword$

        CASE "tab$"
        Stk$[Tmp] = "TAB$"
        Use_TAB = UseFlag = TRUE
'jcfuller changed 07/01/2013
        CASE "true"
'        IF UseCpp THEN
'          Stk$[Tmp] = "true"
'        ELSE
          Stk$[Tmp] = "TRUE"
'        END IF

        CASE "trim$"
        Stk$[Tmp] = "$$trim$"
        Use_Trim = UseFlag = TRUE

        CASE "tally"
        Stk$[Tmp] = "tally"
        Use_Tally = UseLCaseTbl = Use_Stristr = Use_StrStr = Use_Proto = Use_Lcase = UseFlag = Use_StrUpLow = TRUE

        CASE "tempdir$"
        Stk$[Tmp] = "$$tempdir$()"
        CompPtr += Convert2SimpleFunction(Tmp)
        Use_Tempdir = UseFlag = TRUE

        CASE "tempfilename$"
        Stk$[Tmp] = "$$TempFileName$"
        Use_TempFileName = UseFlag = TRUE

        CASE "textmode"
        Stk$[Tmp] = "TextMode"
        Use_Textmode = Use_Proto = TRUE

        CASE "time$"
        IF Stk$[Tmp+1] <> "("  THEN
          Stk$[Tmp] = "$$timef$()"
        ELSE
          Stk$[Tmp] = "$$timef$"
        END IF
        CompPtr += Convert2SimpleFunction(Tmp)
        Use_Time = UseFlag = TRUE

        CASE "timer"
        Stk$[Tmp] = "timer()"
        CompPtr += Convert2SimpleFunction(Tmp)
        Use_Timer = Use_Proto = TRUE

      END SELECT

      CASE  21
      SELECT CASE Keyword$

        CASE "ucase$"
        IF iSubLoc = 2 THEN
          IF Stk$[Tmp+1] = "(" THEN
            Abort( "'ucase' can only be used as a Function Pointer when in a SET")
          END IF
          Stk$[Tmp] = "ucase"
        ELSE
          Stk$[Tmp] = "$$ucase$"
        END IF
        Use_Ucase = UseFlag = TRUE
        Use_StrUpLow = TRUE				        'jcfuller added
        CASE "ubound"
        Stk$[Tmp] = "ubound"
        Use_Ubound = Use_SysMacros = TRUE

        CASE "using$"
        Stk$[Tmp] = "$$Using$"
        Use_Using = UseFlag = TRUE
      END SELECT

      CASE  22
      SELECT CASE Keyword$

        CASE "val"
        Stk$[Tmp] = "VAL"
        Use_Val = Use_SysMacros = TRUE

        CASE "vall"
        Stk$[Tmp] = "VALL"
        Use_Vall = Use_SysMacros = TRUE

        CASE "variant2str"
        'INPUT:
        ' variant2str(variant, string)
        'TRANSFORMS TO
        ' BEGINBLOCK
        ' RAW sBuf[wlen(variant.bstrVal)+2] AS char
        ' wstrcpy(sBuf, lComVariant.bstrVal)
        ' BCX_COM_WS2AS(sBuf)
        ' string = bcx_temp_ans_string_pointer$
        ' ENDBLOCK
        CALL Add2SplitLines("BEGINBLOCK")
        CALL Add2SplitLines("RAW sBuf[wlen("+Stk$[Tmp+2]+".bstrVal)+2] AS char")
        CALL Add2SplitLines("wstrcpy(sBuf,"+Stk$[Tmp+2]+".bstrVal)")
        CALL Add2SplitLines("BCX_COM_WS2AS(sBuf)")
        CALL Add2SplitLines(Stk$[Tmp+4]+" = bcx_temp_ans_string_pointer$")
        CALL Add2SplitLines("ENDBLOCK")
        Ndx = 0
        Use_BCX_COM_UsesConversion = TRUE

        CASE "varptr"
        Stk$[Tmp] = ""
        INCR CompPtr

        CASE "vchr$"
        Stk$[Tmp] = "$$vchr$"
        Use_VChr = UseFlag = TRUE

        CASE "vt$"
        Stk$[Tmp] = "VT$"
        Use_VT = UseFlag = TRUE

        CASE "virtual"
          IF Tmp = 1 THEN

            Stk$[Tmp] = "dim"
            IsVirtual = TRUE
            RAW i = Ndx
            WHILE Stk$[i] <> ")" : i-- : WEND
            i++
            IF iMatchWrd(Stk$[Ndx],"stdcall") THEN
              RAW iNdx = Ndx-1
              IF iMatchWrd(Stk$[iNdx],"as") THEN iNdx--
              IF i <= iNdx THEN
                CALL BuildDelimStr(i, iNdx, szVirtual$)
              ELSE
                szVirtual$ = ""
              END IF
            ELSE
              IF i <= Ndx THEN
            CALL BuildDelimStr(i, Ndx, szVirtual$)

          ELSE
                szVirtual$ = ""
              END IF
            END IF
          ELSE
            ' Misplaced ???
          END IF

        CASE "vector"
          IF Stk$[Tmp+1] = "<" THEN
            Stk$[Tmp] = "vector"
            HasVector = TRUE
          END IF

        CASE "verify"
        Stk$[Tmp] = "Verify"
        Use_Verify = Use_Mid = UseFlag = TRUE

        CASE "vbs_addcode","vbs_run_script","vbs_eval_str$"
        Stk$[Tmp] = UCASE$(Stk$[Tmp])
        Use_VBS = UseFlag = TRUE

        CASE "vbs_eval_num","vbs_eval_num#"
        Stk$[Tmp] = "VBS_EVAL_NUM#"
        Use_VBS = UseFlag = TRUE

        CASE "vbs_start","vbs_stop","vbs_reset","vbs_error$"
        Use_VBS = UseFlag = TRUE
        Stk$[Tmp] = UCASE$(Stk$[Tmp]) + "()"
        CompPtr += Convert2SimpleFunction(Tmp)

      END SELECT

      CASE  23
      SELECT CASE Keyword$

        CASE "widetoansi$"
        Stk$[Tmp] = "$$WideToAnsi$"
        Use_WideToAnsi = UseFlag = TRUE


        CASE "windir$"
        Stk$[Tmp] = "$$windir$()"
        CompPtr += Convert2SimpleFunction(Tmp)
        Use_Windir = UseFlag = TRUE

        CASE "wndproc"
        IF Tmp = 2 AND Ndx < 6 THEN
          Src$ = "FUNCTION|WndProc(hWnd|AS|HWND,Msg|AS|UINT,wParam|AS|WPARAM,lParam|AS|LPARAM)|AS|CALLBACK|LRESULT"
          'Src$ = "FUNCTION|LRESULT CALLBACK WndProc(hWnd|AS|HWND,Msg|AS|UINT,wParam|AS|WPARAM,lParam|AS|LPARAM)"
          FastLexer(Src$,"|",",()")
          Use_Wingui = TRUE 'Use_Str_Cmp = Use_Ucase = TRUE
        END IF

        CASE "winmain"
        Use_Wingui = InWinMain = TRUE 'Use_Str_Cmp = Use_Ucase = TRUE
        IF Tmp = 2 AND Ndx < 6 THEN
          Src$ = "FUNCTION|WinMain(hInst|AS|HINSTANCE,hPrev|AS|HINSTANCE,CmdLine|AS|LPSTR,CmdShow|AS|int)AS|int WINAPI"
          FastLexer(Src$,"|",",()")
        ELSE
          Stk$[Tmp] = "WinMain"
        END IF

		'jcf added 11/02/2013
		CASE "wstr"
		  Stk$[Tmp] = "wstr"
		  Use_Wstr = UseFlag =TRUE

      END SELECT

    CASE  26
      SELECT CASE Keyword$

      CASE "zstring"
        IF iMatchWrd(Stk$[Tmp+1], "ptr") THEN
          Stk$[Tmp] = "char"
          INCR Tmp
          INCR CompPtr
          Stk$[Tmp-1] = Stk$[Tmp-1] + "*"
          Stk$[Tmp] = ""
          INCR CompPtr
          IF Tmp = Ndx THEN
            Ndx--
            WHILE TALLY(Stk$[Ndx],"*") = (int)(LEN(Stk$[Ndx]))
              CONCAT(Stk$[Ndx-1], Stk$[Ndx])
              Stk$[Ndx] = ""
              Ndx--
            WEND
          ELSE
            i = Tmp-1
            WHILE TALLY(Stk$[i],"*") = (int)(LEN(Stk$[i]))
              CONCAT(Stk$[i-1], Stk$[i])
              Stk$[i] = ""
              i--
              CompPtr++
            WEND
          END IF
        END IF
        Stk$[Tmp] = "string"
      END SELECT

    CASE 27
      SELECT CASE Keyword$
        CASE "$ifndef"
        Stk$[Tmp] = "~ifndef"
        InConditional++

        CASE "$if","$ifdef"
        Stk$[Tmp] = "~if"
        InConditional++

        CASE "$endif"
        Stk$[Tmp] = "~endif"
        InConditional--
        IF InConditional < 0 THEN       'simple check to see if conditionals are balanced
          Abort("To many $ENDIFs")
        END IF
      END SELECT
    END SELECT
  NEXT





  IF CompPtr THEN CALL RemEmptyTokens()

  '************************************************************
  ' Moved the WITH/END WITH handling here from the Emit sub
  ' The ill formed variables would cause conflict with the new
  ' AsmUnKnown structs function.
  '************************************************************
  IF PrependCnt THEN
    i = PrependCnt
    WHILE i
      IF NOT iMatchWrd(Stk$[1],"with") AND NOT iMatchWrd(Stk$[1],"prepend") AND NOT iMatchWrd(Stk$[1],"endwith") AND NOT iMatchWrd(Stk$[1],"endprepend") THEN
        CALL InsertTokens(0,1,PrependVar$[i])
      END IF
      i--
    WEND
    'CALL BuildDelimStr(1,Ndx, Src$)
    'CALL XParse(Src$)
  END IF

'jcf added 09/08/2014
'same code as prepend
  IF WithCnt Then
	i = WithCnt
    WHILE i
      IF NOT iMatchWrd(Stk$[1],"with") AND NOT iMatchWrd(Stk$[1],"prepend") AND NOT iMatchWrd(Stk$[1],"endwith") AND NOT iMatchWrd(Stk$[1],"endprepend") THEN
        CALL InsertTokens(0,1,WithVar$[i])
      END IF
      i--
    WEND
  End If

  'IF WithCnt THEN
    'i = Ndx
    'WHILE i
      'IF LEFT$(Stk$[i],2) = "->" OR (*Stk$[i] = ASC(".") AND NOT IsNumber(Stk[i]+1)) THEN
        'IF WithVar$[WithCnt] = "Me" AND *Stk$[i] = ASC(".") THEN
          'Stk$[i] = "->" + MID$(Stk$[i],2)
        'END IF
        'Stk$[i] = WithVar$[WithCnt] + Stk$[i]
      'END IF
      'i--
    'WEND
  'END IF
  IF PrependCnt THEN
    CALL BuildDelimStr(1,Ndx, Src$)
    CALL XParse(Src$)
  END IF

  IF WithCnt THEN
    CALL BuildDelimStr(1,Ndx, Src$)
    CALL XParse(Src$)
  END IF

'$COMMENT
    'FOR i = 1 TO Ndx
      'IF LEFT$(Stk$[i],2) = "->" OR (LEFT$(Stk$[i],1) = "." AND NOT IsNumber(MID$(Stk$[i],2,1))) THEN
        'IF WithVar$[WithCnt] = "Me" AND LEFT$(Stk$[i],1) = "." THEN
          'Stk$[i] = "->" + MID$(Stk$[i],2)
        'END IF
        'IF i = 1 THEN
          'Stk$[i] = WithVar$[WithCnt] + Stk$[i]
        'ELSE
          'IF NOT IsReservedWord(Stk$[i-1]) THEN
            'IF NOT (isalpha(Stk[i-1][LEN(Stk$[i-1]-1)]) OR IsNumber(RIGHT$(Stk$[i-1],LEN(Stk$[i-1]-1)))) THEN
              'Stk$[i] = WithVar$[WithCnt] + Stk$[i]
            'END IF
          'ELSE
            'Stk$[i] = WithVar$[WithCnt] + Stk$[i]
          'END IF
        'END IF
        'WHILE (isalpha(*Stk[i+1]) OR *Stk[i+1] = ASC(".")) AND (i < Ndx)
          'INCR i
        'WEND
      'END IF
    'NEXT
  'END IF
'$COMMENT

  '************************************************************
  ' handle programming style global and locals using same name
  '************************************************************

  IF CompToken = 1 THEN

    Keyword$ = LCASE$(Stk$[1])

    SELECT CASE Keyword$
      CASE "dim"         :  CompToken = 0
      CASE "local"       :  CompToken = 0
      CASE "global"      :  CompToken = 0
      CASE "static"      :  CompToken = 0
      CASE "shared"      :  CompToken = 0
      CASE "raw"         :  CompToken = 0
      CASE "dynamic"     :  CompToken = 0
      CASE "free"        :  CompToken = 0
      CASE "redim"       :  CompToken = 0
      CASE "sub"         :  CompToken = 0
      CASE "function"    :  CompToken = 0
      CASE "overloaded"  :  CompToken = 0
      CASE "callback"    :  CompToken = 0
      CASE "public"      :  CompToken = 0
      CASE "declare"     :  CompToken = 0
      CASE "c_declare"   :  CompToken = 0
      'CASE "auto"        :  CompToken = 0
      'CASE "register"    :  CompToken = 0
      CASE "extern"      :  CompToken = 0
      CASE ELSE          :  CALL AsmUnknownStructs(1)
    END SELECT

  END IF
END SUB ' TokenSubstitutions



SUB JoinStrings(iThisToken, inif )
  DIM RAW DoJoin   = 0
  DIM RAW InBrace  = 0
  DIM RAW OnlyPara = 0
  DIM RAW j  = 0
  DIM RAW sj = iThisToken
  DIM RAW szToken$
  DIM RAW vt

  WHILE iThisToken <= Ndx

    szToken$ = Stk$[iThisToken]

    IF NOT j AND NOT OnlyPara AND NOT InBrace THEN
      vt = DataType(szToken$)
      IF vt = vt_INT THEN vt = GetNextVarType(iThisToken)
      IF vt = vt_STRVAR OR vt = vt_STRLIT THEN
        sj = iThisToken
        INCR iThisToken
        ITERATE
      END IF
    END IF

    szToken$ = LCASE$(szToken$)

    SELECT CASE szToken$

      CASE "&"
        IF OnlyPara THEN EXIT SELECT
'FIX ME
        vt = DataType(Stk$[iThisToken+1])
        IF vt = vt_INT THEN vt = GetNextVarType(iThisToken+1)
        IF vt <> vt_STRVAR AND vt <> vt_STRLIT THEN
          vt = DataType(Stk$[iThisToken-1])
          IF vt = vt_INT THEN vt = GetPrevVarType(iThisToken-1, 1)
        END IF
        IF vt = vt_STRVAR OR vt = vt_STRLIT THEN
          j++
          Stk$[iThisToken] = ","
          szToken$ = ""
        END IF

      CASE "["
        INCR InBrace

      CASE "]"
       DECR InBrace

      CASE "("
        IF Stk$[iThisToken+1] <> "*" THEN
          CALL JoinStrings(iThisToken+1, inif)
          RAW iBuildHere = iThisToken-1
          WHILE Stk$[iThisToken] <> ")"
            Stk$[iBuildHere] = Stk$[iBuildHere] + Stk$[iThisToken] + " "
            Stk$[iThisToken] = ""
            iThisToken++
          WEND
          CONCAT(Stk$[iBuildHere], Stk$[iThisToken])
          Stk$[iThisToken] = ""
        END IF

      CASE ")"
        IF j THEN
          Stk$[sj] = "join$(" + STR$(j+1) + "," + Stk$[sj]
          j = sj
          WHILE ++j < iThisToken
            CONCAT(Stk$[sj], Stk$[j])
            Stk$[j] = ""
          WEND
          CONCAT(Stk$[sj], ")")
        END IF
        EXIT SUB

      CASE "||"
        Stk$[iThisToken] = " or "
        DoJoin = TRUE

      CASE "&&"
        Stk$[iThisToken] = " and "
        DoJoin = TRUE

      CASE "then", "for", "xfor"
        DoJoin = TRUE

      CASE "="
        IF NOT inif THEN
          OnlyPara = TRUE
        ELSE
          DoJoin = TRUE
        END IF

      CASE "if", "elseif", "while"
        inif = TRUE
        sj = iThisToken + 1

      CASE  "sprint", "lprint", "fprint", "fprintf", "print", "print#"
        OnlyPara = TRUE

      CASE ELSE
        IF LEFT$(Stk$[iThisToken],2) = "]." OR LEFT$(Stk$[iThisToken],3) = "]->" THEN
          DECR InBrace
        END IF

    END SELECT

    IF (DoJoin OR INCHR(",+-*/^;:<>~|&", szToken$)) AND NOT OnlyPara AND NOT InBrace THEN
      DoJoin = 0
      IF j THEN
        Stk$[sj] = "join$(" + STR$(j+1) + "," + Stk$[sj]
        j = sj
        'j++

        WHILE ++j < iThisToken
          CONCAT(Stk$[sj], Stk$[j])
          Stk$[j] = ""
          'j++
        WEND

        CONCAT(Stk$[sj], ")")
      END IF

      j = 0
      sj = iThisToken + 1
    END IF

    INCR iThisToken

  WEND

  IF j THEN
    Stk$[sj] = "join$(" + STR$(j+1) + "," + Stk$[sj]
    j = sj
    WHILE ++j <= iThisToken
      CONCAT(Stk$[sj], Stk$[j])
      Stk$[j] = ""
    WEND
    CONCAT(Stk$[sj], ")")
  END IF

END SUB ' JoinStrings



SUB Transforms()
  DIM RAW a
  DIM RAW i
  DIM RAW Keyword$
  DIM RAW lszTmp$
  RAW tpBCX AS tagTokenSubFunctions PTR

  Keyword$ = LCASE$(Stk$[1])
  tpBCX = GetWordInfo(Keyword$)
  IF tpBCX THEN
    IF (tpBCX->iWordInfo BAND eWI_Transform) = 0 THEN
      EXIT SUB
    END IF
  ELSE
    EXIT SUB
  END IF

  lszTmp$  = ""
  a = INCHR("abcdefghijklmnopqrstuvwxyz$", Keyword$)
  SELECT CASE a
    CASE 4

    '**************************************************************************
    ' The following code introduces the following DLL declarations to BCX
    '**************************************************************************
    '  DECLARE FUNCTION Foo LIB "FOO.DLL" ALIAS "FooA" ( A$ )
    '                     OR
    '  DECLARE FUNCTION Foo LIB "FOO.DLL" ( A$ ) - Alias will default to "FOO"
    '  [5.08.1102] Foo = (BCXFPROTx)GetProcAddress(H_FOO, "FooA");
    '**************************************************************************

    IF Keyword$ = "declare" AND iMatchWrd(Stk$[4],"lib") THEN
      RAW szAlias$, i, idx=-1

      REMOVE DQ$ FROM Stk$[5]
      FOR i = 1 TO LoadLibsCnt
        IF Stk$[5] = Loadlibs$[i] THEN
          idx = i
          EXIT FOR
        END IF
      NEXT
      IF idx < 0 THEN
        IF cMaxLoadlibs = ++LoadLibsCnt THEN CALL Abort("Maximum number of LIBs that can be loaded exceeded.")
        Loadlibs$[LoadLibsCnt] = Stk$[5]
      END IF

      IF iMatchWrd(Stk$[6],"alias") THEN
        szAlias$ = Stk$[7]
        Stk$[6] = ""
        Stk$[7] = ""
      ELSE
        szAlias$ = ENC$(UCASE$(Stk$[3]))
      END IF

      INCR DllCnt
      IF DllCnt >= cMaxDLLDecl THEN Abort("Maximum number of declarations exceded.")
      Dim mod_name$
'      mod_name$ = UCASE$(EXTRACT$(Stk$[5], "."))
	  mod_name$ = Ucase$(RemoveExtension$(Stk$[5]))
      If (Instr(mod_name$,"-")) OR (Instr(mod_name$,".")) Then
		'Replace "-" With "_" IN mod_name$
		mod_name$ = ReplaceAny$(mod_name$,"-.",Asc("_"))
      End If
      'cout << mod_name$ << endl
      DllDecl$ [DllCnt] = Clean$(Stk$[3]) + "=(BCXFPROT" + LTRIM$(STR$(DllCnt)) + _
      ")GetProcAddress(H_" + mod_name$ + ", " + szAlias$ + ");"

      'DllDecl$ [DllCnt] = Clean$(Stk$[3]) + "=(BCXFPROT" + LTRIM$(STR$(DllCnt)) + _
      '")GetProcAddress(H_" + UCASE$(EXTRACT$(Stk$[5], ".")) + ", " + szAlias$ + ");"

      Stk$[4] = ""
      Stk$[5] = ""
    END IF
    EXIT SUB

    CASE 9
$COMMENT
      'IF Keyword$ = "if" THEN
        'RAW IFCond
        'RAW j
        'IFCond = 2
        'FOR i = 3 TO Ndx
          'IF iMatchWrd(Stk$[i],"if") THEN IFCond = i + 1
          'IF iMatchWrd(Stk$[i],"then") AND iMatchWrd(Stk$[i+1],"if") THEN
            'FOR j = i + 2 TO Ndx
              'IF iMatchWrd(Stk$[j],"else") THEN
                'EXIT FOR
              'END IF
            'NEXT
            'IF j > Ndx THEN            ' safe to transform
              'FOR j = i TO IFCond + 1 STEP -1
                'Stk$[j] = Stk$[j - 1]
              'NEXT
              'Stk$[IFCond] = "("
              'i++
              'Stk$[i] = ")"
              'i++
              'FOR j = Ndx TO i STEP -1
                'Stk$[j + 2] = Stk$[j]
              'NEXT
              'Ndx++
              'Ndx++
              'Stk$[i] = "&&"
              'i++
              'Stk$[i] = "("
              'i++
              'FOR i = i TO Ndx
                'IF iMatchWrd(Stk$[i],"then") THEN
                  'Ndx++
                  'FOR j = Ndx TO i STEP -1
                    'Stk$[j] = Stk$[j - 1]
                  'NEXT
                  'Stk$[i] = ")"
                  'EXIT FOR
                'END IF
              'NEXT
              'i--
            'ELSE
              'EXIT FOR
            'END IF
          'END IF
        'NEXT
        'EXIT SUB
      'END IF
$COMMENT
    IF Keyword$ = "iremove" THEN
      '***********************************************************
      '  Translate   IREMOVE UCASE$("aaa") FROM LTRIM$(RTRIM$(A$))
      '  into   A$ = IREMOVE$(LTRIM$(RTRIM$(A$)),UCASE$("aaa"))
      '***********************************************************
      DIM RAW Mat$, Fat$

      FOR i = 2 TO Ndx
        IF iMatchWrd(Stk$[i],"from") THEN
          Stk$[i] = ""
          EXIT FOR
        END IF
      NEXT

      CALL BuildStr(2, i, Mat$)    ' build match string
      CALL BuildStr(i, Ndx, Fat$)    ' build fat source
      lszTmp$ = "=iremove$(" + Fat$ + "," + Mat$ + ")"
      FastLexer(Fat$," ()","")
      lszTmp$ = Stk$[Ndx] + lszTmp$
      CALL XParse(lszTmp$)
      CALL TokenSubstitutions(1) : CALL EmitMain()
      Ndx = 0
      EXIT SUB
    END IF

    IF Keyword$ = "ireplace" THEN
      '**********************************************************
      '  IREPLACE "this" WITH "that" IN A$ is transformed into
      '  A$ = ireplace$ ( A$, "this", "that" )
      '  BCX 3.73 introduces CASE INSENSITIVE REPLACE
      '**********************************************************

      IF Ndx < 6 THEN Abort("Problem with IREPLACE statement")

      DIM RAW W, I, VV$, RR$, WW$

      FOR W = 2 TO Ndx
        IF iMatchWrd(Stk$[W],"with") THEN
          Stk$[W]= ""
          EXIT FOR
        END IF
      NEXT

      FOR I = 2 TO Ndx
        IF iMatchWrd(Stk$[I],"in") THEN
          Stk$[I]= ""
          EXIT FOR
        END IF
      NEXT

      CALL BuildStr(I+1, Ndx, VV$)
      CALL BuildStr(2, W, RR$)
      CALL BuildStr(W+1, I, WW$)
      lszTmp$ = "=ireplace$(" + VV$ + "," + RR$ + "," + WW$ + ")"
      FastLexer(VV$," ()","")
      lszTmp$ = Stk$[Ndx] + lszTmp$
      CALL XParse(lszTmp$)
      CALL TokenSubstitutions(1) : CALL EmitMain()
      Ndx = 0
    END IF
    EXIT SUB

    CASE 18
    IF Keyword$ = "remove" THEN
      '***********************************************************
      '  Translate   REMOVE UCASE$("aaa") FROM LTRIM$(RTRIM$(A$))
      '  into   A$ = REMOVE$(LTRIM$(RTRIM$(A$)),UCASE$("aaa"))
      '***********************************************************

      DIM RAW Mat$, Fat$

      XFOR i = 2 WHILE i <= Ndx AND NOT iMatchWrd(Stk$[i],"from") BY i++ : XNEXT
      IF i > Ndx THEN CALL Abort("Malformed REMOVE statement.")

      CALL BuildStr(2, i-1, Mat$)     ' build match string
      CALL BuildStr(i+1, Ndx, Fat$)   ' build fat source
      lszTmp$ = "=remove$(" + Fat$ + "," + Mat$ + ")"

      FastLexer(Fat$," ()","")
      lszTmp$ = Stk$[Ndx] + lszTmp$
      CALL XParse(lszTmp$)
      CALL TokenSubstitutions(1) : CALL EmitMain()
      Ndx = 0
      EXIT SUB
    END IF

    IF Keyword$ = "replace" THEN
      '*******************************************************
      '  REPLACE "this" WITH "that" IN A$ is transformed into
      '  A$ = replace$ ( A$, "this", "that" )
      '  BCX 2.93 allows expressions and arrays to be used
      '*******************************************************

      IF Ndx < 6 THEN Abort("Problem with REPLACE statement")

      DIM RAW W, I, VV$, RR$, WW$

      FOR W = 2 TO Ndx
        IF iMatchWrd(Stk$[W],"with") THEN
          Stk$[W]= ""
          EXIT FOR
        END IF
      NEXT

      FOR I = 2 TO Ndx
        IF iMatchWrd(Stk$[I],"in") THEN
          Stk$[I] = ""
          EXIT FOR
        END IF
      NEXT

      IF I < W OR W = 0 THEN Abort("Malformed REPLACE statement")

      CALL BuildStr(I+1, Ndx, VV$)
      CALL BuildStr(2, W, RR$)
      CALL BuildStr(W+1, I, WW$)

      lszTmp$ = VV$ + "=replace$(" + VV$ + "," + RR$ + "," + WW$ + ")"
      CALL XParse(lszTmp$)
      CALL TokenSubstitutions(1) : CALL EmitMain()
      Ndx = 0
    END IF
    EXIT SUB
  END SELECT
END SUB ' Transforms



FUNCTION LocateJoiner(iStart AS INT)
  WHILE iStart < Ndx
    IF Stk$[iStart] = "&" OR (Stk$[iStart] = "+" AND Stk$[iStart+1] <> "+") THEN FUNCTION = iStart
    iStart++
  WEND
  FUNCTION = 0
END FUNCTION ' LocateJoiner



FUNCTION GetNextVarType(iLoc AS INT) AS INT
  RAW vt1 AS INT
  RAW cvt1 AS INT
  RAW Tmp AS INT
  RAW k AS INT

  cvt1 = CheckType(Stk$[iLoc])
'FIX ME
  IF cvt1 = 0 THEN
    vt1 = DataType(Stk$[iLoc])
  ELSE
    IF cvt1 = vt_UDT OR cvt1 = vt_STRUCT THEN
      IF Stk$[iLoc+1] = "[" THEN
        XFOR Tmp = iLoc+2, k = 1 WHILE Tmp <= Ndx AND k BY Tmp++
          IF Stk$[Tmp] = "[" THEN k++
          IF Stk$[Tmp] = "]" THEN k--
        XNEXT
        vt1 = DataType(Stk$[Tmp])
      ELSE
        vt1 = DataType(Stk$[iLoc+1])
      END IF
    ELSE
      IF cvt1 = vt_CHAR THEN
        RAW i, varid
        RAW vi AS VarInfo PTR
        vi = NULL
        i = CheckLocal(Stk$[iLoc], &varid)
        IF i THEN vi = &LocalVars[varid]
        IF i = vt_UNKNOWN THEN
          i = CheckGlobal(Stk$[iLoc], &varid)
          IF i THEN vi = &GlobalVars[varid]
        END IF
        IF vi THEN
          IF *(vi->VarDim$) THEN
            cvt1 = vt_STRVAR
          ELSE
            cvt1 = DataType(Stk$[iLoc])
          END IF
        ELSE
          cvt1 = DataType(Stk$[iLoc])
        END IF
      END IF
      vt1 = cvt1
    END IF
  END IF

  FUNCTION = vt1
END FUNCTION  ' GetNextVarType



FUNCTION GetPrevVarType(iLoc AS INT, iEarly AS INT) AS INT
  RAW vt AS INT
  RAW Tmp AS INT
  RAW k AS INT

  IF Stk$[iLoc] = ")" OR Stk$[iLoc] = "]" THEN
    XFOR Tmp = iLoc-1, k = 1 WHILE Tmp >= iEarly AND k BY Tmp--
      IF Stk$[Tmp] = ")" THEN k++
      IF Stk$[Tmp] = "]" THEN k++
      IF Stk$[Tmp] = "(" THEN k--
      IF Stk$[Tmp] = "[" THEN k--
    XNEXT
    vt = DataType(Stk$[Tmp])
  ELSE
    vt = DataType(Stk$[iLoc])
    IF vt = vt_INT THEN vt = CheckType(Stk$[iLoc])
    IF vt = vt_CHAR THEN
      RAW i, varid
      RAW vi AS VarInfo PTR
      vi = NULL
      i = CheckLocal(Stk$[iLoc], &varid)
      IF i THEN vi = &LocalVars[varid]
      IF i = vt_UNKNOWN THEN
        i = CheckGlobal(Stk$[iLoc], &varid)
        IF i THEN vi = &GlobalVars[varid]
      END IF
      IF vi THEN
        IF *(vi->VarDim$) THEN vt = vt_STRVAR
      END IF
    END IF
  END IF

  FUNCTION = vt
END FUNCTION  ' GetPrevVarType



'FUNCTION JoinStrTest(iStart AS INT, iEarly AS INT)
  'RAW Plus2Amp, vt, vt1, iJoiner, iDoJoin
  'iDoJoin = 0
  'Plus2Amp = iMatchNQ(Stk$[iStart++], "&")

  'iJoiner = LocateJoiner(iStart)
  'IF iJoiner = 0 THEN FUNCTION = iDoJoin
  'vt = GetPrevVarType(iJoiner-1, iEarly)
  'vt1 = GetNextVarType(iJoiner+1)
  'IF (vt = vt_STRVAR OR vt = vt_STRLIT) AND (vt1 = vt_STRVAR OR vt1 = vt_STRLIT) THEN
    'Stk$[iJoiner] = "&"
    'Plus2Amp = TRUE
    'iEarly = iJoiner+1
  'END IF

  'iStart = iJoiner+1

  'IF iStart < Ndx THEN
    'iDoJoin = JoinStrTest(iStart, iEarly) BOR Plus2Amp
  'ELSE
    'iDoJoin = Plus2Amp
  'END IF

  'FUNCTION = iDoJoin
'END FUNCTION ' JoinStrTest

'Waynes fix 07/13/2013
FUNCTION JoinStrTest(iStart AS INT, iEarly AS INT)
    RAW Plus2Amp, vtLeft, vtRight, iJoiner, iDoJoin
    iDoJoin = 0
    Plus2Amp = iMatchNQ(Stk$[iStart++], "&")

    iJoiner = LocateJoiner(iStart)
    IF iJoiner = 0 THEN
        FUNCTION = iDoJoin
    END IF
    vtLeft = GetPrevVarType(iJoiner-1, iEarly)
    vtRight = GetNextVarType(iJoiner+1)
    IF vtLeft = vt_STRVAR OR vtLeft = vt_STRLIT OR vtLeft = vt_LPSTR OR vtLeft = vt_LPSTRPTR OR vtLeft = vt_PCHAR THEN
        vtLeft = 1
    ELSE
        vtLeft = 0
    End If

    IF vtRight = vt_STRVAR OR vtRight = vt_STRLIT OR vtRight = vt_LPSTR OR vtRight = vt_LPSTRPTR OR vtRight = vt_PCHAR THEN
        vtRight = 1
    ELSE
        vtRight = 0
    END IF

    IF vtLeft AND vtRight THEN
        Stk$[iJoiner] = "&"
        Plus2Amp = TRUE
        iEarly = iJoiner+1
    END IF

    iStart = iJoiner+1

    IF iStart < Ndx THEN
        iDoJoin = JoinStrTest(iStart, iEarly) BOR Plus2Amp
    ELSE
        iDoJoin = Plus2Amp
    END IF

    FUNCTION = iDoJoin
END FUNCTION ' JoinStrTest


SUB FixUps()
  DIM RAW A, B
  DIM RAW CommaCnt
  DIM RAW AmpCnt
  DIM RAW i
  DIM RAW j
  DIM RAW lszTmp$
  DIM RAW L_Stk_1$
  DIM RAW L_Stk_2$
  DIM RAW Var1$

  L_Stk_1$ = ""
  L_Stk_2$ = ""
  lszTmp$  = ""
  Var1$    = ""
  PassOne = FALSE

  '***********************************************************
  ' Join strings using Join(Numberofstrings, string1, string2, ...)
  '
  IF NOT iMatchWrd(Stk$[1],"function")  THEN
    IF JoinStrTest(1,1) THEN
      'Use_Join = UseFlag = TRUE
      RAW k, Tmp
      j = 0
      k = 0
      AmpCnt = 0
      XFOR Tmp = 1 WHILE Tmp < Ndx AND (j = 0 OR k = 0) BY Tmp++
        IF Stk$[Tmp] = "&" THEN
'FIX ME
          A = GetNextVarType(Tmp+1)
'          A = DataType(Stk$[Tmp+1])
'          IF A <> vt_STRVAR AND A <> vt_STRLIT THEN
'            A = DataType(Stk$[Tmp-1])
'          END IF

            IF A = vt_STRVAR OR A = vt_STRLIT THEN
              AmpCnt++
              IF NOT k THEN k = Tmp
            END IF
        ELSE
          A = CheckLocal(Stk$[Tmp], &i)
          IF A = vt_UNKNOWN THEN A = CheckGlobal(Stk$[Tmp], &i)
          IF A = vt_STRUCT OR A = vt_UDT OR A = vt_UNION THEN   'added vt_UNION 4.40
            j = 1
          END IF
        END IF

      XNEXT

      IF AmpCnt > 1 THEN
        Use_Join = UseFlag = TRUE
      END IF

      IF k THEN
        IF j THEN CALL AsmUnknownStructs(0)
        CALL JoinStrings(1, 0)
        CALL BuildDelimStr(1, Ndx, Src$)
        CALL XParse(Src$)
      END IF
    END IF
  END IF

  '***********************************************************
  'Moved here by Mike H. Was being applied too early.
  'causing lines with multiple statements to not receive the
  'conversion. i.e. sp->lpVtbl->Release(sp) : sp = NULL
  '***********************************************************

  IF UseCpp THEN
    IF iMatchNQ(Src$,"->lpVtbl") THEN
      FOR INTEGER i= 1 TO Ndx
        IF iMatchRgt(Stk$[i],"->lpVtbl") THEN
          Stk$[i] = EXTRACT$(Stk$[i],"->lpVtbl")
          IF (Stk$[i+3] = Stk$[i-1] OR Stk$[i+3] = Stk$[i]) AND Stk$[i+3] <> ")" THEN
            Stk$[i+3] = ""
            IF Stk$[i+4] = "," THEN Stk$[i+4] = ""
          END IF
        END IF
      NEXT
      CALL RemEmptyTokens
    END IF
  END IF

  '********************************************************************
  '  At this point we have a fresh set of Stk$[] values, totaling Ndx
  '                Start handling some unique situations
  '********************************************************************

  '****************[ Exponentiation Operator Handler ]******************

  IF HasThisToken("^") THEN
    DIM RAW lp = 0
    DIM RAW rp = 0
    DIM RAW Insert1
    DIM RAW Insert2

    FOR i = 1 TO Ndx
      IF Stk$[i] = "^" THEN
        IF Stk$[i+1] = "-" THEN
          InsertTokens(i,1,"(")
          B = i+3
          IF Stk$[B] = "(" THEN
            lp=0
            rp=0
            DO
              IF Stk$[B] = "(" THEN lp++
              IF Stk$[B] = ")" THEN rp++
              B++
            LOOP UNTIL lp = rp
            InsertTokens(B,1,")")
          ELSE
            B=i+4
            IF INCHR("[",Stk$[B]) THEN
              DO
                B++
              LOOP UNTIL INCHR("]",Stk$[B])
              Ndx++
              InsertTokens(B,1,")")
            ELSE
              IF INCHR("(",Stk$[B]) THEN
                DO
                  B++
                LOOP UNTIL INCHR(")",Stk$[B])
                InsertTokens(B,1,")")
              ELSE
                InsertTokens(B,1,")")
              END IF
            END IF
          END IF
        END IF
        Insert1 = i - 1
        B = 0

        WHILE Stk$[Insert1] <> "="
          IF Stk$[Insert1] = "]" THEN B++
          IF Stk$[Insert1] = ")" THEN B++
          IF Stk$[Insert1] = "[" THEN B--
          IF Stk$[Insert1] = "(" THEN B--
          IF B = 0 THEN EXIT WHILE
          Insert1--
        WEND

        IF Stk$[Insert1] = "[" THEN Insert1--
        IF Stk$[Insert1] = "=" THEN Insert1++

        IF Stk$[Insert1] = "(" THEN
          B = DataType(Stk$[Insert1-1])        ' check if it's a function
          IF NOT iMatchWrd(Stk$[Insert1-1], "print") AND  _
            (B = vt_INTEGER OR B = vt_SINGLE OR B = vt_DOUBLE) THEN
            Insert1--
          END IF
        END IF


        Insert1--

        Stk$[i] = ","

        Insert2 = i + 1
        B = DataType(Stk$[Insert2])
        IF (Stk$[Insert2 + 1] = "(" OR Stk$[Insert2 + 1] = "[") AND _
          (B = vt_INTEGER OR B = vt_SINGLE OR B = vt_DOUBLE) THEN
          Insert2++
        END IF
        B = 0

        WHILE Insert2 <= Ndx
          IF Stk$[Insert2] = "[" THEN B++
          IF Stk$[Insert2] = "(" THEN B++
          IF Stk$[Insert2] = "]" THEN B--
          IF Stk$[Insert2] = ")" THEN B--
          IF NOT B THEN EXIT WHILE
          Insert2++
        WEND
        'Insert the tokens in reverse order
        InsertTokens(Insert2, 1, ")")
        InsertTokens(Insert1, 2, "pow","(")
      END IF
    NEXT
  END IF

'jcf 0 strip test ok
  '******************************

  CALL TokenSubstitutions(1)
'jcf 0 strip test bad


  IF Ndx = 0 THEN EXIT SUB

  '******************************
  IF Ndx = 3 AND NOT WithCnt THEN
    IF Stk$[2] = "+" AND Stk$[3] = "+" THEN
      FPRINT Outfile, Scoot$;Clean$(Stk$[1]);"++;"
      Ndx = 0
      Statements++
      EXIT SUB
    END IF
    IF Stk$[2] = "-" AND Stk$[3] = "-" THEN
      FPRINT Outfile, Scoot$;Clean$(Stk$[1]);"--;"
      Ndx = 0
      Statements++
      EXIT SUB
    END IF
    IF Stk$[1] = "+" AND Stk$[2] = "+" THEN
      FPRINT Outfile, Scoot$;"++";Clean$(Stk$[3]);";"
      Ndx = 0
      Statements++
      EXIT SUB
    END IF
    IF Stk$[1] = "-" AND Stk$[2] = "-" THEN
      FPRINT Outfile, Scoot$;"--";Clean$(Stk$[3]);";"
      Ndx = 0
      Statements++
      EXIT SUB
    END IF
  END IF

  '******************************
  IsCallBack = 0
  IF iMatchWrd(Stk$[Ndx],"callback") THEN
    IsCallBack = 1
    Stk$[Ndx--] = ""
  END IF

  '******************************

  CALL Transforms()

  IF Ndx = 0 THEN EXIT SUB

  '***********************************************************
  'Modification to allow 2 names as function types
  '***********************************************************

  IF iMatchWrd(Stk$[1],"function") OR iMatchWrd(Stk$[1],"impfunction") THEN
    IF iMatchWrd(Stk$[Ndx-2],"as") AND Stk$[Ndx] <> ")" THEN
      IF NOT iMatchWrd(Stk$[Ndx],"export") AND NOT iMatchWrd(Stk$[Ndx],"stdcall") THEN
        Stk$[Ndx-1] = Stk$[Ndx-1] + " " + Stk$[Ndx]
        Ndx--
      END IF
    END IF
  END IF

  '********************************************************************
  'Modification to allow 2 names as argument types in sub or function
  '********************************************************************
  RAW iP = 1
  IF iMatchLft(Stk$[1],"public") OR iMatchLft(Stk$[1],"private") THEN iP++
  IF iMatchWrd(Stk$[iP],"function") OR iMatchWrd(Stk$[iP],"sub") THEN
    DIM RAW offset
    DIM RAW LastBrk = Ndx - 2
    FOR i = Ndx TO 3 STEP -1
      IF Stk$[i] = ")" THEN
        LastBrk = i
        EXIT FOR
      END IF
    NEXT
    XFOR i = 3, INT j = 1 WHILE i <= LastBrk AND j BY i++
      offset = 2
      j = GetAsPosF(i, LastBrk)
      IF j THEN
        i = j
        IF (i < LastBrk) AND Stk$[i + offset] <> "=" THEN
          IF iMatchWrd(Stk$[i+1],"function") THEN offset = 3
          IF NOT INCHR(Stk$[i + offset],")") AND NOT INCHR(Stk$[i + offset],",") THEN
            IF LEN(Stk$[i + offset]) <> 0 AND NOT iMatchWrd(Stk$[i + 3],"as") THEN
              Stk$[i+offset-1] = Stk$[i+offset-1] + " " + Stk$[i+offset]
              Stk$[i + offset] = ""
            END IF
          END IF
        END IF
      END IF
    XNEXT
  END IF
  '***********************************************************
  'DynaCall Handler

  IF NOT iMatchWrd(Stk$[1],"declare") THEN
    FOR i = 1 TO Ndx
      IF iMatchWrd(Stk$[i],"lib") THEN
        IF Stk$[i-1] = "(" AND (DataType(Stk$[i+1]) = vt_STRLIT OR DataType(Stk$[i+1]) = vt_STRVAR) THEN
          j = GetNumArgs(i+2)
          lszTmp$ = "BCX_DynaCallB"
          IF NOT iMatchWrd(Stk$[1],"print") THEN  'print does its own casting
            IF DataType(Stk$[i-2]) = vt_STRVAR OR DataType(Stk$[1]) = vt_STRVAR THEN
              lszTmp$ = "(char*)" & lszTmp$
            END IF
          END IF
          Var1$ = RIGHT$(Stk$[i-2], 1)
          IF INCHR (VarTypes$, Var1$) THEN
            CONCAT (lszTmp$, Var1$)
            Stk$[i] = ENC$(LEFT$(Stk$[i-2], LEN(Stk$[i-2]) - 1))
          ELSE
            Stk$[i] = ENC$(Stk$[i-2])
          END IF
          Stk$[i-2] = lszTmp$
          FOR B = Ndx+3 TO i+3 STEP -1
            Stk$[B] = Stk$[B-3]
          NEXT
          Stk$[i+2] = Stk$[i+1]
          Stk$[i+1] = ","
          Stk$[i+3] = ","
          Stk$[i+4] = LTRIM$(STR$(j))
          Stk$[i+5] = IIF$(j, ",", ")")
          INCR Ndx, 3
          Use_DynacallCommon = Use_Dynacall = UseFlag = TRUE
        END IF
      END IF
    NEXT
  END IF


  '*****************************************************
  L_Stk_1$ = LCASE$(Stk$[1])   ' Performance Optimizer
  L_Stk_2$ = LCASE$(Stk$[2])   ' Performance Optimizer
  '*****************************************************

  IF L_Stk_1$ = "open" THEN
    FOR A = 1 TO Ndx
      IF iMatchWrd(Stk$[A],"binary") THEN
        EXIT FOR
      END IF
    NEXT
    IF A < Ndx THEN
      A++
      Var1$ = LCASE$(Stk$[A])
      IF Var1$ = "new" THEN
        Stk$[A-1]= "binarynew"
        CALL DeleteTokens(A, 1)
      END IF

      IF Var1$ = "append" THEN
        Stk$[A-1]= "binaryappend"
        CALL DeleteTokens(A, 1)
      END IF

      IF Var1$ = "input" THEN
        Stk$[A-1]= "binaryinput"
        CALL DeleteTokens(A, 1)
      END IF

      IF Var1$ = "output" THEN
        Stk$[A-1]= "binaryoutput"
        CALL DeleteTokens(A, 1)
      END IF
    END IF
    EXIT SUB
  END IF


  IF L_Stk_1$ = "option" AND L_Stk_2$ = "base" THEN
    OptionBase = VAL(Stk$[3])
    Ndx = 0
    EXIT SUB
  END IF

  '******************************

  IF L_Stk_1$   = "dim"  THEN
    lszTmp$ = ENC$(L_Stk_2$, ASC(" "))
    'IF iMatchNQ(" shared , dynamic , raw , local , auto , register , static ", lszTmp$) THEN
    'IF iMatchNQ(" shared , dynamic , raw , local , register , static ", lszTmp$) THEN
    IF iMatchNQ(" shared , dynamic , raw , local , static ", lszTmp$) THEN
      Stk$[1]     = L_Stk_2$
      L_Stk_1$    = L_Stk_2$
      CALL DeleteTokens(2, 1)
    END IF
    EXIT SUB
  END IF

  '******************************

  IF L_Stk_1$ = "public" THEN
    IF L_Stk_2$ = "function" OR L_Stk_2$ = "sub" THEN
      IF InClassModule THEN
        CONCAT(L_Stk_1$,L_Stk_2$)
        Stk$[1] = L_Stk_1$
      ELSE
        Stk$[1]  = L_Stk_2$
      END IF
      CALL DeleteTokens(2, 1)
    END IF
    EXIT SUB
  END IF

  '******************************

  ' creates a static function for use in $PROJECTs
  IF L_Stk_1$ = "private" THEN
    IF L_Stk_2$ = "function" OR L_Stk_2$ = "sub" THEN
      IF InClassModule THEN
        CONCAT(L_Stk_1$,L_Stk_2$)
        Stk$[1] = L_Stk_1$
      ELSE
        Use_Static = TRUE
        Stk$[1]  = L_Stk_2$
      END IF
      CALL DeleteTokens(2, 1)
    END IF
    EXIT SUB
  END IF

  '******************************

  IF L_Stk_1$ = "onexit" THEN
    IF L_Stk_2$ = "sub" THEN
      Use_ExitCode = Use_Proto = TRUE
      IF cMaxExitSub = ++ExitNdx THEN CALL Abort("Maximum number of exit calls exceeded.")
      ExitSub$[ExitNdx] = Stk$[3]
      Stk$[1]  = L_Stk_2$
      L_Stk_1$ = L_Stk_2$
      CALL DeleteTokens(2, 1)
    END IF
    EXIT SUB
  END IF

  '******************************

  IF L_Stk_1$ = "onstart" THEN
    IF L_Stk_2$ = "sub" THEN
      Use_StartupCode = Use_Proto = TRUE
      IF cMaxStartSub = ++StartNdx THEN CALL Abort("Maximum number of startup calls exceeded.")
      StartSub$[StartNdx] = Stk$[3]
      Stk$[1]  = L_Stk_2$
      L_Stk_1$ = L_Stk_2$
      CALL DeleteTokens(2, 1)
      EXIT SUB
    END IF
    CALL Abort("ONSTART syntax error, can only be used with a SUB.")
  END IF

  '******************************

  IF L_Stk_1$ = "overloaded" THEN
    IF L_Stk_2$ = "function" THEN
      Stk$[1] = "overloadedfunction"
      L_Stk_1$ = "overloadedfunction"
      CALL DeleteTokens(2, 1)
      IF Stk$[2] <> "=" THEN
        OkayToSend = TRUE
      END IF
      EXIT SUB
    END IF

    IF L_Stk_2$ = "sub" THEN
     Stk$[1]= "overloadedsub"
      CALL DeleteTokens(2, 1)
      EXIT SUB
    END IF
  END IF

  '******************************

  IF L_Stk_1$ = "function" AND iMatchWrd(Stk[3],"optional") THEN
    Stk$[1]= "optfunction"
    L_Stk_1$ = "optfunction"
    CALL DeleteTokens(3, 1)
    IF Stk$[2] <> "=" THEN
      OkayToSend = TRUE
    END IF
    EXIT SUB
  END IF

  '******************************

  IF L_Stk_1$ = "sub" AND iMatchWrd(Stk[3],"optional") THEN
    L_Stk_1$ = "optsub"
    Stk$[1]= "optsub"
    CALL DeleteTokens(3, 1)
    EXIT SUB
  END IF

  '******************************

  IF L_Stk_1$ = "end" AND Stk$[2] <> "=" THEN
    Stk$[1]= L_Stk_1$ + L_Stk_2$
    IF Ndx = 2 THEN
      Ndx = 1
      EXIT SUB
    ELSE
      IF iMatchWrd(Stk$[3],"as") THEN
        Stk$[2] = ""
        CALL RemEmptyTokens()
        EXIT SUB
      END IF
    END IF
  END IF

  '******************************

  IF L_Stk_1$ = "function" AND Stk$[2] <> "=" THEN
    OkayToSend = TRUE
  END IF

  '******************************

  IF L_Stk_1$ = "midstr"  THEN

    CommaCnt = 0

    FOR i = 1 TO Ndx
      IF Stk$[i] = "," THEN
        INCR CommaCnt
      ELSEIF Stk$[i]= "=" THEN
        IF CommaCnt < 2 THEN
          Stk$[i] = "-1,"
        ELSE
          Stk$[i]= ""
        END IF
        Stk$[i-1]= ","
        Ndx++
        Stk$[Ndx]= ")"
        EXIT FOR
      END IF
    NEXT
  END IF

  '******************************

  IF L_Stk_1$ = "endevents" OR L_Stk_1$ = "endmdievents" OR L_Stk_1$ = "endmdichildevents" THEN
    RAW szError$

    IF Use_Vscroll OR Use_Hscroll THEN
      Use_Min = Use_Max = TRUE
      '========================================================================
      Src$ = "GLOBAL BCX_siX AS SCROLLINFO"       : CALL XT1E(Src$)
      Src$ = "GLOBAL BCX_siY AS SCROLLINFO"       : CALL XT1E(Src$)
      Src$ = "GLOBAL BCX_DynaScroll AS INTEGER"   : CALL XT1E(Src$)
      FPRINT Outfile,"  ";szProject$;"int BCX_ViewWidth  =", Use_Hscroll, ";"
      FPRINT Outfile,"  ";szProject$;"int BCX_ViewHeight =", Use_Vscroll, ";"
      FPRINT Outfile,"  ";szProject$;"int BCX_SmallChangeX;"
      FPRINT Outfile,"  ";szProject$;"int BCX_SmallChangeY;"
      FPRINT Outfile,"  ";szProject$;"int BCX_LargeChangeX;"
      FPRINT Outfile,"  ";szProject$;"int BCX_LargeChangeY;"
      FPRINT Outfile,"  ";szProject$;"int BCX_ScrollInit;"
      FPRINT Outfile,""
      FPRINT Outfile,"  if(!BCX_ScrollInit)"
      FPRINT Outfile,"   {"
      FPRINT Outfile,"     BCX_siY.cbSize=sizeof(BCX_siY);"
      FPRINT Outfile,"     BCX_siX.cbSize=sizeof(BCX_siX);"
      FPRINT Outfile,"     BCX_siY.fMask=SIF_ALL;"
      FPRINT Outfile,"     BCX_siX.fMask=SIF_ALL;"
      FPRINT Outfile,"     BCX_siX.nMax=BCX_ViewWidth;"
      FPRINT Outfile,"     BCX_siY.nMax=BCX_ViewHeight;"
      FPRINT Outfile,"     BCX_SmallChangeX=1;"
      FPRINT Outfile,"     BCX_LargeChangeX=20;"
      FPRINT Outfile,"     BCX_SmallChangeY=1;"
      FPRINT Outfile,"     BCX_LargeChangeY=20;"
      FPRINT Outfile,"     BCX_siY.nPage=1;"
      FPRINT Outfile,"     BCX_siX.nPage=1;"
      FPRINT Outfile,"     SetScrollInfo(hWnd,SB_VERT,&BCX_siY,TRUE);"
      FPRINT Outfile,"     SetScrollInfo(hWnd,SB_HORZ,&BCX_siX,TRUE);"
      FPRINT Outfile,"     BCX_DynaScroll=TRUE;"
      FPRINT Outfile,"     BCX_ScrollInit=TRUE;"
      FPRINT Outfile,"   }"
      FPRINT Outfile," if(Msg==WM_HSCROLL||WM_VSCROLL||WM_SIZE)"
      FPRINT Outfile,"   {"
      FPRINT Outfile,"     BCX_Scroll(hWnd,Msg,wParam,lParam,BCX_LargeChangeX,"
      FPRINT Outfile,"     BCX_LargeChangeY,BCX_SmallChangeX,BCX_SmallChangeY,"
      FPRINT Outfile,"     BCX_ViewWidth,BCX_ViewHeight,BCX_DynaScroll);"
      FPRINT Outfile,"   }"
    END IF

    IF NOT Use_BCX_Class_Info THEN
      Use_BCX_Class_Info = TRUE
      iEmitVariableGroup = iEmitVariableGroup BOR (eFontGroup BOR eClassName)
    END IF

    IF L_Stk_1$ <> "endmdichildevents" AND Use_MainEvent THEN
      Use_MainEvent = FALSE
      FPRINT Outfile,"  if(Msg==WM_DESTROY)"
      FPRINT Outfile,"    {"
      FPRINT Outfile,"       PostQuitMessage(0);"
      FPRINT Outfile,"       return 0;"
      FPRINT Outfile,"    }"
    END IF

    IF L_Stk_1$ = "endevents" THEN
      FPRINT Outfile," return DefWindowProc(hWnd,Msg,wParam,lParam);"' // endevents"
    ELSEIF L_Stk_1$ = "endmdievents" THEN
      FPRINT Outfile," return DefFrameProc(hWnd,BCX_hwndMDIClient,Msg,wParam,lParam);"
    ELSEIF L_Stk_1$ = "endmdichildevents" THEN
      FPRINT Outfile," return DefMDIChildProc(hWnd,Msg,wParam,lParam);"
    END IF
    FPRINT Outfile,"}\n\n"
    sprintf(szError, "To many un-indents for END %s", UCASE$(L_Stk_1+3))
    CALL BumpDown(szError$)
    IF Indent THEN CALL Abort("Possible missing END IF before END "+UCASE$(MID$(L_Stk_1$,4)))
    Ndx = 0
    'InFunc = FALSE
    InFunc = eNotInOne
    EXIT SUB
  END IF

  '******************************

  IF Stk$[2]= ":" THEN
    IF Ndx = 2 THEN
      RAW szTmp$
      szTmp$ = ENC$(L_Stk_1$,ASC(" "))
      IF iMatchNQ(" public , private , protected ", szTmp$) = 0 THEN
        Stk$[1]= UCASE$(Stk$[1]) + ":"    'preserve the GOTO labels
        Ndx = 1
      END IF
      EXIT SUB
    END IF
  END IF

  '******************************

  IF LCASE$(Stk$[3])= "createwindow" THEN    'HELPER
    Comma = 0
    FOR A = 4 TO Ndx
      IF Stk$[A]= "," THEN Comma++
      IF Stk$[A]= "," THEN
        IF Comma = 8 THEN
          Stk$[A]= ",(HMENU)"
          Comma++
        END IF
      END IF
    NEXT
  END IF

  '******************************

  IF LCASE$(Stk$[3])= "createwindowex" THEN    'HELPER
    Comma = 0
    FOR A = 4 TO Ndx
      IF Stk$[A]= "," THEN Comma++
      IF Stk$[A]= "," THEN
        IF Comma = 9 THEN
          Stk$[A]= ",(HMENU)"
          Comma++
        END IF
      END IF
    NEXT
  END IF

  '******************************

  IF Stk$[Ndx]= "*" THEN
    Stk$[Ndx-1]= Stk$[Ndx-1] + "*"
    Ndx--
  END IF

  '******************************

  IF iMatchWrd(Stk$[3],"setwindowlong") OR iMatchWrd(Stk$[3],"setwindowlongptr") THEN    'HELPER
    Comma = 0
    Stk$[3]= "(WNDPROC)(LONG_PTR)SetWindowLongPtr"
    FOR A = 4 TO Ndx
      IF Comma = 1 THEN
        IF Stk$[A] <> "GWL_STYLE" AND Stk$[A] <> "GWL_EXSTYLE" AND Stk$[A] <> "GWL_ID" THEN
          IF INSTR(Stk$[A], "P_") = 0 THEN
            REPLACE "_" WITH "P_" IN Stk$[A]
          END IF
        END IF
      END IF
      IF Stk$[A]= "," THEN Comma++
      IF Stk$[A]= "," THEN
        IF Comma = 2 THEN
          Stk$[A]= ",(LONG_PTR)"
          Comma++
        END IF
      END IF
    NEXT
    EXIT SUB
  END IF

  'IF TestState = TRUE THEN
  IF TestState THEN
    IF LastCmd = 0 THEN
      IF Stk$[1] = "*" THEN
        Z$ = Clean$(Stk$[2])
      ELSE
        Z$ = Clean$(Stk$[1])
      END IF
      IF LEFT$(Z$,1) = "*" THEN Z$ = MID$(Z$,2)
      i = INCHR(Z$,".")
      IF i = 0 THEN i = INSTR(Z$,"->")
      IF i > 0 THEN
        IF WithCnt THEN
          Z$ = WithVar$[WithCnt]
        ELSE
          Z$ = LEFT$(Z$, i - 1)
        END IF
      END IF
      IF INCHR(Z$,"[") THEN Z$ = EXTRACT$(Z$,"[")
      IF CheckLocal(Z$, &j) = vt_UNKNOWN THEN
        IF CheckGlobal(Z$, &j) = vt_UNKNOWN THEN
          Z$ = LCASE$(Z$)
          IF Stk$[2] = "=" AND Z$ <> "functionreturn" AND Z$ <> "bcx_retstr" AND Z$ <> "end" THEN
            Warning("Assignment before Declaration in Line " + STR$(ModuleLineNos[ModuleNdx]) + " in Module: " + TRIM$(Modules$[ModuleNdx]) + ": " + Src$)
          END IF
        END IF
      END IF
    END IF
  END IF
END SUB ' FixUps




'SUB FuncSubDecs1(s$, iStart AS INT, iEnd AS INT, ptVar AS VARCODE PTR)
SUB FuncSubDecs1(sccp As const char Ptr, iStart AS INT, iEnd AS INT, ptVar AS VARCODE PTR)
  Raw s$
  s$ = (char*)sccp
  static utlp
    '*****************
    RAW iBracketPairLocation, iEmpty
    '*****************
'IF _ZTRACE_ Then
'	ZPRINT("Hello From FuncSubDecs1")
'	ZPRINT("iEnd = " + STR$(iEnd))
'END IF

    IF iMatchRgt(Stk$[iStart], s$) THEN
        IF DataType(Stk$[iStart+1]) = vt_STRVAR THEN
            Abort("Invalid " + s$ + " name")
        END IF
    END IF
'jcfuller removed 08/11/2013 per bcx 7.0.7 fix
    'IF UsingTemplate THEN

		''If utlp = 1 Then
		''	UsingTemplate = 0
		''	utlp = 0
		''
		''End If
		''utlp = 1
        'IF iMatchWrd(Stk$[iEnd], TemplateContainer$) = 0 THEN
            'UsingTemplate = 0

			''IF _ZTRACE_ Then
				''ZPRINT("-------")
				''ZPRINT("iMatchWrd(Stk$[iEnd], TemplateContainer$) = 0 ")
				''ZPRINT(Stk$[iEnd])
				''ZPRINT(TemplateContainer$)
				''ZPRINT("-------")
			''END IF
        ''ELSE
			''IF _ZTRACE_ Then
				''ZPRINT("-------")
				''ZPRINT("iMatchWrd(Stk$[iEnd], TemplateContainer$) <> 0 ")
				''ZPRINT(Stk$[iEnd])
				''ZPRINT(TemplateContainer$)
				''ZPRINT("-------")
			''END IF

        'END IF
    'END IF

    XFOR iEmpty = FALSE, iBracketPairLocation = GetBracketPairPosF(iStart, iEnd) WHILE iBracketPairLocation BY iBracketPairLocation = GetBracketPairPosF(iBracketPairLocation, iEnd)
        RAW iVarLoc = iBracketPairLocation - 1
        IF iMatchWrd(Stk$[iBracketPairLocation+2],"as") THEN
            Stk$[iBracketPairLocation+3] = Stk$[iBracketPairLocation+3] + "*"
            Stk$[iBracketPairLocation++] = "" : Stk$[iBracketPairLocation] = ""
            iEmpty = TRUE
        ELSEIF Stk$[iBracketPairLocation+2] = "[" THEN
            WHILE iBracketPairLocation <= iEnd
                IF iMatchWrd(Stk$[iBracketPairLocation],"as") THEN EXIT WHILE 'FOR
                IF iMatchRgt(Stk$[iVarLoc],"]") AND INCHR(",)=", Stk$[iBracketPairLocation]) THEN EXIT WHILE 'FOR
                CONCAT(Stk$[iVarLoc],Stk$[iBracketPairLocation])
                Stk$[iBracketPairLocation++] = ""
                iEmpty = TRUE
            WEND
        ELSE
            RAW iDataType = DataType(Stk$[iVarLoc])
            Stk$[iVarLoc] = Clean$(Stk$[iVarLoc])
            IF iDataType = vt_STRVAR THEN
                CALL InsertTokens(iBracketPairLocation+1,5,"[",csSizeOfDefaultString,"]","as","char")
                iEnd += 5
            ELSE
                Stk$[iBracketPairLocation++] = "as"
                Stk$[iBracketPairLocation] = GetVarTypeName$(iDataType)+"*"
            END IF
        END IF
    XNEXT

'IF _ZTRACE_ Then
'    zTrace(ANSITOWIDE((char*) "After xFor -> iEnd = " + STR$(iEnd)))
'	xfor int jc = 0 While jc < 20 BY jc++
'	   zTrace(ANSITOWIDE((char*)Str$(jc)+" = " + Stk$[jc]))
'	xNext
'END IF


    IF iMatchWrd(Stk$[iEnd],"export") THEN
        Ndx--
        ptVar->IsExported = TRUE
        IF UseStdCall THEN
            CallType$ = "__stdcall "
        ELSE
            CallType$ = "__cdecl "
        END IF
    END IF

    IF iEmpty THEN
        CALL RemEmptyTokens
    END IF

END SUB ' FuncSubDecs1

'==============================================================================
SUB RemEmptyTokens()
  DIM RAW i, j
  FOR i = 1 TO Ndx
    IF NOT *Stk[i] THEN
      j = i
      WHILE NOT *Stk[j] AND (j < Ndx)
        INCR j
      WEND
      IF NOT *Stk[j] THEN EXIT FOR
      Stk$[i] = Stk$[j]
      Stk$[j] = ""
    END IF
  NEXT i
  Ndx = i-1
END SUB



'SUB FuncSubDecs2(s$, methd, VarCode AS VARCODE PTR, iFirstToken AS INT, iLastToken AS INT PTR)
SUB FuncSubDecs2(sccp As const char Ptr, methd, VarCode AS VARCODE PTR, iFirstToken AS INT, iLastToken AS INT PTR)
  Raw s$
  s$ = (char*)sccp
'IF _ZTRACE_ Then
'	zTrace(ANSITOWIDE((char*)"Hello From FuncSubDecs2"))
'END IF

  IF iMatchRgt(Stk$[iFirstToken], s$) THEN
    IF iMatchWrd(Stk$[*iLastToken-1],"as") THEN
      Abort("Attempted type assignment to " + s$)
    END IF
    VarCode->IsPtrFlag = 0
    CurrentFuncType = vt_VOID
  ELSE
    IF iMatchWrd(Stk$[(*iLastToken)-1],"as") THEN
      CurrentFuncType  = CheckType(Stk$[*iLastToken])
      VarCode->Token$   = Stk$[iFirstToken+1]
      VarCode->AsToken$ = Stk$[*iLastToken]
      VarCode->IsPtrFlag = TALLY(Stk$[*iLastToken],"*")
      Stk$[(*iLastToken)--]   = ""
      Stk$[(*iLastToken)--] = ""
    ELSE
      ' Check if Constructor/Destructor
      IF ConstructDestructTest(1) THEN
        CurrentFuncType = vt_ConsDes
      ELSE
        CurrentFuncType = DataType(Stk$[iFirstToken+1])
      END IF
      VarCode->Token$ = Stk$[iFirstToken+1]
      VarCode->IsPtrFlag = TALLY(Stk$[iFirstToken+1],"*")
      VarCode->AsToken$ = ""
    END IF
  END IF
  VarCode->Proto$    = " ("
  VarCode->Header$   = " ("
  VarCode->Functype$ = ""
  VarCode->Methd%    = methd
  VarCode->VarNo%    = CurrentFuncType
  CALL GetVarCode(VarCode,"FuncSubDecs2")
END SUB ' FuncSubDecs2


SUB FuncSubDecs3(varcode AS VARCODE PTR, iLast AS INT, iExtended AS INT)

'IF _ZTRACE_ Then
'	zTrace(ANSITOWIDE((char*)"Hello From FuncSubDecs3"))
'END IF

  IF *Stk[iLast-1] = ASC(".") THEN                    ' Allow Functions | Subs WITH one OR
    Stk$[iLast-1] = "..."
    'varcode->Header$ = varcode->Header$  +  "..."   ' more "." TO produce the "..." needed
  END IF

  varcode->Header$ = RTRIM$(varcode->Header$)
  'IF iMatchRgt(varcode->Header$, ",") THEN
    'may not be needed.
  '  MID$(varcode->Header$, LEN(varcode->Header$)) = ")"
  'ELSE
    CONCAT(varcode->Header$, ")")
  'END IF

  IF UseCpp = FALSE THEN
    REPLACE "()" WITH "(void)" IN varcode->Header$
  END IF
  IF iExtended THEN
    varcode->Header$ = varcode->Functype$ + "(*" + varcode->Token$ + ")" + varcode->Header$
  ELSE
    varcode->Header$ = varcode->Functype$ + varcode->Token$ + varcode->Header$
  END IF
'check
  IF varcode->Methd% = 2 THEN
    varcode->Proto$ = RTRIM$(varcode->Proto$)
    IF iMatchRgt(varcode->Proto$, ",")  THEN
      MID$(varcode->Proto$, LEN(varcode->Proto$)) = ")"
    ELSE
      CONCAT(varcode->Proto$, ")")
    END IF

    REPLACE "()" WITH "(void)" IN varcode->Proto$
    IF iExtended THEN
      varcode->Proto$ = varcode->Functype$ + "(*)" + varcode->Proto$
    ELSE
      varcode->Proto$ = varcode->Functype$ + varcode->Token$ + varcode->Proto$ + ";"
    END IF
  END IF

  IF varcode->UseInLine THEN
    varcode->Header$ = "inline " + varcode->Header$
    varcode->Proto$  = "inline " + varcode->Proto$
  END IF
  UseInLine = FALSE

  IF varcode->IsExported THEN
    varcode->Proto$  = "C_EXPORT " + varcode->Proto$
    varcode->Header$ = "C_EXPORT " + varcode->Header$
  END IF
END SUB ' FuncSubDecs3



SUB AddTypeDefs(sTypeDefName$, TDef)
  TypeDefsCnt++
  IF TypeDefsCnt = MaxTypes THEN Abort("Exceeded TYPE Limits.")
  TypeDefs[TypeDefsCnt].VarName$ = sTypeDefName$
  TypeDefs[TypeDefsCnt].TypeofDef = TDef
  TypeDefs[TypeDefsCnt].EleCnt = 0
END SUB ' AddTypeDefs



FUNCTION DefsID(ZZ$)
  IF TypeDefsCnt > 0 THEN
    FOR INT i = 1 TO TypeDefsCnt
      IF ZZ$ = TypeDefs[i].VarName$ THEN
        FUNCTION = i
      END IF
    NEXT
  END IF
  FUNCTION = 0
END FUNCTION ' DefsID



SUB GetTypeInfo(stk$, BYREF IsPointer, BYREF UdtIdx, BYREF vtCode)
  RAW Var1$
  IsPointer = TALLY(stk$,"*")
  Var1$     = TRIM$(REMOVE$(stk$,"*"))
  ' if it's a CLASS then get the structure information added 2008/10/07
  IF RIGHT$(Var1$,6) = "_CLASS" THEN Var1$ = LEFT$(Var1$,LEN(Var1$)-6)
  vtCode    = CheckType(Var1$)

  IF vtCode = vt_UNKNOWN THEN
    CALL AddTypeDefs(Var1$, vt_UDT)    'windows def
    vtCode = vt_UDT
  END IF
  UdtIdx = 0
  IF vtCode = vt_STRUCT OR vtCode = vt_UNION OR vtCode = vt_UDT THEN
    UdtIdx = DefsID(Var1$)
  END IF
END SUB ' GetTypeInfo



SUB AddTypedefElement(WorkingTypeDefsCnt, ElType, EName$, EType$, EPtr)

  DIM RAW TD AS UserTypeDefs PTR

  TD = &(TypeDefs[WorkingTypeDefsCnt])
  IF TD->EleCnt = MaxElements THEN Abort("Exceeded TYPE Element Limits.")
  TD->Elements[TD->EleCnt].ElementType    = ElType
  TD->Elements[TD->EleCnt].ElementDynaPtr = EPtr
  IF ElType = vt_STRUCT OR ElType = vt_UNION OR ElType = vt_UDT THEN
    TD->Elements[TD->EleCnt].ElementID = DefsID(EType$)
  ELSE
    TD->Elements[TD->EleCnt].ElementID = 0
  END IF
  TD->Elements[TD->EleCnt].ElementName$ = EName$
  TD->EleCnt = 1 + TD->EleCnt

END SUB ' AddTypedefElement



FUNCTION GetElement$(StartStk, BYREF vt, BYREF dms, id)
  DIM RAW BC = 0, i, ZZ$

  FOR i = StartStk+1 TO Ndx
    IF Stk$[i] = "[" THEN
      INCR BC
    ELSEIF Stk$[i] = "]" THEN
      DECR BC
    ELSE
      IF BC = 0 THEN
        IF iMatchLft(Stk$[i], "->") OR *Stk$[i] = ASC(".") THEN
          ZZ$ = Clean$(Stk$[i])
          RemoveAll(ZZ$, ".->(*)", 1)
          vt = GetElementInfo(&id, &dms, ZZ$)
          IF vt <> vt_STRUCT AND vt <> vt_UNION THEN EXIT FOR
        END IF
      END IF
    END IF
  NEXT

  IF vt = vt_UDT OR vt = vt_UNION OR vt = vt_STRUCT THEN
    ZZ$ = TypeDefs[id].VarName$
  ELSE
    ZZ$ = GetVarTypeName$(vt)
  END IF
  FUNCTION = ZZ$
END FUNCTION



FUNCTION GetElementInfo(BYREF DefID, BYREF EPtr, Elename$)
  DIM RAW i, id
  id = DefID
  FOR i = 0 TO TypeDefs[id].EleCnt - 1
    IF Elename$ = TypeDefs[id].Elements[i].ElementName$ THEN
      DefID = TypeDefs[id].Elements[i].ElementID
      EPtr  = TypeDefs[id].Elements[i].ElementDynaPtr
      FUNCTION = TypeDefs[id].Elements[i].ElementType
    END IF
  NEXT

  FUNCTION = 0
END FUNCTION



SUB HandleNonsense
  DIM RAW i
  FOR i = 1 TO Ndx    ' tolerate nonsense like DIM A% as double
    IF iMatchWrd(Stk$[i],"as") THEN Stk$[i - 1] = Clean$(Stk$[i - 1])
    IF OptionBase THEN   ' This was the easiest way I could see to do this!
      IF Stk$[i] = "[" THEN Stk$[i+1] = LTRIM$(STR$(OptionBase)) + "+" + Stk$[i+1]
    END IF
  NEXT
END SUB ' HandleNonsense



SUB ValidVar(v$)
  DIM RAW ZZ$

  IF NOT isalpha(*v$) AND *v$ <> ASC("_") THEN
    IF NOT iMatchLft(v$, "(*") AND v$ <> "&" THEN  ' Allow byref format (*A).xxx
      Abort("Invalid String Variable Name")
    END IF
  END IF

  IF RestrictedWords(v$) AND TestState THEN
    ZZ$ = "Variable " + v$ + " on line"
    ZZ$ = ZZ$ + STR$(ModuleLineNos[ModuleNdx]) + " in Module: " + TRIM$(Modules$[ModuleNdx]) + " is a Restricted Word"
    CALL Warning(ZZ$)
  END IF
END SUB ' ValidVar



SUB PointerFix()
  CONCAT(Stk$[Ndx-1],Stk$[Ndx])
  Stk[Ndx][0] = 0
  Ndx--
  WHILE TALLY(Stk$[Ndx],"*") = (int)(LEN(Stk$[Ndx]))
    CONCAT(Stk$[Ndx-1],Stk$[Ndx])
    Stk[Ndx][0] = 0
    Ndx--
  WEND
END SUB ' PointerFix



SUB DimDynaString(SVar$, DG, s)
  DIM RAW DS$

  DS$ = "if (" + SVar$ + ") { free(" + SVar$ + ");" + SVar$ + " = NULL; }"
  'IF InFunc AND (IsLocal OR IsDim OR IsRaw OR IsAuto OR IsRegister) AND DG = 0 THEN
  'IF InFunc <> eNotInOne AND (IsLocal OR IsDim OR IsRaw OR IsAuto OR IsRegister) AND DG = 0 THEN
  'IF InFunc <> eNotInOne AND (IsLocal OR IsDim OR IsRaw OR IsRegister) AND DG = 0 THEN
  IF InFunc <> eNotInOne AND (IsLocal OR IsDim OR IsRaw ) AND DG = 0 THEN
    IF cMaxDynaStr = ++LocalDynaCnt THEN CALL Abort("Maximum number of local dynamic allocations exceeded.")
    DynaStr$[LocalDynaCnt] = DS$
    'IF IsAuto THEN
    '  FPRINT Outfile,Scoot$;"auto char *";SVar$;";"
    'IF IsRegister THEN
    '  FPRINT Outfile,Scoot$;"register char *";SVar$;";"
    'ELSE
    FPRINT Outfile,Scoot$;"char *";SVar$;";"
    'END IF
    CALL AddLocal(SVar$, vt_CHAR, 0,"",1,0,0,0)
  ELSE
    IF Use_GenFree THEN
      CALL AddDynamicGlobal(DS$)
    END IF
    IF DG = 2 THEN
      CALL AddGlobal(SVar$, vt_CHAR, 0,"",1,0,1,0,0)
    ELSE
      IF s THEN
        CALL AddGlobal(SVar$, vt_CHAR, 0,"",1,0,2,0,0)
      ELSE
        CALL AddGlobal(SVar$, vt_CHAR, 0,"",1,0,0,0,0)
      END IF
    END IF
  END IF
  IF DG <> 2 THEN

    FPRINT Outfile,Scoot$; SVar$ ; "=(char*)calloc(";
    Stk$[++Ndx] = ",1);"
    CALL WriteCleanTokens(4,Ndx)

  END IF
END SUB ' DimDynaString



SUB AddDynamicGlobal(szGlobalStr AS PCHAR)
  GlobalDynaCnt++
  IF cMaxGlobalDyna = GlobalDynaCnt THEN CALL Abort("Maximum number of global dynamic arrays exceeded.")
  GlobalDynaStr$[GlobalDynaCnt] = szGlobalStr$
END SUB


FUNCTION SubFuncTest()
  IF iMatchWrd(Stk$[2],"function") OR iMatchWrd(Stk$[2],"sub") THEN
    FUNCTION = 1
  END IF
  FUNCTION = 0
END FUNCTION ' SubFuncTest



FUNCTION ConstructDestructTest(iTokenLoc AS INT)
  IF iMatchWrd(Stk$[iTokenLoc],"constructor") OR iMatchWrd(Stk$[iTokenLoc],"destructor") THEN
    FUNCTION = 1
  END IF
  FUNCTION = 0
END FUNCTION ' ConstructDestructTest



FUNCTION DimSubFunc(iMeth)
  DIM RAW i
  DIM RAW lszTmp$
  DIM RAW StartPoint = 3
  DIM RAW Funptr     = 0

  lszTmp$ =   ""

  IF iMatchWrd(Stk$[Ndx],"stdcall") THEN
    CallType$ = "__stdcall "
    Stk$[Ndx--] = ""
    IsStdFunc = TRUE
  ELSE
    IF InClassModule OR InPPTypeModule THEN
      CallType$ = ""
    ELSE
      CallType$ = "__cdecl "    ' Default calling convention
    END IF
    IsStdFunc = FALSE
  END IF

  GLOBAL SFPOINTER
  RAW FP AS functionParse

  IF iMatchWrd(Stk$[3],"operator") THEN
'IF _ZTRACE_ THEN
'zTrace(ANSITOWIDE((char*)"Hello From line 12456"))
'END IF

    RAW bOppFound AS BOOL
    XFOR i = 4,bOppFound = FALSE WHILE NOT bOppFound BY i++
      IF Stk$[i] = "(" THEN
        IF Stk$[i+1] <> ")" AND Stk$[i+2] <> "(" THEN bOppFound = TRUE
        IF Stk$[i+1] = ")" AND i > 4 THEN bOppFound = TRUE
      END IF
      IF NOT bOppFound THEN
        CONCAT(Stk$[3],Stk$[i])
        Stk$[i] = ""
      END IF
    XNEXT
  END IF

  RAW w, id, vt, szWrk$
  szWrk$ = Clean$(Stk$[Ndx])
  IF *szWrk$ THEN
    GetTypeInfo(szWrk$, &w, &id, &vt)

    IF vt = vt_WINBOOL THEN
      IREPLACE "WINBOOL" WITH "BOOL" IN Stk$[Ndx]
    END IF
  END IF

  '------------------------------------------------------
  '  Find start of function body ( ... )
  '------------------------------------------------------
  CALL SepFuncArgs(3, &FP, TRUE)
  'jcfuller changed 11/02/2013
  'StartPoint = MAX(FP.CommaPos[0], 3)
  StartPoint = max(FP.CommaPos[0], 3)
  IF NOT InTypeDef AND NOT InClassModule AND NOT InPPTypeModule THEN
    SFPOINTER = TRUE
    '------------------------------------------------------
    '  Get intialized data  " = xxx" or "= {xxx,xxx}"
    '------------------------------------------------------
    IF FP.NumArgs = 0 THEN
    'jcf 11/02
      'i = MIN(FP.CommaPos[1]+1, Ndx)
      StartPoint = min(FP.CommaPos[0], 3)
    ELSE
      'i = MIN(FP.CommaPos[FP.NumArgs]+1, Ndx)
      i = min(FP.CommaPos[FP.NumArgs]+1, Ndx)
    END IF

    IF Stk$[i] = "=" THEN
      Stk$[i++] = ""
      WHILE NOT iMatchWrd(Stk$[i], "as") AND i <= Ndx
        lszTmp$ = lszTmp$ +Stk$[i]
        Stk$[i++] = ""
      WEND
      RemoveAll(lszTmp$, "{}", 1)
      IF lszTmp$ <> "" THEN CALL RemEmptyTokens
    END IF
    '------------------------------------------------------

    FPRINT FP_UDT,Scoot$;MakeDecProto$(&FP);";"
    SFPOINTER = FALSE

    Ndx = StartPoint
    Stk$[2] = ""
    IF lszTmp$ <> "" THEN
      Stk$[Ndx++] = "="
      Stk$[Ndx++] = "{"
      Stk$[Ndx++] = Clean$(lszTmp$)
      Stk$[Ndx++] = "}"
    END IF
    Stk$[Ndx++] = "as"
    Stk$[Ndx] = Clean$(Stk$[3]) + "_TYPE" + STRING$(Funptr, ASC("*"))
    CALL RemEmptyTokens
    FUNCTION = FALSE

  ELSE ' C++
    RAW szV$
    IF IsVirtual THEN
      szV$ = "virtual "
      IsVirtual = FALSE
    ELSE
      szV$ = ""
    END IF
    RAW szWrk$
    RAW szStatic$
    RAW szIsConst$
    RAW szInit$
    RAW iEqualLoc
    szInit$ = ""
    iEqualLoc = Ndx
    WHILE Stk$[iEqualLoc] <> "=" AND iEqualLoc
      IF Stk$[iEqualLoc] = ")" THEN EXIT WHILE
      iEqualLoc--
    WEND
    IF Stk$[iEqualLoc] = "=" THEN
      szInit$ = Stk$[iEqualLoc++]
      CONCAT(szInit$,Stk$[iEqualLoc++])
    END IF
    IF iMatchWrd(Stk$[Ndx], "const") THEN
'IF _ZTRACE_ THEN
'zTrace(ANSITOWIDE((char*)"Hello From line 14590"))
'END IF
      szIsConst$ = "const"
    ELSE
      szIsConst$ = ""
    END IF
    szStatic$ = ""
    IF iMatchWrd(Stk$[1], "static") THEN szStatic$ = "static "

    szWrk$ = MakeDecProto$(&FP)

    IF iMeth THEN
      szWrk$ = TRIM$(MID$(szWrk$,INSTR(szWrk$," ")))
    END IF
'------------------------------------------------------------------------------
'jcfuller added 08/20/2015
    If szVirtual$ = szInit$ Then
		szInit$ = ""
    End If
'------------------------------------------------------------------------------
    FPRINT FP_UDT,Scoot$;szV$;szStatic$;szWrk$;szVirtual$;szInit$;szIsConst$;";"

    'cout << "*****" << endl
    'cout << szV$ << endl
    'cout << szStatic$ << endl
    'cout << szWrk$ << endl
    'cout << szVirtual$ << endl
    'cout << szInit$ << endl
    'cout << szIsConst$ << endl
    'cout << "*****" << endl
    szVirtual$ = ""
  END IF

  FUNCTION = TRUE
END FUNCTION ' DimSubFunc



SUB InBlockReSet()
  LocalVarCnt = LocalInBlock[InBlock]
  InBlock--
  IF InBlock < 0 THEN
    Abort("To many END BLOCKS")
  END IF
END SUB



SUB InBlockSet()
  InBlock++
  IF InBlock = cMaxLocalInBlocks THEN Abort("To many nested BEGINBLOCK/ENDBLOCKs")
  LocalInBlock[InBlock] = LocalVarCnt
END SUB



FUNCTION IsName(sS$)
  IF isalpha(*sS) OR *sS = ASC("_") THEN FUNCTION = TRUE
  FUNCTION = FALSE
END FUNCTION



SUB AddSpace(i AS INT)
  IF IsName(Stk$[i]) AND IsName(Stk$[i+1]) THEN
    CONCAT(Stk$[i],SPC$)
  END IF
END SUB



SUB EmitOld(FuncRetnFlag AS INT PTR)
  '******************************
  DIM RAW HasStorage = 0
  DIM RAW A,B,i,j
  DIM RAW k  = 0
  DIM RAW Arg$
  DIM RAW lszTmp$
  DIM RAW ZZ$
'bc9106 moved these from below
LOCAL strtest, varid, vi AS VarInfo PTR, vr$, brcnt
  IF Ndx = 0 THEN EXIT SUB

  lszTmp$       =  ""
  ZZ$           =  ""

    '**********************************************************************
    ' "="   We MUST be processing an assignment statement if we get here!
    '       or perhaps calling a SUB without using the CALL keyword
    '**********************************************************************

    FOR B = 1 TO Ndx
      IF Stk$[B]= "=" THEN
        IF NOT(Stk$[B-1] = "<" OR Stk$[B-1] = ">" OR Stk$[B-1] = "+" OR Stk$[B-1] = "-" OR Stk$[B-1] = "/" OR Stk$[B-1] = "*") THEN
          EXIT FOR
        END IF
      END IF
    NEXT

    '*************************************************************************
    'There's no "=" so we're either calling a SUB or this is a FUNCTION RETURN
    '*************************************************************************

    IF B-1 = Ndx THEN
      CALL BuildCleanStr(1, Ndx, lszTmp$)
      CONCAT(lszTmp$, ";")
      IF *FuncRetnFlag = 2 THEN
        FPRINT Outfile,lszTmp$
      ELSE
        FPRINT Outfile, Scoot$;lszTmp$
      END IF

      IF *FuncRetnFlag = 2 THEN
        *FuncRetnFlag = 0
        Stk$[1] = ""
        EXIT SUB
      END IF

      EXIT SUB
    END IF

    '*************************************************************************
    '      It can only be one thing now -- a normal assignment statement
    '*************************************************************************

    FOR i = 2 TO B-1
      CONCAT(Stk$[1], Stk$[i])    ' IF present, build the Array Variable
    NEXT

    A = INCHR(Stk$[1], "*")
    IF A THEN
      IF NOT ( INCHR(Stk$[1], "$") AND A > 1 ) THEN 'Exclude strings BYREF
        RemoveAll(Stk$[1], "$")
        GOTO ProcessNumeric
      END IF
    END IF

    '*************************************************************************
    '                    'processing a string equation
    '*************************************************************************
'bc9106    jcf
'Moving these to top
    'LOCAL strtest, varid, vi AS VarInfo PTR, vr$, brcnt

    strtest = DataType(Stk$[1])

    IF strtest = vt_INTEGER THEN
      brcnt = TALLY(Stk$[1], "[")
      vr$ = EXTRACT$(Stk$[1], "[")
      strtest = CheckLocal(vr$, &varid)
      IF strtest = vt_UNKNOWN THEN
        strtest = CheckGlobal(vr$, &varid)
        vi = &(GlobalVars[varid])
      ELSE
        vi = &(LocalVars[varid])
      END IF

      IF strtest = vt_CHAR THEN
        strtest = vt_STRVAR
      END IF
      IF strtest = vt_STRVAR THEN
        IF vi->VarPntr <> 0 THEN
          ' string pointer
          GOTO ProcessNumeric
        END IF
        IF TALLY(vi->VarDim,"[") = brcnt THEN
          ' the character within string
          GOTO ProcessNumeric
        END IF
        IF TALLY(vi->VarDim,"[") <> brcnt+1 THEN
          ' string pointer
          GOTO ProcessNumeric
        END IF
      END IF
    END IF

    IF strtest = vt_STRVAR THEN
      '*************************************************************************

      IF B+1 = Ndx THEN
        IF Stk$[Ndx] = DDQ$ THEN
          FPRINT Outfile, Scoot$;"*",Clean$(Stk$[1]),"=0;"
          GOTO StringExit
        END IF
      END IF

      ' [ Speed up No. 1 ] ****************************************************

      IF Ndx = 3 THEN
        Stk$[1]=Clean$(Stk$[1])
        Stk$[3]=Clean$(Stk$[3])

        IF Stk$[1] = "BCX_RetStr" THEN
        	'jcfuller changed
'          FPRINT Outfile,Scoot$;"BCX_RetStr = BCX_TmpStr(strlen(" ; Stk$[3] ; "));"
		   FPRINT Outfile,Scoot$;"BCX_RetStr = BCX_TmpStr(strlen(" ; Stk$[3] ; "),0,1);"
        END IF

        FPRINT Outfile, Scoot$;"strcpy(", Stk$[1], ",", Stk$[3], ");"
        GOTO StringExit
      END IF


      '***********************
      Arg$    = ""
      lszTmp$ = ""
      j=k=0
      '***********************
      IF iMatchLft(Stk$[3],"$$") THEN HasStorage = TRUE

      Var$ = Clean$(Stk$[1])

      IF Clean$(Stk$[B+1]) = Var$ THEN
        k = TRUE
      END IF

      FOR A = B+1 TO Ndx ' B marks the position of the "=" char
        IF Stk$[A]= "&" AND Stk$[A-1] <> "," AND Stk$[A-1] <> "(" THEN
          INCR j
          CONCAT(Arg$,lszTmp$)
          lszTmp$ = ","
        ELSE
          CONCAT(lszTmp$, Clean$(Stk$[A]))
        END IF
      NEXT

      IF *lszTmp <> 0 AND lszTmp$ <> "," THEN
        CONCAT(Arg$,lszTmp$)
      END IF


      '*************************************************************************
      '                                 Rules
      '*************************************************************************
      ' IF j = 0 & K = ANY                     THEN use strcpy
      ' IF j = 1 & K = TRUE                    THEN use strcat
      ' All else                               THEN use join
      '*************************************************************************

      RemoveAll(Var$, SPC$)             'Added this during the beta testing
      '*** needs to be checked out still ***
      'stk[++i] is getting here as stk [ + + i ]
IF _ZTRACE_ Then
  ZPRINT("#1")
End If
      IF j = 0 THEN
        IF Var$ = "BCX_RetStr" THEN
          IF HasStorage THEN
            FPRINT Outfile, Scoot$;"BCX_RetStr=", Arg$, ";"
            GOTO StringExit
          ELSE
          'jcfuller changed
            'FPRINT Outfile,Scoot$;"BCX_RetStr = BCX_TmpStr(strlen(" , Arg$ , "));"
            FPRINT Outfile,Scoot$;"BCX_RetStr = BCX_TmpStr(strlen(" , Arg$ , "),0,1);"
          END IF
        END IF
        FPRINT Outfile, Scoot$;"strcpy(", Var$ , "," , Arg$, ");"
        GOTO StringExit
      END IF

IF _ZTRACE_ Then
  ZPRINT("#2")
End If

      'If we make it here then we should have 2 or more expressions

      'IF k = TRUE AND j = 1 THEN
      IF k  AND j = 1 THEN
        FPRINT Outfile, Scoot$;"strcat(", Arg$ , ");"
        GOTO StringExit
      END IF

      lszTmp$ = LTRIM$(STR$(++j))
      Use_Join = UseFlag = TRUE

      IF Var$ = "BCX_RetStr" THEN
        FPRINT Outfile, Scoot$;"BCX_RetStr=join(" , lszTmp$ , "," , Arg$, ");"
      ELSE
        FPRINT Outfile, Scoot$;"strcpy(",Var$, ", join(" , lszTmp$ , "," , Arg$, "));"
      END IF

      StringExit:
        EXIT SUB

      '***********************
    ELSE
      '***********************
      ProcessNumeric:
      '***********************

      FOR i = 2 TO B
        Stk$[i] = ""
      NEXT

      Stk$[B]= "="    'This is necessary

      ' change x = x ? c to x ?= c

      IF Stk$[B + 1] = Stk$[1] AND Ndx = 5 THEN
        IF Inset(Stk$[B + 2], "+-*/") AND Stk$[B + 3] <> ">" THEN
          Stk$[B] = Stk$[B + 2] + Stk$[B]
          Stk$[B + 1] = ""
          Stk$[B + 2] = ""
        END IF
      END IF

      FOR A = 2 TO Ndx
        IF isdigit(*Stk$[A]) AND iMatchRgt(Stk$[A],"E") THEN
          CONCAT(Stk$[A],Stk$[A+1])
          IF Stk$[A+1] = "-" THEN
            CONCAT(Stk$[A],Stk$[A+2])
            Stk$[A+2] = ""
          END IF
          Stk$[A+1] = ""
        END IF
      NEXT

      FPRINT Outfile, Scoot$;Clean$(Stk$[1]);
      FOR A = 2 TO Ndx
        IF Stk$[A] = "!" THEN
          FPRINT Outfile,"!";
        ELSE
          FPRINT Outfile,Clean$(Stk$[A]);
        END IF
        IF A < Ndx THEN
          IF NOT ispunct(*Stk$[A+1]) THEN FPRINT Outfile,SPC$;
        END IF
      NEXT
      FPRINT Outfile,";"
    END IF

END SUB ' EmitOld

SUB KillFiles()
  IF InternalDebugOff THEN
    KILL hdrFile$
    KILL enuFile$           '
    KILL SystemConstFile$
    KILL UserConstFile$
    KILL udtFile$
    KILL setFile$
    KILL ccodeFile$
    KILL prcFile$
    KILL ovrFile$
    KILL datFile$
    KILL resFile$
  END IF
END SUB

'SUB Abort(Z$)
SUB Abort(ZZ As const char Ptr)

  DIM RAW i = 0
  DIM RAW j = 0
  DIM RAW k = 0
  DIM RAW varnum = 0
  DIM RAW t$
  DIM RAW frmt$
  DIM Z$
  Z$ = ZZ
  WarnMsg$ = ""

  IF LEFT$(AbortSrc$,11) = "$BCXVERSION" THEN
    CONCAT(WarnMsg$,Z$)
  ELSE
    WarnMsg$ = WarnMsg$ + Z$ + " at line" + STR$(ModuleLineNos[ModuleNdx]) + " in Module: " + TRIM$(Modules$[ModuleNdx]) + CRLF$

    WarnMsg$ = WarnMsg$ + "Original line" + CRLF$
    WarnMsg$ = WarnMsg$ +  AbortSrc$ + CRLF$
    WarnMsg$ = WarnMsg$ + "==============" + CRLF$
    WarnMsg$ = WarnMsg$ + "Current Tokens" + CRLF$
    WarnMsg$ = WarnMsg$ + "==============" + CRLF$

    FOR k = 1 TO Ndx
      j = LEN(Stk$[k])

      IF j < 40 THEN
        j = 40 - j
      ELSE
        j = 8 - IMOD(j,8)
      END IF

      frmt$ = LPAD$(STR$(k),3)

      WarnMsg$ = WarnMsg$ + frmt$ + " " + Stk$[k] + STRING$(j,32) + CRLF$

      t$ = Clean$(Stk$[k])
      i = CheckLocal(t$, &varnum)

      IF i <> vt_UNKNOWN THEN

        WarnMsg$ = WarnMsg$ + "is a LOCAL defined at line" + STR$(LocalVars[varnum].VarLine)

        WarnMsg$ = WarnMsg$ + " in Module: " + LocalVars[varnum].VarModule$ + CRLF$
      ELSE
        i = CheckGlobal(t$, &varnum)
        IF i <> vt_UNKNOWN THEN
          WarnMsg$ = WarnMsg$ + "is a GLOBAL defined at line" + STR$(GlobalVars[varnum].VarLine)
          WarnMsg$ = WarnMsg$ + " in Module: " + GlobalVars[varnum].VarModule$ + CRLF$
          WarnMsg$ = WarnMsg$ + " " + Stk$[k] & GlobalVars[varnum].VarDim$ + " as "
          IF GlobalVars[varnum].VarDef THEN
            WarnMsg$ = WarnMsg$ + TRIM$(TypeDefs[GlobalVars[varnum].VarDef].VarName$) + CRLF$
          ELSE
            WarnMsg$ = WarnMsg$ + TRIM$(GetVarTypeName$(GlobalVars[varnum].VarType)) + CRLF$
          END IF
        ELSE
          IF Stk[k][0] = c_DblQt THEN
            WarnMsg$ = WarnMsg$ + "is a STRING LITERAL" + CRLF$
          END IF
        END IF
      END IF
    NEXT

    WarnMsg$ = WarnMsg$ + "===============" + CRLF$
    WarnMsg$ = WarnMsg$ + "Original Tokens" + CRLF$
    WarnMsg$ = WarnMsg$ + "===============" + CRLF$
    CALL XParse(AbortSrc$)
    FOR k = 1 TO Ndx
      j = LEN(Stk$[k])
      IF j < 40 THEN
        j = 40 - j
      ELSE
        j = 8 - IMOD(j,8)
      END IF

      frmt$ = LPAD$(STR$(k),3)

      WarnMsg$ = WarnMsg$ + frmt$ + " " + Stk$[k] + STRING$(j,32) + CRLF$

      t$ = Clean$(Stk$[k])
      i = CheckLocal(t$, &varnum)

      IF i <> vt_UNKNOWN THEN
        WarnMsg$ = WarnMsg$ + "is a LOCAL defined at line" + STR$(LocalVars[varnum].VarLine)
        WarnMsg$ = WarnMsg$ + " in Module: " + LocalVars[varnum].VarModule$ + CRLF$
      ELSE
        i = CheckGlobal(t$, &varnum)
        IF i <> vt_UNKNOWN THEN
          WarnMsg$ = WarnMsg$ + "is a GLOBAL defined at line" + STR$(GlobalVars[varnum].VarLine)
          WarnMsg$ = WarnMsg$ + " in Module: " + GlobalVars[varnum].VarModule$ + CRLF$
          WarnMsg$ = WarnMsg$ + " " + Stk$[k] & GlobalVars[varnum].VarDim$ + " as "
          IF GlobalVars[varnum].VarDef THEN
            WarnMsg$ = WarnMsg$ + TypeDefs[GlobalVars[varnum].VarDef].VarName$ + CRLF$
          ELSE
            WarnMsg$ = WarnMsg$ + GetVarTypeName$(GlobalVars[varnum].VarType) + CRLF$
          END IF
        ELSE
          IF Stk[k][0] = c_DblQt THEN
            WarnMsg$ = WarnMsg$ + "is a string literal" + CRLF$
          END IF
        END IF
      END IF
    NEXT
  END IF

  WarnMsg$ = WarnMsg$ + CRLF$

  CALL CloseAll()

  CALL KillFiles()
  KILL "$WRK$.TXT"
  KILL FileOut$
  KILL "$t$e$m$p"

  IF ErrFile THEN
    OPEN FileErr$ FOR APPEND AS fpErr
    FPRINT fpErr, Z$ ; " at line" ; ModuleLineNos[ModuleNdx] ; " in Module: "; TRIM$(Modules$[ModuleNdx]) 'LinesRead
    CLOSE fpErr
  END IF

  IF InfoBoxWarn THEN
    INFOBOX("Warnings! :" , WarnMsg$, GetSystemMetrics(SM_CXSCREEN)/4, GetSystemMetrics(SM_CYSCREEN)/4)
    'INFOBOX("Error! " + FileIn$,WarnMsg$)
  ELSE
    PRINT "Error!",CRLF$, FileIn$,CRLF$, WarnMsg$
  END IF
  CALL FREEGLOBALS
  END = 1
END SUB ' Abort



'SUB BumpDown(szErr$)
SUB BumpDown(szErr As const char Ptr)
  Indent--
  Indent--
  IF Indent<0 THEN
    IF szErr$ = "" THEN

      CALL Abort("Unknown Error")
    ELSE
      CALL Abort(szErr$)
    END IF
    'Indent = 0
  END IF
  Scoot$ = SPACE$(Indent)
END SUB ' BumpDown



SUB BumpUp()
  IF Indent<0 THEN Indent = 0
  Indent++
  Indent++
  Scoot$ = SPACE$(Indent)
END SUB ' BumpUp



FUNCTION BraceCount( Arg$ )
  DIM RAW p AS CHAR PTR
  DIM RAW braces
  p = Arg$
  braces = 0
  WHILE *p
    IF *p = c_DblQt THEN
      p++
      WHILE *p <> c_DblQt
        IF *p = 0 THEN FUNCTION = braces
        p++
      WEND
    END IF
    IF *p = ASC("}") THEN braces--
    IF *p = ASC("{") THEN braces++
    p++
  WEND
  FUNCTION = braces
END FUNCTION ' BraceCount



FUNCTION BracketHandler(Src$,l) AS CHAR PTR
  DIM RAW s AS CHAR PTR

  s = Src$

  SELECT CASE l
    CASE 0
    DO
      IF *s = 0 THEN EXIT DO
      IF *s = c_DblQt THEN
        s++
        WHILE *s <> c_DblQt
          IF *s = 0 THEN EXIT WHILE
          s++
        WEND
      END IF

      IF *s = c_LtBkt THEN
        s++
        s = BracketHandler(s,1)
      END IF
      IF *s = c_LPar THEN
        s++
        s = BracketHandler(s,2)
      END IF
      s++
    LOOP

    CASE 1
    WHILE *s <> c_RtBkt
      IF *s = c_DblQt THEN
        s++
        WHILE *s <> c_DblQt
          IF *s = 0 THEN EXIT WHILE
          s++
        WEND
      END IF

      IF *s = c_LtBkt THEN
        s++
        s = BracketHandler(s, 1)
      END IF

      IF *s = c_LPar THEN
        s++
        s = BracketHandler(s, 2)
      END IF
      IF *s = 0 THEN EXIT WHILE
      IF *s = c_Komma THEN *s = 1
      s++
    WEND

    CASE 2
    WHILE *s <> c_RPar
      IF *s = c_DblQt THEN
        s++
        WHILE *s <> c_DblQt
          IF *s = 0 THEN EXIT WHILE
          s++
        WEND
      END IF

      IF *s = c_LtBkt THEN
        s++
        s = BracketHandler(s, 1)
      END IF

      IF *s = c_LPar THEN
        s++
        s = BracketHandler(s, 2)
      END IF
      IF *s = 0 THEN EXIT WHILE
      s++
    WEND
  END SELECT

  IF l = 0 THEN
    REPLACE CHR$(1) WITH "][" IN Src$
    FUNCTION = Src
  END IF
  FUNCTION = s
END FUNCTION ' BracketHandler



SUB PushSelectState(Z$)
  ++PusherSelectState
  IF cMaxNestedSelects = PusherSelectState THEN CALL Abort("Maximum nested SELECT/END SELECT reached.")
  SelectState[PusherSelectState].CaseStk$= Z$
END SUB ' PushSelectState



SUB PopSelectState(Z$)
  Z$ = SelectState[--PusherSelectState].CaseStk$
END SUB ' PopSelectState



SUB EmitEpilog()


  IF Use_Wingui + MakeDLL + NoMain + EndOfProgram = 0 THEN
    FPRINT Outfile,"  return 0;   /* End of main program */"
    FPRINT Outfile,"}"
    FLUSH(Outfile)
    'CALL BumpDown("Error in EmitEpilog()") ' Commented out because of NoMain check others
  END IF
END SUB ' EmitEpilog


' Rewrite for new method
SUB EmitProlog(FP_WRITE AS FILE)
  IF Use_Library THEN
    FPRINT FP_WRITE,"// BCXRTHEADER: INCLUDE FILES"
  ELSE
    FPRINT FP_WRITE,"// *********************************************************************"
    FPRINT FP_WRITE,"//  Created with bc9Basic - BASIC To C/C++ Translator (V) ", Version$
    FPRINT FP_WRITE,"//       The bc9Basic translator (bc9.exe) was compiled with"
    FPRINT FP_WRITE,"//       ", CompilerVersion$
    FPRINT FP_WRITE,"// ----------------------------------------------------------------------"
    FPRINT FP_WRITE,"//                 BCX (c) 1999 - 2009 by Kevin Diggins"
    FPRINT FP_WRITE,"// *********************************************************************"
    IF UseCpp THEN
		If Use_MFC Then
			FPRINT FP_WRITE,"//              Translated for compiling with Visual C++"
			FPRINT FP_WRITE,"//            Using The Microsoft Foundation Class Library"
		ElseIf Use_TCLib Then
			FPRINT FP_WRITE,"//              Translated for compiling with the"
			FPRINT FP_WRITE,"//           Microsoft (R) C/C++ Optimizing Compiler"
		Else
			FPRINT FP_WRITE,"//              Translated for compiling with a C++ Compiler"
		End If
    ELSE
      FPRINT FP_WRITE,"//              Translated for compiling with a C Compiler"
    END IF
	If WxGui OR WxCon Then
		FPRINT FP_WRITE,"//                           Using WxWidgets 3.0"
	Else
		IF (TargetOS = TNIX) THEN
		  FPRINT FP_WRITE,"//                            On a nix OS"
		ELSE
		  FPRINT FP_WRITE,"//                           On MS Windows"
		  If Use_TCLib Then
		      FPRINT FP_WRITE,"//                    Using TCLib by Fred Harris"
		      
		  End if
		End If
    End If
    FPRINT FP_WRITE,"// *********************************************************************"
  END IF

  IF Use_MULTITHREADED_SW THEN
    FPRINT FP_WRITE,"#define __BCX_MULTITHREADED__"
  END IF

  IF Use_COM OR Use_VBS THEN
    FPRINT FP_WRITE,"#ifndef _WIN32_DCOM"
    FPRINT FP_WRITE,"#define _WIN32_DCOM"
    FPRINT FP_WRITE,"#endif"
  END IF

  IF Use_UNICODE_Switch THEN
    ' this should be emitted before any other windows header
    FPRINT FP_WRITE,"#ifndef UNICODE"
    FPRINT FP_WRITE,"#define UNICODE"
    FPRINT FP_WRITE,"#endif"

    FPRINT FP_WRITE,"#ifndef _UNICODE"
    FPRINT FP_WRITE,"#define _UNICODE"
    FPRINT FP_WRITE,"#endif"
    FPRINT FP_WRITE,"#define _X(y) y"
  END IF
If Use_TCLib Then
	FPRINT FP_WRITE,"#include <windows.h>"
	If Not Use_UNICODE_Switch Then
		FPRINT FP_WRITE,"#define _X(y) y"
		FPRINT FP_WRITE,"typedef char *PCHAR,*LPCH,*PCH,*NPSTR,*LPSTR,*PSTR;"
	End if
	If USE_ZTRACE Then
		FPRINT FP_WRITE,"#include ";ENC$("zTrace.h")
	End If
	
	FPRINT FP_WRITE,"#define   x64"

	FPRINT FP_WRITE,"#include ";ENC$("TCLib\\stdio.h")
	FPRINT FP_WRITE,"#include ";ENC$("TCLib\\string.h")
	FPRINT FP_WRITE,"#include ";ENC$("TCLib\\stdlib.h")
	FPRINT FP_WRITE,"#include ";ENC$("TCLib\\memory.h")
	FPRINT FP_WRITE,"#include ";ENC$("TCLib\\malloc.h")
	FPRINT FP_WRITE,"#include ";ENC$("TCLib\\math.h")
	FPRINT FP_WRITE,"#include ";ENC$("TCLib\\tchar.h")
	If Use_fstring Then
		If Use_UNICODE_Switch Then
			FPRINT FP_WRITE,"#include ";ENC$("TCLib\\Strings.cpp")
			'FPRINT FP_WRITE,"extern ";"_X(";ENC$("C");") int _fltused=1;" 
			'FPRINT FP_WRITE,"EXTERN_C int _fltused=1;" 
			FPRINT FP_WRITE,"typedef String fstring;"
		Else
			FPRINT FP_WRITE,"#include <StringsA.cpp>"
			FPRINT FP_WRITE,"typedef String fstring;"
			'FPRINT FP_WRITE,"EXTERN_C int _fltused=1;" 	
		End If	
	ELSE
		FPRINT FP_WRITE,"EXTERN_C int _fltused=1;" 	
	End If
	FPRINT FP_WRITE,"FILE* stdin;"
	FPRINT FP_WRITE,"FILE* stdout;"
	FPRINT FP_WRITE,"FILE* stderr;"
	FPRINT FP_WRITE,"//<---UNICODE AWARE"
	FPRINT FP_WRITE,"#define SFMT (const char*)";ENC$("%s\\r\\n")
	FPRINT FP_WRITE,"//>---UNICODE AWARE"
End If
'jcfuller added 06/16/2014
If WxGui OR WxCon  Then
    FPRINT FP_WRITE,"// WXWIDGETS HEADER FILES //"
    FPRINT FP_WRITE,"#include <wx/wx.h>"
    FPRINT FP_WRITE,"#include <wx/process.h>"
    FPRINT FP_WRITE,"#include <wx/txtstrm.h>"
    FPRINT FP_WRITE,"#include <wx/msgdlg.h>"
    FPRINT FP_WRITE,"#include <wx/stdpaths.h>"
    FPRINT FP_WRITE,"#include <wx/event.h>"
    'jcfuller added for dynamic loading of shared libraries
    FPRINT FP_WRITE,"#include <wx/dynlib.h>"
    FPRINT FP_WRITE,"// ******************* //"
	FPRINT FP_WRITE,"//=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*"
    FPRINT FP_WRITE,"// wxWidget WxString STR$ Functions //"
    FPRINT FP_WRITE,"//------------------------------------------------------------------------------"
	FPRINT FP_WRITE,"wxString wxStr(int i){return wxString::Format(wxT(";DQ$;"%i";DQ$;"),i);}"
	FPRINT FP_WRITE,"wxString wxStr(long i){return wxString::Format(wxT(";DQ$;"%li";DQ$;"),i);}"
	FPRINT FP_WRITE,"wxString wxStr(double i){return wxString::Format(wxT(";DQ$;"%f";DQ$;"),i);}"
	FPRINT FP_WRITE,"wxString wxStr(float i){return wxString::Format(wxT(";DQ$;"%f";DQ$;"),i);}"
    FPRINT FP_WRITE,"//------------------------------------------------------------------------------"
    FPRINT FP_WRITE,"// Bcx String To wxString Coversion //"
	FPRINT FP_WRITE,"wxString b2xstr (char *bString){return wxString(bString,wxConvUTF8);}"
    FPRINT FP_WRITE,"//=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*"

End If
  'IF (UseCpp = TRUE) AND (UseCpphdr = TRUE) AND (NoIncludes = FALSE) Then
IF UseCpp  AND UseCpphdr  AND (NoIncludes = FALSE) Then

    FPRINT FP_WRITE,"// Additional lines may be needed"
    FPRINT FP_WRITE,"#if defined( __cplusplus )"
    'jcf added 5/30/2015
    FPRINT FP_WRITE,"  #define overloaded"
    If UseIO Then
      FPRINT FP_WRITE,"  #include <iostream>"
    End If
    FPRINT FP_WRITE,"  #include <fstream>"
    FPRINT FP_WRITE,"  #include <sstream>"
    FPRINT FP_WRITE,"  #include <iomanip>"
	'FPRINT FP_WRITE,"  #include <strstream>"
'jcfuller added 3/14/2013
    FPRINT FP_WRITE,"  #include <locale>"
    FPRINT FP_WRITE,"  #include <algorithm>"
'jcfuller added 10/24/2013
    FPRINT FP_WRITE,"  #include <vector>"
    FPRINT FP_WRITE,"  typedef std::string::value_type charT;"

    FPRINT FP_WRITE,"  typedef std::string stdstr;"
    FPRINT FP_WRITE,"  typedef std::wstring wstdstr;"
    FPRINT FP_WRITE,"  #define _X(y) y"
    FPRINT FP_WRITE,"  using namespace std;"
    FPRINT FP_WRITE,"  #ifdef UNICODE"
    FPRINT FP_WRITE,"    typedef std::wstring _string;"
    FPRINT FP_WRITE,"  #else"
    FPRINT FP_WRITE,"    typedef std::string _string;"
    FPRINT FP_WRITE,"  #endif"

    FPRINT FP_WRITE,"#endif"
  END IF
'jcfuller
'=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
  If Use_ClassProps Then

	PREPEND FPRINT FP_WRITE,
		"//=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*"
	    "/* Class Property Support */"
		"#ifndef INC_PROPERTY_HPP"
		"  #ifndef NULL"
		"    #define NULL 0"
		"  #endif"
		"  #define INC_PROPERTY_HPP"
		"  #define READ_ONLY 1"
		"  #define WRITE_ONLY 2"
		"  #define READ_WRITE 3"
		"  template<typename Container, typename ValueType, int nPropType>"
		"  class property"
		"  {"
		"    public:"
		"      property()"
		"      {"
		"        m_cObject = NULL;"
		"        Set = NULL;"
		"        Get = NULL;"
		"      }"
		"      void setContainer(Container* cObject)"
		"      {"
		"        m_cObject = cObject;"
		"      }"
		"      void setter(void (Container::*pSet)(ValueType value))"
		"      {"
		"        if((nPropType == WRITE_ONLY) || (nPropType == READ_WRITE))"
		"          Set = pSet;"
		"        else"
		"          Set = NULL;"
		"      }"
		"      void getter(ValueType (Container::*pGet)())"
		"      {"
		"        if((nPropType == READ_ONLY) || (nPropType == READ_WRITE))"
		"          Get = pGet;"
		"        else"
		"          Get = NULL;"
		"      }"
		"      ValueType operator =(const ValueType& value)"
		"      {"
		"        (m_cObject->*Set)(value);"
		"        return value;"
		"      }"
		"      operator ValueType()"
		"      {"
		"        return (m_cObject->*Get)();"
		"      }"
		"    private:"
		"      Container* m_cObject;"
		"      void (Container::*Set)(ValueType value);"
		"      ValueType (Container::*Get)();"
		"  };"
		"#endif"
		"//=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*"
	END PREPEND

  End If
'=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*

  IF Use_LeanAndMean THEN
    FPRINT FP_WRITE,"#define WIN32_LEAN_AND_MEAN // limits reading seldom used header files"
  END IF
'jcfuller changed 03/10/2014
  'IF WinHeaders OR Use_Project THEN
  IF WinHeaders OR Use_Project AND (NoIncludes = FALSE) THEN
    If Use_BC9Dialog Then
  	  FPRINT FP_WRITE,"#if defined( __POCC__ )"
  	  FPRINT FP_WRITE,"#define _WINDOWS_"
	  FPRINT FP_WRITE,"#include <pellescmem.h>"
	  FPRINT FP_WRITE,"#endif"
     End If
    FPRINT FP_WRITE,"#include <windows.h>    // Win32 Header File "
	If USE_ZTRACE Then
		FPRINT FP_WRITE,"#include ";ENC$("zTrace.h")
	End If
    FPRINT FP_WRITE,"#include <windowsx.h>   // Win32 Header File "
    FPRINT FP_WRITE,"#include <commctrl.h>   // Win32 Header File "
    FPRINT FP_WRITE,"#include <commdlg.h>    // Win32 Header File "
    FPRINT FP_WRITE,"#include <mmsystem.h>   // Win32 Header File "
    FPRINT FP_WRITE,"#include <shellapi.h>   // Win32 Header File "
    FPRINT FP_WRITE,"#include <shlobj.h>     // Win32 Header File "
    FPRINT FP_WRITE,"#include <richedit.h>   // Win32 Header File "
    'FPRINT FP_WRITE,"#include <wchar.h>      // Win32 Header File "
    FPRINT FP_WRITE,"#include <objbase.h>    // Win32 Header File "
    FPRINT FP_WRITE,"#include <ocidl.h>      // Win32 Header File "
    FPRINT FP_WRITE,"#include <winuser.h>    // Win32 Header File "
    FPRINT FP_WRITE,"#include <olectl.h>     // Win32 Header File "
    FPRINT FP_WRITE,"#include <oaidl.h>      // Win32 Header File "
    FPRINT FP_WRITE,"#include <ole2.h>       // Win32 Header File "
    FPRINT FP_WRITE,"#include <oleauto.h>    // Win32 Header File "
    FPRINT FP_WRITE,"#include <winsock.h>    // Win32 Header File "
    FPRINT FP_WRITE,"#include <wininet.h>    // Win32 Header File "
    FPRINT FP_WRITE,"#include <uxtheme.h>    // Win32 Header File "
    FPRINT FP_WRITE,"#include <psapi.h>      // Win32 Header File "
    FPRINT FP_WRITE,"#include <shlwapi.h>      // Win32 Header File "
    FPRINT FP_WRITE,"#ifndef __TINYC__       // No Tiny C support"
    FPRINT FP_WRITE,"#include <urlmon.h>     // Win32 Header File "
    FPRINT FP_WRITE,"#endif"
  END IF
  If (TargetOS = TWIN) AND (NoIncludes = FALSE) THEN
    FPRINT FP_WRITE,"#include <process.h>    // dos"
    'FPRINT FP_WRITE,"#include <conio.h>      // dos"
    FPRINT FP_WRITE,"#include <direct.h>     // dos"
    FPRINT FP_WRITE,"#include <io.h>         // dos"
  END IF
  IF NoIncludes = FALSE THEN
  'jcfuller - moved conio.h 10/27/2013
	If TargetOS = TWIN Then
      FPRINT FP_WRITE,"#include <conio.h>      // dos"
    End if
    IF UseCpp Then
        FPRINT FP_WRITE,"#include <cwchar>      // c++ dos/linux "
        FPRINT FP_WRITE,"#include <cctype>      // c++ dos/linux"
        FPRINT FP_WRITE,"#include <cmath>       // c++ dos/linux"
        FPRINT FP_WRITE,"#include <cstdio>      // c++ dos/linux"
        FPRINT FP_WRITE,"#include <cstring>     // c++ dos/linux"
        FPRINT FP_WRITE,"#include <cstddef>     // c++ dos/linux"
        FPRINT FP_WRITE,"#include <cstdlib>     // c++ dos/linux"
        FPRINT FP_WRITE,"#include <csetjmp>     // c++ dos/linux"
        FPRINT FP_WRITE,"#include <ctime>       // c++ dos/linux"
        FPRINT FP_WRITE,"#include <cstdarg>     // c++ dos/linux"
    Else
		FPRINT FP_WRITE,"#include <wchar.h>      // dos/linux "
		FPRINT FP_WRITE,"#include <ctype.h>      // dos/linux"
		FPRINT FP_WRITE,"#include <math.h>       // dos/linux"
		FPRINT FP_WRITE,"#include <stdio.h>      // dos/linux"
		FPRINT FP_WRITE,"#include <string.h>     // dos/linux"
		FPRINT FP_WRITE,"#include <stddef.h>     // dos/linux"
		FPRINT FP_WRITE,"#include <stdlib.h>     // dos/linux"
		FPRINT FP_WRITE,"#include <setjmp.h>     // dos/linux"
		FPRINT FP_WRITE,"#include <time.h>       // dos/linux"
		FPRINT FP_WRITE,"#include <stdarg.h>     // dos/linux"
	End If

    FPRINT FP_WRITE,"#include <fcntl.h>      // dos/linux"
    FPRINT FP_WRITE,"#include <sys/types.h>  "
    FPRINT FP_WRITE,"#include <sys/stat.h>   "
    IF Use_UNICODE_Switch THEN
      FPRINT FP_WRITE,"#include <tchar.h>"
      If UseCpp Then
          FPRINT FP_WRITE,"#include <cwctype>"
      Else
          FPRINT FP_WRITE,"#include <wctype.h>"
      End If
      FPRINT FP_WRITE,"#define uni_gets(A) _fgetts(A,1024,stdin)"
      FPRINT FP_WRITE,"//<---UNICODE AWARE"
      FPRINT FP_WRITE,"#define scout cout"
      FPRINT FP_WRITE,"//>---UNICODE AWARE"

    END IF
  END IF
'jcfuller added 02-08-2015
If Use_BC9Dialog Then
If  Use_TCLib Then
	FPRINT FP_WRITE,"#include ",Enc$("Win95ADG.h")
	FPRINT FP_WRITE,"#include ",Enc$("DlgTmplt.h")
	FPRINT FP_WRITE,"#include ",Enc$("DlgTmplt.c")
Else
	If Not WinHeaders Then
	  IF Not UseCpp Then
		FPRINT FP_WRITE,"#if defined( __POCC__ )"
		FPRINT FP_WRITE,"#define _WINDOWS_"
		FPRINT FP_WRITE,"#include <pellescmem.h>"
		FPRINT FP_WRITE,"#endif"
      End If
		FPRINT FP_WRITE,"#include <windows.h>"
		If USE_ZTRACE Then
			FPRINT FP_WRITE,"#include ";ENC$("zTrace.h")
		End If
		
		FPRINT FP_WRITE,"#include <windowsx.h>"
		FPRINT FP_WRITE,"#include <commctrl.h>"
		FPRINT FP_WRITE,"#include <richedit.h>"
		FPRINT FP_WRITE,"#include <wchar.h>"
		FPRINT FP_WRITE,"#include <stdio.h>"
		'FPRINT FP_WRITE,"#include <malloc.h>"
	End If
	FPRINT FP_WRITE,"#include <malloc.h>"
	FPRINT FP_WRITE,"#include ",Enc$("Win95ADG.h")
	FPRINT FP_WRITE,"#include ",Enc$("DlgTmplt.h")
	FPRINT FP_WRITE,"#include ",Enc$("DlgTmplt.c")
	If (Not WinHeaders) AND (g_EmitLibs) Then

		FPRINT FP_WRITE,"// *************************************************"
		FPRINT FP_WRITE,"// Instruct Linker to Search Object/Import Libraries"
		FPRINT FP_WRITE,"// *************************************************"
		FPRINT FP_WRITE,"#pragma comment(lib,", ENC$("kernel32.lib"), ")"
		FPRINT FP_WRITE,"#pragma comment(lib,", ENC$("user32.lib"), ")"
		FPRINT FP_WRITE,"#pragma comment(lib,", ENC$("gdi32.lib"), ")"
		FPRINT FP_WRITE,"#pragma comment(lib,", ENC$("comctl32.lib"), ")"
		'FPRINT FP_WRITE,"#pragma comment(lib,", ENC$("advapi32.lib"), ")"
		'FPRINT FP_WRITE,"#pragma comment(lib,", ENC$("winspool.lib"), ")"
		'FPRINT FP_WRITE,"#pragma comment(lib,", ENC$("shell32.lib"), ")"
		'FPRINT FP_WRITE,"#pragma comment(lib,", ENC$("ole32.lib"), ")"
		'FPRINT FP_WRITE,"#pragma comment(lib,", ENC$("oleaut32.lib"), ")"
		'FPRINT FP_WRITE,"#pragma comment(lib,", ENC$("uuid.lib"), ")"
		'FPRINT FP_WRITE,"#pragma comment(lib,", ENC$("odbc32.lib"), ")"
		'FPRINT LB0,"#pragma comment(lib,", ENC$("odbccp32.lib"), ")"
		'FPRINT LB0,"#pragma comment(lib,", ENC$("delayimp.lib"), ")"
		'FPRINT LB0,"#pragma comment(lib,", ENC$("dxguid.lib"), ")"
		FPRINT FP_WRITE,"#pragma comment(lib,", ENC$("winmm.lib"), ")"
		FPRINT FP_WRITE,"#pragma comment(lib,", ENC$("comdlg32.lib"), ")"
		IF Not UseCpp Then
		  FPRINT FP_WRITE,"#if defined( __POCC__ )"
		  FPRINT FP_WRITE,"  #pragma comment(lib,", ENC$("pellescmem.lib"), ")"
		  FPRINT FP_WRITE,"#endif"
		End If
		'FPRINT LB0,"#pragma comment(lib,", ENC$("htmlhelp.lib"), ")"
	End If
End If
End If


  IF (TargetOS = TNIX) AND (NoIncludes = FALSE) THEN
    FPRINT FP_WRITE,"#include <wchar.h>      // linux only"
    FPRINT FP_WRITE,"#include <stdbool.h>    // linux only"
    FPRINT FP_WRITE,"#include <dirent.h>     // linux only"
'    FPRINT FP_WRITE,"#include <sys/types.h>  // linux only"
'    FPRINT FP_WRITE,"#include <sys/stat.h>   // linux only"
    FPRINT FP_WRITE,"#include <sys/wait.h>   // linux only"
    FPRINT FP_WRITE,"#include <unistd.h>     // linux only"
    FPRINT FP_WRITE,"#include <dlfcn.h>      // linux only"
    FPRINT FP_WRITE,"#include <termios.h>    // linux only"
  END IF


  FPRINT FP_WRITE,""
  'This needs to come after $HEADER
  'I am going to test without it
  'jcfuller changed 01/18/2014

  'IF UseWinApi = FALSE OR WinHeaders = FALSE THEN
  	'FPRINT FP_WRITE,"// ***************************************************"
  	'FPRINT FP_WRITE,"// types from winapi that may be needed"
  	'FPRINT FP_WRITE,"// ***************************************************"
  	'If Use_UNICODE_Switch Then
  	  'FPRINT FP_WRITE,"//<---UNICODE AWARE"
  	  'FPRINT FP_WRITE,"typedef _TCHAR *PCHAR,*LPCH,*PCH,*NPSTR,*LPSTR,*PSTR;"
  	  'FPRINT FP_WRITE,"typedef unsigned long DWORD, *PDWORD, *LPDWORD;"
  	  'FPRINT FP_WRITE,"//>---UNICODE AWARE"
  	'Else
  	  'FPRINT FP_WRITE,"typedef char *PCHAR,*LPCH,*PCH,*NPSTR,*LPSTR,*PSTR;"
  	  'FPRINT FP_WRITE,"typedef unsigned long DWORD, *PDWORD, *LPDWORD;"
  	'End If
  	'FPRINT FP_WRITE,"typedef unsigned int UINT;"
''  	FPRINT FP_WRITE,"typedef char byte;"
  	'FPRINT FP_WRITE,"typedef unsigned long DWORD,ULONG;"
  	'If Use_UNICODE_Switch Then
  	  'FPRINT FP_WRITE,"//<---UNICODE AWARE"
  	  'FPRINT FP_WRITE,"typedef unsigned char UCHAR,byte;"
  	  'FPRINT FP_WRITE,"//>---UNICODE AWARE"
  	'Else
  	  'FPRINT FP_WRITE,"typedef unsigned char UCHAR,byte;"
  	'End If
  	'FPRINT FP_WRITE,"typedef void *PVOID,*LPVOID;"
''jcfuller added 07/01/2013
  	'FPRINT FP_WRITE,"typedef int BOOL;"
  	'FPRINT FP_WRITE,"#ifndef TRUE"
  	'FPRINT FP_WRITE,"  #define TRUE 1"
  	'FPRINT FP_WRITE,"#endif"
  	'FPRINT FP_WRITE,"#ifndef FALSE"
  	'FPRINT FP_WRITE,"  #define FALSE 0"
  	'FPRINT FP_WRITE,"#endif"
''this is in the TDM-GCC but not NUWEN
  	''IF UseWinApi = FALSE THEN
  	'If g_EmitLibs = FALSE Then 'using MinGW
		'FPRINT FP_WRITE,"//----------------------------------------------------"
		'FPRINT FP_WRITE,"// this is missing From MinGWTDM64 stdlib.h"
		'FPRINT FP_WRITE,"//----------------------------------------------------"
		'FPRINT FP_WRITE,"#if defined(__MINGW32__) || defined(__MINGW64__)"
		'FPRINT FP_WRITE,"  #ifndef MAX_PATH"
		'FPRINT FP_WRITE,"    #define MAX_PATH 260"
		'FPRINT FP_WRITE,"  #endif"
		'FPRINT FP_WRITE,"#endif"
  	'END IF
  	'FPRINT FP_WRITE, "//----------------------------------------------------"
  	'FPRINT FP_WRITE,""
  'End If

  'If UseCpp Then
      'FPRINT FP_WRITE, "//----------------------------------------------------"
      'FPRINT FP_WRITE, "#ifndef _MSC_VER"
	  'FPRINT FP_WRITE,"// c++ bool defines"
	  'FPRINT FP_WRITE,"#define _bool	bool"
	  'FPRINT FP_WRITE,"#define _Bool	bool"
	  'FPRINT FP_WRITE,"#define _false false"
	  'FPRINT FP_WRITE,"#define _true true"
	  'FPRINT FP_WRITE,"#endif"
	  'FPRINT FP_WRITE, "//----------------------------------------------------"

    'Else
    'FPRINT FP_WRITE, "//----------------------------------------------------"
	'FPRINT FP_WRITE,"// c bool defines"
	'FPRINT FP_WRITE,"#define _bool _Bool"
	'FPRINT FP_WRITE,"#define _false FALSE"
	'FPRINT FP_WRITE,"#define _true TRUE"
	'FPRINT FP_WRITE, "//----------------------------------------------------"
  'End If
  IF Use_Library THEN
    FPRINT FP_WRITE,"// END BCXRTHEADER\n\n"
    FPRINT FP_WRITE,""
  END IF
END SUB ' EmitProlog



SUB Commandline_Defines(FP_WRITE AS FILE)
  IF CmdLineConst$ <> "" THEN
    RAW Ftmp AS FILE, Z$
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"// ***************************************************"
    FPRINT FP_WRITE,"// Commandline Defines"
    FPRINT FP_WRITE,"// ***************************************************"
    FPRINT FP_WRITE,""
    ' Save FILE Ptr to SourceFile
    Ftmp = FP_CST
    ' Direct output to HeaderFile
    FP_CST = FP_WRITE
    FOR INTEGER i = 1 TO TALLY( CmdLineConst$, CHR$(1) )
      Z$ = STRTOKEN$( CmdLineConst$, CHR$(1), i )
      IF Z$ = "" THEN EXIT FOR
      Z$ = "CONST " + Z$ ' CmdLineConst$
      CALL XFE(Z$)
    NEXT
    'CmdLineConst$ = ""
    ' Restore Ptr to SourceFile
    FP_CST = Ftmp
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"// ***************************************************"
    FPRINT FP_WRITE,"// End of Commandline Defines"
    FPRINT FP_WRITE,"// ***************************************************"
    FPRINT FP_WRITE,""
  END IF
END SUB ' Commandline_Defines


'jcfulller 1/12/2016
'need to revise for c or c++; cdecl or stdcall

SUB EmitUserDirectives(FP_WRITE AS FILE)
  IF EXIST(hdrFile$) THEN
    RAW Z$
    RAW FP_R AS FILE
    OPEN hdrFile$ FOR INPUT AS FP_R     'hdrFile$   ' user specified .h directives
    WHILE NOT EOF(FP_R)
      LINE INPUT FP_R, Z$
      FPRINT FP_WRITE, Z$
    WEND
    CLOSE FP_R
  END IF
END SUB ' EmitUserDirectives
'------------------------------------------------------------------------------



SUB User_GLOBAL_ENUM_Blocks(FP_WRITE AS FILE)
  IF EXIST(enuFile$) THEN
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"// *************************************************"
    FPRINT FP_WRITE,"//        User's GLOBAL ENUM blocks"
    FPRINT FP_WRITE,"// *************************************************"
    RAW Z$
    RAW FP_R AS FILE
    OPEN enuFile$ FOR INPUT AS FP_R     'enuFile$   ' user GLOBAL enum blocks
    WHILE NOT EOF(FP_R)
      LINE INPUT FP_R, Z$
      FPRINT FP_WRITE, Z$
    WEND
    CLOSE FP_R
  END IF
END SUB ' User_GLOBAL_ENUM_Blocks



SUB System_Defined_Constants(FP_WRITE AS FILE)
  IF EXIST(SystemConstFile$) THEN
    IF Use_Library THEN
      FPRINT FP_WRITE,"// BCXRTHEADER: SYSTEM DEFINED CONSTANTS"
    ELSE
      FPRINT FP_WRITE,""
      FPRINT FP_WRITE,"// *************************************************"
      FPRINT FP_WRITE,"//            System Defined Constants"
      FPRINT FP_WRITE,"// *************************************************"
      FPRINT FP_WRITE,""
    END IF
'jcfuller added 06/18/2014
    If NOT WxGui AND NOT WxCon Then
		FPRINT FP_WRITE,"typedef const char* ccptr;"
		FPRINT FP_WRITE,"#define CCPTR const char*"
		FPRINT FP_WRITE,"#define cfree free"
		If Use_UNICODE_Switch Then
			FPRINT FP_WRITE,"//<---UNICODE AWARE"
			FPRINT FP_WRITE,"	typedef char _char;"
			FPRINT FP_WRITE,"	#define _strlen strlen"
			FPRINT FP_WRITE,"//>---UNICODE AWARE"
		End If
		'FPRINT FP_WRITE,"#define WAITKEY system(",ENC$("pause"),")"
		FPRINT FP_WRITE,"#define EQU =="
		FPRINT FP_WRITE,"#define NOT_USED(x) if(x);"
		If TargetOS = TWIN THEN
			FPRINT FP_WRITE,"#define CTLHNDL(id) GetDlgItem(hWnd,id)"
		End if
		If Use_BC9Tab Then
			FPRINT FP_WRITE,"#ifndef IDC_TAB_STATIC"
			FPRINT FP_WRITE,"    #define IDC_TAB_STATIC 12345"
			FPRINT FP_WRITE,"#endif"
			FPRINT FP_WRITE,"#ifndef RECTWIDTH"
			FPRINT FP_WRITE,"    #define RECTWIDTH(tRect) tRect.right-tRect.left"
			FPRINT FP_WRITE,"    #define RECTHEIGHT(tRect) tRect.bottom-tRect.top"
			FPRINT FP_WRITE,"#endif"

		End If
		If Not Use_TCLib Then	'save every byte we can :)
		    FPRINT FP_WRITE,"char   *g_cptr_;  // dummy var for not used returns"
            'FPRINT FP_WRITE,"size_t  g_dum1_;  // dummy var for not used returns"
		    FPRINT FP_WRITE,"unsigned int  g_dum1_;  // dummy var for not used returns"
		    FPRINT FP_WRITE,"int g_dum_int;		// dummy int var for not used returns"
		End if    
	End If
    RAW Z$
    RAW FP_R AS FILE
    OPEN SystemConstFile$ FOR INPUT AS FP_R     'SystemConstFile$    ' system translated CONSTants
    WHILE NOT EOF(FP_R)
      LINE INPUT FP_R, Z$
      FPRINT FP_WRITE, Z$
    WEND
    CLOSE FP_R
  END IF
END SUB ' System_Defined_Constants



SUB User_Defined_Constants(FP_WRITE AS FILE)
  IF EXIST(UserConstFile$) THEN
    IF Use_Library THEN
      FPRINT FP_WRITE,"// BCXRTHEADER: USER DEFINED CONSTANTS"
    ELSE
      FPRINT FP_WRITE,""
      FPRINT FP_WRITE,"// *************************************************"
      FPRINT FP_WRITE,"//            User Defined Constants"
      FPRINT FP_WRITE,"// *************************************************"
      FPRINT FP_WRITE,""
    END IF
    RAW Z$
    RAW FP_R AS FILE
    OPEN UserConstFile$ FOR INPUT AS FP_R     'UserConstFile$      ' user translated CONSTants
    WHILE NOT EOF(FP_R)
      LINE INPUT FP_R, Z$
      FPRINT FP_WRITE, Z$

    WEND
    CLOSE FP_R
  END IF
END SUB ' User_Defined_Constants



SUB User_Defined_Types_And_Unions(FP_WRITE AS FILE)
  IF EXIST(udtFile$) THEN
    FPRINT FP_WRITE, "// *************************************************"
    FPRINT FP_WRITE, "//          User Defined Types, Unions and Classes"
    FPRINT FP_WRITE, "// *************************************************"
    FPRINT FP_WRITE, ""

'jcfuller added 06/16/2014
    If WxGui Then
		FPRINT FP_WRITE,"class " & g_swx$ & " : public wxApp"
		FPRINT FP_WRITE,"{"
		FPRINT FP_WRITE,"    public:"
		FPRINT FP_WRITE,"        virtual bool   OnInit(void);"
		FPRINT FP_WRITE,"};"
    End If
    RAW Z$
    RAW FP_R AS FILE
    OPEN udtFile$ FOR INPUT AS FP_R       'udtFile$   ' translated User Defined Types
    WHILE NOT EOF(FP_R)
      LINE INPUT FP_R, Z$
      FPRINT FP_WRITE, Z$
    WEND
    CLOSE FP_R
  END IF
END SUB ' User_Defined_Types_And_Unions



SUB BeginMain()
  IF NOT Use_Library THEN
    FPRINT Outfile,"int main(int argc, char *argv[])"
    '*****************************************************************************
    '         int main is conditionally removed later IN SUB AssembleParts
    '*****************************************************************************
  END IF
  FLUSH (Outfile)
END SUB ' BeginMain



SUB User_Data_Statements(FP_WRITE AS FILE)
  '********************************
  ' Read In The Data Statement File
  '********************************

  IF LOF(datFile$) > 0 THEN
    RAW Z$
    RAW FP_DAT AS FILE
    OPEN datFile$ FOR INPUT AS FP_DAT
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"// *************************************************"
    FPRINT FP_WRITE,"//              User Data Statements"
    FPRINT FP_WRITE,"// *************************************************"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"const char * DATA [] ="
    FPRINT FP_WRITE,"{"
    WHILE NOT EOF(FP_DAT)
      LINE INPUT FP_DAT,Z$
      FPRINT FP_WRITE,Z$;
      IF NOT EOF(FP_DAT) THEN FPRINT FP_WRITE,","
    WEND
    CLOSE FP_DAT
    FPRINT FP_WRITE,"\n};"
  END IF
END SUB ' User_Data_Statements



SUB User_Global_Variables(FP_WRITE AS FILE)
  RAW i, VarName$,  Storage$, VarDim$, A, P$

  IF GlobalVarCnt OR DllCnt THEN
    IF Use_Library THEN
      FPRINT FP_W,"// BCXRTHEADER: USER GLOBAL VARIABLES"
    ELSE
      FPRINT FP_W,""
      FPRINT FP_W,"// *************************************************"
      FPRINT FP_W,"//            ";BCX_STR_USR_VARS$
      FPRINT FP_W,"// *************************************************"
      FPRINT FP_W,""
    END IF
  END IF

  '*************************************
  ' Declare the DLL Variables
  '*************************************

  IF DllCnt THEN
    FOR INTEGER i = 1 TO DllCnt
      FPRINT FP_W,"static BCXFPROT", LTRIM$(STR$(i)), " ", EXTRACT$(DllDecl$[i],"="), ";"
    NEXT
  END IF

  '*************************************
  ' Declare the simple Variables
  '*************************************

  FOR i = 1 TO GlobalVarCnt
    IF GlobalVars[i].VarEmitFlag THEN ITERATE
    IF "" = GlobalVars[i].VarDim$ AND GlobalVars[i].VarCondLevel = 0 THEN
      P$ = ""
      IF GlobalVars[i].VarPntr THEN P$ = STRING$(GlobalVars[i].VarPntr,42)
      A = GlobalVars[i].VarType
      IF GlobalVars[i].VarSF THEN
        VarName$ = "(*" + GlobalVars[i].VarName$ + ")"
      ELSE
        VarName$ = GlobalVars[i].VarName$
      END IF
      Storage$ = VarStorage$[GlobalVars[i].VarExtn] & VarConst$[GlobalVars[i].VarConstant]
      VarDim$ = GlobalVars[i].VarDim$
  'If Not IsBc9 Then
	'If _ZTRACE_ Then
		'ZPRINT("A        = " + Str$(A))
		'ZPRINT("i        = " + Str$(i))
		'ZPRINT("Storage$ = " + Storage$)
		'ZPRINT("P$       = " + P$)
		'ZPRINT("VarName$ = " + VarName$)
		'ZPRINT("VarDim$  = " + VarDim$)
		'ZPRINT("*********************")
	'End if
  'End If
      
      CALL PrintGlobal(FP_WRITE, A, i, Storage$, P$, VarName$, VarDim$)
    END IF
  NEXT

  '   Next, we declare the Arrays

  FOR i = 1 TO GlobalVarCnt
    IF GlobalVars[i].VarEmitFlag THEN ITERATE
    IF "" <> GlobalVars[i].VarDim$ AND GlobalVars[i].VarCondLevel = 0 THEN
      IF INSTR(GlobalVars[i].VarDim,"{") = 0 THEN     ' do uninitialized global arrays
        P$ = ""
        IF GlobalVars[i].VarPntr THEN P$ = STRING$(GlobalVars[i].VarPntr,42)
        A = GlobalVars[i].VarType
        IF GlobalVars[i].VarSF THEN
          VarName$ = "(*" + GlobalVars[i].VarName$ + EXTRACT$(GlobalVars[i].VarDim,"(") + ")"
          VarDim$ = MID$(GlobalVars[i].VarDim, INSTR(GlobalVars[i].VarDim,"("))
        ELSE
          VarName$ = GlobalVars[i].VarName$
          VarDim$ = GlobalVars[i].VarDim$
        END IF
        Storage$ = VarStorage$[GlobalVars[i].VarExtn] & VarConst$[GlobalVars[i].VarConstant]
        CALL PrintGlobal(FP_WRITE, A, i, Storage$, P$, VarName$, VarDim$)
      END IF
    END IF
  NEXT

  DIM RAW LastDef$
  DIM RAW LastLevel

  LastDef$ = ""
  LastLevel = 1

  FOR i = 1 TO GlobalVarCnt
    IF GlobalVars[i].VarEmitFlag THEN ITERATE
    IF GlobalVars[i].VarCondLevel THEN
      IF LastDef$ = "" THEN
        LastDef$ = GlobalVars[i].VarCondDef$
        LastLevel = GlobalVars[i].VarCondLevel
        FPRINT Outfile,LastDef$
      END IF
      IF LastDef$ <> GlobalVars[i].VarCondDef$ THEN
        IF GlobalVars[i].VarCondDef$ = "#else" THEN
          WHILE LastLevel > GlobalVars[i].VarCondLevel
            FPRINT Outfile,"#endif"
            LastLevel--
          WEND
          FPRINT Outfile,"#else"
          LastDef$ = GlobalVars[i].VarCondDef$
        ELSE
          WHILE LastLevel => GlobalVars[i].VarCondLevel
            FPRINT Outfile,"#endif"
            LastLevel--
          WEND
          LastDef$ = GlobalVars[i].VarCondDef$
          LastLevel = GlobalVars[i].VarCondLevel
          FPRINT Outfile,LastDef$
        END IF
      END IF
      P$ = ""
      IF GlobalVars[i].VarPntr THEN P$ = STRING$(GlobalVars[i].VarPntr,42)
      A = GlobalVars[i].VarType
      IF GlobalVars[i].VarSF THEN
        VarName$ = "(*" + GlobalVars[i].VarName$ + ")"
      ELSE
        VarName$ = GlobalVars[i].VarName$
      END IF
      VarDim$ = GlobalVars[i].VarDim
      Storage$ = VarStorage$[GlobalVars[i].VarExtn] & VarConst$[GlobalVars[i].VarConstant]
      CALL PrintGlobal(FP_WRITE, A, i, Storage$, P$, VarName$, VarDim$)

    END IF
  NEXT

  IF *LastDef$ THEN
    WHILE LastLevel
      FPRINT FP_WRITE,"#endif"
      LastLevel--
    WEND
  END IF
  FPRINT FP_WRITE,""
  IF Use_Library THEN FPRINT FP_WRITE,"// END BCXRTHEADER\n\n"
END SUB ' User_Global_Variables



SUB SYSTEM_VARIABLES(FP_WRITE AS FILE)
    IF Use_Console  OR _
      Use_Findfirst   OR _
      Use_Findnext    OR _
      Use_GoSub       OR _
      UseFlag         OR _
      Use_Crlf        OR _
      Use_Inputbox    OR _
      Use_Infobox     OR _
      Use_Inputbuffer OR _
      Use_BCX_Splitter OR _
      Use_Dynacall     OR _
      Use_DynacallA    OR _
      UseLCaseTbl  THEN

      IF Use_Library THEN
        FPRINT FP_WRITE,"// BCXRTHEADER: SYSTEM VARIABLES"
      ELSE
        FPRINT FP_WRITE,""
        FPRINT FP_WRITE,"// *************************************************"
        FPRINT FP_WRITE,"//                " + BCX_STR_SYS_VARS$
        FPRINT FP_WRITE,"// *************************************************"
        FPRINT FP_WRITE,""
      END IF
    END IF


    IF Use_BCX_Splitter THEN
      FPRINT FP_WRITE,"static COLORREF SplitBarFG=RGB(0,0,255);"
      FPRINT FP_WRITE,"static COLORREF SplitBarBG=RGB(212,212,212);"
      FPRINT FP_WRITE,"#define SPLITBAR_SIZE 2"
      FPRINT FP_WRITE,"#define MIN_PANESIZE 4"
      FPRINT FP_WRITE,""
      FPRINT FP_WRITE,"typedef struct _SPLITTERINFO"
      FPRINT FP_WRITE,"{"
      FPRINT FP_WRITE,"  int  swsStyle;"
      FPRINT FP_WRITE,"  int  splittype;"
      FPRINT FP_WRITE,"  HCURSOR  hCursor;"
      FPRINT FP_WRITE,"  HWND  hwPane1;"
      FPRINT FP_WRITE,"  HWND  hwPane2;"
      FPRINT FP_WRITE,"  BOOL  fMovingBar;"
      FPRINT FP_WRITE,"  int   percent;"
      FPRINT FP_WRITE,"}SPLITTERINFO, *LPSPLITTERINFO;"
      FPRINT FP_WRITE,""
    END IF

    IF Use_Ldouble THEN
      FPRINT FP_WRITE,"#define LDOUBLE long double"
    END IF

    IF Use_Idxqsort THEN
      FPRINT FP_WRITE,"char*** pppStr;"
    END IF

    IF Use_Idxqsort OR Use_IdxqsortSt OR Use_PtrqsortSt THEN
      FPRINT FP_WRITE,"int     Key;"
    END IF

    IF Use_IdxqsortSt THEN
      FPRINT FP_WRITE,"char*   cmp1;"
      FPRINT FP_WRITE,"int     StructSize;"
    END IF

    IF Use_PtrqsortSt THEN
      FPRINT FP_WRITE,"int     OffSet;"
    END IF

    IF Use_Sound THEN
      FPRINT FP_WRITE,""
      FPRINT FP_WRITE,"#define SNDQUE 10000"
      FPRINT FP_WRITE,""
      FPRINT FP_WRITE,"typedef struct _soundtype"
      FPRINT FP_WRITE,"{"
      FPRINT FP_WRITE,"  FLOAT  Freq;"
      FPRINT FP_WRITE,"  INT    Dura;"
      FPRINT FP_WRITE,"  INT    Vol;"
      FPRINT FP_WRITE,"  INT    Voice;"
      FPRINT FP_WRITE,"  FLOAT  Tempo;"
      FPRINT FP_WRITE,"  INT    sndTid;"
      FPRINT FP_WRITE,"} soundtype, *LPSOUNDTYPE;"
      FPRINT FP_WRITE,""
      FPRINT FP_WRITE,szProject$;"soundtype  SndPmtr[SNDQUE+1];"
      FPRINT FP_WRITE,szProject$;"UINT       gTenter;"
      FPRINT FP_WRITE,szProject$;"UINT       gTwait;"
      FPRINT FP_WRITE,szProject$;"UINT       gTexit;"
      FPRINT FP_WRITE,szProject$;"UINT       gTarray;"
      FPRINT FP_WRITE,szProject$;"BOOL       gTsig;"
      FPRINT FP_WRITE,szProject$;"HANDLE     gSThread=NULL;"
      FPRINT FP_WRITE,""
    END IF

    IF Use_BCX_Fontdlg THEN
      FPRINT FP_WRITE,""
      FPRINT FP_WRITE,"typedef struct _BCX_FONT_TYPE"
      FPRINT FP_WRITE,"{"
      FPRINT FP_WRITE,"  LOGFONT lf;"
      FPRINT FP_WRITE,"  int  SIZE;"
      FPRINT FP_WRITE,"  int  RGB;"
      FPRINT FP_WRITE,"} BCX_FONT_TYPE;"
      FPRINT FP_WRITE,""
      FPRINT FP_WRITE,szProject$;"BCX_FONT_TYPE BCX_FONT;"
      FPRINT FP_WRITE,""
    END IF

    IF Use_Inputbox THEN
      FPRINT FP_WRITE,"char    BCX_INPUTBOX_VAL";cSizeOfADefaultString$;";"
    END IF

    IF Use_NUL THEN
      FPRINT FP_WRITE,szProject$;"char    NUL [1]={0};     // Null"
    END IF

    IF Use_BEL THEN
      FPRINT FP_WRITE,szProject$;"char    BEL [2]={7,0};   // Bell"
    END IF

    IF Use_BS THEN
      FPRINT FP_WRITE,szProject$;"char    BS  [2]={8,0};   // Back Space"
    END IF

    IF Use_TAB THEN
      FPRINT FP_WRITE,szProject$;"char    TAB [2]={9,0};   /* Horz Tab */"
    END IF

    IF Use_LF THEN
      FPRINT FP_WRITE,szProject$;"char    LF  [2]={10,0};  /* Line Feed */"
    END IF

    IF Use_VT THEN
      FPRINT FP_WRITE,szProject$;"char    VT  [2]={11,0};  /* Vert Tab*/"
    END IF

    IF Use_FF THEN
      FPRINT FP_WRITE,szProject$;"char    FF  [2]={12,0};  /* Form Feed */"
    END IF

    IF Use_CR THEN
      FPRINT FP_WRITE,szProject$;"char    CR  [2]={13,0};  /* Carr Rtn */"
    END IF

    IF Use_EOF THEN
      FPRINT FP_WRITE,szProject$;"char    EF  [2]={26,0};  /* End-of-File */"
    END IF

    IF Use_ESC THEN
      FPRINT FP_WRITE,szProject$;"char    ESC [2]={27,0};  /* Escape */"
    END IF

    IF Use_SPC THEN
      FPRINT FP_WRITE,szProject$;"char    SPC [2]={32,0};  /* Space */"
    END IF

    IF Use_DQ THEN
      FPRINT FP_WRITE,szProject$;"char    DQ  [2]={34,0};  /* Double-Quote */"
    END IF

    IF Use_DDQ THEN
      FPRINT FP_WRITE,szProject$;"char    DDQ [3]={34,34,0}; /* Double-Double-Quote */"
    END IF

    IF Use_Crlf THEN
      FPRINT FP_WRITE,szProject$;"char    CRLF[3]={13,10,0}; /* Carr Rtn & Line Feed */"
    END IF

    'IF Use_Console AND UseWinApi THEN
    IF Use_Console THEN
      FPRINT FP_WRITE,"COORD   cursor;       /* holds coordinates of cursor */"
      FPRINT FP_WRITE,"HANDLE  hConsole;     /* handle of console window */"
      FPRINT FP_WRITE,"int     color_fg = 7; /* forground color set to default */"
      FPRINT FP_WRITE,"int     color_bg = 0; /* background color set to default */"
    END IF

    IF Use_Scan THEN
      FPRINT FP_WRITE,"int     ScanError;   /* holds last error from scan function */"
    END IF

    IF Use_Inputbuffer THEN
      FPRINT FP_WRITE,"char    InputBuffer[";cMaxSrcLen;"];"
    END IF

    IF Use_Hook THEN
      FPRINT FP_WRITE,"HHOOK   CmDlgHook;"
    END IF

    IF Use_Findfirst OR Use_Findnext THEN
      FPRINT FP_WRITE,"HANDLE FileHandle;"
      FPRINT FP_WRITE,"WIN32_FIND_DATA FindData;"
    END IF

    IF Use_GoSub THEN
      FPRINT FP_WRITE,"jmp_buf GosubStack[32];"
      FPRINT FP_WRITE,"int     GosubNdx;"
    END IF

    IF Use_DynacallCommon THEN
      FPRINT FP_WRITE,"HINSTANCE BCX_DllStore[256];"
    END IF

    IF UseLCaseTbl THEN
      FPRINT FP_WRITE,"char *LowCase;"
    END IF
'jcfuller added 6-9-2013
   IF Use_BCX_RegWnd OR Use_BCX_InitGUI THEN
      FPRINT FP_WRITE,"char g_ResMenu[cSizeOfDefaultString];"
   END IF
    IF Use_Library THEN FPRINT FP_WRITE,"// END BCXRTHEADER\n\n"
END SUB ' SYSTEM_VARIABLES



SUB PreParse(Arg$)
  '********************************************
  ' Stk$[) AND Ndx must be declared GLOBAL
  ' and are re-initialized WITH each invocation
  '*********************************************
  DIM RAW szChar$
  DIM RAW Strlit$
  DIM RAW Anyword$
  DIM RAW Counter
  DIM RAW TT
  DIM RAW Tmp
  DIM RAW Arglen
  DIM RAW A
  DIM RAW j
  '********************************************************************
  Anyword$ = "" ' This is the only local that needs to be initialized
  '********************************************************************
  Ndx = 0
  Arg$ = RTRIM$(Arg$)
  IF Arg$ = "" THEN
    Ndx = 0
    EXIT SUB
  END IF
  '********************
  FOR Tmp = 0 TO 15
    Stk$[Tmp] = ""
  NEXT
  '********************
  Arglen = LEN(Arg$)
  Counter = 0
  WHILE Counter <= Arglen
    IF Ndx => MaxStk THEN Abort("Overflowed Parse Stack")
    Counter++
    szChar[0] =Arg[Counter-1]              'This eliminates using MID$
    szChar[1] = 0                          'Remember to null terminate
    TT = ASC(szChar$)
    '***************************************
    SELECT CASE TT
      '***************************************
      CASE c_DblQt   'Identify string literals
      '***************************************
      Strlit$ = szChar$
      szChar$ = ""
      DO
        IF szChar$ = DQ$  THEN EXIT DO
        Counter++
        IF Counter = Arglen THEN
          szChar[0] = Arg[Counter-1]        'This eliminates using MID$
          szChar[1] = 0                     'Remember to null terminate
          CONCAT (Strlit$,szChar$)
          IF szChar$ <> DQ$ THEN
            CONCAT (Strlit$,DQ$)            'Allow unquoted END of string
          END IF
          EXIT DO
        END IF
        szChar[0] = Arg[Counter-1]          'This eliminates using MID$
        szChar[1] = 0                       'Remember to null terminate
        CONCAT (Strlit$,szChar$)
      LOOP
      Ndx++
      Stk$[Ndx]= Strlit$
      '***************
      CASE 32 ' SPACE
      '***************
      IF Anyword[0] THEN
        Ndx++
        Stk$[Ndx] = Anyword$
        Anyword$ = ""
      END IF
      ' *****************************************************************
      '    =   &  (  )  [  ]  '  ,  +  -  *  /  ?  <  >  ;   |  :  ^
      CASE 61,38,40,41,91,93,39,44,43,45,42,47,63,60,62,59,124,58,94
      '******************************************************************
      IF LEN(Anyword$) THEN
        Ndx++
        Stk$[Ndx]= Anyword$
        Anyword$ = ""
      END IF
      Ndx++
      Stk$[Ndx]= szChar$
      '*****************
      CASE ELSE
      '*****************
      A=LEN(Anyword$)
      Anyword[A]   = Arg[Counter-1]        'This eliminates using MID$
      Anyword[A+1] = 0                     'Remember to null terminate
      '*****************
    END SELECT
    '*****************
  WEND
  IF LEN(Anyword$) THEN
    Ndx++
    Stk$[Ndx]= Anyword$
  END IF
  FOR j = 1 TO Ndx
    SELECT CASE LCASE$(Stk$[j])
      CASE "bor"
        Stk$[j] = "|"
      CASE "band"
        Stk$[j] = "&"
    END SELECT
  NEXT
END SUB ' PreParse



FUNCTION GetNumArgs OPTIONAL(Strt, NdxPos AS INTEGER PTR=NULL)
  DIM RAW CountR = 0  '() counter
  DIM RAW CountS = 0  '[] counter
  DIM RAW i           'loop counter
  DIM RAW j = 0       'comma counter
  DIM RAW k = 1       'function end flag

  FOR i = Strt TO Ndx
    SELECT CASE Stk$[i]
      CASE "("
        CountR++
        k++
      CASE ")"
        CountR--
        k--
        IF k = 0 THEN EXIT SELECT, FOR
      CASE "["
        CountS++
      CASE "]"
        CountS--
      CASE ","
        IF CountR = 0 AND CountS = 0 THEN
          j++
          IF NdxPos THEN *NdxPos = i
        END IF
    END SELECT
  NEXT
  FUNCTION = j   'No. of commas = No. of args
END FUNCTION ' GetNumArgs


'Split function into
'SUB GetVarCodeAParam(varcode AS VARCODE PTR)
'END SUB
'SUB GetVarCodeNoParam(varcode AS VARCODE PTR)
'  IF varcode->Methd% = mt_ConsDesNoParam OR varcode->Methd% = mt_FuncSubDecC_DecNoParam OR varcode->Methd% = mt_OverLoadNoParam THEN
'    varcode->Proto$ = varcode->Proto$  +  varcode->Token$
'    varcode->Header$ = varcode->Header$ + varcode->Token$
'    EXIT SUB
'  END IF
'
'  IF varcode->Methd% = mt_OptsNoParam THEN
'    varcode->Proto$ = varcode->Proto$  +  varcode->Token$
'    IF varcode->Token$ = "," OR InClassModule OR varcode->Token$ = "..." THEN
'      varcode->Header$ = varcode->Header$ + varcode->Token$
'    END IF
'    EXIT SUB
'  END IF
'
'END SUB
SUB GetVarCode(varcode AS VARCODE PTR, szWhere AS const char Ptr)
  DIM RAW CB$, PT$, PTH$, VAR$, vn, RF$, bRemoveSplat AS BOOL

  IF varcode->Methd% = mt_ConsDesNoParam OR varcode->Methd% = mt_FuncSubDecC_DecNoParam OR varcode->Methd% = mt_OverLoadNoParam THEN
    varcode->Proto$ = varcode->Proto$  +  varcode->Token$
    varcode->Header$ = varcode->Header$ + varcode->Token$
    EXIT SUB
  END IF

  IF varcode->Methd% = mt_OptsNoParam THEN
    varcode->Proto$ = varcode->Proto$  +  varcode->Token$
    IF varcode->Token$ = "," OR InClassModule OR varcode->Token$ = "..." THEN
      varcode->Header$ = varcode->Header$ + varcode->Token$
    END IF
    EXIT SUB
  END IF

  IF IsCallBack THEN
    CB$ = "CALLBACK "
  ELSE
    CB$ = ""
  END IF

  IF varcode->Methd = mt_ConsDesAParam THEN
    RAW iSplat = INSTR(varcode->AsToken$,"*")
    RAW iLT = INSTR(varcode->AsToken$,"<")
    RAW iGT = INSTR(varcode->AsToken$,">")
    IF iSplat > iLT AND iSplat < iGT THEN
      bRemoveSplat = FALSE
    ELSE
      bRemoveSplat =TRUE
    END IF
  ELSE
    bRemoveSplat = TRUE
  END IF
  IF ((INCHR(varcode->Token$,"*") OR INCHR(varcode->AsToken$,"*")) AND bRemoveSplat) OR varcode->IsPtrFlag THEN
    RemoveAll(varcode->Token$, "*")
    RemoveAll(varcode->AsToken$, "*")
    PT$  = STRING$(varcode->IsPtrFlag, ASC("*")) + " "
    PTH$ = PT$
  ELSE
    PTH$ = SPC$
    PT$ = ""
  END IF

  IF INCHR(varcode->Token$,"&") THEN
    RF$ = " &"
  ELSE
    RF$ = ""
  END IF
  vn = varcode->VarNo%
  VAR$ = GetVarTypeName$(vn)
  RAW pszHead$
  RAW pszProto$
  pszHead$ = Clean$(varcode->Token$)
  pszProto$ = pszHead$
  IF INSTR(pszProto$,"[") THEN
    pszProto$ = MID$(pszProto$,INSTR(pszProto$,"["))
  ELSE
    pszProto$ = ""
  END IF

  SELECT CASE vn

      '************************************************************************
    CASE vt_STRVAR
      '************************************************************************

      SELECT CASE varcode->Methd%

        CASE mt_ProcessSetCommand
          varcode->StaticOut$ = "static char   " + pszHead$

        CASE mt_FuncSubDecC_Dec
          varcode->Functype$ = "char * " + CB$

        CASE mt_FuncSubDecC_DecAParam      ' x
          IF NOT INCHR(varcode->Token$, "[") THEN
            varcode->Header$ = varcode->Header$  +  "char *" + pszHead$
            varcode->Proto$  = varcode->Proto$   +  "char *"
          ELSE
            varcode->Header$ = varcode->Header$  +  "char " + REMOVE$(pszHead$, "*")
            varcode->Proto$  = varcode->Proto$   +  "char []" + cSizeOfADefaultString$
          END IF

        CASE mt_Opts
          varcode->Functype$ = "char *"

        CASE mt_ConsDesAParam
          varcode->Header$ = varcode->Header$  + "char * "  +  pszHead$
          varcode->Proto$  = varcode->Proto$   + "char * "  +  pszHead$

        CASE mt_OptsAParam                 ' x
          varcode->Header$ = varcode->Header$  + "char * "  +  pszHead$
          varcode->Proto$  = varcode->Proto$   + "char * "

        CASE mt_OverLoad
          varcode->Functype$ = "char *"

        CASE mt_OverLoadAParam
          varcode->Header$ = varcode->Header$ + "char *" + pszHead$

      END SELECT

      '************************************************************************
    CASE vt_BOOL,vt_BYTE,vt_COLORREF,vt_DOUBLE,vt_DWORD,vt_FARPROC,vt_HDC, _
        vt_HANDLE,vt_HINSTANCE,vt_HWND,vt_INTEGER,vt_PCHAR,vt_LONG,vt_LPBYTE,vt_LRESULT, _
        vt_SHORT,vt_SINGLE,vt_UINT,vt_ULONG,vt_USHORT,vt_SAFEARRAY,vt_VARIANT,vt_VOID,vt_LDOUBLE, _
        vt_DWORD,vt_WORD,vt_WINBOOL,vt_BSTR
      '************************************************************************

      SELECT CASE varcode->Methd%

        CASE mt_ProcessSetCommand
          varcode->StaticOut$ = "static " + VAR$ + SPC$ + pszHead$

        CASE mt_FuncSubDecC_Dec
          varcode->Functype$ = VAR$ + PTH$ + CB$

        CASE mt_FuncSubDecC_DecAParam
          varcode->Header$ = varcode->Header$  +  VAR$ + PTH$ + pszHead$
          varcode->Proto$  = varcode->Proto$   +  VAR$ + RF$ + PT$

        CASE mt_Opts
          varcode->Functype$ = VAR$ + PTH$

        CASE mt_OptsAParam
          varcode->Header$ = varcode->Header$  +  VAR$ + PTH$ + pszHead$
          varcode->Proto$  = varcode->Proto$   +  VAR$ + RF$ + PT$

        CASE mt_ConsDesAParam
          varcode->Header$ = varcode->Header$  +  VAR$ + PTH$ + pszHead$
          varcode->Proto$  = varcode->Proto$   +  VAR$ + PTH$ + pszHead$

        CASE mt_OverLoad
          varcode->Functype$ = VAR$ + SPC$

        CASE mt_OverLoadAParam
          varcode->Header$ = varcode->Header$ + VAR$ + PTH$ + pszHead$

      END SELECT

      '************************************************************************
    CASE vt_FILEPTR
      '************************************************************************

      SELECT CASE varcode->Methd%

        CASE mt_FuncSubDecC_Dec
          varcode->Functype$ = VAR$ + PTH$ + CB$

        CASE mt_FuncSubDecC_DecAParam          ' y
          varcode->Header$ = varcode->Header$  +  VAR$ + PTH$ + pszHead$
          IF INSTR(varcode->Token$,"[") THEN
            varcode->Proto$  = varcode->Proto$   +  VAR$ + PT$ + SPC$ + pszHead$
          ELSE
            varcode->Proto$  = varcode->Proto$   +  VAR$ + PT$
          END IF

        CASE mt_Opts
          varcode->Functype$ = VAR$ + PTH$

        CASE mt_OptsAParam                     ' y
          varcode->Header$ = varcode->Header$  +  VAR$ + PTH$  +  pszHead$
          varcode->Proto$  = varcode->Proto$   +  VAR$ + PT$

        CASE mt_ConsDesAParam
          varcode->Header$ = varcode->Header$  +  VAR$ + PTH$  +  pszHead$
          varcode->Proto$  = varcode->Proto$   +  VAR$ + PTH$  +  pszHead$

        CASE mt_OverLoad
          varcode->Functype$ = VAR$ + SPC$

        CASE mt_OverLoadAParam
          varcode->Header$ = varcode->Header$ + VAR$ + PTH$ + pszHead$

      END SELECT

    '************************************************************************
    CASE vt_CHAR
    '************************************************************************

      SELECT CASE varcode->Methd%

        CASE mt_FuncSubDecC_Dec
          varcode->Functype$ = VAR$ + PTH$ + CB$

        CASE mt_FuncSubDecC_DecAParam          ' y
          varcode->Header$ = varcode->Header$  +  VAR$ + PTH$ + pszHead$
          varcode->Proto$  = varcode->Proto$   +  VAR$ + PT$ + SPC$ + pszProto$

        CASE mt_Opts
          varcode->Functype$ = VAR$ + PTH$

        CASE mt_OptsAParam                     ' y
          varcode->Header$ = varcode->Header$  +  VAR$ + PTH$  +  pszHead$
          varcode->Proto$  = varcode->Proto$   +  VAR$ + PT$ + SPC$ + pszProto$

        CASE mt_ConsDesAParam
          varcode->Header$ = varcode->Header$  +  VAR$ + PTH$  +  pszHead$
          varcode->Proto$  = varcode->Proto$   +  VAR$ + PTH$  + SPC$ + pszProto$

        CASE mt_OverLoad
          varcode->Functype$ = VAR$ + SPC$

        CASE mt_OverLoadAParam
          varcode->Header$ = varcode->Header$ + VAR$ + PTH$ + pszHead$

      END SELECT

      '************************************************************************
    CASE vt_UDT, vt_STRUCT, vt_UNION
      '************************************************************************

      SELECT CASE varcode->Methd%

        CASE mt_ProcessSetCommand
          IF vn = vt_UNION THEN
            varcode->StaticOut$ = "static union  " + pszHead$
          ELSE
            varcode->StaticOut$ = "static struct _" + pszHead$ + SPC$
          END IF

        CASE mt_FuncSubDecC_Dec
          varcode->Functype$ = varcode->AsToken$ + PTH$ + CB$

        CASE mt_FuncSubDecC_DecAParam
          varcode->Header$ = varcode->Header$  +  varcode->AsToken$ + PTH$ +  pszHead$
          varcode->Proto$  = varcode->Proto$   +  varcode->AsToken$ + RF$ + PT$

        CASE mt_Opts
          varcode->Functype$ = varcode->AsToken$ + PTH$

        CASE mt_OptsAParam
          varcode->Header$ = varcode->Header$ + Clean$(varcode->AsToken$) + PTH$ + SPC$ + pszHead$
          varcode->Proto$ = varcode->Proto$   + Clean$(varcode->AsToken$) + RF$ + PT$

        CASE mt_ConsDesAParam
          varcode->Header$ = varcode->Header$ + Clean$(varcode->AsToken$) + PTH$ + SPC$ + pszHead$
          varcode->Proto$ = varcode->Proto$   + Clean$(varcode->AsToken$) + PTH$ + SPC$ + pszHead$

        CASE mt_OverLoad
          varcode->Functype$ = VAR$ + SPC$

        CASE mt_OverLoadAParam
          varcode->Header$ = varcode->Header$ + varcode->AsToken$ + PTH$ + pszHead$

      END SELECT

    CASE vt_ConsDes
      SELECT CASE varcode->Methd%
        CASE mt_ConsDes
          varcode->Functype$ = VAR$ + PTH$ + CB$
      END SELECT

      '************************************************************************
    CASE ELSE
      '************************************************************************

      SELECT CASE varcode->Methd%

        CASE mt_FuncSubDecC_Dec
          varcode->Functype$ = varcode->AsToken$ + PTH$ + CB$

        CASE mt_FuncSubDecC_DecAParam
          varcode->Header$ = varcode->Header$  +  varcode->AsToken$ + PTH$ +  pszHead$
          varcode->Proto$ = varcode->Proto$    +  varcode->AsToken$ + RF$ + PT$

        CASE mt_Opts
          varcode->Functype$ = varcode->AsToken$ + PTH$

        CASE mt_OptsAParam
          varcode->Header$ = varcode->Header$ + Clean$(varcode->AsToken$) + PTH$ + SPC$ + pszHead$
          varcode->Proto$  = varcode->Proto$  + Clean$(varcode->AsToken$) + RF$ + PT$

        CASE mt_ConsDesAParam
          varcode->Header$ = varcode->Header$ + Clean$(varcode->AsToken$) + SPC$ + pszHead$
          varcode->Proto$  = varcode->Proto$  + Clean$(varcode->AsToken$) + SPC$ + pszHead$

      END SELECT

  END SELECT

END SUB ' GetVarCode



SUB AddMacros(FP_WRITE AS FILE)
  IF Use_SysMacros OR Use_Wingui THEN
    IF Use_Library THEN
      FPRINT FP_WRITE,"// BCXRTHEADER: STANDARD MACROS"
    ELSE
      FPRINT FP_WRITE,""
      FPRINT FP_WRITE,"// *************************************************"
      FPRINT FP_WRITE,"//               " + $BCX_STR_STD_MACROS
      FPRINT FP_WRITE,"// *************************************************"
      FPRINT FP_WRITE,""
    END IF
  END IF

  IF Use_Form OR Use_Button OR Use_BmpButton OR Use_Edit OR Use_BCX_Input OR Use_Label OR _
    Use_Group OR Use_Checkbox OR Use_Radio OR Use_Combobox OR Use_Listbox OR Use_Treeview OR _
    Use_Blackrect OR Use_Whiterect OR Use_Grayrect OR Use_Datepick OR Use_Listview OR Use_BCX_Control OR _
    Use_BCX_Slider OR Use_BCX_Tab OR Use_BCX_Toolbar OR Use_BCX_UpDown OR Use_BCX_FrameWnd OR _
    Use_BCX_Wnd THEN

    IF NOT Use_Project THEN
      FPRINT FP_WRITE,"#define DefaultFont ((BcxFont==0)?GetStockObject(DEFAULT_GUI_FONT):BcxFont)"
    ELSE
      FPRINT FP_WRITE,"#ifndef __BCXFONT_DEFINED__"
      FPRINT FP_WRITE,"#define __BCXFONT_DEFINED__"
      FPRINT FP_WRITE,"#define DefaultFont ((BcxFont==0)?GetStockObject(DEFAULT_GUI_FONT):BcxFont)"
      FPRINT FP_WRITE,"#endif"
    END IF
    FPRINT FP_WRITE,""
  END IF

  IF Use_SysMacros THEN

    IF Use_BCX_OlePicture THEN
      FPRINT FP_WRITE,"#define BCX_OLE_WIDTH(H)  LOWORD(PtrToUlong(GetWindowLongPtr(H,GWLP_USERDATA)))"
      FPRINT FP_WRITE,"#define BCX_OLE_HEIGHT(H) HIWORD(PtrToUlong(GetWindowLongPtr(H,GWLP_USERDATA)))"
    END IF

    IF Use_AndAlso THEN
      FPRINT FP_WRITE,"#define AndAlso &&"
    END IF

    IF Use_OrElse THEN
      FPRINT FP_WRITE,"#define OrElse ||"
    END IF

    IF Use_EqualTo THEN
      FPRINT FP_WRITE,"#define EqualTo =="
    END IF

    IF Use_NotEqualTo THEN
      FPRINT FP_WRITE,"#define NotEqualTo !="
    END IF

    IF Use_BcxSplitPath THEN
        FPRINT FP_WRITE,"#define FDRV   2"
        FPRINT FP_WRITE,"#define FPATH  4"
        FPRINT FP_WRITE,"#define FNAME  8"
        FPRINT FP_WRITE,"#define FEXT  16"
    END IF

    IF Use_BCX_Cursor THEN
      FPRINT FP_WRITE,"#define BCX_Cursor(x)SetCursor(LoadCursor(NULL,x))"
    END IF

    IF Use_Cbool THEN
      FPRINT FP_WRITE,"#define CBOOL(A)(A!=0)?1:0"
    END IF

    IF Use_Isptr THEN
      'FPRINT FP_WRITE,"#define IsPtr(a)((DWORD)a)"
      FPRINT FP_WRITE,"#define IsPtr(a)((LPSTR)a)"
    END IF

    IF Use_Band THEN
      FPRINT FP_WRITE,"#define BAND &"
    END IF

    IF Use_Bor THEN
      FPRINT FP_WRITE,"#define BOR |"
    END IF

    IF Use_Bnot THEN
      FPRINT FP_WRITE,"#define BNOT ~(int)"
    END IF

    IF Use_Inp THEN
      FPRINT FP_WRITE,"#define Inp(port)_inp(port)"
    END IF

    IF Use_Inpw THEN
      FPRINT FP_WRITE,"#define Inpw(port)_inpw(port)"
    END IF

    IF Use_Outp THEN
      FPRINT FP_WRITE,"#define Outp(port,value)_outp(port,value)"
    END IF

    IF Use_Outpw THEN
      FPRINT FP_WRITE,"#define Outpw(port,value)_outpw(port,value)"
    END IF

    IF Use_Ubound THEN
      FPRINT FP_WRITE,"#define ubound(T)(sizeof((T))/sizeof((T[0]))-1)"
    END IF

    IF Use_Clear THEN
      FPRINT FP_WRITE,"#define Clear(arg)memset(&arg,0,sizeof(arg))"
    END IF

    IF Use_Imod THEN
      FPRINT FP_WRITE,"#define imod(a,b)((a)%(b))"
    END IF

    IF Use_Refresh THEN
      FPRINT FP_WRITE,"#define Refresh(A) RedrawWindow(A,NULL,NULL,RDW_ERASE|RDW_INVALIDATE|RDW_ALLCHILDREN|RDW_UPDATENOW);"
    END IF

    IF Use_ShowModal THEN
      FPRINT FP_WRITE,"#define ShowModal(Window)EnableWindow(GetWindow(Window,GW_OWNER),FALSE);Show(Window);"
    END IF

    IF Use_EndModal THEN
      FPRINT FP_WRITE,"#define EndModal(Window)EnableWindow(GetWindow(Window,GW_OWNER),TRUE);DestroyWindow(Window);"
    END IF

    IF Use_Show THEN
      FPRINT FP_WRITE,"#define Show(Window)RedrawWindow(Window,0,0,0);ShowWindow(Window,SW_SHOW);"
    END IF

    IF Use_Hide THEN
      FPRINT FP_WRITE,"#define Hide(Window)ShowWindow(Window,SW_HIDE)"
    END IF

    IF Use_Get THEN
      FPRINT FP_WRITE,"#define GET(A,B,C)fread(B,1,C,A)"
    END IF

    IF Use_Put THEN
      FPRINT FP_WRITE,"#define PUT(A,B,C)fwrite(B,1,C,A)"
    END IF

    IF Use_Strptr THEN
      FPRINT FP_WRITE,"#define STRPTR(A)((char*)&(A))"
    END IF
'jcfuller added 09/22/2016
    IF Use_Val THEN
		If Use_TCLib Then
			FPRINT FP_WRITE,"#define VAL(a)(double)_atof(a)"
		Else
			FPRINT FP_WRITE,"#define VAL(a)(double)atof(a)"
		End If	
    END IF

    IF Use_Vall THEN
      FPRINT FP_WRITE,"#if defined( __LCC__ ) || defined( __POCC__ )"
      FPRINT FP_WRITE,"  #define VALL(a) (long double)strtold(a,(char**)NULL)"
      FPRINT FP_WRITE,"#elif defined( __BCPLUSPLUS__ )"
      FPRINT FP_WRITE,"  #define VALL(a) (long double)_strtold(a,(char**)NULL)"
      FPRINT FP_WRITE,"#else"
      FPRINT FP_WRITE,"  #define VALL(a) (long double)strtod(a,(char**)NULL)"
      FPRINT FP_WRITE,"#endif"
    END IF

    IF Use_Getattr THEN
      FPRINT FP_WRITE,"#define GETATTR(a)(DWORD)GetFileAttributes(a)"
    END IF

    IF Use_Setattr THEN
      FPRINT FP_WRITE,"#define SETATTR(a,b)(DWORD)SetFileAttributes(a,b)"
    END IF

    IF Use_Fint THEN
      FPRINT FP_WRITE,"#define FINT(a)floor(a)"
    END IF

    IF Use_Frac THEN
      FPRINT FP_WRITE,"#define FRAC(a)(double)(a-FIX(a))"
      Use_Fix = TRUE
    END IF

    IF Use_Fracl THEN
      FPRINT FP_WRITE,"#define FRACL(a)(long double)(a-FIX(a))"
      Use_Fix = TRUE
    END IF

    IF Use_Fix THEN
      FPRINT FP_WRITE,"#define FIX(a)(int)((a))"
    END IF

    IF Use_Csng THEN
      FPRINT FP_WRITE,"#define CSNG(a)((float)(a))"
    END IF

    IF Use_Cdbl THEN
      FPRINT FP_WRITE,"#define CDBL(a)((double)(a))"
    END IF

    IF Use_Cldbl THEN
      FPRINT FP_WRITE,"#define CLDBL(a)((long double)(a))"
    END IF

    IF Use_Threads THEN
      FPRINT FP_WRITE,""
      'FPRINT FP_WRITE,"#define BCX_THREAD(a)        (HANDLE)BCX_DynaCallB";
      'FPRINT FP_WRITE,"(", ENC$("_beginthreadex"), ",", ENC$("msvcrt"), ",6,0,0,a,0,0,&BCX_Thread_ID)"
      'FPRINT FP_WRITE,"#define BCX_THREADWAIT(a)    while(WaitForSingleObject((a),0)==WAIT_TIMEOUT){}CloseHandle((a))"
      'FPRINT FP_WRITE,"#define BCX_THREADSUSPEND(a) SuspendThread(a)"
      'FPRINT FP_WRITE,"#define BCX_THREADRESUME(a)  ResumeThread(a)"
      'FPRINT FP_WRITE,"#define BCX_THREADKILL(a)    TerminateThread(a,0); CloseHandle((a))"
      'FPRINT FP_WRITE,"#define BCX_THREADEND        BCX_DynaCallB(", ENC$("_endthreadex"), ",", ENC$("msvcrt"), ",2,0,0)"
      'FPRINT FP_WRITE,"DWORD   BCX_Thread_ID = 0;"
      FPRINT FP_WRITE, "#define BCX_THREAD(a)        (HANDLE)_beginthreadex(0,0,(unsigned int (__stdcall *)(void *))a,0,0,(unsigned int *)&BCX_Thread_ID)"
      FPRINT FP_WRITE, "#define BCX_THREADWAIT(a)    while(WaitForSingleObject(((void *)a),0)==WAIT_TIMEOUT){}CloseHandle(((void *)a))"
      FPRINT FP_WRITE, "#define BCX_THREADSUSPEND(a) SuspendThread((void *)a)"
      FPRINT FP_WRITE, "#define BCX_THREADRESUME(a)  ResumeThread((void *)a)"
      FPRINT FP_WRITE, "#define BCX_THREADKILL(a)    TerminateThread((void *)a,0); CloseHandle((void *)a)"
      FPRINT FP_WRITE, "#define BCX_THREADEND        _endthreadex(0)"
      FPRINT FP_WRITE, "DWORD   BCX_Thread_ID = 0;"

      FPRINT FP_WRITE,""
    END IF

    FPRINT FP_WRITE,""
    IF Use_Library THEN FPRINT FP_WRITE,"// END BCXRTHEADER\n\n"
  END IF
END SUB ' AddMacros



SUB StdProtos(FP_WRITE AS FILE)
  'Dim TempStr$
  IF Use_Project = FALSE THEN

    IF UseFlag OR Use_Console OR Use_Proto THEN
      IF Use_Library THEN
        FPRINT FP_WRITE,"// BCXRTHEADER: STANDARD PROTOTYPES"
      ELSE
        FPRINT FP_WRITE,""
        FPRINT FP_WRITE,"// *************************************************"
        FPRINT FP_WRITE,"//               " + $BCX_STR_STD_PROTOS
        FPRINT FP_WRITE,"// *************************************************"
        FPRINT FP_WRITE,""
      END IF
    END IF

'jcfuller added 01/27/2015     moved 02/02/2015
      IF Use_BC9_MsgPump Then
	     FPRINT FP_WRITE,"int     BC9_MsgPump (HACCEL=0);"
      End If
	If Use_BC9_ResDlg Then
		FPRINT FP_WRITE,"HWND    BC9_ResDlg (int, DLGPROC, HWND=0, LPARAM=0);"
	End If

	If Use_BC9_ResMDlg Then
		FPRINT FP_WRITE,"INT_PTR BC9_ResMDlg (int, DLGPROC, HWND=0, LPARAM=0);"
	End If

	If Use_BC9Dialog Then
	    FPRINT FP_WRITE,"PDLGTEMPLATEEX BC9_Dialog (const char* , int = 0, int = 0, int = 250, int = 150, DWORD = 0, DWORD = 0, const char* = "+DDQ$+", int = 0, int = 400, const char* = "+DDQ$+", const char* = "+DDQ$+");"
	End If

	If Use_BC9DlgShow Then
	    FPRINT FP_WRITE,"HWND    BC9_DlgShow (PDLGTEMPLATEEX, DLGPROC, HWND = 0, LPARAM = 0);"
	End If

	If Use_BC9DlgShowModal Then
	    FPRINT FP_WRITE,"INT_PTR    BC9_DlgShowModal (PDLGTEMPLATEEX, DLGPROC, HWND = 0, LPARAM = 0);"
	End If

	If Use_BC9Control Then
	'added the generic BC9_CONTROL 05/01/2015
	    FPRINT FP_WRITE,"void    BC9_Control (const char* , PDLGTEMPLATEEX* , const char* , int, int, int, int, int, int, int);"
	End If

	If Use_BC9Button Then
	    FPRINT FP_WRITE,"void    BC9_Button (const char* , PDLGTEMPLATEEX* , int, int, int, int, int, int = 0, int = 0);"
	End If

	If Use_BC9Checkbox Then
	    FPRINT FP_WRITE,"void    BC9_Checkbox (const char* , PDLGTEMPLATEEX* , int, int, int, int, int, int = 0, int = 0);"
	End If

	If Use_BC9Group Then
	    FPRINT FP_WRITE,"void    BC9_Group (const char* , PDLGTEMPLATEEX* , int, int, int, int, int, int = 0, int = 0);"
	End If

	If Use_BC9Combo Then
	    FPRINT FP_WRITE,"void    BC9_Combobox (const char* , PDLGTEMPLATEEX* , int, int, int, int, int, int = 0, int = 0);"
	End If

	If Use_BC9BlackRect Then
	    FPRINT FP_WRITE,"void    BC9_BlackRect (const char* , PDLGTEMPLATEEX* , int, int, int, int, int, int = 0, int = 0);"
	End If
	If Use_BC9DatePick Then
	    FPRINT FP_WRITE,"void    BC9_DatePick (const char* , PDLGTEMPLATEEX* , int, int, int, int, int, int = 0, int = 0);"
	End If
	If Use_BC9GrayRect Then
	    FPRINT FP_WRITE,"void    BC9_GrayRect (const char* , PDLGTEMPLATEEX* , int, int, int, int, int, int = 0, int = 0);"
	End If
	If Use_BC9WhiteRect Then
	    FPRINT FP_WRITE,"void    BC9_WhiteRect (const char* , PDLGTEMPLATEEX* , int, int, int, int, int, int = 0, int = 0);"
	End If
	If Use_BC9Edit Then
	    FPRINT FP_WRITE,"void    BC9_Edit (const char* , PDLGTEMPLATEEX* , int, int, int, int, int, int = 0, int = -1);"
	End If

	If Use_BC9Input Then
	    FPRINT FP_WRITE,"void    BC9_Input (const char* , PDLGTEMPLATEEX* , int, int, int, int, int, int = 0, int = -1);"
	End If

	If Use_BC9Label Then
	    FPRINT FP_WRITE,"void    BC9_Label (const char* , PDLGTEMPLATEEX* , int, int, int, int, int, int = 0, int = 0);"
	End If
	If Use_BC9Listbox Then
	    FPRINT FP_WRITE,"void    BC9_Listbox (const char* , PDLGTEMPLATEEX* , int, int, int, int, int, int = 0, int = -1);"
	End If
	If Use_BC9Listview Then
	    FPRINT FP_WRITE,"void    BC9_Listview (const char* , PDLGTEMPLATEEX* , int, int, int, int, int, int = 0, int = 0);"
	End If
	If Use_BC9Bitmap Then
	    FPRINT FP_WRITE,"void    BC9_Bitmap (const char* , PDLGTEMPLATEEX* , int, int, int, int, int, int = 0, int = 0);"
	End If
	If Use_BC9Icon Then
	    FPRINT FP_WRITE,"void    BC9_Icon (const char* , PDLGTEMPLATEEX* , int, int, int, int, int, int = 0, int = 0);"
	End If
	If Use_BC9Radio Then
	    FPRINT FP_WRITE,"void    BC9_Radio (const char* , PDLGTEMPLATEEX* , int, int, int, int, int, int = 0, int = 0);"
	End If
	If Use_BC9RichEdit Then
	    FPRINT FP_WRITE,"void    BC9_RichEdit (const char* , PDLGTEMPLATEEX* , int, int, int, int, int, int = 0, int = 0);"
	End If
	If Use_BC9Status Then
	    FPRINT FP_WRITE,"void    BC9_Status (const char* , PDLGTEMPLATEEX* , int, int = 0x50000003);"
	    FPRINT FP_WRITE,"void    BC9_SetSbParts (HWND, double*);"
	End If
	If Use_BC9Tab Then
        FPRINT FP_WRITE,"void    CenterChildOnTab (HWND hWndChild, HWND hWndTab);"
        FPRINT FP_WRITE,"void    InitTab (HWND, HWND* , PDLGTEMPLATEEX*);"
        FPRINT FP_WRITE,"void    BC9_Tab (const char* , PDLGTEMPLATEEX* , int, int, int, int, int, int = 0, int = 0);"
        'FPRINT FP_WRITE,"PDLGTEMPLATEEX BC9_TabPage (int = 250, int = 150, const char* = "+DDQ$+", int = 0, int = 400, const char* = "+DDQ$+", const char* = "+DDQ$+");"
        FPRINT FP_WRITE,"PDLGTEMPLATEEX BC9_TabPage (int = 250, int = 150, const char* = "+DDQ$+", int = 0, int = 400);"
	End If
	If Use_BC9HCenterCtrlOnDialog Then
        FPRINT FP_WRITE,"void    BC9_HCenterCtrlOnDialog (HWND, HWND);"
	End If
	If Use_BC9VCenterCtrlOnDialog Then
        FPRINT FP_WRITE,"void    BC9_VCenterCtrlOnDialog (HWND, HWND);"
	End If

    IF Use_Library THEN
      FPRINT FP_WRITE,"char *Get_RTL_Version(void);"
    END IF

    IF Use_COM THEN
      CALL CommonCOMOutput(FP_WRITE)
    END IF

    IF Use_GUINoMain OR Use_MDIGUINoMain OR Use_Wingui THEN
      IF Use_BCX_FrameWnd THEN
        FPRINT FP_WRITE,"HWND    BCX_FrameWnd (const char* ,WNDPROC,char* ,HMENU=NULL,int=0,int=CW_USEDEFAULT,int=CW_USEDEFAULT,int=CW_USEDEFAULT,int=CW_USEDEFAULT,int=0,int=0);"
      END IF
      IF Use_BCX_Wnd THEN
        FPRINT FP_WRITE,"HWND    BCX_Wnd (const char*,WNDPROC,const char* ,HWND=0,int=CW_USEDEFAULT,int=CW_USEDEFAULT,int=CW_USEDEFAULT,int=CW_USEDEFAULT,int=0,int=0,int=0);"
      END IF
      IF Use_BCX_SetBkGrdBrush THEN
        FPRINT FP_WRITE,"void    BCX_SetBkGrdBrush (HWND, HBRUSH);"
      END IF
      IF Use_BCX_SetClassStyle THEN
        FPRINT FP_WRITE,"void    BCX_SetClassStyle (HWND, long);"
      END IF
      IF Use_BCX_SetIcon THEN
        FPRINT FP_WRITE,"void    BCX_SetIcon (HWND, int);"
      END IF
      IF Use_BCX_SetIconSm THEN
        FPRINT FP_WRITE,"void    BCX_SetIconSm (HWND, int);"
      END IF
      IF Use_BCX_SetCursor THEN
        FPRINT FP_WRITE,"void    BCX_SetCursor (HWND, const char *);"
      END IF
      IF Use_BCX_SetMetric THEN
        FPRINT FP_WRITE,"void    BCX_SetMetric (const char *);"
      END IF
      IF Use_Library THEN
        FPRINT FP_WRITE,"int     BCX_MsgPump (HACCEL=0);"
        FPRINT FP_WRITE,"int     BCX_MDI_MsgPump (HACCEL=0);"
      ELSE
        IF Use_GUINoMain THEN
          IF Use_BCX_MsgPump THEN
            FPRINT FP_WRITE,"int     BCX_MsgPump (HACCEL=0);"
          END IF
        ELSEIF Use_MDIGUINoMain THEN
          IF Use_BCX_MDI_MsgPump THEN
            FPRINT FP_WRITE,"int     BCX_MDI_MsgPump (HACCEL=0);"
          END IF
        END IF
      END IF

      IF Use_BCX_RegWnd THEN
        FPRINT FP_WRITE,"void    BCX_RegWnd (const char *, WNDPROC);"
      END IF
      IF Use_BCX_InitGUI THEN
        FPRINT FP_WRITE,"void    BCX_InitGUI (void);"
      END IF
    END IF

   If Use_Tcl_LineInput Then
       FPRINT FP_WRITE,"int LineInput(HANDLE, fstring*,int = 2048);"
       'FPRINT FP_WRITE,"int LineInput(HANDLE, fstring&);"
   End If
   If Use_LineInput Then
		FPRINT FP_WRITE,"int LineInput(HANDLE, char*,int = 2048);"
   End If
   If Use_fprintS Then
		If Use_TCLib AND Use_fstring Then
			FPRINT FP_WRITE,"int fPrintS (HANDLE, fstring*);"
			FPRINT FP_WRITE,"int fPrintS (HANDLE, char*);"
			FPRINT FP_WRITE,"int fPrintS (HANDLE, fstring);"
		Else
			FPRINT FP_WRITE,"int fPrintS (HANDLE, char*);"
		End If	
   End If
    IF Use_Acosh THEN
      FPRINT FP_WRITE,"#if !defined( __WATCOM_CPLUSPLUS__ )"
      FPRINT FP_WRITE,"double  acosh(double);"
      FPRINT FP_WRITE,"#endif"
    END IF

    IF Use_Asinh THEN
      FPRINT FP_WRITE,"#if !defined( __WATCOM_CPLUSPLUS__ )"
      FPRINT FP_WRITE,"double  asinh(double);"
      FPRINT FP_WRITE,"#endif"
    END IF

    IF Use_Atanh THEN
      FPRINT FP_WRITE,"#if !defined( __WATCOM_CPLUSPLUS__ )"
      FPRINT FP_WRITE,"double  atanh(double);"
      FPRINT FP_WRITE,"#endif"
    END IF

    IF Use_Clng THEN
      FPRINT FP_WRITE,"long    CLNG(double);"
    END IF

    IF Use_Cint THEN
      FPRINT FP_WRITE,"int     Cint(double);"
    END IF

    IF Use_StartupCode THEN
      FPRINT FP_WRITE,"int     BCX_StartupCode_(void);"
    END IF

    IF Use_ExitCode THEN
      FPRINT FP_WRITE,"int     BCX_ExitCode_(void);"
    END IF

    IF Use_Str_Cmp THEN
      'FPRINT FP_WRITE,"int     str_cmp(char*, char*);"
      FPRINT FP_WRITE,"int     str_cmp(const char*, const char*);"
    END IF

    IF Use_Eof THEN
      FPRINT FP_WRITE,"int     EoF (FILE*);"
    END IF

    IF Use_AppActivate THEN
      FPRINT FP_WRITE,"int     AppActivate (const char *);"
    END IF

    IF Use_BoxCommon THEN
      FPRINT FP_WRITE,"LPWORD  lpwAlign(LPWORD);"
    END IF

    IF Use_Inputbox THEN
      FPRINT FP_WRITE,"char*   InputBox(const char*,const char*,const char*,int=0);"
      FPRINT FP_WRITE,"LRESULT CreatePrompter(char*,char*,char*,int=0);"
      FPRINT FP_WRITE,"LRESULT CALLBACK Prompter(HWND,UINT,WPARAM,LPARAM);"
    END IF

    IF Use_VBS THEN
      FPRINT FP_WRITE,"HRESULT VBS_RUN_SCRIPT (char*);"
      FPRINT FP_WRITE,"HRESULT VBS_ADDCODE    (char*);"
      FPRINT FP_WRITE,"double  VBS_EVAL_NUM   (char*);"
      FPRINT FP_WRITE,"char*   VBS_EVAL_STR   (char*);"
      FPRINT FP_WRITE,"BOOL    VBS_START      (void);"
      FPRINT FP_WRITE,"void    VBS_STOP       (void);"
      FPRINT FP_WRITE,"void    VBS_RESET      (void);"
      FPRINT FP_WRITE,"char*   VBS_ERROR      (void);"
    END IF

    IF Use_Infobox THEN
      FPRINT FP_WRITE,"void    InfoBox(const char*,const char*,int=160,int=155);"
      FPRINT FP_WRITE,"LRESULT CALLBACK CB_InfoBox(HWND,UINT,WPARAM,LPARAM);"
    END IF

    IF Use_Mdigui THEN
      FPRINT FP_WRITE,"HWND    BCX_MDICHILD (const char *, const char *,int=CW_USEDEFAULT,int=CW_USEDEFAULT,int=CW_USEDEFAULT,int=CW_USEDEFAULT,DWORD=0,LPARAM=0);"
      'FPRINT FP_WRITE,"void    BCX_MDICLASS (WNDPROC,const PCHAR);"
      FPRINT FP_WRITE,"void    BCX_MDICLASS (WNDPROC, const char*);"
      FPRINT FP_WRITE,"HWND    BCX_MDICLIENT (HWND,int);"
    END IF

    IF Use_BCX_Colordlg THEN
      FPRINT FP_WRITE,"int     BCX_ColorDlg (COLORREF=RGB(128,128,128),HWND=0);"
    END IF

    IF Use_BCXMDialog THEN
      FPRINT FP_WRITE,"INT_PTR BCX_MDialog(DLGPROC,const char*,HWND,int=0,int=0,int=250,int=150,int=0,int=0,char* =0,int=0);"
    END IF

    IF Use_BCXDialog THEN
      FPRINT FP_WRITE,"HWND    BCX_Dialog(DLGPROC,const char*,HWND,int=0,int=0,int=250,int=150,int=0,int=0,char* =0,int=0);"
    END IF

    IF Use_BCXDialogCommon THEN
      FPRINT FP_WRITE,"void    SetDialogScale (HWND, BOOL);"
    END IF


    IF Use_Form THEN
      FPRINT FP_WRITE,"HWND    BCX_Form(const char*,int=0,int=0,int=250,int=150,int=-1,int=0);"
    END IF
'------------------------------------------------------------------------------
'jcfuller added 01/19/2015
	If Use_DlgWin Then
	  FPRINT FP_WRITE,"HWND    BC9_DlgWin(int);"
	End If
    IF Use_SetDimension THEN
      FPRINT FP_WRITE,"void   SetDimension (const char* , int, HWND, BOOL=FALSE);"
    END IF

    IF Use_GetDimension THEN
      FPRINT FP_WRITE,"int    GetDimension(const char* ,HWND, BOOL=FALSE);"
    END IF
'New fget,fput,fgetc,fseek
	If Use_FGet Then
		FPRINT FP_WRITE,"DWORD   FGet(HANDLE, LPVOID, int);"
	End If
	
	If Use_FGetC Then
		FPRINT FP_WRITE,"//<---UNICODE AWARE"
		FPRINT FP_WRITE,"char   FGetC (HANDLE);"	
		FPRINT FP_WRITE,"//>---UNICODE AWARE"
	End If
	
	If Use_FPut Then
		FPRINT FP_WRITE,"BOOL    FPut(HANDLE, LPVOID, int);"
	End If
	
	If Use_FSeek Then
		FPRINT FP_WRITE,"void    FSeek(HANDLE, int);"
	End If
	
    IF Use_Edit THEN
      FPRINT FP_WRITE,"HWND    BCX_Edit(const char*,HWND,int,int,int,int,int,int=0,int=-1);"
    END IF

    IF Use_BCX_Input THEN
      FPRINT FP_WRITE,"HWND    BCX_Input(const char*,HWND,int,int,int,int,int,int=0,int=-1);"
    END IF

    IF Use_Button THEN
      FPRINT FP_WRITE,"HWND    BCX_Button(const char*,HWND,int=0,int=0,int=0,int=0,int=0,int=0,int=-1);"
    END IF

    IF Use_BmpButton THEN
      FPRINT FP_WRITE,"HWND    BCX_BmpButton(const char*,HWND,int=0,int=0,int=0,int=0,int=0,int=0,int=0,int=-1);"
    END IF

    IF Use_Label THEN
      FPRINT FP_WRITE,"HWND    BCX_Label(const char*,HWND,int=0,int=0,int=0,int=0,int=0,int=0,int=0);"
    END IF

    IF Use_Group THEN
      FPRINT FP_WRITE,"HWND    BCX_Group(const char*,HWND,int,int,int,int,int,int=0,int=0);"
    END IF

    IF Use_Checkbox THEN
      FPRINT FP_WRITE,"HWND    BCX_Checkbox(const char*,HWND,int=0,int=0,int=0,int=0,int=0,int=0,int=0);"
    END IF

    IF Use_Radio THEN
      FPRINT FP_WRITE,"HWND    BCX_Radio(const char*,HWND,int=0,int=0,int=0,int=0,int=0,int=0,int=0);"
    END IF

    IF Use_Combobox THEN
      FPRINT FP_WRITE,"HWND    BCX_Combobox(const char*,HWND,int,int,int,int,int,int=0,int=-1);"
    END IF

    IF Use_Listbox THEN
      FPRINT FP_WRITE,"HWND    BCX_Listbox(const char*,HWND,int,int,int,int,int,int=0,int=-1);"
    END IF

    IF Use_Blackrect THEN
      FPRINT FP_WRITE,"HWND    BCX_BlackRect(const char*,HWND,int,int,int,int,int,int=0,int=0);"
    END IF

    IF Use_Whiterect THEN
      FPRINT FP_WRITE,"HWND    BCX_WhiteRect(const char*,HWND,int,int,int,int,int,int=0,int=0);"
    END IF

    IF Use_Grayrect THEN
      FPRINT FP_WRITE,"HWND    BCX_GrayRect(const char*,HWND,int,int,int,int,int,int=0,int=0);"
    END IF

    IF Use_Datepick THEN
      FPRINT FP_WRITE,"HWND    BCX_DatePick(const char*,HWND,int,int,int,int,int,int=0,int=-1);"
    END IF

    IF Use_Richedit THEN
      FPRINT FP_WRITE,"HWND    BCX_RichEdit (const char*,HWND,int,int,int,int,int,int=0,int=-1);"
      FPRINT FP_WRITE,"void    SetWindowRTFText (HWND, const char *);"
    END IF

    IF Use_Status THEN
      FPRINT FP_WRITE,"HWND    BCX_Status (const char*,HWND,int=200,int=1,int* =0);"
    END IF

    IF Use_BCX_OlePicture THEN
      FPRINT FP_WRITE,"HWND    BCX_OlePicture(const char*,HWND=0,int=0,int=0,int=0,int=0,int=0,int=0,int=0,int=0);"
    END IF

    IF Use_Bitmap THEN
      FPRINT FP_WRITE,"HWND    BCX_Bitmap(const char*,HWND=0,int=0,int=0,int=0,int=0,int=0,int=0,int=0,int=0);"
    END IF

    IF Use_Icon THEN
      FPRINT FP_WRITE,"HWND    BCX_Icon(const char*,HWND=0,int=0,int=0,int=0,int=0,int=0,int=0,int=0,int=0);"
    END IF

    IF Use_Listview THEN
      FPRINT FP_WRITE,"HWND    BCX_ListView(const char*,HWND,int,int,int,int,int,int=0,int=-1,int=15);"
    END IF

    IF Use_Treeview THEN
      FPRINT FP_WRITE,"HWND    BCX_Treeview(const char*,HWND,int,int,int,int,int,int=0,int=-1);"
    END IF

    IF Use_BCX_Control THEN
      FPRINT FP_WRITE,"HWND    BCX_Control (const char*,HWND,const char*,int,int,int,int,int,int=0,int=0);"
    END IF

    IF Use_ProgressBar THEN
      FPRINT FP_WRITE,"HWND    BCX_ProgressBar (const char*,HWND,int=0,int=0,int=0,int=0,int=0,int=0,int=-1);"
    END IF

    IF Use_BCX_Slider THEN
      FPRINT FP_WRITE,"HWND    BCX_Slider(const char*,HWND,int,int,int,int,int,int=0,int=0,int=0);"
    END IF

    IF Use_BCX_Splitter THEN
      FPRINT FP_WRITE,"HWND    BCX_Splitter (HWND,int,int=0,int=0,int=0,int=0,int=0,int=0);"
      FPRINT FP_WRITE,"void    DrawXorBar (HWND, RECT *);"
      FPRINT FP_WRITE,"int     BCX_SetSplitPos (HWND,int=50,int=0);"
      FPRINT FP_WRITE,"LRESULT CALLBACK SplitterWndProc (HWND, UINT, WPARAM, LPARAM);"
    END IF

    IF Use_BCX_Toolbar THEN
      FPRINT FP_WRITE,"HWND    BCX_Toolbar (HWND,int,int,char* =0,int* =0,void* =0,int* =0,int=0,int=0,int=0,int=0);"
    END IF

    IF Use_BCX_Tab THEN
      FPRINT FP_WRITE,"HWND    BCX_Tab (HWND, int, int, HWND *, char []";cSizeOfADefaultString$;",int,int,int,int,HIMAGELIST=NULL,int=0,int=0);"
      FPRINT FP_WRITE,"HWND    BCX_AddTab (HWND, int, char*, int=-1, int=0);"
      FPRINT FP_WRITE,"void    BCX_RemTab (HWND, int);"
      FPRINT FP_WRITE,"int     BCX_TabSelect (HWND, LPARAM);"
      FPRINT FP_WRITE,"LRESULT CALLBACK TabPageWndProc (HWND, UINT, WPARAM, LPARAM);"
      FPRINT FP_WRITE,"LRESULT CALLBACK TabCallback (HWND, UINT, WPARAM, LPARAM);"
      FPRINT FP_WRITE,"LRESULT CALLBACK TabSizeCallback(HWND, UINT, WPARAM, LPARAM);"
    END IF

    IF Use_Draw THEN
      FPRINT FP_WRITE,"HDC     StartDraw (HWND);"
      FPRINT FP_WRITE,"HBITMAP EndDraw (HWND, HDC);"
    END IF

    IF Use_BCX_UpDown THEN
      FPRINT FP_WRITE,"HWND    BCX_UpDown (HWND,int,int,int,int,int,int,int=0);"
    END IF

    IF Use_BCX_Get_UpDown THEN
      FPRINT FP_WRITE,"int     BCX_Get_UpDown (HWND);"
    END IF

    IF Use_BCX_Print THEN
      FPRINT FP_WRITE,"int     BCX_Print (HWND, int , int , const char *, HDC=0);"
    END IF

    IF Use_SetFormColor THEN
      FPRINT FP_WRITE,"void    BCX_Set_Form_Color (HWND,COLORREF);"
    END IF

    IF Use_BCX_Tile THEN
      FPRINT FP_WRITE,"void    BCX_Tile (HWND,HBITMAP);"
    END IF

    IF Use_GetText THEN
      FPRINT FP_WRITE,"char*   BCX_Get_Text(HWND);"
    END IF

    IF Use_GetResource THEN
      FPRINT FP_WRITE,"LPVOID  GetResource(int, const char*, DWORD*);"
    END IF

    IF Use_SetText THEN
      FPRINT FP_WRITE,"int     BCX_Set_Text(HWND,const char*);"
    END IF

    IF Use_Elf THEN
      FPRINT FP_WRITE,"void    EditLoadFile (HWND, const char*);"
    END IF

    IF Use_ListBoxLoadFile THEN
      FPRINT FP_WRITE,"void    ListBoxLoadFile(HWND,const char*,int=0,int=0);"
    END IF

    IF Use_ComboBoxLoadFile THEN
      FPRINT FP_WRITE,"void    ComboBoxLoadFile(HWND,const char*);"
    END IF

    IF Use_SetFont THEN
      FPRINT FP_WRITE,"HFONT   BCX_Set_Font (const char *,float,int=0,int=0,int=0,int=0,int=0);"
    END IF

    IF Use_BCX_Preset THEN
      FPRINT FP_WRITE,"int     BCX_Preset (HWND,int,int,HDC=0);"
    END IF

    IF Use_BCX_Line THEN
      FPRINT FP_WRITE,"int     BCX_Line (HWND,int,int,int,int,int=0,HDC=0);"
    END IF

    IF Use_BCX_Lineto THEN
      FPRINT FP_WRITE,"int     BCX_Lineto (HWND,int,int,int=0,HDC=0);"
    END IF

    IF Use_BCX_Polygon THEN
      FPRINT FP_WRITE,"int     BCX_Polygon (HWND ,CONST POINT *,int,int=0,HDC=0);"
    END IF

    IF Use_BCX_PolyBezier THEN
      FPRINT FP_WRITE,"int     BCX_PolyBezier (HWND,CONST POINT *,int,int=0,HDC=0);"
    END IF

    IF Use_BCX_Polyline THEN
      FPRINT FP_WRITE,"int     BCX_Polyline (HWND ,CONST POINT *,int,int=0,HDC=0);"
    END IF

    IF Use_BCX_Circle THEN
      FPRINT FP_WRITE,"int     BCX_Circle (HWND,int,int,int,int=0,int=0,HDC=0);"
    END IF

    IF Use_BCX_Ellipse THEN
      FPRINT FP_WRITE,"int     BCX_Ellipse (HWND,int,int,int,int,int=0,int=0,HDC=0);"
    END IF

    IF Use_BCX_Rectangle THEN
      FPRINT FP_WRITE,"int     BCX_Rectangle (HWND,int,int,int,int,int=0,int=0,HDC=0);"
    END IF

    IF Use_BCX_Roundrect THEN
      FPRINT FP_WRITE,"int     BCX_Roundrect(HWND,int,int,int,int,int,int,int=0,int=0,HDC=0);"
    END IF

    IF Use_BCX_Arc THEN
      FPRINT FP_WRITE,"int     BCX_Arc (HWND,int,int,int,int,int,int,int,int,int=0,HDC=0);"
    END IF

    IF Use_Set_BCX_Bitmap THEN
      FPRINT FP_WRITE,"void    Set_BCX_Bitmap(HWND,const char*,int=0,int=0,int=0);"
    END IF

    IF Use_Set_BCX_Bitmap2 THEN
      FPRINT FP_WRITE,"HBITMAP Set_BCX_Bitmap2(HWND,HBITMAP,int=1);"
    END IF

    IF Use_Set_BCX_BmpButton THEN
      FPRINT FP_WRITE,"void    Set_BCX_BmpButton(HWND,const char*,int=0);"
    END IF

    IF Use_Set_BCX_Icon THEN
      FPRINT FP_WRITE,"void    Set_BCX_Icon(HWND,const char*,int=0,int=0,int=0);"
    END IF

    IF Use_BCX_Fontdlg THEN
      'IF UseCpp THEN
      '  FPRINT FP_WRITE,"int     BCX_FontDlg (bool=0,HWND=0);"
      'ELSE
        FPRINT FP_WRITE,"int     BCX_FontDlg (BOOL=0,HWND=0);"
      'END IF
    END IF

    IF Use_BCX_Pset THEN
      FPRINT FP_WRITE,"COLORREF BCX_Pset (HWND,int,int,int=0,HDC=0);"
    END IF

    IF Use_BCX_Floodfill THEN
      FPRINT FP_WRITE,"int BCX_FloodFill (HWND,int,int,int,int,HDC=0,int=0);"
    END IF

    IF Use_BCX_Getpixel THEN
      FPRINT FP_WRITE,"COLORREF BCX_Getpixel (HWND,int,int,HDC=0);"
    END IF

    IF Use_BCX_Get THEN
      FPRINT FP_WRITE,"HBITMAP BCX_Get (HWND,int,int,int,int,int=SRCCOPY,HDC=0);"
    END IF

    IF Use_BCX_Put THEN
      FPRINT FP_WRITE,"void    BCX_Put (HWND,HBITMAP,int,int,int,int,int=SRCCOPY,HDC=0);"
    END IF

    IF Use_BCX_LoadBMP THEN
      FPRINT FP_WRITE,"HBITMAP BCX_LoadBMP (const char *, int=0, int=0);"
    END IF

    IF Use_BCX_LoadImage THEN
      FPRINT FP_WRITE,"HBITMAP BCX_LoadImage (const char *, int=0);"
    END IF

    IF Use_DrawTransBMP THEN
      FPRINT FP_WRITE,"void    DrawTransBMP (HWND,HBITMAP,COLORREF,int,int,HDC=0);"
    END IF

    IF Use_BCX_BmpWidth THEN
      FPRINT FP_WRITE,"int     BCX_BmpWidth (HBITMAP);"
    END IF

    IF Use_BCX_BmpHeight THEN
      FPRINT FP_WRITE,"int     BCX_BmpHeight (HBITMAP);"
    END IF

    IF Use_QBColor THEN
      FPRINT FP_WRITE,"int     qbcolor (int);"
    END IF

    IF Use_SetColor THEN
      FPRINT FP_WRITE,"LRESULT Set_Color (int,int,HDC,HWND);"
    END IF

    IF Use_PlayWav THEN
      FPRINT FP_WRITE,"void    PlayWav (const char *,int=0, int=SND_SYNC);"
    END IF

    IF Use_SaveBmp THEN
      'FPRINT FP_WRITE,"void    SaveBmp(LPVOID, LPTSTR);"
      FPRINT FP_WRITE,"void    SaveBmp(LPVOID, const char*);"
    END IF

    IF Use_GetBmp THEN
      FPRINT FP_WRITE,"HDC     GetBmp (int, int, int, int, HWND);"
    END IF

    IF Use_Center THEN
      FPRINT FP_WRITE,"void    Center (HWND,HWND=0,HWND=0);"
    END IF

    IF Use_Cls THEN
      FPRINT FP_WRITE,"void    cls(void);"
    END IF

    IF Use_Color THEN
      FPRINT FP_WRITE,"void    color (int,int);"
    END IF

    IF Use_Panel THEN
      FPRINT FP_WRITE,"void    panel (int,int,int,int,int,int,int,int);"
    END IF

    'IF Use_Locate AND UseWinApi THEN
    IF Use_Locate THEN
      FPRINT FP_WRITE,"void    locate (int,int,int=1,int=12);"
    END IF

    'IF Use_Pos AND UseWinApi THEN
    IF Use_Pos THEN
      FPRINT FP_WRITE,"int     Pos (void);"
    END IF

    IF Use_Csrlin THEN
      FPRINT FP_WRITE,"int     Csrlin (void);"
    END IF

    IF Use_Run THEN
      FPRINT FP_WRITE,"int     Run (const char*, int =1, int =0);"
    END IF

    IF Use_Doevents THEN
      FPRINT FP_WRITE,"void    DoEvents(void);"
    END IF

    IF Use_Randomize THEN
      FPRINT FP_WRITE,"void    randomize (unsigned int);"
    END IF

    IF Use_Midstr THEN

      FPRINT FP_WRITE,"void    midstr (char*, int, int, const char *);"
    END IF

    IF Use_Swap THEN
      FPRINT FP_WRITE,"void    swap (byte*,byte*,int);"
    END IF

    IF UseFlag THEN
      FPRINT FP_WRITE,"char*   BCX_TmpStr(size_t,size_t= 0,int= 1);"
    END IF

    IF Use_EmptyTmpStr THEN
      FPRINT FP_WRITE,"void    EmptyTmpStr (void);"
    END IF

    IF Use_sziif THEN
      'IF UseCpp THEN
      '  FPRINT FP_WRITE,"char*   sziif (bool,const char*,const char*);"
      'ELSE
        FPRINT FP_WRITE,"char*   sziif (BOOL,const char*,const char*);"
      'END IF
    END IF

    IF Use_Using THEN
      FPRINT FP_WRITE,"char*   Using (const char*,double);"
    END IF

    IF Use_TempFileName THEN
      FPRINT FP_WRITE,"char*   TempFileName (const char*,const char*);"
    END IF

    IF Use_AppExePath THEN
      FPRINT FP_WRITE,"char*   AppExePath (void);"
    END IF

    IF Use_AppExeName THEN
      FPRINT FP_WRITE,"char*   AppExeName (void);"
    END IF

    IF Use_Lcase THEN
      FPRINT FP_WRITE,"char*   lcase (const char*);"
      If UseCpphdr AND Use_SingleFile AND Not Use_TCLib Then
      	Prepend FPRINT FP_WRITE,
      	  "stdstr lcase(stdstr &,int=0);"
          "charT lower(charT arg)"
          "{"
          "  return std::use_facet<std::ctype<charT> >(std::locale()).tolower(arg);"
          "}"
        End Prepend

      End If

    END IF

    IF Use_Ucase  THEN
      FPRINT FP_WRITE,"char*   ucase (const char*);"
'jcfuller added 3/14/2013
      If UseCpphdr AND Use_SingleFile Then
        Prepend	FPRINT FP_WRITE,
          "stdstr ucase(stdstr &,int=0);"
          "charT upper(charT arg)"
          "{"
             "return std::use_facet<std::ctype<charT> >(std::locale()).toupper(arg);"
          "}"
        End Prepend
      End If
    END IF

    IF Use_Mid THEN
'jcfuller added 3/13/2013
    '  IF UseCpp THEN
		If UseCpphdr AND Not Use_TCLib Then
			FPRINT FP_WRITE,"std::string   mid (std::string, size_t, int=-1);"
        End If

      FPRINT FP_WRITE,"char*   mid (const char*, int, int=-1);"
    END IF

    IF Use_StrUpLow THEN
      FPRINT FP_WRITE,"char*   _strupr_(char *);"
      FPRINT FP_WRITE,"char*   _strlwr_(char *);"
    END IF

	IF Use_Instat THEN
		'IF TargetOS = TNIX Then
			FPRINT FP_WRITE,"int instat(void);"
		'Else
		'	FPRINT FP_WRITE,"void instat(void);"
		'End If
	End If
    IF Use_Ltrim THEN
'jcfuller added for std::string 3/13/2013
      If UseCpphdr And Not Use_TCLib Then
      	'FPRINT FP_WRITE,"std::string   ltrim (std::string,std::string=",ENC$(" "),");"
      	FPRINT FP_WRITE,"//$EMIT_ANSI"
      	FPRINT FP_WRITE,"std::string   ltrim (std::string,std::string=",ENC$("\\t\\r\\n\\v\\f "),");"
      	FPRINT FP_WRITE,"//$EMIT_ANSI"
      	'FPRINT FP_WRITE,"std::string   ltrim (std::string,std::string=";DQ$;"\\t\\r\\n\\v\\f ";DQ$;");"
      End If

      FPRINT FP_WRITE,"char*   ltrim (const char*,char=32);"
    END IF

    IF Use_Rtrim THEN
      IF UseCpphdr And Not Use_TCLib Then
        If Use_UNICODE_Switch Then
			FPRINT FP_WRITE,"std::wstring   rtrim (std::wstring,std::wstring=",ENC$("\\t\\r\\n\\v\\f "),");"
		Else
			FPRINT FP_WRITE,"std::string   rtrim (std::string,std::string=",ENC$("\\t\\r\\n\\v\\f "),");"
        End If
      END IF

      FPRINT FP_WRITE,"char*   rtrim (const char*,char=32);"
    END IF

    IF Use_Trim THEN
'jcfuller added 3/13/2013
      If UseCpphdr And Not Use_TCLib Then
      	FPRINT FP_WRITE,"std::string   trim (std::string);"
      End If

      FPRINT FP_WRITE,"char*   trim (const char*);"
    END IF

    IF Use_Strim THEN
'jcfuller added 3/13/2013
      If UseCpphdr And Not Use_TCLib Then
      	FPRINT FP_WRITE,"std::string   strim   (std::string);"
      End If

      FPRINT FP_WRITE,"char*   strim   (const char*);"
    END IF

    IF Use_Left THEN
'jcfuller added for c++ std::string
      IF UseCpphdr And Not Use_TCLib THEN
      	FPRINT FP_WRITE,"std::string   left (std::string,int);"
      End If

      FPRINT FP_WRITE,"char*   left (const char*,int);"
    END IF

    IF Use_Right THEN
'jcfuller added for c++ std::string
      IF UseCpphdr And Not Use_TCLib THEN
      	FPRINT FP_WRITE,"std::string   right (std::string,int);"
      End If

      FPRINT FP_WRITE,"char*   right (const char*,int);"
    END IF

'jcfuller added 10/01/2015
'added UseCpphdr 09/15/2016
	If Use_Choose And UseCpphdr Then
		Prepend FPRINT FP_WRITE,
			"stdstr  choose (int, std::initializer_list <stdstr>, stdstr, int, stdstr);"
			"wstring choose (int, std::initializer_list <wstring>, wstring, int, wstring);"
		End Prepend
	End If

    IF Use_Rpad THEN
      FPRINT FP_WRITE,"char*   rpad (const char*,int,int=32);"
    END IF

    IF Use_Lpad THEN
      FPRINT FP_WRITE,"char*   lpad (const char*,int,int=32);"
    END IF

    IF Use_String THEN
      FPRINT FP_WRITE,"char*   stringx (int,int);"
    END IF

    IF Use_Repeat THEN
      FPRINT FP_WRITE,"char*   repeat (int,const char*);"
    END IF

    IF Use_Extract THEN
      FPRINT FP_WRITE,"char*   extract (const char*,const char*);"
'jcfuller added 3/13/2013
      If UseCpphdr And Not Use_TCLib Then
      	FPRINT FP_WRITE,"stdstr   extract (stdstr,stdstr);"
'jcfuller added 9/11/2015
      	'FPRINT FP_WRITE,"stdstr   extract (stdstr,const char*);"
      End if

    END IF

    IF Use_Remain THEN
      FPRINT FP_WRITE,"char*   remain (const char*,const char*);"
'jcfuller added 3/13/2013
      If UseCpphdr And Not Use_TCLib Then
      	FPRINT FP_WRITE,"stdstr   remain (stdstr,stdstr);"
      End If

    END IF

    IF Use_Reverse THEN
      FPRINT FP_WRITE,"char*   reverse (const char*);"
    END IF

    IF Use_Command THEN
      FPRINT FP_WRITE,"char*   command (int=-1);"
    END IF

    IF Use_Mcase THEN
      FPRINT FP_WRITE,"char*   mcase (const char*);"
    END IF

    IF Use_Replace THEN
'jcfuller added 3/13/2013
      If UseCpphdr And Not Use_TCLib Then
      	FPRINT FP_WRITE,"stdstr replace(stdstr&,stdstr,stdstr,int=0);"

      End If

      FPRINT FP_WRITE,"char*   replace (const char*,const char*,const char*);"
    END IF

    IF Use_iReplace THEN
'jcfuller added 3/13/2013
      If UseCpphdr And Not Use_TCLib Then
      	FPRINT FP_WRITE,"stdstr   iReplace (stdstr&,stdstr,stdstr,int=0);"
      End If

      FPRINT FP_WRITE,"char*   iReplace (const char*,const char*,const char*);"
    END IF

    IF Use_Space THEN
      FPRINT FP_WRITE,"char*   space (int a);"
    END IF

    IF Use_Str THEN
      FPRINT FP_WRITE,"char*   str (double);"
    END IF

    IF Use_Strl THEN
      FPRINT FP_WRITE,"char*   strl (long double);"
    END IF

    IF Use_Findfirst THEN
      FPRINT FP_WRITE,"char*   findfirst (const char*);"
    END IF

    IF Use_Findnext THEN
      FPRINT FP_WRITE,"char*   findnext (void);"
    END IF

    IF Use_Curdir THEN
      FPRINT FP_WRITE,"char*   curdir (void);"
    END IF

    IF Use_Windir THEN
      FPRINT FP_WRITE,"char*   windir (void);"
    END IF

    IF Use_GetSpecialFolder THEN
      FPRINT FP_WRITE,"char*   GetSpecialFolder (int,int=0,HWND=NULL);"
    END IF

    IF Use_Sysdir THEN
      FPRINT FP_WRITE,"char*   sysdir (void);"
    END IF

    IF Use_Tempdir THEN
      FPRINT FP_WRITE,"char*   tempdir (void);"
    END IF

    IF Use_Environ THEN
      FPRINT FP_WRITE,"char*   Environ (const char*);"
    END IF

    IF Use_Boolstr THEN
      FPRINT FP_WRITE,"char*   BoolStr (int);"
    END IF

    IF Use_Hex THEN
      FPRINT FP_WRITE,"char*   hex (int);"
    END IF

    IF Use_Bin THEN
      FPRINT FP_WRITE,"char*   Bin (int);"
    END IF

    IF Use_Oct THEN
      FPRINT FP_WRITE,"char*   oct (int);"
    END IF

    IF Use_Date THEN
      FPRINT FP_WRITE,"char*   date (int=0);"
    END IF

    IF Use_Now THEN
      FPRINT FP_WRITE,"char*   now (int=0);"
    END IF

    IF Use_SearchPath THEN
      FPRINT FP_WRITE,"char*   SEARCHPATH (const char *);"
    END IF

    IF Use_BcxSplitPath THEN
      FPRINT FP_WRITE,"char*   BcxSplitPath (const char *, int);"
      If TargetOS = TNIX Then
      	FPRINT FP_WRITE,"void    _splitpath(const char* path, char* drv, char* dir, char* name, char* ext);"
      End If
    END IF

    IF Use_BCX_Path THEN
      FPRINT FP_WRITE,"char*   BcxPath (void);"
    END IF

    IF Use_LccPath THEN
      FPRINT FP_WRITE,"char*   LccPath (void);"
    END IF

    IF Use_PellesPath THEN
      FPRINT FP_WRITE,"char*   PellesPath (void);"
    END IF

    IF Use_Strtoken THEN
      FPRINT FP_WRITE,"char*   StrToken (const char*,const char*,int);"
    END IF

    IF Use_RegExist THEN
      'FPRINT FP_WRITE,"long    RegExist (HKEY,PCHAR,PCHAR);"
      FPRINT FP_WRITE,"long    RegExist (HKEY,CCPTR,CCPTR);" ' const char*
    END IF

    IF Use_RegString THEN
      FPRINT FP_WRITE,"char*   RegString (HKEY,CCPTR,CCPTR);" 'CCPTR -> cpnst char*
    END IF

    IF Use_CreateRegString THEN
      FPRINT FP_WRITE,"void    CreateRegString (HKEY,const char*,const char*,const char*);"
    END IF

    IF Use_DeleteRegKey THEN
      FPRINT FP_WRITE,"void    DeleteRegKey (HKEY,CCPTR);"
    END IF

    IF Use_CreateRegInt THEN
      FPRINT FP_WRITE,"void   CreateRegInt (HKEY,CCPTR,CCPTR,int);"
    END IF

    IF Use_RegInt THEN
      FPRINT FP_WRITE,"int    RegInt (HKEY,CCPTR,CCPTR);"
    END IF

    IF Use_FileLocked THEN
      FPRINT FP_WRITE,"int    FileLocked (CCPTR);"
    END IF

    IF Use_Bff THEN
      FPRINT FP_WRITE,"char*   BFF (const char*,int=0,const char* =0);"
      FPRINT FP_WRITE,"int     CALLBACK BFFCallBack (HWND, UINT, LPARAM, LPARAM);"
    END IF

    IF Use_FillArray THEN
      FPRINT FP_WRITE,"int     fillarray (const char *, int, int, void *);"
    END IF

    IF Use_Remove THEN
'jcfuller added 3/13/2013
      If UseCpphdr And Not Use_TCLib Then
      	FPRINT FP_WRITE,"stdstr   RemoveStr (stdstr,stdstr);"
      End If

      FPRINT FP_WRITE,"char*   RemoveStr (const char*,const char*);"
    END IF

    IF Use_IRemove THEN
'jcfuller added 3/13/2013
      If UseCpphdr And Not Use_TCLib Then
      	FPRINT FP_WRITE,"stdstr   IRemoveStr (stdstr,stdstr);"
      End If

      FPRINT FP_WRITE,"char*   IRemoveStr (const char*,const char*);"
    END IF

    IF Use_Hook THEN
      FPRINT FP_WRITE,"LRESULT CALLBACK SBProc (int, WPARAM, LPARAM);"
    END IF

    IF Use_Getfilename THEN
      FPRINT FP_WRITE,"char*    GetFileName (const char*,const char*,int=0,HWND=0,DWORD=0,const char* =0,const char* =0,int* =0);"
    END IF

    IF Use_GetTextSize THEN
      FPRINT FP_WRITE,"SIZE*   GetTextSize (const char*, HWND=0, HFONT=0);"
    END IF


    IF Use_Time THEN
      FPRINT FP_WRITE,"char*   timef(int=0, int=0);"
    END IF

    IF Use_Join THEN
      FPRINT FP_WRITE,"char*   join (int, ... );"
    END IF

    IF Use_Enclose THEN
      FPRINT FP_WRITE,"char*   enc (const char*, int=0, int=0);"
    END IF

    IF Use_Chr THEN
      'FPRINT FP_WRITE,"char*   chr(int,int=0,int=0,int=0,int=0,int=0,int=0,int=0,int=0,int=0);"
      FPRINT FP_WRITE,"char*   chr(int);"
    END IF

    IF Use_VChr THEN
      FPRINT FP_WRITE,"char*   vchr (int,...);"
    END IF

    IF Use_Freefile THEN
      FPRINT FP_WRITE,"FILE*   FreeFile (void);"
    END IF

    IF Use_PeekStr THEN
      FPRINT FP_WRITE,"char*   peekstr (LPVOID,int);"
    END IF

    IF Use_Asc THEN
      IF NOT Use_Library THEN FPRINT FP_WRITE,"int     asc (char *,int=0);"
    END IF

    IF Use_Instrrev THEN
      FPRINT FP_WRITE,"int     InstrRev (const char*,const char*,int=0,int=0);"
    END IF

    IF Use_FirstInstance THEN
      FPRINT FP_WRITE,"BOOL    FindFirstInstance (const char*);"
    END IF

    IF Use_Instr THEN
      FPRINT FP_WRITE,"int     instr(const char*,const char*,int=0,int=0);"
'jcfuller added 3/13/2013
      If UseCpphdr And Not Use_TCLib Then
      	FPRINT FP_WRITE,"int     instr(std::string,std::string,int=0,int=0);"
      End If

    END IF

    IF UseLCaseTbl THEN
      FPRINT FP_WRITE,"char    *MakeLCaseTbl(void);"
    END IF

    IF Use_Stristr THEN
      FPRINT FP_WRITE,"char    *_stristr_(char*,char*);"
    END IF

    IF Use_StrStr THEN
      FPRINT FP_WRITE,"char    *_strstr_(char*,char*);"
    END IF

    IF Use_Verify THEN
      FPRINT FP_WRITE,"int     Verify (CCPTR,CCPTR);"
      FPRINT FP_WRITE,"int     VerifyInstr(char*,char*,int=0);"
    END IF

    IF Use_Retain THEN
      FPRINT FP_WRITE,"char*   Retain (const char*,const char *);"
    END IF

    IF Use_LoadFile THEN
      FPRINT FP_WRITE,"char*   LoadFile (const char*);"
    END IF
'jcfuller added 09/03/2015
	If Use_FileScan Then
	    FPRINT FP_WRITE,"int     FileScan (const char*  , int* , int*);"
	End If

    IF Use_Inchr THEN
      FPRINT FP_WRITE,"int     inchr (const char*,const char*);"
    END IF

    IF Use_Idxqsort THEN
      FPRINT FP_WRITE,"int     IdxCompare (const void *,const void *);"
    END IF

    IF Use_IdxqsortSt THEN
      FPRINT FP_WRITE,"int     IdxCompareSt (const void *,const void *);"
    END IF

    IF Use_PtrqsortSt THEN
      FPRINT FP_WRITE,"int     PtrCompareSt (const void *,const void *);"
    END IF

    IF Use_Strqsorta THEN
      FPRINT FP_WRITE,"int     StrCompareA (const void *,const void *);"
    END IF

    IF Use_Strqsortd THEN
      FPRINT FP_WRITE,"int     StrCompareD (const void *,const void *);"
    END IF

    IF Use_DynStrqsorta THEN
      FPRINT FP_WRITE,"int     DynStrCompareA (const void *,const void *);"
    END IF

    IF Use_DynStrqsortd THEN
      FPRINT FP_WRITE,"int     DynStrCompareD (const void *,const void *);"
    END IF

    IF Use_DynAlphaNumericA THEN
      FPRINT FP_WRITE,"int DynAlphaNumericA (const void *, const void *);"
    END IF

    IF Use_DynAlphaNumericD THEN
      FPRINT FP_WRITE,"int DynAlphaNumericD (const void *, const void *);"
    END IF

    IF Use_AlphaNumericA THEN
      FPRINT FP_WRITE,"int AlphaNumericA (const void *, const void *);"
    END IF

    IF Use_AlphaNumericD THEN
      FPRINT FP_WRITE,"int AlphaNumericD (const void *, const void *);"
    END IF

    IF Use_AlphaNumeric THEN
      FPRINT FP_WRITE,"int AlphaNumeric(const void *, const void *);"
    END IF

    IF Use_Numqsortaint THEN
      FPRINT FP_WRITE,"int     NumCompareAint (const void *,const void *);"
    END IF

    IF Use_Numqsortdint THEN
      FPRINT FP_WRITE,"int     NumCompareDint (const void *,const void *);"
    END IF

    IF Use_Numqsortafloat THEN
      FPRINT FP_WRITE,"int     NumCompareAfloat (const void *,const void *);"
    END IF

    IF Use_Numqsortdfloat THEN
      FPRINT FP_WRITE,"int     NumCompareDfloat (const void *,const void *);"
    END IF

    IF Use_Numqsortadouble THEN
      FPRINT FP_WRITE,"int     NumCompareAdouble (const void *,const void *);"
    END IF

    IF Use_Numqsortddouble THEN
      FPRINT FP_WRITE,"int     NumCompareDdouble (const void *,const void *);"
    END IF

    IF Use_Msgbox THEN
      FPRINT FP_WRITE,"int     MsgBox (const char*,const char*,int);"
    END IF

    IF Use_Like THEN
      FPRINT FP_WRITE,"int     like (CCPTR,CCPTR);"
    END IF

    IF Use_Textmode THEN
      FPRINT FP_WRITE,"int     TextMode (int);"
    END IF

    IF Use_Tally THEN
      FPRINT FP_WRITE,"int tally (const char*,const char*,int=0);"
    END IF

    IF Use_Inkey THEN
      FPRINT FP_WRITE,"char*   inkey (void);"
    END IF

    IF Use_InkeyD THEN
      FPRINT FP_WRITE,"int     inkeyd (void);"
    END IF

    IF Use_Bin2dec THEN
      FPRINT FP_WRITE,"int     Bin2Dec (const char*);"
    END IF

    IF Use_Hex2Dec THEN
      FPRINT FP_WRITE,"int     Hex2Dec (const char*);"
    END IF

    IF Use_Download THEN
      FPRINT FP_WRITE,"int     Download (char*,char*);"
    END IF

    IF Use_Exist THEN
    	IF UseWinApi OR Use_TCLib THEN
          FPRINT FP_WRITE,"BOOL    Exist   (const char*);"
          FPRINT FP_WRITE,"BOOL    Exist_A (char*);"
          FPRINT FP_WRITE,"BOOL    Exist_B (char*);"
        ELSE
          FPRINT FP_WRITE,"int    Exist(const char*);"
        END IF
    END IF
'jcfuller added 08/13/2013

	IF Use_Clipboard Then
		FPRINT FP_WRITE,"void ClipboardSetText( char *text_to_set );"
		FPRINT FP_WRITE,"char* ClipboardGetText ();"
		FPRINT FP_WRITE,"DWORD ClipboardGetTextSize ();"
	End If


    IF Use_Ins THEN
'jcfuller added 3/13/2013
      If UseCpphdr And Not Use_TCLib Then
      	FPRINT FP_WRITE,"stdstr ins(stdstr&,int,stdstr,int=0);"
      End If

      FPRINT FP_WRITE,"char*   ins (const char *S, int i, const char *a);"
    END IF

    IF Use_Del THEN
'jcfuller added 3/13/2013
      If UseCpphdr And Not Use_TCLib Then
      	FPRINT FP_WRITE,"stdstr   del (stdstr&,int,int,int=0);"
      End If

      FPRINT FP_WRITE,"char*   del (const char*,int,int);"
    END IF

    IF Use_Screen THEN
      FPRINT FP_WRITE,"int     Screen (int,int,int=0);"
    END IF

    IF Use_Pause THEN
      FPRINT FP_WRITE,"void    Pause (void);"
    END IF

    IF Use_Keypress THEN
      FPRINT FP_WRITE,"int     keypress (void);"
    END IF

	IF Use_Getch THEN
		IF TargetOS = TNIX THEN
			FPRINT FP_WRITE,"int    _getch(void);"
		End If
	End If
'jcfuller changed 09/03/2015
'don't know why this did not have const added sooner
' TDMGCC warned today
    IF Use_Lof THEN
      'FPRINT FP_WRITE,"DWORD   lof (char*);"
      FPRINT FP_WRITE,"DWORD   lof (const char*);"
    END IF

    IF Use_Sgn THEN
      FPRINT FP_WRITE,"double  sgn (double);"
    END IF

    IF Use_Round THEN
      FPRINT FP_WRITE,"double  Round (double,int);"
    END IF

    'IF Use_Abs THEN
    '  FPRINT FP_WRITE,"double  Abs (double);"
    'END IF

    IF Use_Rnd THEN
      FPRINT FP_WRITE,"float   rnd (void);"
    END IF

    IF Use_Exp THEN
      FPRINT FP_WRITE,"double  Exp (double);"
    END IF

    IF Use_Min THEN
      FPRINT FP_WRITE,"double  MIN (double,double);"
    END IF

    IF Use_Modstyle THEN
      FPRINT FP_WRITE,"BOOL    ModStyle (HWND, DWORD=0, DWORD=0, BOOL=0);"
    END IF

    IF Use_Max THEN
      FPRINT FP_WRITE,"double  MAX (double,double);"
    END IF

    IF Use_Timer THEN
      FPRINT FP_WRITE,"float   timer (void);"
    END IF

    IF Use_Iif THEN
'jcfuller change 07/03/2013
      'IF UseCpp THEN
      '  FPRINT FP_WRITE,"double  iif (bool,double,double);"
      'ELSE
      If (UseCpp = FALSE)  Then
		FPRINT FP_WRITE,"double  iif (BOOL,double,double);"
	  End If	
      'END IF
    END IF

    IF Use_Loc THEN
      FPRINT FP_WRITE,"int     loc (FILE *fp, int fplen);"
    END IF

    IF Use_Rec THEN
      FPRINT FP_WRITE,"int     rec (FILE *fp, int fplen);"
    END IF

    IF Use_RecCount THEN
      FPRINT FP_WRITE,"int     reccount (FILE *fp, int fplen);"
    END IF

    IF Use_Scan THEN
      FPRINT FP_WRITE,"int     scan (char *input, char *format, ... );"
    END IF

    IF Use_Split THEN
      FPRINT FP_WRITE,"int     Split (char []";cSizeOfADefaultString$;", const char*, const char*, int=0);"
    END IF

    IF Use_DSplit THEN
      FPRINT FP_WRITE,"int     DSplit (LPSTR *, const char*, const char*, int=0);"
    END IF

    IF Use_SysStr THEN
        If UseCpp AND Use_UNICODE_Switch Then
		    FPRINT FP_WRITE,"BSTR    SysStr (const _TCHAR * szIn, int=0);"
	    Else
            FPRINT FP_WRITE, "//<---UNICODE AWARE"
            FPRINT FP_WRITE,"BSTR    SysStr (const char * szIn, int=0, int=0);"
            FPRINT FP_WRITE, "//>---UNICODE AWARE"
	  	
        End If
    END IF

    IF Use_WideToAnsi THEN
      IF Use_UNICODE_Switch Then
        FPRINT FP_WRITE, "//<---UNICODE AWARE"
      End If
      FPRINT FP_WRITE,"char*   WideToAnsi (BSTR, UINT=CP_ACP, DWORD=0);"
      IF Use_UNICODE_Switch Then
        FPRINT FP_WRITE, "//>---UNICODE AWARE"
      END IF
    END IF

    IF Use_AnsiToWide THEN
      IF Use_UNICODE_Switch Then
        FPRINT FP_WRITE, "//<---UNICODE AWARE"
      END IF
      FPRINT FP_WRITE,"LPOLESTR AnsiToWide (const char*,UINT=CP_ACP,DWORD=MB_PRECOMPOSED);"
      'FPRINT FP_WRITE,"LPOLESTR AnsiToWide (char*,UINT=0,DWORD=1);"
      IF Use_UNICODE_Switch Then
        FPRINT FP_WRITE, "//>---UNICODE AWARE"
      END IF
    END IF

    IF Use_SafeArrays THEN
      FPRINT FP_WRITE,"HRESULT InitSafeArray (SAFEARRAY** ppsa, VARTYPE vtype, UINT ndim, ...);"
      FPRINT FP_WRITE,"HRESULT DestroySafeArray(SAFEARRAY* psA);"
    END IF

    IF Use_BCX_COM_UsesConversion THEN
      FPRINT FP_WRITE,"HRESULT  BCX_COM_AS2WS(LPCSTR ansi_string, UINT code_page = CP_ACP);"
      FPRINT FP_WRITE,"HRESULT  BCX_COM_WS2AS(LPCWSTR wide_string, UINT code_page = CP_ACP);"
    END IF

    IF Use_COM THEN
      FPRINT FP_WRITE,"//  COM functions used internally by BCX"
      FPRINT FP_WRITE,"void     bcx_ole_initialize(void);"
      FPRINT FP_WRITE,"void     bcx_ole_uninitialize(void);"
      FPRINT FP_WRITE,"void     bcx_catch_hr_error_desc(HRESULT hr, const TCHAR* extra_info);"
      FPRINT FP_WRITE,"DISPID   bcx_get_DISPID_of_dispatch(IDispatch* lpDispatch, LPOLESTR comsegment);"
      FPRINT FP_WRITE,"void     bcx_get_next_dispatch(OBJECT* object, LPOLESTR comsegment);"
      FPRINT FP_WRITE,"void     bcx_invoke_helper(OBJECT* object, const LPOLESTR comsegment,WORD wFlags, VARIANT *pvResult);"
      FPRINT FP_WRITE,"void     bcx_build_exception_info(HRESULT hr,  EXCEPINFO* pexcep = NULL, UINT uiArgErr= 0);"
      FPRINT FP_WRITE,"void     bcx_clean_parameter_list(void);"
      FPRINT FP_WRITE,"void     bcx_reset_dispatch_chain(OBJECT* object);"
      FPRINT FP_WRITE,"void     bcx_create_safe_array(void);"

      IF build_com_trace_code OR Use_Library  THEN ' used if com trace variable is set
        IF Use_Library THEN
          FPRINT FP_WRITE,"char bcx_com_trace_line";cSizeOfADefaultString$;";"
        ELSE
          FPRINT FP_WRITE,"static char bcx_com_trace_line";cSizeOfADefaultString$;";"
        END IF
        FPRINT FP_WRITE,"void bcx_com_trace_dump_DISPPARAMS(DISPPARAMS* dp);"
        FPRINT FP_WRITE,"void bcx_com_trace_add_line(char* dp);"
        FPRINT FP_WRITE,"void bcx_com_trace_dump_indicators(OBJECT* object);"
        FPRINT FP_WRITE,"void bcx_com_trace_dump_flags(WORD wFlags);"
      END IF

      FPRINT FP_WRITE,"// public COM support functions >>> "
      FPRINT FP_WRITE,"void     BCX_SetNothing(OBJECT* object);"
      FPRINT FP_WRITE,"HRESULT  BCX_GET_COM_ERROR_CODE(void);"
      FPRINT FP_WRITE,"char*    BCX_GET_COM_ERROR_DESC(void);"
      FPRINT FP_WRITE,"BOOL     BCX_GET_COM_SUCCESS(void);"
      FPRINT FP_WRITE,"BOOL     BCX_GET_COM_STATUS(OBJECT* object);"
      FPRINT FP_WRITE,"void     BCX_SHOW_COM_ERRORS(BOOL Show_err);"

      IF Use_BCX_COM_CreateObject THEN   FPRINT FP_WRITE,"void     BCX_CreateObject(TCHAR* objname, OBJECT* obj);"
      IF Use_BCX_COM_GetObject THEN
        FPRINT FP_WRITE,"void     BCX_GetObject(TCHAR* objname, OBJECT* obj);"
        FPRINT FP_WRITE,"void     BCX_GetObjectMon(LPCOLESTR objname, OBJECT* obj);"
      END IF

      IF Use_BCX_COM_DispatchObject THEN FPRINT FP_WRITE,"void     BCX_DispatchObject(IUnknown* iobj, OBJECT* obj, BOOL b_release = TRUE);"
      FPRINT FP_WRITE,"// <<< public COM support functions "

      FPRINT FP_WRITE,"void     BCX_COM_FREE_TEMP_ANSI_STRING(void);"
      FPRINT FP_WRITE,"void     BCX_COM_FREE_TEMP_WIDE_STRING(void);"
    END IF

    IF Use_Cvi THEN
      FPRINT FP_WRITE,"short   CVI (const char*);"
    END IF

    IF Use_Mki THEN
      FPRINT FP_WRITE,"char*   MKI (short);"
    END IF

    IF Use_Cvl THEN
      FPRINT FP_WRITE,"long    CVL (char*);"
    END IF

    IF Use_Mkl THEN
      FPRINT FP_WRITE,"char*   MKL (int);"
    END IF

    IF Use_Cvs THEN
      FPRINT FP_WRITE,"float   CVS (char*);"
    END IF

    IF Use_Mks THEN
      FPRINT FP_WRITE,"char*   MKS (float);"
    END IF

    IF Use_Cvd THEN
      FPRINT FP_WRITE,"double  CVD (char*);"
    END IF

    IF Use_Cvld THEN
      FPRINT FP_WRITE,"long double  CVLD (char*);"
    END IF

    IF Use_Mkd THEN
      FPRINT FP_WRITE,"char*   MKD (double);"
    END IF

    IF Use_Mkld THEN
      FPRINT FP_WRITE,"char*   MKLD (long double);"
    END IF

    IF Use_OSVersion THEN
      FPRINT FP_WRITE,"int     OSVersion (void);"
    END IF

    IF Use_Sound THEN
      FPRINT FP_WRITE,"int     Sound (float,int=0,int=127,int=0,float=1);"
      FPRINT FP_WRITE,"int     PlaySnd (void);"
    END IF

    IF Use_Hscroll OR Use_Vscroll THEN
      FPRINT FP_WRITE,"void    BCX_Scroll (HWND,int,int,int,int,int,int,int,int,int,int);"
    END IF

    IF Use_DynacallCommon THEN
      FPRINT FP_WRITE,"HINSTANCE BCX_LoadDll(const char *);"
      FPRINT FP_WRITE,"void    BCX_UnloadDll(void);"
      FPRINT FP_WRITE,"typedef int (CALLBACK *DYNACALL1)(void);"
      IF Use_Dynacall THEN
        FPRINT FP_WRITE,"int     BCX_DynaCallB(const char *, const char *, int, ...);"
      END IF
      IF Use_DynacallA THEN
        FPRINT FP_WRITE,"int     BCX_DynaCallA(const char *, const char *, int, int *);"
      END IF
    END IF

    IF Use_DynamicA THEN
'jcf changed 02/21/2016
		FPRINT FP_WRITE,"void*   CreateArr (void*, int, int, int, size_t *);"
      'FPRINT FP_WRITE,"void*   CreateArr (void*,int,int,int,...);"
      'FPRINT FP_WRITE,"void*   CreateArr_internal(void*, int, int, int, va_list);"
      FPRINT FP_WRITE,"void    DestroyArr (void**,int,int);"
    END IF

    IF Use_ContainedIn THEN
      FPRINT FP_WRITE,"int     containedin(const char * ,const char **,int=0);"
      'FPRINT FP_WRITE,"int     containedin( char * , char **,int=0);"
    END IF

    IF Use_FindInType THEN
      FPRINT FP_WRITE,"int     FindInType(const char *,const char *,int,int,int,int=0,int* =0);"
    END IF

    IF Use_Printer THEN
      FPRINT FP_WRITE,"int  PrinterOpen  (char * =" & ENC$("Courier New") & ",int=12,int=DEFAULT_CHARSET);"
      FPRINT FP_WRITE,"void PrinterWrite (char*, int=80, int= 60);"
      FPRINT FP_WRITE,"void EjectPage    (void);"
      FPRINT FP_WRITE,"void PrinterClose (void);"
    END IF

    IF Use_Library THEN FPRINT FP_WRITE,"// END BCXRTHEADER\n\n"

  END IF ' IF Use_Project = FALSE
END SUB ' StdProtos



SUB User_Global_Initialized_Arrays(FP_WRITE AS FILE)
  ' begin for initialized global arrays
  DIM RAW P$, i, A
  DIM RAW VarName$
  DIM RAW VarDim$
  DIM RAW Storage$
  DIM RAW VAR$

  IF Use_Library THEN
    FPRINT FP_WRITE,"// BCXRTHEADER: USER GLOBAL INITIALIZED ARRAYS"
  ELSE
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"// *************************************************"
    FPRINT FP_WRITE,"//            User Global Initialized Arrays"
    FPRINT FP_WRITE,"// *************************************************"
    FPRINT FP_WRITE,""
  END IF

  FOR i = 1 TO GlobalVarCnt
    IF GlobalVars[i].VarEmitFlag THEN ITERATE
    IF "" <> GlobalVars[i].VarDim$ AND GlobalVars[i].VarCondLevel = 0 THEN
      IF INSTR(GlobalVars[i].VarDim,"{") THEN
        P$ = ""
        IF GlobalVars[i].VarPntr THEN P$ = STRING$(GlobalVars[i].VarPntr,42)
        A = GlobalVars[i].VarType
        IF GlobalVars[i].VarSF THEN
          VarName$ = "(*" + GlobalVars[i].VarName$ + EXTRACT$(GlobalVars[i].VarDim,"(") + ")"
          VarDim$ = MID$(GlobalVars[i].VarDim, INSTR(GlobalVars[i].VarDim,"("))
        ELSE
          VarName$ = GlobalVars[i].VarName$
          VarDim$ = GlobalVars[i].VarDim
        END IF
        Storage$ = VarStorage$[GlobalVars[i].VarExtn] & VarConst$[GlobalVars[i].VarConstant]
        SELECT CASE A
          ' handle exceptions

          CASE vt_STRVAR
          FPRINT FP_WRITE,Storage$;"char    ";VarName$;VarDim$;";"

          CASE vt_FILEPTR
          REMOVE "@" FROM GlobalVars[i].VarName$
          FPRINT FP_WRITE,Storage$;"FILE   *";VarName$;VarDim$;";"

          CASE vt_LPSTR
          FPRINT FP_WRITE,Storage$;"LPSTR   ";P$;VarName$;VarDim$;";"

          CASE vt_UDT, vt_STRUCT, vt_UNION
          VAR$ = TypeDefs[GlobalVars[i].VarDef].VarName$
          VAR$ = RPAD$(VAR$, 7)
          FPRINT FP_WRITE,Storage$;VAR$;SPC$;P$;VarName$;VarDim$;";"

          ' handle normal

          CASE vt_VarMin TO vt_VarMax
          VAR$ = GetVarTypeName$(GlobalVars[i].VarType)
          VAR$ = RPAD$(VAR$, 7)
          FPRINT FP_WRITE,Storage$;VAR$;SPC$;P$;VarName$;VarDim$;";"
        END SELECT
      END IF
    END IF
  NEXT

  FPRINT FP_WRITE,""
  ' end of initialized global arrays
END SUB ' User_Global_Initialized_Arrays



SUB User_Overloaded_SubsFunctions(FP_WRITE AS FILE)
  IF Use_Overloaded THEN
    IF Use_Library THEN
      FPRINT FP_WRITE,"// BCXRTHEADER: USER OVERLOADED SUBS AND FUNCTIONS"
    ELSE
      FPRINT FP_WRITE,"// *************************************************"
      FPRINT FP_WRITE,"//        User's Overloaded Subs/Functions          "
      FPRINT FP_WRITE,"// *************************************************"
    END IF
    RAW ZZ$
    RAW FP_OVR_IN AS FILE
    OPEN ovrFile$ FOR INPUT AS FP_OVR_IN
    WHILE NOT EOF(FP_OVR_IN)
      LINE INPUT FP_OVR_IN,ZZ$
      IF INSTR(ZZ$,"overloaded") THEN
        FPRINT FP_WRITE,"\n"
      END IF
      FPRINT FP_WRITE,ZZ$
    WEND

    CLOSE FP_OVR_IN
    IF Use_Library THEN FPRINT FP_WRITE,"// END BCXRTHEADER"
    FPRINT FP_WRITE,"\n\n"
  END IF
END SUB ' User_Overloaded_SubsFunctions



SUB User_GLOBAL_SET_Statements(FP_WRITE AS FILE)
  IF LOF(setFile$) > 0 THEN
    RAW Z$
    RAW FP_DAT AS FILE
    OPEN setFile$ FOR INPUT AS FP_DAT
    IF Use_Library THEN
      FPRINT FP_WRITE,"// BCXRTHEADER: USER GLOBAL SET STATEMENTS"
    ELSE
      FPRINT FP_WRITE,"// *************************************************"
      FPRINT FP_WRITE,"//              User GLOBAL SET Statements"
      FPRINT FP_WRITE,"// *************************************************"
      FPRINT FP_WRITE,""
    END IF
    WHILE NOT EOF(FP_DAT)
      LINE INPUT FP_DAT,Z$
      FPRINT FP_WRITE,Z$
    WEND
    FPRINT FP_WRITE,""
    CLOSE FP_DAT
  END IF
END SUB ' User_GLOBAL_SET_Statements



SUB User_Prototypes(FP_WRITE AS FILE)
  IF ProtoCnt THEN

    IF Use_Library THEN
      FPRINT FP_WRITE,"// BCXRTHEADER: USER PROTOTYPES"
    ELSE
      FPRINT FP_WRITE,""
      FPRINT FP_WRITE,"// *************************************************"
      FPRINT FP_WRITE,"//               ";BCX_STR_USR_PROTOS$
      FPRINT FP_WRITE,"// *************************************************"
    END IF
    FPRINT FP_WRITE,""

    RAW LastDef$
    RAW LastLevel
    RAW A

    LastDef$ = ""
    LastLevel = 1

    FOR A = 1 TO ProtoCnt
      IF LastDef$ = "" THEN
        LastDef$ = ProtoType[A].Condition$
        LastLevel = ProtoType[A].CondLevel
        IF Use_SingleFile = FALSE THEN
          IF LastDef$ <> "" THEN
            FPRINT fpHFile, LastDef$
          END IF
        END IF
        IF LastDef$ <> "" THEN FPRINT FP_WRITE, LastDef$
      END IF

      IF LastDef$ <> ProtoType[A].Condition$ THEN
        IF ProtoType[A].Condition$ = "#else" THEN
          WHILE LastLevel > ProtoType[A].CondLevel
            IF Use_SingleFile = FALSE THEN
              FPRINT fpHFile, "#endif"
            END IF
            FPRINT FP_WRITE,"#endif"
            LastLevel--
          WEND
          IF Use_SingleFile = FALSE THEN
            FPRINT fpHFile, "#else"
          END IF
          FPRINT FP_WRITE,"#else"
          LastDef$ = ProtoType[A].Condition$
          LastLevel = ProtoType[A].CondLevel

        ELSE

          WHILE LastLevel > ProtoType[A].CondLevel
            IF Use_SingleFile = FALSE THEN
              FPRINT fpHFile, "#endif"
            END IF
            FPRINT FP_WRITE,"#endif"
            LastLevel--
          WEND
          LastDef$ = ProtoType[A].Condition$
          LastLevel = ProtoType[A].CondLevel
          IF Use_SingleFile = FALSE THEN
            IF LastDef$ <> "" THEN
              FPRINT fpHFile, LastDef$
            END IF
          END IF
          IF LastDef$ <> "" THEN
            FPRINT FP_WRITE, LastDef$
          END IF
        END IF
      END IF

      IF UseStdCall AND UseCpp THEN
        IF LEFT$(ProtoType[A].Prototype$, 9) = "C_EXPORT " THEN
          EmitExportDef(ProtoType[A].Prototype$)
        END IF
      END IF

      T$ = EXTRACT$(ProtoType[A].Prototype$, SPC$)
      T$ = RPAD$(T$, 7) + SPC$
      ProtoType[A].Prototype$ = T$ + REMAIN$(ProtoType[A].Prototype$, SPC$)

      IF Use_SingleFile = FALSE THEN
'IF _ZTRACE_ THEN
'  zTrace(ANSITOWIDE((char*)ProtoType[A].Prototype$))
'END IF

        FPRINT fpHFile, ProtoType[A].Prototype$
      END IF

      FPRINT FP_WRITE,ProtoType[A].Prototype$

    NEXT 'A 'ProtoCnt

    IF fpdef THEN CLOSE fpdef

    IF *LastDef$ THEN
      WHILE LastLevel > 0
        IF Use_SingleFile = FALSE THEN
          FPRINT fpHFile, "#endif"
        END IF
        FPRINT FP_WRITE,"#endif"
        LastLevel--
      WEND
    END IF
    IF Use_Library THEN FPRINT FP_WRITE,"// END BCXRTHEADER\n\n"
  END IF
END SUB ' User_Prototypes



SUB Emit_BCX_TmpStrSize(FP_WRITE AS FILE)
  FPRINT FP_WRITE,"#ifndef BCXTmpStrSize"
  FPRINT FP_WRITE,"#define BCXTmpStrSize ";BCX_TmpStrSize
  FPRINT FP_WRITE,"#endif"
END SUB
'------------------------------------------------------------------------------
'jcfuller added 9/14/2013 from bcx 7.0.8
SUB EmitOSVersionEnum()
    FPRINT FP_ENU, ""
    FPRINT FP_ENU, "enum"
    FPRINT FP_ENU, "  {"
    FPRINT FP_ENU, "  OSUnknown = -2,"
    FPRINT FP_ENU, "  OSError = -1,"
    FPRINT FP_ENU, "  OS_3x,"
    FPRINT FP_ENU, "  OS_95,"
    FPRINT FP_ENU, "  OS_98,"
    FPRINT FP_ENU, "  OS_ME,"
    FPRINT FP_ENU, "  OS_NT3,"
    FPRINT FP_ENU, "  OS_2000,"
    FPRINT FP_ENU, "  OS_XP,"
    FPRINT FP_ENU, "  OS_XP_Pro_x64,"
    FPRINT FP_ENU, "  OS_Server_2003,"
    FPRINT FP_ENU, "  OS_Home_Server,"
    FPRINT FP_ENU, "  OS_Server_2003_R2,"
    FPRINT FP_ENU, "  OS_Vista,"
    FPRINT FP_ENU, "  OS_Server_2008,"
    FPRINT FP_ENU, "  OS_Server_2008_R2,"
    FPRINT FP_ENU, "  OS_Win_7,"
    FPRINT FP_ENU, "  OS_Server_2012,"
    FPRINT FP_ENU, "  OS_Win_8"
    FPRINT FP_ENU, "  };"
    FPRINT FP_ENU, ""
END SUB


SUB RunTimeFunctions(FP_WRITE AS FILE)

  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"// *************************************************"
  FPRINT FP_WRITE,"//                 ";$BCX_STR_RUNTIME
  FPRINT FP_WRITE,"// *************************************************"
  FPRINT FP_WRITE,""

  IF Use_Library THEN
    FPRINT FP_WRITE,"// BCXRTLIB: Get_RTL_Version"
    FPRINT FP_WRITE,"char *Get_RTL_Version(void)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  return ";ENC$(Version$);";"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF UseFlag THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_TmpStr"
    CALL Emit_BCX_TmpStrSize(FP_WRITE)
    FPRINT FP_WRITE,"char *BCX_TmpStr (size_t Bites,size_t  iPad,int iAlloc)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  static int   StrCnt;"
    FPRINT FP_WRITE,"  static char *StrFunc[BCXTmpStrSize];"
    FPRINT FP_WRITE,"  StrCnt=(StrCnt + 1) & (BCXTmpStrSize-1);"
    FPRINT FP_WRITE,"  if(StrFunc[StrCnt]) {free (StrFunc[StrCnt]); StrFunc[StrCnt] = NULL;}"
    FPRINT FP_WRITE,"#if defined BCX_MAX_VAR_SIZE"
    FPRINT FP_WRITE,"  if(Bites*sizeof(char)>BCX_MAX_VAR_SIZE)"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"  printf(",ENC$("Buffer Overflow caught in BCX_TmpStr - requested space of %d EXCEEDS %d\\n"),",(int)(Bites*sizeof(char)),BCX_MAX_VAR_SIZE);"
    FPRINT FP_WRITE,"  abort();"
    FPRINT FP_WRITE,"  }"
    FPRINT FP_WRITE,"#endif"
'jcfuller changed 7/22/2013
    'FPRINT FP_WRITE,"  if(iAlloc) StrFunc[StrCnt]=(char*)calloc(Bites+128,sizeof(char));"
    FPRINT FP_WRITE,"  if(iAlloc) StrFunc[StrCnt]=(char*)calloc(Bites+iPad+1,sizeof(char));"
    FPRINT FP_WRITE,"  return StrFunc[StrCnt];"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF
'jcfuller added 9/25/2015
	If Use_Bit Then
		Prepend FPRINT FP_WRITE,
			"inline"
			"bool bc9_bit(int n, int idx)"
			"{"
			"	return n & (1 << idx);"
			"}"
		End Prepend
	End If

  IF Use_EmptyTmpStr THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: EmptyTmpStr"
    CALL Emit_BCX_TmpStrSize(FP_WRITE)
    FPRINT FP_WRITE,"void EmptyTmpStr (void)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int     i;"
    FPRINT FP_WRITE,"  for(i=0; i<=BCXTmpStrSize-1; i++)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      BCX_TmpStr(0,0,0);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_Str_Cmp THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: str_cmp"
    'jcfuller added "const"
    FPRINT FP_WRITE,"int str_cmp (const char *a, const char *b)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register int counter=0;"
    FPRINT FP_WRITE,"  int counter=0;"
    FPRINT FP_WRITE,"  for(;;)"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"    if((a[counter]^b[counter]))"
    FPRINT FP_WRITE,"     {"
    FPRINT FP_WRITE,"      if((UINT) a[counter]>= (UINT) b[counter])"
    FPRINT FP_WRITE,"      return  1;"
    FPRINT FP_WRITE,"      return -1;"
    FPRINT FP_WRITE,"     }"
    FPRINT FP_WRITE,"    if(!a[counter]) return 0;"
    FPRINT FP_WRITE,"    counter++;"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_Eof THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Eof"
    FPRINT FP_WRITE,"int EoF (FILE* stream)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register int c, status = ((c = fgetc(stream)) == EOF);"
    FPRINT FP_WRITE,"  int c, status = ((c = fgetc(stream)) == EOF);"
    FPRINT FP_WRITE,"  ungetc(c,stream);"
    FPRINT FP_WRITE,"  return status;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_AppActivate THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: AppActivate"
    FPRINT FP_WRITE,"int AppActivate (const char *Z)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int   CurThread;"
    FPRINT FP_WRITE,"  int   NewThread;"
    FPRINT FP_WRITE,"  int   Rc;"
    FPRINT FP_WRITE,"  int   ArgLen;"
    FPRINT FP_WRITE,"  char  Buffer";cSizeOfADefaultString$;";"
    FPRINT FP_WRITE,"  HWND  hWnd;"
    FPRINT FP_WRITE,"  *Buffer = 0;"
    FPRINT FP_WRITE,"  ArgLen  = strlen((char*)Z);"
    FPRINT FP_WRITE,"  CurThread = GetCurrentThreadId();"
    FPRINT FP_WRITE,"  hWnd = GetForegroundWindow();"
    FPRINT FP_WRITE,"  for(Rc=0;Rc<=1000;Rc++)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      hWnd=GetNextWindow(hWnd,GW_HWNDNEXT);"
    FPRINT FP_WRITE,"      GetWindowText(hWnd,Buffer,256);"
    FPRINT FP_WRITE,"      if(instr(left(lcase(Buffer),ArgLen),lcase(Z),0,0)) break;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if(Rc==1001) return 0;"
    FPRINT FP_WRITE,"  NewThread=GetWindowThreadProcessId(hWnd,NULL);"
    FPRINT FP_WRITE,"  AttachThreadInput(CurThread,NewThread,TRUE);"
    FPRINT FP_WRITE,"  SetActiveWindow(hWnd);"
    FPRINT FP_WRITE,"  return TRUE;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_Cint THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Cint"
    FPRINT FP_WRITE,"int Cint (double A)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  return (A >=0 ? (int)(A+0.5) : (int)(A-0.5));"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_Clng THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: CLNG"
    FPRINT FP_WRITE,"long CLNG (double A)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  float   r=.5;"
    FPRINT FP_WRITE,"  double  a=A-(long)A;"
    FPRINT FP_WRITE,"  if(A<0) { r=-.5; a=-a; }"
    FPRINT FP_WRITE,"  if(((long)A % 2)==0&&a<=.5)"
    FPRINT FP_WRITE,"    return (long)A;"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"    return (long)(A+r);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_Left THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: left"
'jcfuller added for c++ 3/13/2013
    IF UseCpphdr And Not Use_TCLib THEN
    	FPRINT FP_WRITE, "std::string left (std::string s, int length)"
    	FPRINT FP_WRITE, "{"
    	FPRINT FP_WRITE, "  return s.substr(0,length);"
    	FPRINT FP_WRITE, "}"
    End If

    FPRINT FP_WRITE,"char *left (const char *S, int length)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register int tmplen = strlen(S);"
    FPRINT FP_WRITE,"  int tmplen = strlen(S);"
    FPRINT FP_WRITE,"  if(length<1) return BCX_TmpStr(1,0,1);"
    FPRINT FP_WRITE,"  if(length<tmplen) tmplen=length;"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(tmplen,1,1);"
    FPRINT FP_WRITE,"  return (char*)memcpy(strtmp,S,tmplen);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_Right THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: right"
'jcfuller added 3/13/2013
    IF UseCpphdr And Not Use_TCLib THEN
    	FPRINT FP_WRITE, "std::string right (std::string s, int length)"
    	FPRINT FP_WRITE, "{"
    	FPRINT FP_WRITE, "  return s.substr(s.length()-length,length);"
    	FPRINT FP_WRITE, "}"
    End If

    FPRINT FP_WRITE,"char *right (const char *S, int length)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int tmplen = strlen(S);"
    FPRINT FP_WRITE,"  char *BCX_RetStr = BCX_TmpStr(tmplen,1,1);"
    FPRINT FP_WRITE,"  tmplen -= length;"
    FPRINT FP_WRITE,"  if (tmplen<0) tmplen = 0;"
    FPRINT FP_WRITE,"  return strcpy(BCX_RetStr, &S[tmplen]);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_Rpad THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: rpad"
    FPRINT FP_WRITE,"char *rpad (const char *a, int L, int c)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *strtmp;"
    FPRINT FP_WRITE,"  int s = strlen(a);"
    FPRINT FP_WRITE,"  if((L-s)<1) return (char*)a;"
    FPRINT FP_WRITE,"  strtmp=BCX_TmpStr(L,1,1);"
    FPRINT FP_WRITE,"  strcpy(strtmp,a);"
    FPRINT FP_WRITE,"  memset(&strtmp[s],c,(L-s));"
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF



  IF Use_Lpad THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: lpad"
    FPRINT FP_WRITE,"char *lpad (const char *a, int L, int c)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *strtmp;"
    FPRINT FP_WRITE,"  L=L-strlen(a);"
    FPRINT FP_WRITE,"  if(L<1) return (char*)a;"
    FPRINT FP_WRITE,"  strtmp = BCX_TmpStr(L,1,1);"
    FPRINT FP_WRITE,"  memset(strtmp,c,L);"
    FPRINT FP_WRITE,"  return strcat(strtmp,a);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Mid THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: mid"
'jcfuller added 3/13/2013
    IF UseCpphdr And Not Use_TCLib And Not Use_UNICODE_Switch THEN
      FPRINT FP_WRITE,"std::string mid (std::string s, size_t start, int length)"
      FPRINT FP_WRITE,"{"
      FPRINT FP_WRITE,"  if (start > s.length() || start < 1)  return ";DQ$;DQ$;" ;"
      FPRINT FP_WRITE,"  if (length < 0) length = s.length();"
      'FPRINT FP_WRITE,"  if (length < 1) length = s.length();"
      FPRINT FP_WRITE,"  return s.substr(start-1,length);"
      FPRINT FP_WRITE,"}"

    End If

    FPRINT FP_WRITE,"char *mid (const char *S, int start, int length)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *strtmp;"
    'FPRINT FP_WRITE,"  register int tmplen = strlen(S);"
    FPRINT FP_WRITE,"  int tmplen = strlen(S);"
    FPRINT FP_WRITE,"  if(start>tmplen||start<1) return BCX_TmpStr(1,1,1);"
    FPRINT FP_WRITE,"  if (length<0 || length>(tmplen-start)+1)"
    FPRINT FP_WRITE,"    length = (tmplen-start)+1;"
    FPRINT FP_WRITE,"  strtmp = BCX_TmpStr(length,1,1);"
    FPRINT FP_WRITE,"  return (char*)memcpy(strtmp,&S[start-1],length);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Trim THEN
    'jcfuller added for std::string
    If UseCpphdr And Not Use_TCLib  And Not Use_UNICODE_Switch Then
    	Prepend FPRINT FP_WRITE,
		  "std::string trim (std::string str)"
          "{"
          "str.erase(0, str.find_first_not_of(",ENC$(" \\t\\n\\v\\r\\f"),"));       //prefixing whitespaces"
          "str.erase(str.find_last_not_of(",ENC$(" \\t\\n\\v\\r\\f"),")+1);         //surfixing whitespaces"
          "return str;"
          "}"
        End Prepend
    End If

    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: trim"
    FPRINT FP_WRITE,"char *trim (const char *S)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  if(S[0]==0) return (char*)S;"  '//; changed/added by whatsup
    FPRINT FP_WRITE,"  while(*S==32 || (*S>=9 && *S<=13)) S++;"  '//; changed/added by whatsup
    '                 tab ,carriage return, vertical tab, newline, space
    'FPRINT FP_WRITE,"  register int i = strlen(S);"
    FPRINT FP_WRITE,"  int i = strlen(S);"
    FPRINT FP_WRITE,"  while( i>0 && (S[i-1]==32 || (S[i-1]>=9 && S[i-1]<=13))) i--;"  '//; changed/added by whatsup
    FPRINT FP_WRITE,"  char *strtmp=BCX_TmpStr(i,1,1);"
    FPRINT FP_WRITE,"  return (char*)memcpy(strtmp,S,i);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Ltrim THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: ltrim"
'jcfuller added for std::string 3/13/2013
    If UseCpphdr And Not Use_TCLib Then
    	Prepend FPRINT FP_WRITE,
    	  "std::string ltrim(std::string str,std::string ctrim)"
    	  "{"
    	  "str.erase(0, str.find_first_not_of(ctrim));"
    	  "return str;"
    	  "}"
    	End Prepend
    End If

    FPRINT FP_WRITE,"char *ltrim (const char *S, char c)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  if(S[0]==0) return (char*)S;"
    FPRINT FP_WRITE,"  while(*S==32 || (*S>=9 && *S<=13) || *S==c) S++;"  '//; changed/added by whatsup
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(strlen(S),1,1);"
    FPRINT FP_WRITE,"  return strcpy(strtmp,S);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Rtrim THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: rtrim"
    If UseCpphdr And Not Use_TCLib Then
		'If Use_UNICODE_Switch Then

			'Prepend FPRINT FP_WRITE,
			  '"wstring rtrim(wstring str,wstring ctrim)"
			  '"{"
			  '"str.erase(str.find_last_not_of(ctrim)+1);"
			  '"return str;"
			  '"}"
			'End Prepend

		'Else
			Prepend FPRINT FP_WRITE,
			  "std::string rtrim(std::string str,std::string ctrim)"
			  "{"
			  "str.erase(str.find_last_not_of(ctrim)+1);"
			  "return str;"
			  "}"
			End Prepend
'jcfuller added 9/28/2015
			Prepend FPRINT FP_WRITE,
			  "std::wstring rtrim(std::wstring str,std::wstring ctrim)"
			  "{"
			  "str.erase(str.find_last_not_of(ctrim)+1);"
			  "return str;"
			  "}"
			End Prepend

		'End If

    End If

    FPRINT FP_WRITE,"char *rtrim (const char *S,char c)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  if(S[0]==0) return (char*)S;"
    'FPRINT FP_WRITE,"  register int i = strlen(S);"
    FPRINT FP_WRITE,"  int i = strlen(S);"
    FPRINT FP_WRITE,"  while(i>0 && (S[i-1]==32 || (S[i-1]>=9 && S[i-1]<=13) || S[i-1]==c)) i--;"  '//; changed/added by whatsup
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(i,1,1);"
    FPRINT FP_WRITE,"  return (char*)memcpy(strtmp,S,i);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Strim THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: strim"
'jcfuller added 3/13/2013 cheatin a bit here with a call to the char Ptr version
    If UseCpphdr And Not Use_TCLib Then
    	Prepend FPRINT FP_WRITE,
			"//<---UNICODE AWARE"
            "std::string strim(std::string s)"
            "{"
            "	std::istringstream iss(s);"
            "  	s = "+ENC$("")+";"
            "    std::string ss;"
            "    while(iss >> ss)"
            "    {"
            "      if(s != "+ENC$("")+") s += "+ENC$(" ")+ " + ss;"
            "      else s = ss;"
            "    }  	"
            "  return s;"
            "}"
            "//------------------------------------------------------------------------------"
            "std::wstring strim(std::wstring s)"
            "{"
            "	std::wistringstream iss(s);"
            "  	s = L"+ENC$("")+";"
            "    std::wstring ss;"
            "    while(iss >> ss)"
            "    {"
            "      if(s != L"+ENC$("")+") s += L"+ENC$(" ")+" + ss;"
            "      else s = ss;"
            "    }  	"
            "  return s;"
            "}"
			"//>---UNICODE AWARE"
    	  '"std::string strim(std::string s)"
    	  '"{"
    	  '   "return strim((char*)s.c_str());"
    	  '"}"
    	End Prepend
    End If

    FPRINT FP_WRITE,"char *strim (const char *src)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(strlen(src),1,1);"
    'FPRINT FP_WRITE,"  register char *dst = strtmp;"
    FPRINT FP_WRITE,"  char *dst = strtmp;"
    FPRINT FP_WRITE,"  while (isspace((unsigned char)*src)) src++;"
    FPRINT FP_WRITE,"  do"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"    while (*src && ! isspace((unsigned char)*src)) *dst++ = *src++;"
    FPRINT FP_WRITE,"    if (*src)"
    FPRINT FP_WRITE,"      {"
    FPRINT FP_WRITE,"        *dst++ = *src++;"
    FPRINT FP_WRITE,"        while (isspace((unsigned char)*src)) src++;"
    FPRINT FP_WRITE,"      }"
    FPRINT FP_WRITE,"  } while (*src);"
    FPRINT FP_WRITE,"  if (isspace((unsigned char)*(--dst))) *dst = 0;"
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Command THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: command"
    IF UseWinApi = FALSE AND Use_TCLib = FALSE THEN
	    FPRINT FP_WRITE,"char *command (int nArg)"
	    FPRINT FP_WRITE," {"
	    FPRINT FP_WRITE," int i = 0;"
	    FPRINT FP_WRITE," char *retstr=BCX_TmpStr(1,1,1);"
	    FPRINT FP_WRITE," if(nArg < i) // return entire commandline"
	    FPRINT FP_WRITE,"    {"
	    FPRINT FP_WRITE,"      retstr = BCX_TmpStr(g_argc * 2048,1,1);"
	    FPRINT FP_WRITE,"      for(i=1; i < g_argc; i++)"
	    FPRINT FP_WRITE,"         {"
	    FPRINT FP_WRITE,"         strcat(retstr, g_argv[i]);"
	    FPRINT FP_WRITE,"         strcat(retstr, SPC);"
	    FPRINT FP_WRITE,"         }"
	    FPRINT FP_WRITE,"         retstr[strlen(retstr)-1] = 0;"
	    FPRINT FP_WRITE,"    }"
	    FPRINT FP_WRITE," else if(nArg < g_argc)"
	    FPRINT FP_WRITE,"    {"
	    FPRINT FP_WRITE,"      retstr = BCX_TmpStr(strlen(g_argv[nArg]) + 1,1,1);"
	    FPRINT FP_WRITE,"      strcpy(retstr, g_argv[nArg]);"
	    FPRINT FP_WRITE,"    }"
	    FPRINT FP_WRITE," return retstr;"
    ELSE
	    FPRINT FP_WRITE,"char *command (int nArg)"
	    FPRINT FP_WRITE,"{"
	    'FPRINT FP_WRITE," register int i = 0;"
	    FPRINT FP_WRITE," int i = 0;"
	    FPRINT FP_WRITE," char *c = 0, *retstr, *s = GetCommandLine();"
	    FPRINT FP_WRITE," if(nArg < i) // return entire commandline"
	    FPRINT FP_WRITE,"    {"
	    FPRINT FP_WRITE,"    while(*s && *s != 32) {"
	    FPRINT FP_WRITE,"      if(*s == 34) while(*++s && *s != 34);"
	    FPRINT FP_WRITE,"      s++;"
	    FPRINT FP_WRITE,"      }"
	    FPRINT FP_WRITE,"    while(isspace((unsigned char)*s))s++;"
	    FPRINT FP_WRITE,"    retstr = BCX_TmpStr(strlen(s)+1,1,1);"
	    FPRINT FP_WRITE,"    strcpy(retstr, s);"
	    FPRINT FP_WRITE,"    if(*(retstr+strlen(retstr)-1)==20) *retstr=0;"
	    FPRINT FP_WRITE,"    return retstr;"
	    FPRINT FP_WRITE,"    }"
	    FPRINT FP_WRITE,"  while(i <= nArg) {"
	    FPRINT FP_WRITE,"    while(isspace((unsigned char)*s)) s++; // skip whitespace"
	    FPRINT FP_WRITE,"    c = s;"
	    FPRINT FP_WRITE,"    if(*s == 34) {                           // argument starts a quote"
	    FPRINT FP_WRITE,"      while(*++s && *s != 34);          // skip till next quote"
	    FPRINT FP_WRITE,"        if(*s) s++;                       // skip quote itself"
	    FPRINT FP_WRITE,"    }"
	    FPRINT FP_WRITE,"    else {"
	    FPRINT FP_WRITE,"      while(*s && *s != 32) s++;"
	    FPRINT FP_WRITE,"     }"
	    FPRINT FP_WRITE,"    i++;"
	    FPRINT FP_WRITE,"    }"
	    FPRINT FP_WRITE,"  if(*c == 34) {"
	    FPRINT FP_WRITE,"      c++;                                 // skip leading quote"
	    FPRINT FP_WRITE,"      if(*(s-1) == 34) s--;                // skip any trailing quotes"
	    FPRINT FP_WRITE,"    }"
	    FPRINT FP_WRITE,"  retstr = BCX_TmpStr((s - c) + 1,1,1);"
	    FPRINT FP_WRITE,"  strncpy(retstr, c, (s - c));"
	    FPRINT FP_WRITE,"  retstr[s-c]=0;"
	    FPRINT FP_WRITE,"  return retstr;"
	END IF
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Extract THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: extract"
'jcfuller added 3/13/2013
    If UseCpphdr And Not Use_TCLib Then
    	Prepend FPRINT FP_WRITE,
			"stdstr extract (stdstr mane,stdstr match)"
			"{"
			"	int n;"
			"	n = mane.find(match);"
			"	stdstr s = mane.substr(0,n);"
			"	return s;"
			"}"
    	End Prepend
'jcfuller added 9/11/2015
    	'Prepend FPRINT FP_WRITE,
			'"stdstr extract (stdstr mane,const char *match)"
			'"{"
			'"	int n;"
			'"	n = mane.find(match);"
			'"	stdstr s = mane.substr(0,n);"
			'"	return s;"
			'"}"
    	'End Prepend

    End If

    FPRINT FP_WRITE,"char *extract (const char *mane, const char *match)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register char *a;"
    FPRINT FP_WRITE,"  char *a;"
    'FPRINT FP_WRITE,"  register char *strtmp = BCX_TmpStr(strlen(mane),1,1);"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(strlen(mane),1,1);"
    FPRINT FP_WRITE,"  if(*match!=0)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      a=_strstr_((char*)mane,(char*)match);"
    FPRINT FP_WRITE,"      if(a) return (char*)memcpy(strtmp,mane,a-mane);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  return strcpy(strtmp,mane);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Remain THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: remain"
    If UseCpphdr And Not Use_TCLib Then
    	Prepend FPRINT FP_WRITE,
    		"stdstr remain(stdstr mane,stdstr match)"
    		"{"
  			"int n;"
  			"n = mane.find(match);"
  			"if (n>=0) n+=match.length();"
  			"return mane.substr(n,mane.length());"
			"}"
    	End Prepend
    End If

    FPRINT FP_WRITE,"char *remain (const char *mane, const char *mat)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register char *p = strstr((char*)mane,(char*)mat);"
    FPRINT FP_WRITE,"  char *p = strstr((char*)mane,(char*)mat);"
    FPRINT FP_WRITE,"  if(p)"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"    p+=(strlen(mat));"
    FPRINT FP_WRITE,"    return p;"
    FPRINT FP_WRITE,"  }"
    FPRINT FP_WRITE,"  return (char*)mane;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Replace THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: replace"
'jcfuller added 3/13/2013
    If UseCpphdr And Not Use_TCLib Then
    	Prepend FPRINT FP_WRITE,
          "stdstr replace(stdstr & mane,stdstr match,stdstr change,int f)"
          "{"
          "  char* m;"
          "  char* mt;"
          "  char* c;"
          "  char* rv;"
          "  stdstr s;"
          "  m = (char*)mane.c_str();"
          "  mt = (char*)match.c_str();"
          "  c = (char*)change.c_str();"
          "  rv = replace(m,mt,c);"
          "  s = rv;"
          "  if(f) m = rv;"
          "  return rv;"
          "}"
    	End Prepend
    End If


    FPRINT FP_WRITE,"char *replace (const char *src, const char *pat, const char *rep)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register size_t patsz, repsz, tmpsz, delta;"
    FPRINT FP_WRITE,"  size_t patsz, repsz, tmpsz, delta;"
    'FPRINT FP_WRITE,"  register char *strtmp, *p, *q, *r;"
    FPRINT FP_WRITE,"  char *strtmp, *p, *q, *r;"
    FPRINT FP_WRITE,"  if (!pat || !*pat)"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"     strtmp = BCX_TmpStr(strlen(src),1,1);"
    FPRINT FP_WRITE,"     if (!strtmp) return NULL;"
    FPRINT FP_WRITE,"     return strcpy(strtmp, src);"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"  repsz = strlen(rep);"
    FPRINT FP_WRITE,"  patsz = strlen(pat);"
    FPRINT FP_WRITE,"  for (tmpsz=0, p=(char*)src; (q=_strstr_(p,(char*)pat))!=0; p=q+patsz)"
    FPRINT FP_WRITE,"   tmpsz += (size_t) (q - p) + repsz;"
    FPRINT FP_WRITE,"   tmpsz += strlen(p);"
    FPRINT FP_WRITE,"   strtmp = BCX_TmpStr(tmpsz,1,1);"
    FPRINT FP_WRITE,"   if (!strtmp) return NULL;"
    FPRINT FP_WRITE,"    for (r=strtmp,p=(char*)src; (q=_strstr_(p,(char*)pat))!=0;p=q+patsz)"
    FPRINT FP_WRITE,"     {"
    FPRINT FP_WRITE,"       delta = (size_t) (q-p);"
    FPRINT FP_WRITE,"       memcpy(r,p,delta); r += delta;"
    FPRINT FP_WRITE,"       strcpy(r,rep);      r += repsz;"
    FPRINT FP_WRITE,"     }"
    FPRINT FP_WRITE,"  strcpy(r,p);"
    FPRINT FP_WRITE,"  return strtmp;"

    'FPRINT FP_WRITE,"  register size_t patsz, repsz, tmpsz, delta;"
    'FPRINT FP_WRITE,"  register char *strtmp, *p, *q, *r;"
    'FPRINT FP_WRITE,"  if (!pat || !*pat)"
    'FPRINT FP_WRITE,"   {"
    'FPRINT FP_WRITE,"     strtmp = BCX_TmpStr(strlen(src),128,1);"
    'FPRINT FP_WRITE,"     if (!strtmp) return NULL;"
    'FPRINT FP_WRITE,"     return strcpy(strtmp, src);"
    'FPRINT FP_WRITE,"   }"
    'FPRINT FP_WRITE,"  repsz = strlen(rep);"
    'FPRINT FP_WRITE,"  patsz = strlen(pat);"
    'FPRINT FP_WRITE,"  for (tmpsz=0, p=src; (q=_strstr_(p,pat))!=0; p=q+patsz)"
    'FPRINT FP_WRITE,"   tmpsz += (size_t) (q - p) + repsz;"
    'FPRINT FP_WRITE,"   tmpsz += strlen(p);"
    'FPRINT FP_WRITE,"   strtmp = BCX_TmpStr(tmpsz,128,1);"
    'FPRINT FP_WRITE,"   if (!strtmp) return NULL;"
    'FPRINT FP_WRITE,"    for (r=strtmp,p=src; (q=_strstr_(p,pat))!=0;p=q+patsz)"
    'FPRINT FP_WRITE,"     {"
    'FPRINT FP_WRITE,"       delta = (size_t) (q-p);"
    'FPRINT FP_WRITE,"       memcpy(r,p,delta); r += delta;"
    'FPRINT FP_WRITE,"       strcpy(r,rep);      r += repsz;"
    'FPRINT FP_WRITE,"     }"
    'FPRINT FP_WRITE,"  strcpy(r,p);"
    'FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Reverse THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: reverse"
    FPRINT FP_WRITE,"char *reverse (const char *s)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int j=strlen(s);"
    'FPRINT FP_WRITE,"  register char *rstr = BCX_TmpStr(j,1,1);"
    FPRINT FP_WRITE,"  char *rstr = BCX_TmpStr(j,1,1);"
    FPRINT FP_WRITE,"  while(j)  rstr[--j] = *(s++);"
    FPRINT FP_WRITE,"  return rstr;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_Findfirst THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: findfirst"
    FPRINT FP_WRITE,"char *findfirst (const char *S)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register char *strtmp = BCX_TmpStr(strlen(S),1,1);"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(strlen(S),1,1);"
    FPRINT FP_WRITE,"  if(FileHandle) FindClose(FileHandle);"
    FPRINT FP_WRITE,"  FileHandle = FindFirstFile(S,&FindData);"
    FPRINT FP_WRITE,"  if (FileHandle != INVALID_HANDLE_VALUE)"
    FPRINT FP_WRITE,"    strcpy(strtmp,FindData.cFileName);"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"    FileHandle = 0;"
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Findnext THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: findnext"
    FPRINT FP_WRITE,"char *findnext (void)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register char *strtmp = BCX_TmpStr(";csSizeOfDefaultString$;",1,1);"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(";csSizeOfDefaultString$;",1,1);"
    FPRINT FP_WRITE,"  if(FileHandle) {"
    'FPRINT FP_WRITE,"  register int Found = FindNextFile(FileHandle,&FindData);"
    FPRINT FP_WRITE,"  int Found = FindNextFile(FileHandle,&FindData);"
    FPRINT FP_WRITE,"  if(Found)"
    FPRINT FP_WRITE,"    strcpy(strtmp,FindData.cFileName);"
    FPRINT FP_WRITE,"    else {"
    FPRINT FP_WRITE,"      FindClose(FileHandle);"
    FPRINT FP_WRITE,"      FileHandle = 0;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  }"
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_Instat Then
  	If TargetOS = TNIX Then
	    FPRINT FP_WRITE,"int instat(void)"
	    FPRINT FP_WRITE,"{"
	    FPRINT FP_WRITE,"  struct termios oldt, newt;"
	    FPRINT FP_WRITE,"  int ch;"
	    FPRINT FP_WRITE,"	int oldf;"

	    FPRINT FP_WRITE,"  tcgetattr(STDIN_FILENO, &oldt);"
	    FPRINT FP_WRITE,"  newt = oldt;"
	    FPRINT FP_WRITE,"  newt.c_lflag &= ~(ICANON | ECHO);"
	    FPRINT FP_WRITE,"  tcsetattr(STDIN_FILENO, TCSANOW, &newt);"
	    FPRINT FP_WRITE,"  oldf = fcntl(STDIN_FILENO, F_GETFL, 0);"
	    FPRINT FP_WRITE,"  fcntl(STDIN_FILENO, F_SETFL, oldf | O_NONBLOCK);"

	    FPRINT FP_WRITE,"  ch = getchar();"

	    FPRINT FP_WRITE,"  tcsetattr(STDIN_FILENO, TCSANOW, &oldt);"
	    FPRINT FP_WRITE,"  fcntl(STDIN_FILENO, F_SETFL, oldf);"

	    FPRINT FP_WRITE,"  if(ch != EOF)"
	    FPRINT FP_WRITE,"  {"
	    FPRINT FP_WRITE,"    ungetc(ch, stdin);"
	    FPRINT FP_WRITE,"    return 1;"
	    FPRINT FP_WRITE,"  }"

	    FPRINT FP_WRITE,"  return 0;"
	    FPRINT FP_WRITE,"}\n\n"
	Else
	    FPRINT FP_WRITE,"int instat(void)"
	    FPRINT FP_WRITE,"{"
	    FPRINT FP_WRITE," return _kbhit();"
	    FPRINT FP_WRITE,"  }\n\n"
  	End If
  End If

  IF Use_Ucase THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: ucase"
'jcfuller added 3/14/2013
    If UseCpphdr And Not Use_TCLib Then
    	Prepend FPRINT FP_WRITE,
          "stdstr ucase(stdstr & m, int f)"
          "{"
          "  stdstr s;"
          "  if(f)"
          "    {"
          "      std::transform(m.begin(), m.end(),m.begin(), upper);"
          "      return s;"
          "    }"
          "  s = m;"
          "  std::transform(s.begin(), s.end(),s.begin(), upper);"
          "  return s;"
          "}"
    	End Prepend
    End If

    FPRINT FP_WRITE,"char *ucase (const char *S)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register char *strtmp = BCX_TmpStr(strlen(S),1,1);"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(strlen(S),1,1);"
    FPRINT FP_WRITE,"  return _strupr_(strcpy(strtmp,(char*)S));"				'strupr -> _strupr_ (jcfuller)
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Lcase THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: lcase"
'jcfuller added 3/14/2013
    If UseCpphdr And Not Use_TCLib Then
    	Prepend FPRINT FP_WRITE,
          "stdstr lcase(stdstr & m, int f)"
           "{"
           "  stdstr s;"
           "  s = m;"
           "  std::transform(s.begin(), s.end(),s.begin(), lower);"
           "  if(f) m=s;"
           "  return s;"
           "}"
    	End Prepend
    End If

    FPRINT FP_WRITE,"char *lcase (const char *S)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register char *strtmp = BCX_TmpStr(strlen(S),1,1);"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(strlen(S),1,1);"
    FPRINT FP_WRITE,"  return _strlwr_(strcpy(strtmp,(char*)S));"				'strlwr -> _strlwr_ (jcfuller)
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Mcase THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: mcase"
    FPRINT FP_WRITE,"char *mcase (const char *S)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register char *strtmp = BCX_TmpStr(strlen(S)+1,1,1);"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(strlen(S)+1,1,1);"
    'FPRINT FP_WRITE,"  register char *s = strtmp;"
    FPRINT FP_WRITE,"  char *s = strtmp;"
    FPRINT FP_WRITE,"  _strlwr_(strcpy(strtmp,S));"						'strlwr -> _strlwr_ (jcfuller)
    FPRINT FP_WRITE,"  while(*s)"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"    if(islower(*s))"
    FPRINT FP_WRITE,"      {"
    FPRINT FP_WRITE,"        *s-=32;"
    FPRINT FP_WRITE,"        while(isalpha(*++s));"
    FPRINT FP_WRITE,"      }"
    FPRINT FP_WRITE,"     s++;"
    FPRINT FP_WRITE,"  }"
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Remove THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: RemoveStr"
    If UseCpphdr And Not Use_TCLib Then
'jcfuller added 3/13/2013 cheatin a bit :)
      Prepend FPRINT FP_WRITE,
      	"stdstr RemoveStr(stdstr a, stdstr b)"
      	"{"
      	"  char *c,*d,*rv;"
      	"  stdstr s;"
      	"  c = (char*)a.c_str();"
      	"  d = (char*)b.c_str();"
      	"  rv = RemoveStr(c,d);"
      	"  s = rv;"
      	"  return s;"
      	"}"
      End Prepend
    End If

    FPRINT FP_WRITE,"char *RemoveStr (const char *a, const char *b)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *strtmp, *p, *d;"
    FPRINT FP_WRITE,"  int  tmplen;"
    FPRINT FP_WRITE,"  strtmp = d = BCX_TmpStr(strlen(a),1,1);"
    FPRINT FP_WRITE,"  if(!b || !*b) return strcpy(strtmp,a);"
    FPRINT FP_WRITE,"  p=_strstr_((char*)a,(char*)b); tmplen = strlen(b);"
    FPRINT FP_WRITE,"  while(p)"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"     memcpy(d,a,p-a);"
    FPRINT FP_WRITE,"     d+= (p-a);"
    FPRINT FP_WRITE,"     a=p+tmplen;"
    FPRINT FP_WRITE,"     p=_strstr_((char*)a,(char*)b);"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"  strcpy(d,a);"
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_IRemove THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: IRemove"
    If UseCpphdr And Not Use_TCLib Then
'jcfuller added 3/13/2013 cheatin a bit :)
      Prepend FPRINT FP_WRITE,
      	"stdstr IRemoveStr(stdstr a, stdstr b)"
      	"{"
      	"  char *c,*d,*rv;"
      	"  stdstr s;"
      	"  c = (char*)a.c_str();"
      	"  d = (char*)b.c_str();"
      	"  rv = IRemoveStr(c,d);"
      	"  s = rv;"
      	"  return s;"
      	"}"
      End Prepend
    End If


    FPRINT FP_WRITE,"char *IRemoveStr (const char *a, const char *b)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *strtmp, *p, *d;"
    FPRINT FP_WRITE,"  int  tmplen;"
    FPRINT FP_WRITE,"  strtmp = d = BCX_TmpStr(strlen(a),1,1);"
    FPRINT FP_WRITE,"  if(!b || !*b) return strcpy(strtmp,a);"
    FPRINT FP_WRITE,"  p=_stristr_((char*)a,(char*)b); tmplen = strlen(b);"
    FPRINT FP_WRITE,"  while(p)"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"     memcpy(d,a,p-a);"
    FPRINT FP_WRITE,"     d+= (p-a);"
    FPRINT FP_WRITE,"     a=p+tmplen;"
    FPRINT FP_WRITE,"     p=_stristr_((char*)a,(char*)b);"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"  strcpy(d,a);"
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_Ins THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: ins"
'jcfuller added 3/13/2013
    If UseCpphdr And Not Use_TCLib Then
    	Prepend FPRINT FP_WRITE,
			"stdstr ins(stdstr& m,int p,stdstr s,int flag)"
			"{"
  				"if (flag!=0){ m.insert(p-1,s);return m;}"
  				"stdstr str;"
  				"str = m;"
  				"str.insert(p-1,s);"
  				"return str;"
			"}"
    	End Prepend
    End If

    FPRINT FP_WRITE,"char *ins (const char *S, int i, const char *a)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register int j = strlen(S);"
    FPRINT FP_WRITE,"  int j = strlen(S);"
    FPRINT FP_WRITE,"  if(i<1 || i>j+1) return (char*)S;"
    'FPRINT FP_WRITE,"  register char *strtmp = BCX_TmpStr(j + strlen(a),1,1);"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(j + strlen(a),1,1);"
    FPRINT FP_WRITE,"  memcpy(strtmp,S,--i);"
    FPRINT FP_WRITE,"  strcpy(&strtmp[i],a);"
    FPRINT FP_WRITE,"  return strcat(strtmp,&S[i]);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Del THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: del"
    'jcfuller added 3/13/2013
    If UseCpphdr And Not Use_TCLib Then
    	Prepend FPRINT FP_WRITE,
          "stdstr del(stdstr & m ,int p,int c,int f)"
          "{"
		  "  if((p>=m.length()) || (p<1) || (c>m.length()) || (c<1)) return m;"
          "  if(f>0) {m.erase(p-1,c);"
          "    return m;"
          "   }"
          "  else{"
          "    stdstr s;"
          "    s = m;"
          "    s.erase(p-1,c);"
          "    return s;"
          "  }"
          "}"
    	End Prepend
    End If

    FPRINT FP_WRITE,"char *del (const char *S, int i, int j)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int ln = strlen(S);"
    FPRINT FP_WRITE,"  if(i<1 || i>ln) return (char*) S;"
    'FPRINT FP_WRITE,"  register char *strtmp = BCX_TmpStr(ln,1,1);"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(ln,1,1);"
    FPRINT FP_WRITE,"  memcpy(strtmp,S,--i);"
    FPRINT FP_WRITE,"  return strcat(strtmp,&S[i+j]);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Str THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: str"
    FPRINT FP_WRITE,"char *str (double d)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register char *strtmp = BCX_TmpStr(24,1,1);"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(24,1,1);"
    FPRINT FP_WRITE,"  sprintf(strtmp,";D1$;",d);"
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  If Use_Sstr Then
    PREPEND FPRINT FP_WRITE,
      "template <typename T>"
      "string sstr ( T Number )"
      "{"
	  "    stringstream ss;"
	  "    ss << Number;"
	  "    return ss.str();"
      "}"
    END PREPEND
  End If

  If Use_Wstr Then
    PREPEND FPRINT FP_WRITE,
      "template <typename T>"
      "wstring wstr ( T Number )"
      "{"
	  "    wstringstream wss;"
	  "    wss << Number;"
	  "    return wss.str();"
      "}"
    END PREPEND
  End If

  If Use_Sscvrt Then
    PREPEND FPRINT FP_WRITE,
      "std::string sscvrt(std::wstring& str){"
      "std::string ss;"
      "ss.assign(str.begin(), str.end());"
      "return ss;"
      "}"
      ""
      "std::wstring sscvrt(std::string& str){"
      "std::wstring ws;"
      "ws.assign(str.begin(), str.end());"
      "return ws;"
      "}"
    END PREPEND
  End If

If Use_Choose And UseCpphdr Then
    PREPEND FPRINT FP_WRITE,
		"template <typename T>"
		"T choose (int Index, std::initializer_list <T>  list, T  UseElse , int useBits )"
		"{"
		"	int      i = {0};"
		"	T        RetVal;"
		"	if(!useBits )"
		"	{"
		"		Index--;"
		"	}"
		"	RetVal = UseElse;"
		"	if(Index < 0 )"
		"	{"
		"		return RetVal;"
		"	}"
		"	for(auto elem : list)"
		"	{"
		"		if(useBits == 0 )"
		"		{"
		"			if(i == Index )"
		"			{"
		"				return elem;"
		"			}"
		"		}"
		"		else if(useBits == 1 )"
		"		{"
		"			if(bc9_bit(Index, i))"
		"			{"
		"				return elem;"
		"			}"
		"		}"
		"		i++;"
		"	}"
		"	return RetVal;"
		"}"
		"//-------------------------------------------------------------"
		"stdstr choose (int Index, std::initializer_list <stdstr>  list, stdstr  UseElse, int useBits, stdstr  ssep)"
		"{"
		"	int      i = {0};"
		"	stdstr   RetVal;"
		"	stdstr   ss;"
		"	if(!useBits )"
		"	{"
		"		Index--;"
		"	}"
		"	RetVal = UseElse;"
		"	if(Index < 0 )"
		"	{"
		"		return RetVal;"
		"	}"
		"	for(auto elem : list)"
		"	{"
		"		if(useBits == 0 )"
		"		{"
		"			if(i == Index )"
		"			{"
		"				return elem;"
		"			}"
		"		}"
		"		else if(useBits == 1 )"
		"		{"
		"			if(bc9_bit(Index, i))"
		"			{"
		"				return elem;"
		"			}"
		"		}"
		"		else if(useBits == 2 )"
		"		{"
		"			if(bc9_bit(Index, i))"
		"			{"
		"				ss += elem;"
		"				ss += ssep;"
		"			}"
		"			else if(UseElse.size())"
		"			{"
		"				ss += UseElse;"
		"				ss += ssep;"
		"			}"
		"		}"
		"		i++;"
		"	}"
		"	if(ss.size())"
		"	{"
		"		RetVal = rtrim( ss, ssep);"
		"	}"
		"	return RetVal;"
		"}"
		"//-------------------------------------------------------------"
		"wstring choose (int Index, std::initializer_list <wstring>  list, wstring  UseElse, int useBits, wstring  ssep)"
		"{"
		"	int      i = {0};"
		"	wstring  RetVal;"
		"	wstring  ss;"
		"	if(!useBits )"
		"	{"
		"		Index--;"
		"	}"
		"	RetVal = UseElse;"
		"	if(Index < 0 )"
		"	{"
		"		return RetVal;"
		"	}"
		"	for(auto elem : list)"
		"	{"
		"		if(useBits == 0 )"
		"		{"
		"			if(i == Index )"
		"			{"
		"				return elem;"
		"			}"
		"		}"
		"		else if(useBits == 1 )"
		"		{"
		"			if(bc9_bit(Index, i))"
		"			{"
		"				return elem;"
		"			}"
		"		}"
		"		else if(useBits == 2 )"
		"		{"
		"			if(bc9_bit(Index, i))"
		"			{"
		"				ss += elem;"
		"				ss += ssep;"
		"			}"
		"			else if(UseElse.size())"
        "    		{"
        "        	ss += UseElse;"
        "        	ss += ssep;"
        "    		}"
		"		}"
		"		i++;"
		"	}"
		"	if(ss.size())"
		"	{"
		"		RetVal = rtrim( ss, ssep);"
		"	}"
		"	return RetVal;"
		"}"

	END PREPEND
End If

  IF Use_Strl THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: strl"
    FPRINT FP_WRITE,"char *strl (long double d)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register char *strtmp = BCX_TmpStr(32,1,1);"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(32,1,1);"
    FPRINT FP_WRITE,"  sprintf(strtmp,";D2$;",d);"
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_Curdir THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: curdir"
    FPRINT FP_WRITE,"char *curdir (void)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register char *strtmp = BCX_TmpStr(";csSizeOfDefaultString$;",1,1);"
    FPRINT FP_WRITE,"   char *strtmp = BCX_TmpStr(";csSizeOfDefaultString$;",1,1);"
    IF UseWinApi  THEN
      FPRINT FP_WRITE,"  GetCurrentDirectory (1024,strtmp);"
    ELSE
      'FPRINT FP_WRITE,"   char *res=getcwd(strtmp, 1024);"
      FPRINT FP_WRITE,"   getcwd(strtmp, 1024);"
    END IF
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_Hex THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: hex"
    FPRINT FP_WRITE,"char *hex (int a)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register char *strtmp = BCX_TmpStr(16,1,1);"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(16,1,1);"
    FPRINT FP_WRITE,"  sprintf(strtmp,";X1$;",a);"
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Tempdir THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: tempdir"
    FPRINT FP_WRITE,"char *tempdir (void)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register char *strtmp = BCX_TmpStr(";csSizeOfDefaultString$;",1,1);"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(";csSizeOfDefaultString$;",1,1);"
    FPRINT FP_WRITE,"  GetTempPath (1024,strtmp);"
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Windir THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: windir"
    FPRINT FP_WRITE,"char *windir (void)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register char *strtmp = BCX_TmpStr(";csSizeOfDefaultString$;",1,1);"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(";csSizeOfDefaultString$;",1,1);"
    FPRINT FP_WRITE,"  GetWindowsDirectory (strtmp,";cDefaultStringSize;");"
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Sysdir THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: sysdir"
    FPRINT FP_WRITE,"char *sysdir (void)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register char *strtmp = BCX_TmpStr(";cDefaultStringSize;",1,1);"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(";cDefaultStringSize;",1,1);"
    FPRINT FP_WRITE,"  GetSystemDirectory (strtmp,";cDefaultStringSize;");"
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Repeat THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: repeat"
    FPRINT FP_WRITE,"char *repeat (int count, const char *a)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register char *strtmp = BCX_TmpStr((1+count)*strlen(a),1,1);"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr((1+count)*strlen(a),1,1);"
    FPRINT FP_WRITE,"  while(count-->0) strtmp = strcat(strtmp, a);"
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_String THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: string"
    FPRINT FP_WRITE,"char *stringx (int count, int a)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  if(count<1) return BCX_TmpStr(1,1,1);"
    'FPRINT FP_WRITE,"  register char *strtmp = BCX_TmpStr(count,1,1);"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(count,1,1);"
    FPRINT FP_WRITE,"  return (char*)memset(strtmp,a,count);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Space THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: space"
    FPRINT FP_WRITE,"char *space (int count)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  if(count<1) return BCX_TmpStr(1,1,1);"
    'FPRINT FP_WRITE,"  register char *strtmp = BCX_TmpStr(count,1,1);"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(count,1,1);"
    FPRINT FP_WRITE,"  return (char*)memset(strtmp,32,count);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Time THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: timef"
    FPRINT FP_WRITE,"char *timef (int t, int u)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  time_t elapse_time;"
    FPRINT FP_WRITE,"  struct tm *tp;"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(256,1,1);"
    FPRINT FP_WRITE,"  time (&elapse_time);"
    FPRINT FP_WRITE,"  if(u==0)"
    FPRINT FP_WRITE,"    tp = localtime(&elapse_time);"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"    tp = gmtime(&elapse_time);"
    FPRINT FP_WRITE,"  switch (t)"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"   case 0:"
    FPRINT FP_WRITE,"   strftime(strtmp,256,",T0$, ",tp); break;"
    FPRINT FP_WRITE,"   case 1:"
    FPRINT FP_WRITE,"   strftime(strtmp,256,",T1$, ",tp); break;"
    FPRINT FP_WRITE,"   case 2:"
    FPRINT FP_WRITE,"   strftime(strtmp,256,",T2$, ",tp); break;"
    FPRINT FP_WRITE,"   case 3:"
    FPRINT FP_WRITE,"   strftime(strtmp,256,",T3$, ",tp); break;"
    FPRINT FP_WRITE,"   case 4:"
    FPRINT FP_WRITE,"   strftime(strtmp,256,",T4$, ",tp); break;"
    FPRINT FP_WRITE,"   case 5:"
    FPRINT FP_WRITE,"   strftime(strtmp,256,",T5$, ",tp); break;"
    FPRINT FP_WRITE,"   case 6:"
    FPRINT FP_WRITE,"   strftime(strtmp,256,",T6$, ",tp); break;"
    FPRINT FP_WRITE,"   case 7:"
    FPRINT FP_WRITE,"   strftime(strtmp,256,",T7$, ",tp); break;"
    FPRINT FP_WRITE,"   case 8:"
    FPRINT FP_WRITE,"   strftime(strtmp,256,",T8$, ",tp); break;"
    FPRINT FP_WRITE,"   case 9:"
    FPRINT FP_WRITE,"   strftime(strtmp,256,",T9$, ",tp); break;"
    FPRINT FP_WRITE,"   case 10:"
    FPRINT FP_WRITE,"   strftime(strtmp,256,",T10$, ",tp); break;"
    FPRINT FP_WRITE,"   case 11:"
    FPRINT FP_WRITE,"   strftime(strtmp,256,",T11$, ",tp); break;"
    FPRINT FP_WRITE,"  }"
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Enclose THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: enc"
    FPRINT FP_WRITE,"char *enc (const char *A, int L, int R)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"register int tmplen = strlen(A);"
    FPRINT FP_WRITE,"int tmplen = strlen(A);"
    'FPRINT FP_WRITE,"register char *BCX_RetStr = BCX_TmpStr(tmplen+3,1,1);"
    FPRINT FP_WRITE,"char *BCX_RetStr = BCX_TmpStr(tmplen+3,1,1);"
    FPRINT FP_WRITE,"memcpy(BCX_RetStr+1,A,tmplen);"
    FPRINT FP_WRITE,"*BCX_RetStr = (char)((L==0) ? 34 : L);"
    FPRINT FP_WRITE,"BCX_RetStr[++tmplen] = (char)((R==0) ? *BCX_RetStr : R);"
    FPRINT FP_WRITE,"BCX_RetStr[++tmplen] = 0;"
    FPRINT FP_WRITE,"return BCX_RetStr;"
    'FPRINT FP_WRITE,"  register char *BCX_RetStr = BCX_TmpStr(strlen(A)+3);"
    'FPRINT FP_WRITE,"  if(L==0) L=34;"
    'FPRINT FP_WRITE,"  if(R==0) R=L;"
    'FPRINT FP_WRITE,"  sprintf(BCX_RetStr,",ENC$("%c%s%c%s"),",L,A,R,",ENC$("\0"),");"
    'FPRINT FP_WRITE,"  return BCX_RetStr;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Chr THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: chr"
     FPRINT FP_WRITE,"char *chr (int a)"
     FPRINT FP_WRITE,"{"
     'FPRINT FP_WRITE,"  register char *strtmp = BCX_TmpStr(2,1,1);"
     FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(2,1,1);"
     FPRINT FP_WRITE,"  strtmp[0]  = a;"
     FPRINT FP_WRITE,"  return strtmp;"
'    FPRINT FP_WRITE,"char *chr (int a,int b,int c,int d,int e,int f,int g,int h,int i,int j)"
'    FPRINT FP_WRITE,"{"
'    FPRINT FP_WRITE,"  register char *strtmp = BCX_TmpStr(11);"
'    FPRINT FP_WRITE,"  strtmp[0]  = a;"
'    FPRINT FP_WRITE,"  strtmp[1]  = b;"
'    FPRINT FP_WRITE,"  strtmp[2]  = c;"
'    FPRINT FP_WRITE,"  strtmp[3]  = d;"
'    FPRINT FP_WRITE,"  strtmp[4]  = e;"
'    FPRINT FP_WRITE,"  strtmp[5]  = f;"
'    FPRINT FP_WRITE,"  strtmp[6]  = g;"
'    FPRINT FP_WRITE,"  strtmp[7]  = h;"
'    FPRINT FP_WRITE,"  strtmp[8]  = i;"
'    FPRINT FP_WRITE,"  strtmp[9]  = j;"
'    FPRINT FP_WRITE,"  strtmp[10] = 0;"
'    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_VChr THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: vchr"
    FPRINT FP_WRITE,"char *vchr(int charcount, ...)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register int c = 0, i = charcount;"
    FPRINT FP_WRITE,"  int c = 0, i = charcount;"
    FPRINT FP_WRITE,"  char *s_ = BCX_TmpStr(charcount + 1,1,1);"
    FPRINT FP_WRITE,"  va_list marker;"
    FPRINT FP_WRITE,"  s_[i] = 0;"
    FPRINT FP_WRITE,"  va_start(marker, charcount);"
    FPRINT FP_WRITE,"  while(i-- > 0) s_[c++] = va_arg(marker,int);"
    FPRINT FP_WRITE,"  va_end(marker);"
    FPRINT FP_WRITE,"  return s_;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Join THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: join"
    FPRINT FP_WRITE,"char * join(int n, ...)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register int i = n, tmplen = 0;"
    FPRINT FP_WRITE,"  int i = n, tmplen = 0;"
    'FPRINT FP_WRITE,"  register char *s_;"
    FPRINT FP_WRITE,"  char *s_;"
    'FPRINT FP_WRITE,"  register char *strtmp;"
    FPRINT FP_WRITE,"  char *strtmp;"
    FPRINT FP_WRITE,"  va_list marker;"
    FPRINT FP_WRITE,"  va_start(marker, n); // Initialize variable arguments"
    FPRINT FP_WRITE,"  while(i-- > 0)"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"    s_ = va_arg(marker, char *);"
    FPRINT FP_WRITE,"    if(s_) tmplen += strlen(s_);"
    FPRINT FP_WRITE,"  }"
    FPRINT FP_WRITE,"  strtmp = BCX_TmpStr(tmplen,1,1);"
    FPRINT FP_WRITE,"  va_end(marker); // Reset variable arguments"
    FPRINT FP_WRITE,"  i = n;"
    FPRINT FP_WRITE,"  va_start(marker, n); // Initialize variable arguments"
    FPRINT FP_WRITE,"  while(i-- > 0)"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"    s_ = va_arg(marker, char *);"
    FPRINT FP_WRITE,"    if(s_) strcat(strtmp, s_);"
    FPRINT FP_WRITE,"  }"
    FPRINT FP_WRITE,"  va_end(marker); // Reset variable arguments"
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Environ THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Environ"
    FPRINT FP_WRITE,"char* Environ(const char *S)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(32767,1,1);"
    FPRINT FP_WRITE,"  GetEnvironmentVariable((char*)S,strtmp, 32767);"
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Oct THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: oct"
    FPRINT FP_WRITE,"char *oct (int a)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(";cDefaultStringSize;",1,1);"
    FPRINT FP_WRITE,"  sprintf(strtmp,";O1$;",a);"
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_Bin THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Bin"
    FPRINT FP_WRITE,"char* Bin(int number)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(";cDefaultStringSize;",1,1);"
    FPRINT FP_WRITE,"   _itoa(number,strtmp,2);"
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_Getch Then
  	IF TargetOS = TNIX Then
  		FPRINT FP_WRITE,"int _getch(void)"
  		FPRINT FP_WRITE,"{"
  		FPRINT FP_WRITE,"  struct termios oldt, newt;"
  		FPRINT FP_WRITE,"  int ch;"
  		FPRINT FP_WRITE,"  tcgetattr( STDIN_FILENO, &oldt );"
  		FPRINT FP_WRITE,"  newt = oldt;"
  		FPRINT FP_WRITE,"  newt.c_lflag &= ~( ICANON | ECHO );"
  		FPRINT FP_WRITE,"  tcsetattr( STDIN_FILENO, TCSANOW, &newt );"
  		FPRINT FP_WRITE,"  ch = getchar();"
  		FPRINT FP_WRITE,"  tcsetattr( STDIN_FILENO, TCSANOW, &oldt );"
  		FPRINT FP_WRITE,"  return ch;"
        FPRINT FP_WRITE,"}"
  	End If
  End If

  IF Use_Pause THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Pause"
    FPRINT FP_WRITE,"void Pause(void)"
    FPRINT FP_WRITE,"{"
	

    IF UseWinApi Then
    'IF UseCpp = FALSE THEN
    '  FPRINT FP_WRITE,"  printf(", ENC$("\\n%s\\n"), ",", ENC$("Press any key to continue . . ."), ");"
    '  FPRINT FP_WRITE,"  keypress();"
    'ELSE
      FPRINT FP_WRITE,"  printf(", ENC$("\\n%s\\n"), ",", ENC$("Press any key to continue . . ."), ");"
      'IF TargetOS = TNIX THEN
      '  FPRINT FP_WRITE,"  _getch_(TRUE);"
      'ELSE
        FPRINT FP_WRITE,"  _getch();"
      'END IF
    'END IF
    ElseIf Use_TCLib Then
		FPRINT FP_WRITE,"  printf(", ENC$("\\n%s\\n"), ",", ENC$("Press any key to continue . . ."), ");"
		'FPRINT FP_WRITE,"  getchar();"
		FPRINT FP_WRITE,"  _getwch();"
		
    Else
		FPRINT FP_WRITE,"system(",ENC$("pause"),");"
    End If
    FPRINT FP_WRITE,sENDBCXRTLIB$


  END IF

  IF Use_Keypress THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: keypress"
    FPRINT FP_WRITE,"int keypress(void)"
    FPRINT FP_WRITE,"{"
    IF (UseCpp = FALSE) AND (UseWinApi ) THEN
      'FPRINT FP_WRITE,"  register int ch = 0;"
      FPRINT FP_WRITE,"  int ch = 0;"
      FPRINT FP_WRITE,"  INPUT_RECORD InputRecord;"
      FPRINT FP_WRITE,"  DWORD Count = 0, cks;"
      FPRINT FP_WRITE,"  WORD vkc, vsc;"
      FPRINT FP_WRITE,"  HANDLE hStdIn = GetStdHandle(STD_INPUT_HANDLE);"
      FPRINT FP_WRITE,"  PeekConsoleInput(hStdIn, &InputRecord, 1, &Count);"
      FPRINT FP_WRITE,"  DWORD OldConsoleMode;"
      FPRINT FP_WRITE,"  GetConsoleMode(hStdIn, &OldConsoleMode);"
      FPRINT FP_WRITE,"  SetConsoleMode(hStdIn, 0);"
      'FPRINT FP_WRITE,"  register int i = 0;"
      FPRINT FP_WRITE,"  int i = 0;"
      FPRINT FP_WRITE,"  static char uchr[44];"
      FPRINT FP_WRITE,"  static char lchr[44];"
      FPRINT FP_WRITE,"  strcpy(uchr,";DQ$;"\\x7E\\x21\\x40\\x23\\x24\\x25\\x5E\\x26\\x2A\\x28\\x29\\x5F\\x2B\\x7C\\x7B\\x7D\\x3A\\x22\\x3C\\x3E\\x3F\\x60\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x30\\x2D\\x3D\\x5C\\x5B\\x5D\\x3B\\x27\\x2C\\x2E\\x2F\\x00";DQ$;");"
      FPRINT FP_WRITE,"  strcpy(lchr,";DQ$;"\\x60\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x30\\x2D\\x3D\\x5C\\x5B\\x5D\\x3B\\x27\\x2C\\x2E\\x2F\\x7E\\x21\\x40\\x23\\x24\\x25\\x5E\\x26\\x2A\\x28\\x29\\x5F\\x2B\\x7C\\x7B\\x7D\\x3A\\x22\\x3C\\x3E\\x3F\\x00";DQ$;");"
      FPRINT FP_WRITE,"  do"
      FPRINT FP_WRITE,"  {"
      FPRINT FP_WRITE,"   ReadConsoleInput(hStdIn, &InputRecord, 1, &Count);"
      FPRINT FP_WRITE,"   SetConsoleMode(hStdIn, OldConsoleMode);"
      FPRINT FP_WRITE,"   if (Count && InputRecord.EventType == KEY_EVENT"
      FPRINT FP_WRITE,"     && InputRecord.Event.KeyEvent.bKeyDown)"
      FPRINT FP_WRITE,"   {"
      FPRINT FP_WRITE,"  vkc = InputRecord.Event.KeyEvent.wVirtualKeyCode;"
      FPRINT FP_WRITE,"  vsc = InputRecord.Event.KeyEvent.wVirtualScanCode;"
      FPRINT FP_WRITE,"  ch = InputRecord.Event.KeyEvent.uChar.AsciiChar;"
      FPRINT FP_WRITE,"  cks = InputRecord.Event.KeyEvent.dwControlKeyState;"
      FPRINT FP_WRITE,"  FlushConsoleInputBuffer(hStdIn);"
      FPRINT FP_WRITE,"  if((!ch && vsc>58))"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      if((cks & 3))"
      FPRINT FP_WRITE,"        {"
      FPRINT FP_WRITE,"          return (1000+vsc)*(-1);"
      FPRINT FP_WRITE,"        }"
      FPRINT FP_WRITE,"      if((cks & 12))"
      FPRINT FP_WRITE,"        {"
      FPRINT FP_WRITE,"          return (2000+vsc)*(-1);"
      FPRINT FP_WRITE,"        }"
      FPRINT FP_WRITE,"      return vsc*(-1);"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"  if (ch && (cks & 3))"
      FPRINT FP_WRITE,"   return vkc + 1000;"
      FPRINT FP_WRITE,"  if ((vsc == 15) && (cks & 16))"
      FPRINT FP_WRITE,"   return 15;"
      FPRINT FP_WRITE,"  if (vkc == 27)"
      FPRINT FP_WRITE,"   return 27;"
      FPRINT FP_WRITE,"  if (ch && (cks & 128))"
      FPRINT FP_WRITE,"  {"
      FPRINT FP_WRITE,"   for (i = 0; i <= strlen(lchr); i++)"
      FPRINT FP_WRITE,"   {"
      FPRINT FP_WRITE,"    if (uchr[i] == ch)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"     ch = lchr[i];"
      FPRINT FP_WRITE,"     break;"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"   }"
      FPRINT FP_WRITE,"  }"
      FPRINT FP_WRITE,"  if (ch)"
      FPRINT FP_WRITE,"   return ch;"
      FPRINT FP_WRITE,"   }"
      FPRINT FP_WRITE,"  }while (TRUE);"
      FPRINT FP_WRITE,"   return 0;"
    ELSE
'      IF TargetOS = TNIX THEN
'        FPRINT FP_WRITE,"  return _getch(TRUE);"
'      ELSE
        FPRINT FP_WRITE,"  return _getch();"
'      END IF
    END IF
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Inkey THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: inkey"
    FPRINT FP_WRITE,"char* inkey(void)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(2,1,1);"
    FPRINT FP_WRITE,"  if (kbhit())"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"     int asccodereturn = getch();"
    FPRINT FP_WRITE,"     strtmp[0] = asccodereturn;"
    FPRINT FP_WRITE,"     strtmp[1] = 0;"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_InkeyD THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: inkeyd"
    FPRINT FP_WRITE,"int inkeyd(void)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register int ch = 0;"
    FPRINT FP_WRITE,"  int ch = 0;"
    FPRINT FP_WRITE,"  INPUT_RECORD InputRecord;"
    FPRINT FP_WRITE,"  DWORD Count = 0, cks;"
    FPRINT FP_WRITE,"  WORD vkc, vsc;"
    FPRINT FP_WRITE,"  HANDLE hStdIn = GetStdHandle(STD_INPUT_HANDLE);"
    FPRINT FP_WRITE,"  PeekConsoleInput(hStdIn, &InputRecord, 1, &Count);"
    FPRINT FP_WRITE,"  DWORD OldConsoleMode;"
    FPRINT FP_WRITE,"  GetConsoleMode(hStdIn, &OldConsoleMode);"
    FPRINT FP_WRITE,"  SetConsoleMode(hStdIn, 0);"
    'FPRINT FP_WRITE,"  register int i = 0;"
    FPRINT FP_WRITE,"  int i = 0;"
    FPRINT FP_WRITE,"  static char uchr[44];"
    FPRINT FP_WRITE,"  static char lchr[44];"
    FPRINT FP_WRITE,"  strcpy(uchr,";DQ$;"\\x7E\\x21\\x40\\x23\\x24\\x25\\x5E\\x26\\x2A\\x28\\x29\\x5F\\x2B\\x7C\\x7B\\x7D\\x3A\\x22\\x3C\\x3E\\x3F\\x60\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x30\\x2D\\x3D\\x5C\\x5B\\x5D\\x3B\\x27\\x2C\\x2E\\x2F\\x00";DQ$;");"
    FPRINT FP_WRITE,"  strcpy(lchr,";DQ$;"\\x60\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x30\\x2D\\x3D\\x5C\\x5B\\x5D\\x3B\\x27\\x2C\\x2E\\x2F\\x7E\\x21\\x40\\x23\\x24\\x25\\x5E\\x26\\x2A\\x28\\x29\\x5F\\x2B\\x7C\\x7B\\x7D\\x3A\\x22\\x3C\\x3E\\x3F\\x00";DQ$;");"
    FPRINT FP_WRITE,"  ReadConsoleInput(hStdIn, &InputRecord, 1, &Count);"
    FPRINT FP_WRITE,"  SetConsoleMode(hStdIn, OldConsoleMode);"
    FPRINT FP_WRITE,"  if (Count && InputRecord.EventType == KEY_EVENT"
    FPRINT FP_WRITE,"     && InputRecord.Event.KeyEvent.bKeyDown)"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"    vkc = InputRecord.Event.KeyEvent.wVirtualKeyCode;"
    FPRINT FP_WRITE,"    vsc = InputRecord.Event.KeyEvent.wVirtualScanCode;"
    FPRINT FP_WRITE,"    ch = InputRecord.Event.KeyEvent.uChar.AsciiChar;"
    FPRINT FP_WRITE,"    cks = InputRecord.Event.KeyEvent.dwControlKeyState;"
    FPRINT FP_WRITE,"    FlushConsoleInputBuffer(hStdIn);"
    FPRINT FP_WRITE,"    if(!ch && vsc>58)"
    FPRINT FP_WRITE,"     {"
    FPRINT FP_WRITE,"       if(cks & 3) return (1000+vsc)*(-1);"
    FPRINT FP_WRITE,"       if(cks & 12) return (2000+vsc)*(-1);"
    FPRINT FP_WRITE,"       return vsc*(-1);"
    FPRINT FP_WRITE,"     }"
    FPRINT FP_WRITE,"    if (ch && (cks & 3)) return vkc + 1000;"
    FPRINT FP_WRITE,"    if ((vsc == 15) && (cks & 16)) return 15;"
    FPRINT FP_WRITE,"    if (vkc == 27) return 27;"
    FPRINT FP_WRITE,"    if (ch && (cks & 128))"
    FPRINT FP_WRITE,"     {"
    FPRINT FP_WRITE,"      for (i = 0; i <= strlen(lchr); i++)"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"          if (uchr[i] == ch)"
    FPRINT FP_WRITE,"            {"
    FPRINT FP_WRITE,"             ch = lchr[i];"
    FPRINT FP_WRITE,"             break;"
    FPRINT FP_WRITE,"           }"
    FPRINT FP_WRITE,"       }"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"    if (ch) return ch;"
    FPRINT FP_WRITE,"  }"
    FPRINT FP_WRITE,"  return 0;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_Date THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: date"
    FPRINT FP_WRITE,"char *date (int u)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  time_t elapse_time;"
    FPRINT FP_WRITE,"  struct tm *tp;"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(";cDefaultStringSize;",1,1);"
    FPRINT FP_WRITE,"  time(&elapse_time);"
    FPRINT FP_WRITE,"  if(u==0)"
    FPRINT FP_WRITE,"    tp = localtime(&elapse_time);"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"    tp = gmtime(&elapse_time);"
    FPRINT FP_WRITE,"  strftime(strtmp,256,", ENC$("%m/%d/%y"), ",tp);"
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_Now THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: now"
    FPRINT FP_WRITE,"char *now (int u)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  time_t elapse_time;"
    FPRINT FP_WRITE,"  struct tm *tp;"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(";cDefaultStringSize;",1,1);"
    FPRINT FP_WRITE,"  time(&elapse_time);"
    FPRINT FP_WRITE,"  if(u==0)"
    FPRINT FP_WRITE,"    tp = localtime(&elapse_time);"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"    tp = gmtime(&elapse_time);"
    FPRINT FP_WRITE,"  strftime(strtmp,256,", ENC$("%m/%d/%y %I:%M:%S %p"), ",tp);"
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Hook THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: SBProc"
    FPRINT FP_WRITE,"LRESULT CALLBACK SBProc (int Msg, WPARAM wParam, LPARAM lParam)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  if(Msg==HCBT_ACTIVATE)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"     static  RECT  rc1;"
    FPRINT FP_WRITE,"     static  RECT  rc2;"
    FPRINT FP_WRITE,"     GetWindowRect(GetDesktopWindow(),&rc1);"
    FPRINT FP_WRITE,"     GetWindowRect((HWND)wParam,&rc2);"
    FPRINT FP_WRITE,"     SetWindowPos((HWND)wParam,HWND_TOP,(rc1.left+rc1.right-rc2.right+rc2.left)/2,"
    FPRINT FP_WRITE,"     (rc1.top+rc1.bottom-rc2.bottom+rc2.top)/2,0,0,SWP_NOSIZE|SWP_NOACTIVATE);"
    FPRINT FP_WRITE,"     UnhookWindowsHookEx(CmDlgHook);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  return 0;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Getfilename THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: GetFileName"
    FPRINT FP_WRITE,"char *GetFileName(const char *Title,const char *Filter,int Flag,HWND hWnd,DWORD Flags,const char *InitialDir,const char *Initfname,int *ExtIdx)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  OPENFILENAME OpenFileStruct = {0};"
    FPRINT FP_WRITE,"  char Extension[256];"
    FPRINT FP_WRITE,"  UINT  Counter=0, TmpSize;"
    FPRINT FP_WRITE,"  static char *filename;"
    FPRINT FP_WRITE,"  static UINT BufSize;"
    FPRINT FP_WRITE,"  TmpSize = ((Flags&OFN_ALLOWMULTISELECT) ? 500000:MAX_PATH);"
    FPRINT FP_WRITE,"  if(TmpSize>BufSize)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      BufSize=TmpSize;"
    FPRINT FP_WRITE,"      filename=(char*)realloc(filename, BufSize);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  memset(filename,0,BufSize);"
    FPRINT FP_WRITE,"  memset(Extension,0,256);"
    'FPRINT FP_WRITE,"  memset(&OpenFileStruct,0,sizeof(OpenFileStruct));"
    FPRINT FP_WRITE,"  if(Initfname) strcpy(filename,Initfname);"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"  for(Counter=0;Counter<=strlen(Filter);Counter++)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      if(Filter[Counter]=='|')"
    FPRINT FP_WRITE,"          Extension[Counter]=0;"
    FPRINT FP_WRITE,"      else"
    FPRINT FP_WRITE,"          Extension[Counter]=Filter[Counter];"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  CmDlgHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)SBProc,(HINSTANCE)NULL,GetCurrentThreadId());"
    FPRINT FP_WRITE,"  OpenFileStruct.lStructSize=sizeof(OpenFileStruct);"
    FPRINT FP_WRITE,"  OpenFileStruct.hwndOwner=hWnd;"
    FPRINT FP_WRITE,"  OpenFileStruct.hInstance=0;"
    FPRINT FP_WRITE,"  OpenFileStruct.lpstrFilter=Extension;"
    FPRINT FP_WRITE,"  OpenFileStruct.lpstrTitle=Title;"
    FPRINT FP_WRITE,"  OpenFileStruct.nMaxFile=BufSize;"
    FPRINT FP_WRITE,"  OpenFileStruct.nMaxFileTitle=0;"
    FPRINT FP_WRITE,"  OpenFileStruct.lpstrFile=filename;"
    FPRINT FP_WRITE,"  OpenFileStruct.lpstrFileTitle=NULL;"
    FPRINT FP_WRITE,"  OpenFileStruct.lpstrCustomFilter=0;"
    FPRINT FP_WRITE,"  OpenFileStruct.nMaxCustFilter=0;"
    FPRINT FP_WRITE,"  if(ExtIdx) OpenFileStruct.nFilterIndex=*ExtIdx;"
    FPRINT FP_WRITE,"  OpenFileStruct.lpstrInitialDir=InitialDir;"
    FPRINT FP_WRITE,"  OpenFileStruct.nFileOffset=0;"
    FPRINT FP_WRITE,"  OpenFileStruct.nFileExtension=0;"
    FPRINT FP_WRITE,"  OpenFileStruct.lpstrDefExt=0;"
    FPRINT FP_WRITE,"  OpenFileStruct.lCustData=0;"
    FPRINT FP_WRITE,"  OpenFileStruct.lpfnHook=0;"
    FPRINT FP_WRITE,"  OpenFileStruct.lpTemplateName=0;"
    FPRINT FP_WRITE,"  if(!Flags)"
    FPRINT FP_WRITE,"      OpenFileStruct.Flags = OFN_HIDEREADONLY | OFN_CREATEPROMPT | OFN_EXPLORER;"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"      OpenFileStruct.Flags = Flags | OFN_EXPLORER;"
    FPRINT FP_WRITE,"  if(!Flag)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      if(GetOpenFileName(&OpenFileStruct)==0)"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"          *filename=0;"
    FPRINT FP_WRITE,"        }else{"
    FPRINT FP_WRITE,"          int len=strlen(filename);"
    FPRINT FP_WRITE,"          if(filename[len+1]==0) return filename;"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"          char *fname = filename+len;"
    FPRINT FP_WRITE,"          while(fname[1])"
    FPRINT FP_WRITE,"            {"
    FPRINT FP_WRITE,"              *fname= ',';"
    FPRINT FP_WRITE,"              len=strlen(++fname);"
    FPRINT FP_WRITE,"              fname+=len;"
    FPRINT FP_WRITE,"            }"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      if(GetSaveFileName(&OpenFileStruct)==0) *filename=0;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if(ExtIdx) *ExtIdx=OpenFileStruct.nFilterIndex;"
    FPRINT FP_WRITE,"  return filename;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_AppExePath THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: AppExePath"
    FPRINT FP_WRITE,"char *AppExePath (void)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE," char *strtmp = BCX_TmpStr(";cDefaultStringSize;",1,1);"
    'FPRINT FP_WRITE," register int i;"
    FPRINT FP_WRITE," int i;"
    FPRINT FP_WRITE," i=GetModuleFileName(GetModuleHandle(0),strtmp,";cDefaultStringSize;");"
    FPRINT FP_WRITE," while(i && strtmp[i] != 0x5C)"
    FPRINT FP_WRITE,"   i--;"
    FPRINT FP_WRITE," strtmp[i+1] = 0;"
    FPRINT FP_WRITE," return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_AppExeName THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: AppExeName"
    FPRINT FP_WRITE,"char *AppExeName (void)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(";cDefaultStringSize;",1,1);"
    'FPRINT FP_WRITE,"  register int i;"
    FPRINT FP_WRITE,"  int i;"
    FPRINT FP_WRITE,"  i=GetModuleFileName(GetModuleHandle(NULL),strtmp,";cDefaultStringSize;");"
    FPRINT FP_WRITE,"  while(i && strtmp[i] != 0x5C)"
    FPRINT FP_WRITE,"    i--;"
    FPRINT FP_WRITE,"  return &strtmp[i+1];"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_TempFileName THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: TempFileName"
    FPRINT FP_WRITE,"char *TempFileName (const char *Folder,const char*Prefix)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(";cDefaultStringSize;",1,1);"
    FPRINT FP_WRITE,"  GetTempFileName((char*)Folder,(char*)Prefix,0,strtmp);"
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Boolstr THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BoolStr"
    FPRINT FP_WRITE,"char * BoolStr (int a)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *BCX_RetStr=BCX_TmpStr(5,1,1);"
    FPRINT FP_WRITE,"  if(a) return strcpy(BCX_RetStr,",ENC$("True"),");"
    FPRINT FP_WRITE,"  return strcpy(BCX_RetStr,",ENC$("False"),");"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Using THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Using"
    FPRINT FP_WRITE,"char *Using (const char *Mask, double Num)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register int Spaces = 0;"
    FPRINT FP_WRITE,"  int Spaces = 0;"
    'FPRINT FP_WRITE,"  register int CntDec = 0;"
    FPRINT FP_WRITE,"  int CntDec = 0;"
    'FPRINT FP_WRITE,"  register int Decimals = 0;"
    FPRINT FP_WRITE,"  int Decimals = 0;"
    'FPRINT FP_WRITE,"  register int Dollar = 0;"
    FPRINT FP_WRITE,"  int Dollar = 0;"
    FPRINT FP_WRITE,"  char* BCX_RetStr = BCX_TmpStr(512,1,1);"
    FPRINT FP_WRITE,"  char Buf_1[512]={0};"
    FPRINT FP_WRITE,"  char* p = (char*)Mask;"
    FPRINT FP_WRITE,"  char* r;"
    FPRINT FP_WRITE,"  int  len;"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"  while (*p)"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"    if (*p == 36) Dollar++;"
    FPRINT FP_WRITE,"    if (*p == 32) Spaces++;"
    FPRINT FP_WRITE,"    if ((*p == 32 || *p == 35)&& CntDec) Decimals++;"
    FPRINT FP_WRITE,"    if (*p == 46) CntDec = 1;"
    FPRINT FP_WRITE,"    p++;"
    FPRINT FP_WRITE,"  }"
    FPRINT FP_WRITE,"  sprintf(Buf_1,", ENC$("%1.*f"), ",Decimals,Num);"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"  len = strlen(Buf_1)-Decimals-(Decimals>0?1:0);"
    FPRINT FP_WRITE,"  r = BCX_RetStr+Dollar+Spaces;"
    FPRINT FP_WRITE,"  p = Buf_1;"
    FPRINT FP_WRITE,"  while (*p)"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"     *r++ = *p++;"
    FPRINT FP_WRITE,"     if (--len>2 && *(p-1) != '-' && len % 3 == 0)"
    FPRINT FP_WRITE,"       {"
    FPRINT FP_WRITE,"         *r++ = ',';"
    FPRINT FP_WRITE,"       }"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"  if(Dollar) BCX_RetStr[Spaces]=36;"
    FPRINT FP_WRITE,"  if(Spaces) memset(BCX_RetStr,32,Spaces);"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"  return BCX_RetStr;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_SearchPath THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: SEARCHPATH"
    FPRINT FP_WRITE,"char *SEARCHPATH (const char *szFile)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *BCX_RetStr=BCX_TmpStr(MAX_PATH+1,1,1);"
    FPRINT FP_WRITE,"  LPSTR lpbs=0;"
    FPRINT FP_WRITE,"  SearchPath(0,(char*)szFile,0,MAX_PATH,BCX_RetStr,&lpbs);"
    FPRINT FP_WRITE,"  if(lpbs) *lpbs=0;"
    FPRINT FP_WRITE,"  return BCX_RetStr;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Instrrev THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: InstrRev"
    FPRINT FP_WRITE,"int InstrRev (const char *s, const char *p, int os, int sens)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE," int sl, pl, ox;"
    FPRINT FP_WRITE," int (*cmp)(const char *, const char *, size_t );"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE," if (!s || !p)  return 0;"
    FPRINT FP_WRITE," sl  = strlen(s); pl  = strlen(p);"
    FPRINT FP_WRITE," if (os > sl || sl == 0 || pl == 0 || (ox = sl - pl) < 0)"
    FPRINT FP_WRITE,"   return 0;"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE," if (os <= 0)  "
    FPRINT FP_WRITE,"   os = ox ;"
    FPRINT FP_WRITE," else if(os >= pl)"
    FPRINT FP_WRITE,"   os = os - pl ;"
    FPRINT FP_WRITE," else"
    FPRINT FP_WRITE,"   return 0;"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE," cmp = (sens ? strnicmp : strncmp);"
    FPRINT FP_WRITE," do { if (cmp(s + os , p, pl) == 0)"
    FPRINT FP_WRITE,"       return os+1;"
    FPRINT FP_WRITE,"    } while (os--);"
    FPRINT FP_WRITE," return 0;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Instr THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: instr"
'jcfuller added 3/13/2013 cheatin a bit again with a call to char ptr
    IF UseCpphdr And Not Use_TCLib THEN
    	Prepend FPRINT FP_WRITE,
    	  "int instr(std::string mane,std::string match,int offset,int sensflag)"
    	  "{"
    	  "  char* m1;"
    	  "  char* m2;"
    	  "  m1 = (char*)mane.c_str();"
    	  "  m2 = (char*)match.c_str();"
    	  "  return instr(m1,m2,offset,sensflag);"
    	  "}"
    	End Prepend
    End If

    FPRINT FP_WRITE,"int instr(const char* mane,const char* match,int offset,int sensflag)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register char *s;"
    FPRINT FP_WRITE,"  char *s;"
    FPRINT FP_WRITE,"  if (!mane || !match || ! *match || offset>(int)strlen(mane)) return 0;"
    FPRINT FP_WRITE,"  if (sensflag)"
    FPRINT FP_WRITE,"    s = _stristr_(offset>0 ? (char*)mane+offset-1 : (char*)mane,(char*)match);"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"    s = _strstr_(offset>0 ? (char*)mane+offset-1 : (char*)mane,(char*)match);"
    FPRINT FP_WRITE,"  return s ? (int)(s-mane)+1 : 0;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

'jcfuller changed
  IF UseLCaseTbl THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: MakeLCaseTbl"
    IF UseWinApi Then
        FPRINT FP_WRITE,"char  *MakeLCaseTbl (void)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"  static char tbl[257];"
        FPRINT FP_WRITE,"      int i; for (i=0; i < 256; i++)"
        FPRINT FP_WRITE,"  tbl[i] = i;"
        FPRINT FP_WRITE,"  tbl[0] = 1;"
        FPRINT FP_WRITE,"  tbl[256] = 0;"
        FPRINT FP_WRITE,"  CharLowerA((char *)tbl);"
        FPRINT FP_WRITE,"  tbl[0] = 0;"
        FPRINT FP_WRITE,"  return tbl;"
        FPRINT FP_WRITE,sENDBCXRTLIB$
     ELSE
        IF UseCpphdr And Not Use_TCLib THEN
			FPRINT FP_WRITE,"char  *MakeLCaseTbl (void)"
			FPRINT FP_WRITE,"{"
			FPRINT FP_WRITE,"  static char tbl[257];"
			FPRINT FP_WRITE,"  string s;"
			FPRINT FP_WRITE,"  int i; for (i=0; i < 256; i++)"
			FPRINT FP_WRITE,"  tbl[i] = i;"
			FPRINT FP_WRITE,"  tbl[0] = 1;"
			FPRINT FP_WRITE,"  tbl[256] = 0;"
			'FPRINT FP_WRITE,"  CharLowerA((char *)tbl);"
			FPRINT FP_WRITE,"  s = tbl;"
			FPRINT FP_WRITE,"  s = lcase(s);"
			FPRINT FP_WRITE,"  strcpy(tbl,s.c_str());"
			FPRINT FP_WRITE,"  tbl[0] = 0;"
			FPRINT FP_WRITE,"  return tbl;"
        ELSE
			FPRINT FP_WRITE,"char  *MakeLCaseTbl (void)"
			FPRINT FP_WRITE,"{"
			FPRINT FP_WRITE,"  static char tbl[256];"
			FPRINT FP_WRITE,"  if(!tbl['a'])"
			FPRINT FP_WRITE,"    {"
			FPRINT FP_WRITE,"      int i; for (i=0; i < 256; i++)"
			FPRINT FP_WRITE,"        tbl[i] = (char)(int)tolower(i);"
			FPRINT FP_WRITE,"    }"
			FPRINT FP_WRITE,"  return tbl;"
        END IF
        'FPRINT FP_WRITE,"}\n\n"
        FPRINT FP_WRITE,sENDBCXRTLIB$
     END IF
  END IF


  IF Use_Stristr THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: _stristr_"
    FPRINT FP_WRITE,"char *_stristr_(char *String, char *Pattern)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int   mi=-1;"
    FPRINT FP_WRITE,"  while(Pattern[++mi])"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"     if(String[mi]==0) return 0;"
    FPRINT FP_WRITE,"     if(LowCase[(unsigned char)String[mi]]!=LowCase[(unsigned char)Pattern[mi]])"
    FPRINT FP_WRITE,"       { String++; mi=-1; }"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"  return String;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_StrStr THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: _strstr_"
    FPRINT FP_WRITE,"char *_strstr_(char *String, char *Pattern)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int   mi=-1;"
    FPRINT FP_WRITE,"  while(Pattern[++mi])"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"     if(String[mi]==0) return 0;"
    FPRINT FP_WRITE,"     if(String[mi]!=Pattern[mi])"
    FPRINT FP_WRITE,"       { String++; mi=-1; }"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"  return String;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Inchr THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: inchr"
    FPRINT FP_WRITE,"int inchr (const char *A, const char *B)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register const char* C=A;"
    FPRINT FP_WRITE,"  const char* C=A;"
    FPRINT FP_WRITE,"  while(*C)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      if(*C==*B) return C-A+1;"
    FPRINT FP_WRITE,"      C++;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  return 0;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Asc THEN
    'IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: asc"
    FPRINT FP_WRITE,"extern int asc (char *z,int index)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  return (unsigned char) z[index];"
    FPRINT FP_WRITE,"}\n\n"
    'IF Use_Library THEN FPRINT FP_WRITE,"// ENDBCXRTLIB"
  END IF


  IF Use_Sgn THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: sgn"
    FPRINT FP_WRITE,"double sgn (double a)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  if(a<0) return -1;"
    FPRINT FP_WRITE,"  if(a>0) return  1;"
    FPRINT FP_WRITE,"  return  0;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Round THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Round"
    FPRINT FP_WRITE,"double Round (double n, int d)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  return (floor((n)*pow(10.0,(d))+0.5)/pow(10.0,(d)));"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Exist THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Exist"
    IF UseWinApi OR Use_TCLib Then
      FPRINT FP_WRITE,"BOOL Exist (const char *szFilePath)"
      FPRINT FP_WRITE,"{"
      FPRINT FP_WRITE,"  if(strchr(szFilePath, '*') || strchr(szFilePath, '?'))"
      FPRINT FP_WRITE,"  return Exist_A ((char*)szFilePath);"
      FPRINT FP_WRITE,"  return Exist_B ((char*)szFilePath);"
      FPRINT FP_WRITE,"}"
      FPRINT FP_WRITE,""
      FPRINT FP_WRITE,"BOOL Exist_A (char *szFilePath)"
      FPRINT FP_WRITE,"{"
      FPRINT FP_WRITE,"  WIN32_FIND_DATA W32FindData;"
      FPRINT FP_WRITE,"  HANDLE rc;"
      FPRINT FP_WRITE,"  rc = FindFirstFile(szFilePath, &W32FindData);"
      FPRINT FP_WRITE,"  if(rc == INVALID_HANDLE_VALUE) return FALSE;"
      FPRINT FP_WRITE,"  FindClose(rc);"
      FPRINT FP_WRITE,"  return TRUE;"
      FPRINT FP_WRITE,"}"
      FPRINT FP_WRITE,""
      FPRINT FP_WRITE,"BOOL Exist_B (char *szFilePath)"
      FPRINT FP_WRITE,"{"
      FPRINT FP_WRITE,"  DWORD ret;"
      FPRINT FP_WRITE,"  ret = GetFileAttributes(szFilePath);"
      FPRINT FP_WRITE,"  if (ret != 0xffffffff) return TRUE;"
      FPRINT FP_WRITE,"  return FALSE;"
    ELSE
      FPRINT FP_WRITE,"int Exist(const char *filename) {"
      FPRINT FP_WRITE,"struct stat buffer;"
      FPRINT FP_WRITE,"return (stat ((char*)filename, &buffer) == 0);"

    END IF
      FPRINT FP_WRITE,sENDBCXRTLIB$

  END IF

'jcfuller added 2011-12-26
  IF Use_Clipboard Then
    FPRINT FP_WRITE,"void ClipboardSetText( char *text_to_set )"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"    INT dwLen;"
    FPRINT FP_WRITE,"    HGLOBAL hgbl;"
    FPRINT FP_WRITE,"    CHAR *pmem;"
    FPRINT FP_WRITE,"    dwLen = strlen( text_to_set );"
    FPRINT FP_WRITE,"    hgbl = GlobalAlloc( GHND, dwLen + 1 );"
    FPRINT FP_WRITE,"    if( hgbl != NULL )"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"        pmem = (CHAR*)GlobalLock( hgbl );"
    FPRINT FP_WRITE,"        strcpy( pmem, text_to_set );"
    FPRINT FP_WRITE,"        GlobalUnlock( hgbl );"
    FPRINT FP_WRITE,"        OpenClipboard( NULL );"
    FPRINT FP_WRITE,"        EmptyClipboard( );"
    FPRINT FP_WRITE,"        SetClipboardData( CF_TEXT, hgbl );"
    FPRINT FP_WRITE,"        CloseClipboard( );"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"}"
  	FPRINT FP_WRITE,"//----------------------------------------"
  	PREPEND FPRINT FP_WRITE,
		"char* ClipboardGetText ()"
		"{"
		"  HGLOBAL  hGlobal=0;"
		"  PTSTR    pGlobal=0;"
		"  static PTSTR    pText;"
		"  BOOL     bAvailable;"
		"  bAvailable= IsClipboardFormatAvailable( CF_TEXT);"
		"  if(bAvailable==0 )"
		"    {"
		"      return NULL;"
		"    }"
		"  OpenClipboard(NULL);"
		"  hGlobal= GetClipboardData( CF_TEXT);"
		"  if(hGlobal )"
		"    {"
		"      pGlobal=( char*) GlobalLock( hGlobal);"
		"      if(pText )"
		"        {"
		"          free(pText), pText=NULL;"
		"        }"
		"      pText=( char*) malloc( GlobalSize( hGlobal));"
		"      lstrcpy(pText,pGlobal);"
		"      GlobalUnlock(hGlobal);"
		"    }"
		"  CloseClipboard();"
		"  return pText;"
		"}"
 		"//----------------------------------------"
		"DWORD ClipboardGetTextSize ()"
		"{"
		"  HGLOBAL  hGlobal=0;"
		"  DWORD    size;"
		"  OpenClipboard(NULL);"
		"  hGlobal= GetClipboardData( CF_TEXT);"
		"  if(hGlobal )"
		"    {"
		"      GlobalLock(hGlobal);"
		"      size= GlobalSize( hGlobal);"
		"      GlobalUnlock(hGlobal);"
		"    }"
		"  CloseClipboard();"
		"  return size;"
		"}"
  	END PREPEND
  End If


  IF Use_Tally THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: tally"
    FPRINT FP_WRITE,"int tally (const char *szLine, const char *szChar, int sensflag)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE," if(!*szChar) return 0;"
    FPRINT FP_WRITE," int mlen = strlen(szChar);"
    'FPRINT FP_WRITE," register int iCount = 0;"
    FPRINT FP_WRITE," int iCount = 0;"
    'FPRINT FP_WRITE," register char *p = (sensflag == 0 ? _strstr_((char*)szLine, (char*)szChar) : _stristr_((char*)szLine, (char*)szChar));"
    FPRINT FP_WRITE," char *p = (sensflag == 0 ? _strstr_((char*)szLine, (char*)szChar) : _stristr_((char*)szLine, (char*)szChar));"
    FPRINT FP_WRITE," while (p)"
    FPRINT FP_WRITE," {"
    FPRINT FP_WRITE," iCount++;"
    FPRINT FP_WRITE," p+=mlen;"
    FPRINT FP_WRITE," p = (sensflag == 0 ? _strstr_(p, (char*)szChar) : _stristr_(p, (char*)szChar));"
    FPRINT FP_WRITE," }"
    FPRINT FP_WRITE," return iCount;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Timer THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: timer"
    FPRINT FP_WRITE,"float timer (void)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  return (GetTickCount()/1000.0);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Rnd THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: rnd"
    FPRINT FP_WRITE,"float rnd (void)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  return (float)rand()/RAND_MAX;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Exp THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Exp"
    FPRINT FP_WRITE,"double Exp (double arg)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  return pow(2.718281828459045,arg);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Asinh THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: asinh"
    ' redefined in Watcom
    FPRINT FP_WRITE,"#if !defined( __WATCOM_CPLUSPLUS__ )"
    FPRINT FP_WRITE,"double asinh (double x)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  return(log(x+sqrt(x*x+1)));"
    FPRINT FP_WRITE,"}"
    FPRINT FP_WRITE,"#endif"
    FPRINT FP_WRITE,sENDBCXRTLIB2$
  END IF


  IF Use_Acosh THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: acosh"
    ' redefined in Watcom
    FPRINT FP_WRITE,"#if !defined( __WATCOM_CPLUSPLUS__ )"
    FPRINT FP_WRITE,"double acosh (double x)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  if(x<1) return 1e308;"
    FPRINT FP_WRITE,"  return(log(x+sqrt(x*x-1)));"
    FPRINT FP_WRITE,"}"
    FPRINT FP_WRITE,"#endif"
    FPRINT FP_WRITE,sENDBCXRTLIB2$
  END IF


  IF Use_Atanh THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: atanh"
    ' redefined in Watcom
    FPRINT FP_WRITE,"#if !defined( __WATCOM_CPLUSPLUS__ )"
    FPRINT FP_WRITE,"double atanh (double x)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  if(x<=-1) return 1e308;"
    FPRINT FP_WRITE,"  if(x>= 1) return 1e308;"
    FPRINT FP_WRITE,"  return(log((1+x)/(1-x))/2);"
    FPRINT FP_WRITE,"}"
    FPRINT FP_WRITE,"#endif"
    FPRINT FP_WRITE,sENDBCXRTLIB2$
  END IF


  IF Use_Randomize THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: randomize"
    FPRINT FP_WRITE,"void randomize (unsigned int seed)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  srand(seed);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  'IF Use_Abs THEN
  '  IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Abs"
  '  FPRINT FP_WRITE,"double Abs (double a)"
  '  FPRINT FP_WRITE,"{"
  '  FPRINT FP_WRITE,"  if(a<0) return -a;"
  '  FPRINT FP_WRITE,"  return  a;"
  '  FPRINT FP_WRITE,sENDBCXRTLIB$
  'END IF


  IF Use_Max THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: MAX"
    FPRINT FP_WRITE,"double MAX (double a, double b)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  if(a>b)"
    FPRINT FP_WRITE,"  return a;"
    FPRINT FP_WRITE,"  return b;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Min THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: MIN"
    FPRINT FP_WRITE,"double MIN (double a, double b)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  if(a<b)"
    FPRINT FP_WRITE,"  return a;"
    FPRINT FP_WRITE,"  return b;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  'IF Use_Locate AND UseWinApi THEN
  IF Use_Locate THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: locate"
    FPRINT FP_WRITE,"void locate (int row,int col,int show,int shape)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  CONSOLE_CURSOR_INFO cci = {0};"
    FPRINT FP_WRITE,"  cursor.X = col-1;"
    FPRINT FP_WRITE,"  cursor.Y = row-1;"
    FPRINT FP_WRITE,"  SetConsoleCursorPosition(hConsole,cursor);"
    FPRINT FP_WRITE,"  cci.bVisible = show;"
    FPRINT FP_WRITE,"  cci.dwSize   = shape;"
    FPRINT FP_WRITE,"  SetConsoleCursorInfo(hConsole,&cci);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Pos THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Pos"
    FPRINT FP_WRITE,"int Pos (void)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HANDLE  hStdOut;"
    FPRINT FP_WRITE,"  CONSOLE_SCREEN_BUFFER_INFO  csbi = {0};"
    FPRINT FP_WRITE,"  hStdOut=GetStdHandle(STD_OUTPUT_HANDLE);"
    FPRINT FP_WRITE,"  GetConsoleScreenBufferInfo(hStdOut,&csbi);"
    FPRINT FP_WRITE,"  return csbi.dwCursorPosition.X+1;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Csrlin THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Csrlin"
    FPRINT FP_WRITE,"int Csrlin (void)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HANDLE  hStdOut;"
    FPRINT FP_WRITE,"  CONSOLE_SCREEN_BUFFER_INFO  csbi = {0};"
    FPRINT FP_WRITE,"  hStdOut=GetStdHandle(STD_OUTPUT_HANDLE);"
    FPRINT FP_WRITE,"  GetConsoleScreenBufferInfo(hStdOut,&csbi);"
    FPRINT FP_WRITE,"  return csbi.dwCursorPosition.Y+1;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Cls THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: cls"
    FPRINT FP_WRITE,"void cls (void)"
    FPRINT FP_WRITE,"{"
'    IF UseWinApi Then
'      FPRINT FP_WRITE,"  COORD coordScreen = {0,0};"
'      FPRINT FP_WRITE,"  DWORD cCharsWritten;"
'      FPRINT FP_WRITE,"  CONSOLE_SCREEN_BUFFER_INFO csbi = {0};"
'      FPRINT FP_WRITE,"  DWORD dwConSize;"
'      FPRINT FP_WRITE,"  register int attr;"
'      FPRINT FP_WRITE,"  cursor.X = 0;"
'      FPRINT FP_WRITE,"  cursor.Y = 0;"
'      FPRINT FP_WRITE,"  GetConsoleScreenBufferInfo( hConsole, &csbi );"
'      FPRINT FP_WRITE,"  dwConSize = csbi.dwSize.X * csbi.dwSize.Y;"
'      FPRINT FP_WRITE,"  FillConsoleOutputCharacter (hConsole, 32, dwConSize,coordScreen, &cCharsWritten);"
'      FPRINT FP_WRITE,"  attr = color_fg + color_bg * 16;"
'      FPRINT FP_WRITE,"  FillConsoleOutputAttribute (hConsole, attr, dwConSize,coordScreen, &cCharsWritten);"
'      FPRINT FP_WRITE,"  locate(1,1,1,12);"
'    ELSE
      IF TargetOS = TNIX Then
      	FPRINT FP_WRITE,"  system(",ENC$("clear"),");"
      Else
        FPRINT FP_WRITE,"  system(",ENC$("cls"),");"
      End If
'    END IF
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Color THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: color"
    FPRINT FP_WRITE,"void color (int fg, int bg)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE," SetConsoleTextAttribute (hConsole,fg+bg*16);"
    FPRINT FP_WRITE,"  color_fg = fg;"
    FPRINT FP_WRITE,"  color_bg = bg;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Panel THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: panel"
    FPRINT FP_WRITE,"void panel (int x1,int y1,int x2,int y2,int fg,int bg,int chr,int flg)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"DWORD ret;"
    'FPRINT FP_WRITE,"register int attr = fg+bg*16,x,y;"
    FPRINT FP_WRITE,"int attr = fg+bg*16,x,y;"
    FPRINT FP_WRITE,"for(y=y1;y<=y2;y++)"
    FPRINT FP_WRITE," {"
    FPRINT FP_WRITE,"  for(x=x1;x<=x2;x++)"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"     cursor.X = x - 1;"
    FPRINT FP_WRITE,"     cursor.Y = y - 1;"
    FPRINT FP_WRITE,"     if(flg)FillConsoleOutputCharacter(hConsole,chr,1,cursor,&ret);"
    FPRINT FP_WRITE,"     FillConsoleOutputAttribute(hConsole,attr,1,cursor,&ret);"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE," }"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Midstr THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: midstr"
'    FPRINT FP_WRITE,"void midstr (char *src, int st, int length, char *rep)"
    FPRINT FP_WRITE,"void midstr (char *src, int st, int length, const char *rep)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int srclen = strlen(src);"
    FPRINT FP_WRITE,"  if(st>srclen++ || st<1) return;"
    FPRINT FP_WRITE,"  int replen = strlen(rep);"
    FPRINT FP_WRITE,"  if(replen < length || length==-1) length=replen;"
    FPRINT FP_WRITE,"  if((st+length) > srclen) length=srclen-st;"
    FPRINT FP_WRITE,"  memcpy(&src[st-1],rep,length);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Swap THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: swap"
    FPRINT FP_WRITE,"void swap ( byte* A, byte* B, int length)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  byte t;"
    FPRINT FP_WRITE,"  while(length--)"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"    t = *A;"
    FPRINT FP_WRITE,"    *(A++) = *B;"
    FPRINT FP_WRITE,"    *(B++) = t;"
    FPRINT FP_WRITE,"  }"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Like THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: like"
    FPRINT FP_WRITE,"int like (const char *raw, const char *pat)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE," char a, b, d;"
    FPRINT FP_WRITE," char *r, *p;"
    FPRINT FP_WRITE," int star = 0;"
    FPRINT FP_WRITE," for(;;) {"
    FPRINT FP_WRITE,"   if ((d = *pat++)==0) return (star || !*raw);"
    FPRINT FP_WRITE,"   else if (d == '*') star = 1;"
    FPRINT FP_WRITE,"   else if (d == '?') { if (!*raw++) return 0; }"
    FPRINT FP_WRITE,"   else break;"
    FPRINT FP_WRITE," }"
    FPRINT FP_WRITE," b = d;"
    FPRINT FP_WRITE," do if ((a = *raw++) == b) {"
    FPRINT FP_WRITE,"   r = (char*)raw;"
    FPRINT FP_WRITE,"   p = (char*)pat;"
    FPRINT FP_WRITE,"   do {"
    FPRINT FP_WRITE,"     if ((d = *p++) == '*')"
    FPRINT FP_WRITE,"       if (like(r, p - 1)) return 1;"
    FPRINT FP_WRITE,"       else break;"
    FPRINT FP_WRITE,"     else if (!d)"
    FPRINT FP_WRITE,"       if (!*r) return 1;"
    FPRINT FP_WRITE,"       else break;"
    FPRINT FP_WRITE,"   } while (*r++ == d || d == '?');"
    FPRINT FP_WRITE," } while (star && a);"
    FPRINT FP_WRITE," return 0;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Lof THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: lof"
'jcfuller changed 09/03/2015
'don't know why this did not have const added sooner
' TDMGCC warned today
    'FPRINT FP_WRITE,"DWORD lof (char *FileName)"
    FPRINT FP_WRITE,"DWORD lof (const char *FileName)"
    FPRINT FP_WRITE,"{"
	IF UseWinApi OR Use_TCLib THEN
      FPRINT FP_WRITE,"  WIN32_FIND_DATA W32FD;"
      FPRINT FP_WRITE,"  HANDLE hFile;"
      FPRINT FP_WRITE,"  int FSize;"
      FPRINT FP_WRITE,"  if(strlen(FileName)==0) return 0;"
      FPRINT FP_WRITE,"  hFile=FindFirstFile(FileName,&W32FD);"
      FPRINT FP_WRITE,"  if(hFile!=INVALID_HANDLE_VALUE)"
      FPRINT FP_WRITE,"   {"
      FPRINT FP_WRITE,"     FSize=W32FD.nFileSizeLow;"
      FPRINT FP_WRITE,"     FindClose(hFile);"
      FPRINT FP_WRITE,"     return FSize;"
      FPRINT FP_WRITE,"   }"
      FPRINT FP_WRITE,"  return 0;"
	
    ELSE
      FPRINT FP_WRITE,""
      FPRINT FP_WRITE,"  int retstat;"
      FPRINT FP_WRITE,"  struct stat sb;"
      FPRINT FP_WRITE,"  if(strlen(FileName)==0) return 0;"
      FPRINT FP_WRITE,"  retstat = stat(FileName, &sb);"
      FPRINT FP_WRITE,"  if(retstat != -1)"
      FPRINT FP_WRITE,"    return sb.st_size;"
      FPRINT FP_WRITE,"  return 0;"
    
    ENDIF
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Screen THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Screen"
    FPRINT FP_WRITE,"int Screen (int y,int x,int mode)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HANDLE  hConsole = GetStdHandle(STD_OUTPUT_HANDLE);"
    FPRINT FP_WRITE,"  DWORD Slen;"
    FPRINT FP_WRITE,"  COORD Coord;"
    FPRINT FP_WRITE,"  WORD  Attr;"
    FPRINT FP_WRITE,"  char  Char[2];"
    FPRINT FP_WRITE,"  Coord.X=x-1;"
    FPRINT FP_WRITE,"  Coord.Y=y-1;"
    FPRINT FP_WRITE,"  ReadConsoleOutputCharacterA(hConsole,Char,1,Coord,&Slen);"
    FPRINT FP_WRITE,"  ReadConsoleOutputAttribute(hConsole,&Attr,1,Coord,&Slen);"
    FPRINT FP_WRITE,"  if(mode)"
    FPRINT FP_WRITE,"  return  Attr;"
    FPRINT FP_WRITE,"  return  Char[0];"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Iif THEN
    'IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: iif"
		If UseCpp AND (IsBc9 = FALSE) Then
			FPRINT FP_WRITE,"template<typename T>"
			FPRINT FP_WRITE,"T iif (BOOL cond, T  trueCase, T  falseCase)"
			FPRINT FP_WRITE,"{"
			FPRINT FP_WRITE,"    if(cond )"
			FPRINT FP_WRITE,"    {"
			FPRINT FP_WRITE,"        return trueCase;"
			FPRINT FP_WRITE,"    }"
			FPRINT FP_WRITE,"    return falseCase;"
			FPRINT FP_WRITE,"}"
		Else
			FPRINT FP_WRITE,"double iif (BOOL cond, double tp, double fp)"
			FPRINT FP_WRITE,"{"
			FPRINT FP_WRITE,"  if(cond) return tp;"
			FPRINT FP_WRITE,"  return fp;"
			FPRINT FP_WRITE,sENDBCXRTLIB$
		End If
  END IF


  IF Use_sziif THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: sziif"
    'IF UseCpp THEN
    '  FPRINT FP_WRITE,"char * sziif (bool i, const char *a, const char *b)"
    'ELSE
      FPRINT FP_WRITE,"char * sziif (BOOL i, const char *a, const char *b)"
    'END IF
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  if(i) return (char*)a;"
    FPRINT FP_WRITE,"  return (char*)b;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Doevents THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: DoEvents"
    FPRINT FP_WRITE,"void DoEvents (void)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  MSG Msg;"
    FPRINT FP_WRITE,"  while (PeekMessage(&Msg,NULL,0,0,PM_REMOVE))"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"     TranslateMessage(&Msg);"
    FPRINT FP_WRITE,"     DispatchMessage(&Msg);"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_DynamicA THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: CreateArr"
'jcfuller changed 02/20/2016    
    'FPRINT FP_WRITE,"void *CreateArr(void *a, int elem_size, int update, int num_dims, ... )"
    'FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  va_list ap;"
    'FPRINT FP_WRITE,"  void   *RetPtr;"
    'FPRINT FP_WRITE,""
    'FPRINT FP_WRITE,"  va_start(ap, num_dims);"
    'FPRINT FP_WRITE,"  RetPtr = CreateArr_internal(a, elem_size, update, num_dims, ap);"
    'FPRINT FP_WRITE,"  va_end(ap);"
    'FPRINT FP_WRITE,"  return (RetPtr);"
    'FPRINT FP_WRITE,"}\n\n"
    'FPRINT FP_WRITE,"void *CreateArr_internal(void *a, int elem_size, int update, int num_dims, va_list ap)"
    'FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  size_t s, s1, s2;"
    'FPRINT FP_WRITE,"  void **vp;"
    'FPRINT FP_WRITE,"  va_list marker;"
    'FPRINT FP_WRITE,""
    'FPRINT FP_WRITE,"#ifdef va_copy"
    'FPRINT FP_WRITE,"  va_copy(marker, ap);"
    'FPRINT FP_WRITE,"#else"
    'FPRINT FP_WRITE,"  marker = ap;"
    'FPRINT FP_WRITE,"#endif"
    'FPRINT FP_WRITE,"  s = va_arg(marker, size_t);"
    'FPRINT FP_WRITE,"  s2 = s + 2;"
    'FPRINT FP_WRITE,"  if(num_dims == 1)"
    'FPRINT FP_WRITE,"        {"
    'FPRINT FP_WRITE,"    if(update && a)"
    'FPRINT FP_WRITE,"        a=realloc(a,s2*elem_size);"
    'FPRINT FP_WRITE,"     else"
    'FPRINT FP_WRITE,"        a=calloc(s2,elem_size);"
    'FPRINT FP_WRITE,"    return a;"
    'FPRINT FP_WRITE,"   }"
    'FPRINT FP_WRITE," else"
    'FPRINT FP_WRITE,"    if(update && a)"
    'FPRINT FP_WRITE,"     {"
    'FPRINT FP_WRITE,"     s1 = 0;"
    'FPRINT FP_WRITE,"     vp = (void**)a;"
    'FPRINT FP_WRITE,"     while(*vp && s1 <= s)"
    'FPRINT FP_WRITE,"       {"
    'FPRINT FP_WRITE,"       vp++;"
    'FPRINT FP_WRITE,"       s1++;"
    'FPRINT FP_WRITE,"       }"
    'FPRINT FP_WRITE,"     if(s1 > s)"
    'FPRINT FP_WRITE,"       {"
    'FPRINT FP_WRITE,"       vp--;"
    'FPRINT FP_WRITE,"        DestroyArr(vp, num_dims, 0);"
    'FPRINT FP_WRITE,"       }"
    'FPRINT FP_WRITE,"      a=realloc(a,s2*sizeof(int *));"
    'FPRINT FP_WRITE,"     s1 = 0;"
    'FPRINT FP_WRITE,"     vp = (void**)a;"
    'FPRINT FP_WRITE,"     while(*vp && s1 <= s)"
    'FPRINT FP_WRITE,"       {"
    'FPRINT FP_WRITE,"       vp++;"
    'FPRINT FP_WRITE,"       s1++;"
    'FPRINT FP_WRITE,"       }"
    'FPRINT FP_WRITE,"     while(s1 < s2)"
    'FPRINT FP_WRITE,"       {"
    'FPRINT FP_WRITE,"       *(((int *)vp)) = 0;"
    'FPRINT FP_WRITE,"       vp++;"
    'FPRINT FP_WRITE,"       s1++;"
    'FPRINT FP_WRITE,"       }"
    'FPRINT FP_WRITE,"     }"
    'FPRINT FP_WRITE,"   else"
    'FPRINT FP_WRITE,"      a=calloc(s2*sizeof(int *),1);"
    'FPRINT FP_WRITE," vp = (void**)a;"
    'FPRINT FP_WRITE," if(--num_dims > 0)"
    'FPRINT FP_WRITE," {"
    'FPRINT FP_WRITE," for(s1 = 0; s1 < s; s1++)"
    'FPRINT FP_WRITE,"   {"
    'FPRINT FP_WRITE,"     vp[s1] = CreateArr_internal(vp[s1], elem_size, update, num_dims, marker);"
    'FPRINT FP_WRITE,"   }"
    'FPRINT FP_WRITE," }"
    'FPRINT FP_WRITE," return a;"
	FPRINT FP_WRITE,"void *CreateArr(void *a, int elem_size, int update, int num_dims, size_t *args )"
	FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"    size_t s, s1, s2;"
    FPRINT FP_WRITE,"    void **vp;"
	FPRINT FP_WRITE,"    size_t *marker;"
	FPRINT FP_WRITE,"    marker = args;"
    FPRINT FP_WRITE,"    s = *marker++;"
    FPRINT FP_WRITE,"    s2 = s + 2;"
    FPRINT FP_WRITE,"    if(num_dims == 1)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"        if(update && a)"
    FPRINT FP_WRITE,"            a = realloc(a, s2 * elem_size);"
    FPRINT FP_WRITE,"        else"
    FPRINT FP_WRITE,"            a = calloc(s2, elem_size);"
    FPRINT FP_WRITE,"        return a;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"    else if(update && a)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"        s1 = 0;"
    FPRINT FP_WRITE,"        vp = (void**)a;"
    FPRINT FP_WRITE,"        while(*vp && s1 <= s)"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"            vp++;"
    FPRINT FP_WRITE,"            s1++;"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"        if(s1 > s)"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"            vp--;"
    FPRINT FP_WRITE,"            DestroyArr(vp, num_dims, 0);"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"        a = realloc(a, s2 * sizeof(int *));"
    FPRINT FP_WRITE,"        s1 = 0;"
    FPRINT FP_WRITE,"        vp = (void**)a;"
    FPRINT FP_WRITE,"        while(*vp && s1 <= s)"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"            vp++;"
    FPRINT FP_WRITE,"            s1++;"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"        while(s1 < s2)"
    FPRINT FP_WRITE,"        {"
    'FPRINT FP_WRITE,"            *(((int *)vp)) = 0;"
    FPRINT FP_WRITE,"            *(((void **)vp)) = NULL;"
    FPRINT FP_WRITE,"            vp++;"
    FPRINT FP_WRITE,"            s1++;"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"    else"
    FPRINT FP_WRITE,"        a = calloc(s2 * sizeof(int *), 1);"
    FPRINT FP_WRITE,"    vp = (void**)a;"
    FPRINT FP_WRITE,"    if(--num_dims > 0)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"        for(s1 = 0; s1 < s; s1++)"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"            vp[s1] = CreateArr(vp[s1], elem_size, update, num_dims, marker);"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"    return a;"
    FPRINT FP_WRITE,"}\n\n"

    FPRINT FP_WRITE,"void DestroyArr (void** a,int num_dims, int top_free)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE," int i = 0;"
    FPRINT FP_WRITE," static int s = 0;"
    FPRINT FP_WRITE," if(num_dims == 1)"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"   free(a);"
    FPRINT FP_WRITE,"   return;"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE," s++;"
    FPRINT FP_WRITE," num_dims--;  "
    FPRINT FP_WRITE," while(a[i])"
    FPRINT FP_WRITE,"     {"
    FPRINT FP_WRITE,"   DestroyArr((void**)a[i], num_dims, top_free);"
    FPRINT FP_WRITE,"   if(num_dims > 1)"
    FPRINT FP_WRITE,"         free(a[i]);"
    FPRINT FP_WRITE,"       a[i++]=NULL;"
    FPRINT FP_WRITE,"       }"
    FPRINT FP_WRITE," s--;"
    FPRINT FP_WRITE," if(s == 0 && top_free)"
    FPRINT FP_WRITE,"   free(a);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_Idxqsort THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: IdxCompare"
    FPRINT FP_WRITE,"int IdxCompare (const void *one, const void *two)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int *ptr1 = (int *)(one);"
    FPRINT FP_WRITE,"  int *ptr2 = (int *)(two);"
    FPRINT FP_WRITE,"  return stricmp (pppStr[Key][*ptr1],pppStr[Key][*ptr2]);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_IdxqsortSt THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: IdxCompareSt"
    FPRINT FP_WRITE,"int IdxCompareSt (const void* one, const void* two)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"#define compare1 cmp1+(StructSize * (*(UINT *)(one)))"
    FPRINT FP_WRITE,"#define compare2 cmp1+(StructSize * (*(UINT *)(two)))"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE," if (Key==0)"      'String
    FPRINT FP_WRITE,"   return  stricmp(compare1, compare2);"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE," if (Key==1)"      'Integer
    FPRINT FP_WRITE," {"
    FPRINT FP_WRITE,"  if (*(int*)(compare1) < *(int*)(compare2)) return -1;"
    FPRINT FP_WRITE,"  if (*(int*)(compare1) > *(int*)(compare2)) return 1;"
    FPRINT FP_WRITE,"  return 0;"
    FPRINT FP_WRITE," }"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE," if (Key==2)"      'Double
    FPRINT FP_WRITE," {"
    FPRINT FP_WRITE,"  if (*(double*)(compare1) < *(double*)(compare2)) return -1;"
    FPRINT FP_WRITE,"  if (*(double*)(compare1) > *(double*)(compare2)) return 1;"
    FPRINT FP_WRITE,"  return 0;"
    FPRINT FP_WRITE," }"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE," if (Key==3)"      'Unsigned integer
    FPRINT FP_WRITE," {"
    FPRINT FP_WRITE,"  if (*(UINT*)(compare1) < *(UINT*)(compare2)) return -1;"
    FPRINT FP_WRITE,"  if (*(UINT*)(compare1) > *(UINT*)(compare2)) return 1;"
    FPRINT FP_WRITE," }"
    FPRINT FP_WRITE,"return 0;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_PtrqsortSt THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: PtrCompareSt"
    FPRINT FP_WRITE,"int PtrCompareSt (const void* one, const void* two)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"#define pcompare1 ((char*)(one)+OffSet)"
    FPRINT FP_WRITE,"#define pcompare2 ((char*)(two)+OffSet)"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE," if (Key==0)"
    FPRINT FP_WRITE,"   return  stricmp(pcompare1, pcompare2);"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE," if (Key==1)"
    FPRINT FP_WRITE," {"
    FPRINT FP_WRITE,"  if (*(int*)(pcompare1) < *(int*)(pcompare2)) return -1;"
    FPRINT FP_WRITE,"  if (*(int*)(pcompare1) > *(int*)(pcompare2)) return 1;"
    FPRINT FP_WRITE,"  return 0;"
    FPRINT FP_WRITE," }"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE," if (Key==2)"
    FPRINT FP_WRITE," {"
    FPRINT FP_WRITE,"  if (*(double*)(pcompare1) < *(double*)(pcompare2)) return -1;"
    FPRINT FP_WRITE,"  if (*(double*)(pcompare1) > *(double*)(pcompare2)) return 1;"
    FPRINT FP_WRITE,"  return 0;"
    FPRINT FP_WRITE," }"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE," if (Key==3)"
    FPRINT FP_WRITE," {"
    FPRINT FP_WRITE,"  if (*(UINT*)(pcompare1) < *(UINT*)(pcompare2)) return -1;"
    FPRINT FP_WRITE,"  if (*(UINT*)(pcompare1) > *(UINT*)(pcompare2)) return 1;"
    FPRINT FP_WRITE," }"
    FPRINT FP_WRITE,"return 0;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_Strqsorta THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: StrCompareA"
    FPRINT FP_WRITE,"int StrCompareA (const void *arg1, const void *arg2)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *v1 = (char*) arg1;"
    FPRINT FP_WRITE,"  char *v2 = (char*) arg2;"
    FPRINT FP_WRITE,"  return stricmp (v1,v2);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Strqsortd THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: StrCompareD"
    FPRINT FP_WRITE,"int StrCompareD (const void *arg1, const void *arg2)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *v1 = (char*) arg1;"
    FPRINT FP_WRITE,"  char *v2 = (char*) arg2;"
    FPRINT FP_WRITE,"  return stricmp (v2,v1);"
    'FPRINT FP_WRITE,"  return strcasecmp (v2,v1);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_DynStrqsorta THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: DynStrCompareA"
    FPRINT FP_WRITE,"int DynStrCompareA (const void *arg1, const void *arg2)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *v1 = *(char **) arg1;"
    FPRINT FP_WRITE,"  char *v2 = *(char **) arg2;"
    FPRINT FP_WRITE,"  return stricmp(v1, v2);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_DynStrqsortd THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: DynStrCompareD"
    FPRINT FP_WRITE,"int DynStrCompareD (const void *arg1, const void *arg2)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *v1 = *(char **) arg1;"
    FPRINT FP_WRITE,"  char *v2 = *(char **) arg2;"
    FPRINT FP_WRITE,"  return stricmp(v2, v1);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_DynAlphaNumericA THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: DynAlphaNumericA"
    FPRINT FP_WRITE,"int DynAlphaNumericA (const void *arg1, const void *arg2)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *v1 = *(char **) arg1;"
    FPRINT FP_WRITE,"  char *v2 = *(char **) arg2;"
    FPRINT FP_WRITE,"  return AlphaNumeric(v1, v2);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_DynAlphaNumericD THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: DynAlphaNumericD"
    FPRINT FP_WRITE,"int DynAlphaNumericD (const void *arg1, const void *arg2)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *v1 = *(char **) arg1;"
    FPRINT FP_WRITE,"  char *v2 = *(char **) arg2;"
    FPRINT FP_WRITE,"  return AlphaNumeric(v2, v1);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_AlphaNumericA THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: AlphaNumericA"
    FPRINT FP_WRITE,"int AlphaNumericA (const void *arg1, const void *arg2)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  return AlphaNumeric (arg1,arg2);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_AlphaNumericD THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: AlphaNumericD"
    FPRINT FP_WRITE,"int AlphaNumericD (const void *arg1, const void *arg2)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  return AlphaNumeric (arg2,arg1);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_AlphaNumeric THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: AlphaNumeric"
    FPRINT FP_WRITE,"int AlphaNumeric(const void *s1p, const void *s2p)"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"  char *s1 = (char*)s1p;"
    FPRINT FP_WRITE,"  char *s2 = (char*)s2p;"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"  do {"
    FPRINT FP_WRITE,"    if (isdigit(s1[0]) && isdigit(s2[0])){"
    FPRINT FP_WRITE,"      /* Compare numbers as numbers */"
    FPRINT FP_WRITE,"      int c1 = strspn(s1,";ENC$("0123456789");"); /* Could be more efficient here... */"
    FPRINT FP_WRITE,"      int c2 = strspn(s2,";ENC$("0123456789");");"
    FPRINT FP_WRITE,"      if (c1 > c2) {"
    FPRINT FP_WRITE,"        return 1;"
    FPRINT FP_WRITE,"      } else if (c1 < c2) {"
    FPRINT FP_WRITE,"        return -1;"
    FPRINT FP_WRITE,"      };"
    FPRINT FP_WRITE,"      /* the digit strings have equal length, so compare digit by digit */"
    FPRINT FP_WRITE,"      while (c1--) {"
    FPRINT FP_WRITE,"        if (s1[0] > s2[0]){"
    FPRINT FP_WRITE,"          return 1;"
    FPRINT FP_WRITE,"        } else if (s1[0] < s2[0]){"
    FPRINT FP_WRITE,"          return -1;"
    FPRINT FP_WRITE,"        };"
    FPRINT FP_WRITE,"        s1++;"
    FPRINT FP_WRITE,"        s2++;"
    FPRINT FP_WRITE,"      };"
    FPRINT FP_WRITE,"    } else if (s1[0] > s2[0]){"
    FPRINT FP_WRITE,"      return 1;"
    FPRINT FP_WRITE,"    } else if (s1[0] < s2[0]){"
    FPRINT FP_WRITE,"      return -1;"
    FPRINT FP_WRITE,"    };"
    FPRINT FP_WRITE,"    s1++;"
    FPRINT FP_WRITE,"    s2++;"
    FPRINT FP_WRITE,"  } while ( (*s1!=0) || (*s2!=0));"
    FPRINT FP_WRITE,"  return 0;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Numqsortaint THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: NumCompareAint"
    FPRINT FP_WRITE,"int NumCompareAint (const void *one, const void *two)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int *ptr1 = (int *)(one);"
    FPRINT FP_WRITE,"  int *ptr2 = (int *)(two);"
    FPRINT FP_WRITE,"  if (*ptr1 < *ptr2) return -1;"
    FPRINT FP_WRITE,"  else if (*ptr1 == *ptr2) return 0;"
    FPRINT FP_WRITE,"  else return 1;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Numqsortdint THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: NumCompareDint"
    FPRINT FP_WRITE,"int NumCompareDint (const void *one, const void *two)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int *ptr1 = (int *)(one);"
    FPRINT FP_WRITE,"  int *ptr2 = (int *)(two);"
    FPRINT FP_WRITE,"  if (*ptr1 > *ptr2) return -1;"
    FPRINT FP_WRITE,"  else if (*ptr1 == *ptr2) return 0;"
    FPRINT FP_WRITE,"  else return 1;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Numqsortafloat THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: NumCompareAfloat"
    FPRINT FP_WRITE,"int NumCompareAfloat (const void *one, const void *two)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  float *ptr1 = (float *)(one);"
    FPRINT FP_WRITE,"  float *ptr2 = (float *)(two);"
    FPRINT FP_WRITE,"  if (*ptr1 < *ptr2) return -1;"
    FPRINT FP_WRITE,"  else if (*ptr1 == *ptr2) return 0;"
    FPRINT FP_WRITE,"  else return 1;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Numqsortdfloat THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: NumCompareDfloat"
    FPRINT FP_WRITE,"int NumCompareDfloat (const void *one, const void *two)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  float *ptr1 = (float *)(one);"
    FPRINT FP_WRITE,"  float *ptr2 = (float *)(two);"
    FPRINT FP_WRITE,"  if (*ptr1 > *ptr2) return -1;"
    FPRINT FP_WRITE,"  else if (*ptr1 == *ptr2) return 0;"
    FPRINT FP_WRITE,"  else return 1;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Numqsortadouble THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: NumCompareAdouble"
    FPRINT FP_WRITE,"int NumCompareAdouble (const void *one, const void *two)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  double *ptr1 = (double *)(one);"
    FPRINT FP_WRITE,"  double *ptr2 = (double *)(two);"
    FPRINT FP_WRITE,"  if (*ptr1 < *ptr2) return -1;"
    FPRINT FP_WRITE,"  else if (*ptr1 == *ptr2) return 0;"
    FPRINT FP_WRITE,"  else return 1;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Numqsortddouble THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: NumCompareDdouble"
    FPRINT FP_WRITE,"int NumCompareDdouble (const void *one, const void *two)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  double *ptr1 = (double *)(one);"
    FPRINT FP_WRITE,"  double *ptr2 = (double *)(two);"
    FPRINT FP_WRITE,"  if (*ptr1 > *ptr2) return -1;"
    FPRINT FP_WRITE,"  else if (*ptr1 == *ptr2) return 0;"
    FPRINT FP_WRITE,"  else return 1;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_FillArray THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: fillarray"
    FPRINT FP_WRITE,"int fillarray(const char *input, int ArrayType, int MaxCnt, void *Array)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE," if(MaxCnt < 1) return -1;"
    FPRINT FP_WRITE," int c = 0, cnt=-1, cnt2;"
    FPRINT FP_WRITE," char A";cSizeOfADefaultString$;";"
    FPRINT FP_WRITE," int    *intptr    = (int *)Array;"
    FPRINT FP_WRITE," float  *floatptr  = (float *)Array;"
    FPRINT FP_WRITE," double *doubleptr = (double *)Array;"
    FPRINT FP_WRITE," long double *ldoubleptr = (long double *)Array;"
    FPRINT FP_WRITE," for(;;)"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"     cnt2=0;"
    FPRINT FP_WRITE,"     while(input[++cnt]!=',')"
    FPRINT FP_WRITE,"      {"
    FPRINT FP_WRITE,"        if(input[cnt]==0) break;"
    FPRINT FP_WRITE,"        A[cnt2++]=input[cnt];"
    FPRINT FP_WRITE,"      }"
    FPRINT FP_WRITE,"     A[cnt2]=0;"
    FPRINT FP_WRITE,"     if(cnt2==0||c==MaxCnt) break;"
    FPRINT FP_WRITE,"     "
    FPRINT FP_WRITE,"     if(ArrayType==2)"
    FPRINT FP_WRITE,"       intptr[c++] = atoi(A);"
    FPRINT FP_WRITE,"     else if(ArrayType==3)"
    FPRINT FP_WRITE,"       floatptr[c++] = atof(A);"
    FPRINT FP_WRITE,"     else if(ArrayType==4)"
    FPRINT FP_WRITE,"       doubleptr[c++] = atof(A);"
    FPRINT FP_WRITE,"     else if(ArrayType==5)"
    FPRINT FP_WRITE,"       ldoubleptr[c++] = atof(A);"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"     if(input[cnt]==0) break;"
    FPRINT FP_WRITE,"  } "
    FPRINT FP_WRITE," return (c-1);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Loc THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: loc"
    FPRINT FP_WRITE,"int loc(FILE *fp, int fplen)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  fpos_t t;"
    FPRINT FP_WRITE,"  fgetpos(fp, &t);"
    FPRINT FP_WRITE,"#if defined( __POCC__ )"
    FPRINT FP_WRITE,"  t.off %= fplen;"
    FPRINT FP_WRITE,"  return (int)t.off;"
    FPRINT FP_WRITE,"#else"
    FPRINT FP_WRITE,"  t %= fplen;"
    FPRINT FP_WRITE,"  return (int)t;"
    FPRINT FP_WRITE,"#endif"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Rec THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: rec"
    FPRINT FP_WRITE,"int rec(FILE *fp, int fplen)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  fpos_t t;"
    FPRINT FP_WRITE,"  fgetpos(fp, &t);"
    FPRINT FP_WRITE,"#if defined( __POCC__ )"
    FPRINT FP_WRITE,"  t.off /= fplen;"
    FPRINT FP_WRITE,"  return (int)++t.off;"
    FPRINT FP_WRITE,"#else"
    FPRINT FP_WRITE,"  t /= fplen;"
    FPRINT FP_WRITE,"  return (int)++t;"
    FPRINT FP_WRITE,"#endif"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_RecCount THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: reccont"
    FPRINT FP_WRITE,"int reccount(FILE *fp, int fplen)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  fpos_t t;"
    FPRINT FP_WRITE,"  fseek(fp,0,SEEK_END);"
    FPRINT FP_WRITE,"  fgetpos(fp, &t);"
    FPRINT FP_WRITE,"#if defined( __POCC__ )"
    FPRINT FP_WRITE,"  t.off /= fplen;"
    FPRINT FP_WRITE,"  return (int)t.off;"
    FPRINT FP_WRITE,"#else"
    FPRINT FP_WRITE,"  t /= fplen;"
    FPRINT FP_WRITE,"  return (int)t;"
    FPRINT FP_WRITE,"#endif"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  
  IF Use_Scan THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: scan"
    FPRINT FP_WRITE,"int scan(char *input, char *format, ... )"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register int c,d ;"
    FPRINT FP_WRITE,"  int c,d ;"
    FPRINT FP_WRITE,"  char     *s_;"
    FPRINT FP_WRITE,"  int      *intptr;"
    FPRINT FP_WRITE,"  float    *floatptr;"
    FPRINT FP_WRITE,"  double   *doubleptr;"
    FPRINT FP_WRITE,"  char     A[50]";cSizeOfADefaultString$;";"
    FPRINT FP_WRITE,"  va_list  marker;"
    FPRINT FP_WRITE,"  c = 0;"
    FPRINT FP_WRITE,"  d = Split(A,input,"; ENC$(",") ; ",0);"
    FPRINT FP_WRITE,"  va_start(marker, format); //Initialize arguments"
    FPRINT FP_WRITE,"  while(d && *format)"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"     if(*format == '%') format++;"
'jcfuller added 09/23/2016    
    If Use_UNICODE_Switch Then
		FPRINT FP_WRITE,"     if(*format == 'l') format++;"
    End If
    FPRINT FP_WRITE,"     if(*format == 's')"
    FPRINT FP_WRITE,"       {"
    FPRINT FP_WRITE,"         s_ = va_arg(marker, char *);"
    FPRINT FP_WRITE,"         strcpy(s_, A[c]);"
    FPRINT FP_WRITE,"         c++;"
    FPRINT FP_WRITE,"         d--;"
    FPRINT FP_WRITE,"       }"
    FPRINT FP_WRITE,"  if(*format == 'd')"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      intptr = va_arg(marker, int *);"
    FPRINT FP_WRITE,"      *intptr = atoi(A[c]);"
    FPRINT FP_WRITE,"      c++;"
    FPRINT FP_WRITE,"      d--;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if(*format == 'g')"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      floatptr = va_arg(marker, float *);"
    If Use_TCLib Then
		FPRINT FP_WRITE,"      *floatptr = _atof(A[c]);"
    Else
		FPRINT FP_WRITE,"      *floatptr = atof(A[c]);"
    End If
    FPRINT FP_WRITE,"      c++;"
    FPRINT FP_WRITE,"      d--;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE," if(*format == 'l')"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      format++;"
    FPRINT FP_WRITE,"      doubleptr = va_arg(marker, double *);"
    If Use_TCLib Then
		FPRINT FP_WRITE,"      *doubleptr = _atof(A[c]);"
    Else
		FPRINT FP_WRITE,"      *doubleptr = atof(A[c]);"
	End If	
    FPRINT FP_WRITE,"      c++;"
    FPRINT FP_WRITE,"      d--;"
    FPRINT FP_WRITE,"     }"
    FPRINT FP_WRITE,"  format++;"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"  va_end(marker);              // Reset variable arguments"
    FPRINT FP_WRITE,"  if(d) return(1);             // More data than variables"
    FPRINT FP_WRITE,"  if(*format == 0) return(0);  // OK"
    FPRINT FP_WRITE,"  return(-1);                  // More variables than data"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Split THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Split"
    FPRINT FP_WRITE,"int Split (char Buf[]";cSizeOfADefaultString$;", const char *T, const char *Delim, int Flg)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int  Begin = 0;"
    FPRINT FP_WRITE,"  int  Count = 0;"
    FPRINT FP_WRITE,"  int  Quote = 0;"
    FPRINT FP_WRITE,"  int  Index,i;"
    FPRINT FP_WRITE,"  int  lenT  = strlen(T);"
    FPRINT FP_WRITE,"  char Chr34[2]={34,0};"
    FPRINT FP_WRITE,"  for(Index=1;Index<=lenT;Index++)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      if(instr(Delim,mid(T,Index,1),0,0)&&!Quote)"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"          strcpy(Buf[Count],(char*)mid(T,Begin,Index-Begin));"
    FPRINT FP_WRITE,"          if ((Flg & 2) == 0)  // 0 if old version"
    FPRINT FP_WRITE,"           Count++;"
    FPRINT FP_WRITE,"          else"
    FPRINT FP_WRITE,"           if (Buf[Count][0] != 0) Count++;"
    FPRINT FP_WRITE,"           Begin=0;"
    FPRINT FP_WRITE,"           if((Flg & 1) == 1)   // 1 if true"
    FPRINT FP_WRITE,"              strcpy(Buf[Count++],(char*)mid(T,Index,1));"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"   else"
    FPRINT FP_WRITE,"     {"
    FPRINT FP_WRITE,"       if(strcmp(mid(T,Index,1),Chr34)==0) Quote=!Quote;"
    FPRINT FP_WRITE,"       if(Begin==0) Begin=Index;"
    FPRINT FP_WRITE,"     }"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"  if(Begin)"
    FPRINT FP_WRITE,"     strcpy(Buf[Count++],(char*)mid(T,Begin,Index-Begin));"
    FPRINT FP_WRITE,"  if((Flg & 1) == 0)   // 0 if false"
    FPRINT FP_WRITE,"      for(i=0;i<Count;i++) strcpy(Buf[i],(char*)RemoveStr(Buf[i],Chr34));"
    FPRINT FP_WRITE,"  return Count;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_DSplit THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: DSplit"
    FPRINT FP_WRITE,"int DSplit (LPSTR *Buf, const char *T, const char *Delim, int Flg)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int  Begin=0;"
    FPRINT FP_WRITE,"  int  Count=0;"
    FPRINT FP_WRITE,"  int  Quote=0;"
    FPRINT FP_WRITE,"  int  Index=0;"
    FPRINT FP_WRITE,"  int  lenT  = strlen(T);"
    FPRINT FP_WRITE,"  char Chr34[2]={34,0};"
    FPRINT FP_WRITE,"  for(Index=1;Index<=lenT;Index++)"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"     if(instr(Delim,mid(T,Index,1),0,0)&&!Quote)"
    FPRINT FP_WRITE,"       {"
    FPRINT FP_WRITE,"         strcpy(Buf[Count],(char*)mid(T,Begin,Index-Begin));"
    FPRINT FP_WRITE,"         if ((Flg & 2) == 0)  // 0 if old version"
    FPRINT FP_WRITE,"         Count++;"
    FPRINT FP_WRITE,"     else"
    FPRINT FP_WRITE,"         if (Buf[Count][0] != 0) Count++;"
    FPRINT FP_WRITE,"         Begin=0;"
    FPRINT FP_WRITE,"         if((Flg & 1) == 1)   // 1 if true"
    FPRINT FP_WRITE,"             strcpy(Buf[Count++],(char*)mid(T,Index,1));"
    FPRINT FP_WRITE,"       }"
    FPRINT FP_WRITE,"    else"
    FPRINT FP_WRITE,"      {"
    FPRINT FP_WRITE,"        if(strcmp(mid(T,Index,1),Chr34)==0) Quote=!Quote;"
    FPRINT FP_WRITE,"        if(Begin==0)  Begin=Index;"
    FPRINT FP_WRITE,"      }"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"  if(Begin) strcpy(Buf[Count++],(char*)mid(T,Begin,Index-Begin));"
    FPRINT FP_WRITE,"  if((Flg & 1) == 0)   // 0 if false"
    FPRINT FP_WRITE,"     for(Index=0;Index<Count;Index++) strcpy(Buf[Index],(char*)RemoveStr(Buf[Index],Chr34));"
    FPRINT FP_WRITE,"  return Count;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Bin2dec THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Bin2Dec"
    FPRINT FP_WRITE,"int Bin2Dec (const char *cptr)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register int i, j = 0;"
    FPRINT FP_WRITE,"  int i, j = 0;"
    FPRINT FP_WRITE,"  while(cptr && *cptr && strchr(";ENC$("01");", *cptr))"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"    i = *cptr++ - '0';"
    FPRINT FP_WRITE,"    j <<= 1;"
    FPRINT FP_WRITE,"    j |= (i & 0x01);"
    FPRINT FP_WRITE,"  }"
    FPRINT FP_WRITE," return(j);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Hex2Dec THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Hex2Dec"
    FPRINT FP_WRITE,"int Hex2Dec (const char *szInput)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char   ch;"
    FPRINT FP_WRITE,"  char  *dwLen   = (char*)szInput+strlen(szInput);"
    FPRINT FP_WRITE,"  DWORD  dwOut   = 0;"
    FPRINT FP_WRITE,"  while(*szInput)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      ch = LowCase[(unsigned char)*szInput++];"
    FPRINT FP_WRITE,"      if((ch >= 'a' && ch <= 'f')  || (ch >= '0' && ch <= '9'))"
    FPRINT FP_WRITE,"        dwOut |=((int)ch - (ch>'9' ? 'a'-10 : '0')) << ((dwLen - szInput) << 2);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  return dwOut;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Verify THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Verify"
    FPRINT FP_WRITE,"int Verify (const char *Src, const char *Allowed)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int j;"
    FPRINT FP_WRITE,"  size_t i;"
    FPRINT FP_WRITE,"  for (i=1; i<=strlen(Src); i++)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      j=VerifyInstr((char*)Allowed,(char*)mid(Src,i,1));"
    FPRINT FP_WRITE,"      if (!j) return 0;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  return TRUE;"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"int VerifyInstr(char* mane,char* match,int offset)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *s;"
    FPRINT FP_WRITE,"  if (!mane || !match || !*match || offset>(int)strlen(mane)) return 0;"
    FPRINT FP_WRITE,"  s = strstr (offset>0 ? mane+offset-1 : mane,match);"
    FPRINT FP_WRITE,"  return s ? (int)(s-mane)+1 : 0;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Retain THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Retain"
    FPRINT FP_WRITE,"char *Retain (const char *Text, const char *ValidChars)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *BCX_RetStr=BCX_TmpStr(strlen(Text),1,1);"
    FPRINT FP_WRITE,"  char *temp=BCX_RetStr;"
    FPRINT FP_WRITE,"  while(*Text)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      if(strchr(ValidChars,*Text)) *(temp++) = *Text;"
    FPRINT FP_WRITE,"      Text++;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  return BCX_RetStr;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

'jcfuller added 09/03/2013
  If Use_FileScan Then
    FPRINT FP_WRITE,"int FileScan (const char* filename, int* LineCount, int* LongestLine)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"    if(!Exist(filename))"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"        return 0;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"    int      lc = {0};"
    FPRINT FP_WRITE,"    int      ll = {0};"
    FPRINT FP_WRITE,"    int      cl = {0};"
    FPRINT FP_WRITE,"    int      FileSize = {0};"
    FPRINT FP_WRITE,"    FileSize = lof( filename) + 1;"
    FPRINT FP_WRITE,"    char *Buf;"
    FPRINT FP_WRITE,"    Buf = (char*)calloc(FileSize + 1 , 1);"
    FPRINT FP_WRITE,"    strcpy(Buf, LoadFile(filename));"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"        int      i;"
    FPRINT FP_WRITE,"        for(i = 0; i < FileSize; i++)"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"            if(Buf[i] == 10 )"
    FPRINT FP_WRITE,"            {"
    FPRINT FP_WRITE,"                if(cl > ll )"
    FPRINT FP_WRITE,"                {"
    FPRINT FP_WRITE,"                    ll = cl;"
    FPRINT FP_WRITE,"                }"
    FPRINT FP_WRITE,"                cl = 0;"
    FPRINT FP_WRITE,"                lc++;"
    FPRINT FP_WRITE,"            }"
    FPRINT FP_WRITE,"            cl++;"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"    (*LineCount) = lc;"
    FPRINT FP_WRITE,"    (*LongestLine) = ll;"
    FPRINT FP_WRITE,"    if (Buf) {"
    FPRINT FP_WRITE,"        free(Buf);"
    FPRINT FP_WRITE,"        Buf = NULL;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"    return 1;"
    FPRINT FP_WRITE,"}"

  End if

  IF Use_LoadFile THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: LoadFile"
    FPRINT FP_WRITE,"char* LoadFile (const char *N)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  FILE* FP1;"
    FPRINT FP_WRITE,"  char* BCX_RetStr;"
    FPRINT FP_WRITE,"  if(Exist(N))"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      BCX_RetStr=BCX_TmpStr(lof((char*)N),1,1);"
    FPRINT FP_WRITE,"      if((FP1=fopen(N,", ENC$("rb"), "))!=0)"
    FPRINT FP_WRITE,"      GET(FP1,BCX_RetStr,lof((char*)N));"
    FPRINT FP_WRITE,"      fclose(FP1);"
    FPRINT FP_WRITE,"      return BCX_RetStr;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      BCX_RetStr=BCX_TmpStr(64,1,1);"
    FPRINT FP_WRITE,"      return strcpy(BCX_RetStr,", ENC$("File Not Found"), ");"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Freefile THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: FreeFile"
    FPRINT FP_WRITE,"FILE* FreeFile (void)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  static FILE *pf;"
    FPRINT FP_WRITE,"  if(pf){free(pf);pf=NULL;}"
    FPRINT FP_WRITE,"  pf = (FILE*)calloc(sizeof(FILE*),sizeof(FILE*));"
    FPRINT FP_WRITE,"  return pf;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Textmode THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: TextMode"
    FPRINT FP_WRITE,"int TextMode (int Y)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);"
    FPRINT FP_WRITE,"  COORD  Coord;"
    FPRINT FP_WRITE,"  Coord.X = 80;"
    FPRINT FP_WRITE,"  Coord.Y = Y;"
    FPRINT FP_WRITE,"  return SetConsoleScreenBufferSize(hConsole,Coord);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Msgbox THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: MsgBox"
    FPRINT FP_WRITE,"int MsgBox (const char *pszMsg, const char *pszTitle, int iNum)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  return MessageBox(GetActiveWindow(),pszMsg,pszTitle,iNum);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Run THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Run"
    FPRINT FP_WRITE,"int Run (const char* Cmdline, int ShowHide, int WaitState)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  STARTUPINFO si = {0};"
    FPRINT FP_WRITE,"  PROCESS_INFORMATION pi = {0};"
    FPRINT FP_WRITE,"  DWORD dwState;"
    FPRINT FP_WRITE,"  int fRet=FALSE;"
    FPRINT FP_WRITE,"  MSG msg = {0};"
    'FPRINT FP_WRITE,"//<---UNICODE AWARE"
    'FPRINT FP_WRITE,"  memset(&si,0,sizeof(si));"
    'FPRINT FP_WRITE,"  memset(&pi,0,sizeof(pi));"
    'FPRINT FP_WRITE,"  memset(&msg,0,sizeof(msg));"
    'FPRINT FP_WRITE,"//>---UNICODE AWARE"
    FPRINT FP_WRITE,"  si.cb=sizeof(si);"
    FPRINT FP_WRITE,"  si.dwFlags=STARTF_USESHOWWINDOW;"
    FPRINT FP_WRITE,"  si.wShowWindow=ShowHide;"
'whineing on Cmdline
    FPRINT FP_WRITE,"  if(CreateProcess (NULL,(LPSTR)Cmdline,NULL,NULL,FALSE, NORMAL_PRIORITY_CLASS,NULL,NULL,&si,&pi)==0)"
'    FPRINT FP_WRITE,"  if(CreateProcess (NULL,Cmdline,NULL,NULL,FALSE, NORMAL_PRIORITY_CLASS,NULL,NULL,&si,&pi)==0)"
    FPRINT FP_WRITE,"    goto EXITRUN;"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"   WaitForInputIdle(pi.hProcess,1500);"
    FPRINT FP_WRITE,"   if(WaitState==TRUE)"
    FPRINT FP_WRITE,"     {"
    FPRINT FP_WRITE,"       if(pi.hProcess)"
    FPRINT FP_WRITE,"         {"
    FPRINT FP_WRITE,"           do {"
    FPRINT FP_WRITE,"               dwState=MsgWaitForMultipleObjects(1,&pi.hProcess,FALSE,INFINITE,QS_ALLINPUT);"
    FPRINT FP_WRITE,"               while(PeekMessage(&msg,NULL,0,0,PM_REMOVE))"
    FPRINT FP_WRITE,"                 {"
    FPRINT FP_WRITE,"                   if(msg.message==WM_QUIT) goto EXITRUN;"
    FPRINT FP_WRITE,"                   DispatchMessage(&msg);"
    FPRINT FP_WRITE,"                   Sleep(0);"
    FPRINT FP_WRITE,"                 }               "
    FPRINT FP_WRITE,"             } while(dwState!=WAIT_OBJECT_0&&dwState!=-1);"
    FPRINT FP_WRITE,"           if(dwState==WAIT_OBJECT_0) fRet=TRUE;"
    FPRINT FP_WRITE,"         }"
    FPRINT FP_WRITE,"     }"
    FPRINT FP_WRITE,"EXITRUN:;"
    FPRINT FP_WRITE,"  if(pi.hThread)  CloseHandle(pi.hThread);"
    FPRINT FP_WRITE,"  if(pi.hProcess) CloseHandle(pi.hProcess);"
    FPRINT FP_WRITE,"  if(msg.message==WM_QUIT) PostQuitMessage(0);"
    FPRINT FP_WRITE,"  return fRet;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_PlayWav THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: PlayWav"
    FPRINT FP_WRITE,"void PlayWav (const char *A, int rsid, int Sync)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  if(!rsid)"
    FPRINT FP_WRITE,"     PlaySound(A, NULL, SND_FILENAME|SND_NODEFAULT|Sync);"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      LPSTR lpRes = (LPSTR)GetResource(rsid, RT_RCDATA, 0);"
    FPRINT FP_WRITE,"      if (lpRes==NULL) return; "
    FPRINT FP_WRITE,"      PlaySound(lpRes, NULL, SND_MEMORY|SND_NODEFAULT|Sync);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_Download THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Download"
    FPRINT FP_WRITE,"int Download (char *URL,char *Localname)"
    FPRINT FP_WRITE,"{"
'    FPRINT FP_WRITE,"  register int RetVal;"
'    FPRINT FP_WRITE,"  RetVal=BCX_DynaCallB (", ENC$("DeleteUrlCacheEntry"), ",",ENC$("wininet.dll"), ", 1, URL);"
'    FPRINT FP_WRITE,"  RetVal=BCX_DynaCallB (", ENC$("URLDownloadToFile"), ",",ENC$("urlmon.dll"), ",5,NULL,URL,Localname,BINDF_GETNEWESTVERSION,NULL);"
'    FPRINT FP_WRITE,"  return (RetVal=!RetVal);"
    FPRINT FP_WRITE,"    DeleteUrlCacheEntry(URL);"
    FPRINT FP_WRITE,"    if(URLDownloadToFile(NULL, URL, Localname, BINDF_GETNEWESTVERSION, NULL) == S_OK )"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"        return 1;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"    return 0;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_FirstInstance THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: FindFirstInstance"
    FPRINT FP_WRITE,"BOOL FindFirstInstance (const char *Application)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HWND  hWnd;"
    FPRINT FP_WRITE,"  char EventName";cSizeOfADefaultString$;";"
    FPRINT FP_WRITE,"  hWnd=FindWindow(Application,NULL);"
    FPRINT FP_WRITE,"  if(hWnd)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      if(IsIconic(hWnd))"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"          strcpy(EventName, Application);"
    FPRINT FP_WRITE,"          strcat(EventName,",ENC$("_EnFI"),");"
    FPRINT FP_WRITE,"          CreateMutex(NULL,TRUE,EventName);"
    FPRINT FP_WRITE,"          if(GetLastError()==ERROR_ALREADY_EXISTS)"
    FPRINT FP_WRITE,"            {"
    FPRINT FP_WRITE,"              return TRUE;"
    FPRINT FP_WRITE,"            }"
    FPRINT FP_WRITE,"          DWORD  dwVersion;"
    'jcfuller changed
    'FPRINT FP_WRITE,"          int    IsNT;"
    FPRINT FP_WRITE,"          int    IsNT={0};"
    FPRINT FP_WRITE,"          dwVersion=GetVersion();"
    FPRINT FP_WRITE,"          if(dwVersion<0x80000000&&(DWORD)(LOBYTE(LOWORD(dwVersion)))>=5)"
    FPRINT FP_WRITE,"            {"
    FPRINT FP_WRITE,"              IsNT=1;"
    FPRINT FP_WRITE,"            }"
    FPRINT FP_WRITE,"          while(GetForegroundWindow()!=hWnd)"
    FPRINT FP_WRITE,"            {"
    FPRINT FP_WRITE,"              FlashWindow(hWnd,TRUE);"
    FPRINT FP_WRITE,"              Sleep(450);"
    FPRINT FP_WRITE,"              if(IsNT==1)"
    FPRINT FP_WRITE,"                {"
    FPRINT FP_WRITE,"                  FlashWindow(hWnd,FALSE);"
    FPRINT FP_WRITE,"                }"
    FPRINT FP_WRITE,"            }"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"      SetForegroundWindow(hWnd);"
    FPRINT FP_WRITE,"      return TRUE;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  return FALSE;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

'added (char*) to Src in memmove
  IF Use_PeekStr THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: peekstr"
    FPRINT FP_WRITE,"char *peekstr (LPVOID Src, int Count)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *Des=BCX_TmpStr(Count,1,1);"
    FPRINT FP_WRITE,"  memmove(Des,(char*)Src,Count);"
    FPRINT FP_WRITE,"  return Des;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Inputbox THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: InputBox"
    FPRINT FP_WRITE,"char *InputBox (const char *Title, const char *Prompt, const char *Value,int psw)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *BCX_RetStr;"
    FPRINT FP_WRITE,"  CreatePrompter((char*)Title,(char*)Prompt,(char*)Value,(int) psw);"
    FPRINT FP_WRITE,"  BCX_RetStr=BCX_TmpStr(strlen(BCX_INPUTBOX_VAL),1,1);"
    FPRINT FP_WRITE,"  return strcpy(BCX_RetStr,BCX_INPUTBOX_VAL);"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"LRESULT CreatePrompter";
    FPRINT FP_WRITE,"(char *Title, char *Prpt, char *Value, int psw)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  LPDLGITEMTEMPLATE lpdit;"
    FPRINT FP_WRITE,"  LPDLGTEMPLATE lpdt;"
    FPRINT FP_WRITE,"  HINSTANCE hInst;"
    FPRINT FP_WRITE,"  HGLOBAL hgbl;"
    FPRINT FP_WRITE,"  LRESULT ret;"
    FPRINT FP_WRITE,"  LPWORD lpw;"
    FPRINT FP_WRITE,"  LPWSTR lpwsz;"
    FPRINT FP_WRITE,"  DWORD MyStyle;"
    FPRINT FP_WRITE,"  int ID_CANCEL = 101;"
    FPRINT FP_WRITE,"  int ID_TEXT   = 102;"
    FPRINT FP_WRITE,"  int ID_EDIT   = 103;"
    FPRINT FP_WRITE,"  int ID_OK     = 104;"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"  hgbl=GlobalAlloc(GMEM_ZEROINIT,32767);"
    FPRINT FP_WRITE,"  lpdt=(LPDLGTEMPLATE)GlobalLock(hgbl);\n"
    FPRINT FP_WRITE,"  MyStyle = WS_VISIBLE | DS_NOFAILCREATE | WS_BORDER |"
    FPRINT FP_WRITE,"            DS_CENTER  | DS_SETFONT;"
    FPRINT FP_WRITE,"  // ********************************"
    FPRINT FP_WRITE,"  //  Create the InputBox Window"
    FPRINT FP_WRITE,"  // ********************************"
    FPRINT FP_WRITE,"  lpdt->style=MyStyle;"
    FPRINT FP_WRITE,"  lpdt->cdit=4;"
    FPRINT FP_WRITE,"  lpdt->cx = 150;"
    FPRINT FP_WRITE,"  lpdt->cy =  60;"
    FPRINT FP_WRITE,"  lpw = (LPWORD)(lpdt+1);"
    FPRINT FP_WRITE,"  *lpw++ = 0;"
    FPRINT FP_WRITE,"  *lpw++ = 0;"
    FPRINT FP_WRITE,"  lpwsz = (LPWSTR)lpw;"
    FPRINT FP_WRITE,"  lpw+=MultiByteToWideChar(CP_ACP,0,Title,-1,lpwsz,1+strlen(Title)*2);"
    FPRINT FP_WRITE,"  *lpw++ = DEFAULT_PITCH;"
    FPRINT FP_WRITE,"  lpwsz = (LPWSTR)lpw;"
    FPRINT FP_WRITE,"  lpw+=MultiByteToWideChar(CP_ACP,0,", ENC$("MS Sans Serif") ,",-1,lpwsz,27);"
    FPRINT FP_WRITE,"  // ********************************"
    FPRINT FP_WRITE,"  //  Create the CANCEL button."
    FPRINT FP_WRITE,"  // ********************************\n"
    FPRINT FP_WRITE,"  lpw   = lpwAlign(lpw);"
    FPRINT FP_WRITE,"  lpdit = (LPDLGITEMTEMPLATE)lpw;"
    FPRINT FP_WRITE,"  lpdit->x  = 95;"
    FPRINT FP_WRITE,"  lpdit->y  = 31;"
    FPRINT FP_WRITE,"  lpdit->cx = 35;"
    FPRINT FP_WRITE,"  lpdit->cy = 12;"
    FPRINT FP_WRITE,"  lpdit->id=ID_CANCEL;"
    FPRINT FP_WRITE,"  lpdit->style = WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | WS_TABSTOP;"
    FPRINT FP_WRITE,"  lpw = (LPWORD)(lpdit+1);"
    FPRINT FP_WRITE,"  *lpw++ = 0xFFFF;"
    FPRINT FP_WRITE,"  *lpw++ = 0x0080;"
    FPRINT FP_WRITE,"  lpwsz  = (LPWSTR)lpw;"
    FPRINT FP_WRITE,"  lpw+=MultiByteToWideChar(CP_ACP,0," , ENC$("CANCEL"),",-1,lpwsz,13);"
    FPRINT FP_WRITE,"  *lpw++ = 0;"
    FPRINT FP_WRITE,"  // ********************************"
    FPRINT FP_WRITE,"  //  Create the OK button."
    FPRINT FP_WRITE,"  // ********************************"
    FPRINT FP_WRITE,"  lpw   = lpwAlign(lpw);"
    FPRINT FP_WRITE,"  lpdit = (LPDLGITEMTEMPLATE)lpw;"
    FPRINT FP_WRITE,"  lpdit->x = 20;"
    FPRINT FP_WRITE,"  lpdit->y = 31;"
    FPRINT FP_WRITE,"  lpdit->cx= 35;"
    FPRINT FP_WRITE,"  lpdit->cy= 12;"
    FPRINT FP_WRITE,"  lpdit->id=ID_OK;"
    FPRINT FP_WRITE,"  lpdit->style = WS_CHILD | WS_VISIBLE | BS_DEFPUSHBUTTON | WS_TABSTOP;"
    FPRINT FP_WRITE,"  lpw    = (LPWORD)(lpdit+1);"
    FPRINT FP_WRITE,"  *lpw++ = 0xFFFF;"
    FPRINT FP_WRITE,"  *lpw++ = 0x0080;"
    FPRINT FP_WRITE,"  lpwsz  = (LPWSTR)lpw;"
    FPRINT FP_WRITE,"  lpw+=MultiByteToWideChar(CP_ACP,0,", ENC$("OK"), ",-1,lpwsz,5);"
    FPRINT FP_WRITE,"  *lpw++ = 0;"
    FPRINT FP_WRITE,"  // ********************************"
    FPRINT FP_WRITE,"  //  Create the STATIC control"
    FPRINT FP_WRITE,"  // ********************************"
    FPRINT FP_WRITE,"  lpw   = lpwAlign(lpw);"
    FPRINT FP_WRITE,"  lpdit = (LPDLGITEMTEMPLATE)lpw;"
    FPRINT FP_WRITE,"  lpdit->x  =  10;"
    FPRINT FP_WRITE,"  lpdit->y  =   5;"
    FPRINT FP_WRITE,"  lpdit->cx = 140;"
    FPRINT FP_WRITE,"  lpdit->cy =  10;"
    FPRINT FP_WRITE,"  lpdit->id=ID_TEXT;"
    FPRINT FP_WRITE,"  lpdit->style = WS_CHILD | WS_VISIBLE | SS_LEFT;"
    FPRINT FP_WRITE,"  lpw=(LPWORD)(lpdit+1);"
    FPRINT FP_WRITE,"  *lpw++ = 0xFFFF;"
    FPRINT FP_WRITE,"  *lpw++ = 0x0082;"
    FPRINT FP_WRITE,"  lpwsz  = (LPWSTR)lpw;"
    FPRINT FP_WRITE,"  lpw+=MultiByteToWideChar(CP_ACP,0,Prpt,-1,lpwsz,1+strlen(Prpt)*2);"
    FPRINT FP_WRITE,"  *lpw++ = 0;             // no creation data"
    FPRINT FP_WRITE,"  // ********************************"
    FPRINT FP_WRITE,"  //  Create the EDIT control"
    FPRINT FP_WRITE,"  // ********************************"
    FPRINT FP_WRITE,"  lpw   = (LPWORD)lpwAlign(lpw);"
    FPRINT FP_WRITE,"  lpdit = (LPDLGITEMTEMPLATE)lpw;"
    FPRINT FP_WRITE,"  lpdit->x  =  10;"
    FPRINT FP_WRITE,"  lpdit->y  =  15;"
    FPRINT FP_WRITE,"  lpdit->cx = 130;"
    FPRINT FP_WRITE,"  lpdit->cy =  12;"
    FPRINT FP_WRITE,"  lpdit->id=ID_EDIT;"
    FPRINT FP_WRITE,"  if(psw)"
    FPRINT FP_WRITE,"    lpdit->style = WS_CHILD | WS_TABSTOP | WS_VISIBLE | ES_AUTOHSCROLL | WS_BORDER | ES_PASSWORD;"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"    lpdit->style = WS_CHILD | WS_TABSTOP | WS_VISIBLE | ES_AUTOHSCROLL | WS_BORDER ;"
    FPRINT FP_WRITE,"  lpw    = (LPWORD)(lpdit+1);"
    FPRINT FP_WRITE,"  *lpw++ = 0xFFFF;"
    FPRINT FP_WRITE,"  *lpw++ = 0x0081;"
    FPRINT FP_WRITE,"  lpwsz  = (LPWSTR)lpw;"
    FPRINT FP_WRITE,"  lpw+=MultiByteToWideChar(CP_ACP,0,Value,-1,lpwsz,1+strlen(Value)*2);"
    FPRINT FP_WRITE,"  *lpw++ = 0;"
    FPRINT FP_WRITE,"  // ******************"
    FPRINT FP_WRITE,"  GlobalUnlock(hgbl);"
    FPRINT FP_WRITE,"  hInst = (HINSTANCE)(LONG_PTR)GetWindowLongPtr(0,GWLP_HINSTANCE);"
    FPRINT FP_WRITE,"  ret = DialogBoxIndirect";
    FPRINT FP_WRITE," (hInst,(LPDLGTEMPLATE)hgbl,GetActiveWindow(),(DLGPROC)Prompter);"
    FPRINT FP_WRITE,"  GlobalFree(hgbl);"
    FPRINT FP_WRITE,"  return ret;"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"LRESULT CALLBACK Prompter";
    FPRINT FP_WRITE,"(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int ID_CANCEL = 101;"
    FPRINT FP_WRITE,"  int ID_EDIT   = 103;"
    FPRINT FP_WRITE,"  int ID_OK     = 104;\n"
    FPRINT FP_WRITE,"  for(;;)"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"  if(Msg==WM_INITDIALOG)"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"    SetFocus(GetDlgItem(hWnd,ID_EDIT));"
    FPRINT FP_WRITE,"    return 0;"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"  if(Msg==WM_COMMAND)"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"    if(LOWORD(wParam)==ID_OK)"
    FPRINT FP_WRITE,"     {"
    FPRINT FP_WRITE,"      GetDlgItemText(hWnd,ID_EDIT,BCX_INPUTBOX_VAL,";cDefaultStringSize;");"
    FPRINT FP_WRITE,"      EndDialog(hWnd,0);"
    FPRINT FP_WRITE,"     }"
    FPRINT FP_WRITE,"    if(LOWORD(wParam)==ID_CANCEL)"
    FPRINT FP_WRITE,"     {"
    FPRINT FP_WRITE,"      *BCX_INPUTBOX_VAL=0;"
    FPRINT FP_WRITE,"      SendMessage(hWnd,WM_CLOSE,0,0);"
    FPRINT FP_WRITE,"     }"
    FPRINT FP_WRITE,"    break;"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"  if(Msg==WM_CLOSE)"
    FPRINT FP_WRITE,"  EndDialog(hWnd,0);"
    FPRINT FP_WRITE,"  break;"
    FPRINT FP_WRITE,"  }"
    FPRINT FP_WRITE,"  return 0;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Infobox THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: InfoBox"
    FPRINT FP_WRITE,"void InfoBox(const char *Title, const char *Value, int xSize, int ySize)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  LPDLGITEMTEMPLATE lpdit;"
    FPRINT FP_WRITE,"  LPDLGTEMPLATE lpdt;"
    FPRINT FP_WRITE,"  HINSTANCE hInst;"
    FPRINT FP_WRITE,"  HGLOBAL hgbl;"
    FPRINT FP_WRITE,"  LPWORD lpw;"
    FPRINT FP_WRITE,"  LPWSTR lpwsz;"
    FPRINT FP_WRITE,"  int nchar;"
    FPRINT FP_WRITE,"  int ID_EDIT = 101;"
    FPRINT FP_WRITE,"  int ID_OKAY = 102;"
    FPRINT FP_WRITE,"  // *************************************"
    FPRINT FP_WRITE,"  hgbl=GlobalAlloc(GMEM_ZEROINIT,49152);"
    FPRINT FP_WRITE,"  lpdt=(LPDLGTEMPLATE)GlobalLock(hgbl);"
    FPRINT FP_WRITE,"  // *************************************"
    FPRINT FP_WRITE,"  //  Create the InfoBox Window"
    FPRINT FP_WRITE,"  // *************************************"
    FPRINT FP_WRITE,"  lpdt->style=WS_VISIBLE | DS_NOFAILCREATE | WS_BORDER | DS_CENTER | DS_SETFONT;"
    FPRINT FP_WRITE,"  lpdt->cdit=2;"
    FPRINT FP_WRITE,"  lpdt->cx = xSize;"
    FPRINT FP_WRITE,"  lpdt->cy = ySize;"
    FPRINT FP_WRITE,"  lpw = (LPWORD)(lpdt+1);"
    FPRINT FP_WRITE,"  *lpw++ = 0;"
    FPRINT FP_WRITE,"  *lpw++ = 0;"
    FPRINT FP_WRITE,"  lpwsz = (LPWSTR)lpw;"
    FPRINT FP_WRITE,"  nchar = MultiByteToWideChar(CP_ACP,0,Title,-1,lpwsz,1+(2*strlen(Title)));"
    FPRINT FP_WRITE,"  lpw+= nchar;"
    FPRINT FP_WRITE,"  *lpw++ = DEFAULT_PITCH;"
    FPRINT FP_WRITE,"  lpwsz = (LPWSTR)lpw;"
    FPRINT FP_WRITE,"  nchar = MultiByteToWideChar(CP_ACP,0,",ENC$("Courier"),",-1,lpwsz,15);"
    FPRINT FP_WRITE,"  lpw+= nchar;"
    FPRINT FP_WRITE,"  // ********************************"
    FPRINT FP_WRITE,"  //  Create the OKAY button."
    FPRINT FP_WRITE,"  // ********************************"
    FPRINT FP_WRITE,"  lpw   = lpwAlign(lpw);"
    FPRINT FP_WRITE,"  lpdit = (LPDLGITEMTEMPLATE)lpw;"
    FPRINT FP_WRITE,"  lpdit->x  = (xSize/2)-24;"
    FPRINT FP_WRITE,"  lpdit->y  = ySize - 29;"
    FPRINT FP_WRITE,"  lpdit->cx = 40;"
    FPRINT FP_WRITE,"  lpdit->cy = 12;"
    FPRINT FP_WRITE,"  lpdit->id = ID_OKAY;"
    FPRINT FP_WRITE,"  lpdit->style = WS_CHILD | WS_VISIBLE | BS_DEFPUSHBUTTON | WS_TABSTOP;"
    FPRINT FP_WRITE,"  lpw = (LPWORD)(lpdit+1);"
    FPRINT FP_WRITE,"  *lpw++ = 0xFFFF;"
    FPRINT FP_WRITE,"  *lpw++ = 0x0080;"
    FPRINT FP_WRITE,"  lpwsz  = (LPWSTR)lpw;"
    FPRINT FP_WRITE,"  nchar  = MultiByteToWideChar(CP_ACP,0,",ENC$("Okay"),",-1,lpwsz,9);"
    FPRINT FP_WRITE,"  lpw+= nchar;"
    FPRINT FP_WRITE,"  lpw = lpwAlign(lpw);"
    FPRINT FP_WRITE,"  *lpw++ = 0;"
    FPRINT FP_WRITE,"  // ************************************"
    FPRINT FP_WRITE,"  //  Create the Read-Only EDIT control"
    FPRINT FP_WRITE,"  // ************************************"
    FPRINT FP_WRITE,"  lpw   = (LPWORD)lpwAlign(lpw);"
    FPRINT FP_WRITE,"  lpdit = (LPDLGITEMTEMPLATE)lpw;"
    FPRINT FP_WRITE,"  lpdit->x  =  4;"
    FPRINT FP_WRITE,"  lpdit->y  =  8;"
    FPRINT FP_WRITE,"  lpdit->cx = xSize-9;"
    FPRINT FP_WRITE,"  lpdit->cy = ySize-40;"
    FPRINT FP_WRITE,"  lpdit->id=ID_EDIT;"
    FPRINT FP_WRITE,"  lpdit->style = WS_VISIBLE  | WS_VSCROLL   | ES_AUTOHSCROLL | WS_CHILD |"
    FPRINT FP_WRITE,"                 ES_READONLY | ES_MULTILINE | ES_WANTRETURN  | WS_HSCROLL;"
    FPRINT FP_WRITE,"  lpw    = (LPWORD)(lpdit+1);"
    FPRINT FP_WRITE,"  *lpw++ = 0xFFFF;"
    FPRINT FP_WRITE,"  *lpw++ = 0x0081;"
    FPRINT FP_WRITE,"  lpwsz  = (LPWSTR)lpw;"
    FPRINT FP_WRITE,"  nchar  = MultiByteToWideChar(CP_ACP,0,Value,-1,lpwsz,1+(2*strlen(Value)));"
    FPRINT FP_WRITE,"  lpw+=    nchar;"
    FPRINT FP_WRITE,"  lpw    = lpwAlign(lpw);"
    FPRINT FP_WRITE,"  *lpw++ = 0;"
    FPRINT FP_WRITE,"  // ********************************"
    FPRINT FP_WRITE,"  GlobalUnlock(hgbl);"
    FPRINT FP_WRITE,"  hInst = (HINSTANCE)(LONG_PTR)GetWindowLongPtr(0,GWLP_HINSTANCE);"
    FPRINT FP_WRITE,"  DialogBoxIndirect (hInst,(LPDLGTEMPLATE)hgbl,GetActiveWindow(),(DLGPROC)CB_InfoBox);"
    FPRINT FP_WRITE,"  GlobalFree(hgbl);"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"LRESULT CALLBACK CB_InfoBox(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int   ID_OKAY = 102;"
    FPRINT FP_WRITE,"  if(Msg==WM_INITDIALOG)"
    FPRINT FP_WRITE,"    return TRUE;\n"
    FPRINT FP_WRITE,"  if(Msg==WM_COMMAND&&LOWORD(wParam)==ID_OKAY)"
    FPRINT FP_WRITE,"    EndDialog(hWnd,0);\n"
    FPRINT FP_WRITE,"  if(Msg==WM_CLOSE)"
    FPRINT FP_WRITE,"    EndDialog(hWnd,0);"
    FPRINT FP_WRITE,"  return 0;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Inputbox OR Use_Infobox THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: lpwAligh"
    FPRINT FP_WRITE,"LPWORD lpwAlign (LPWORD lpIn)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  BYTE*  ul;"
    FPRINT FP_WRITE,"  ul=(BYTE*)lpIn;"
    FPRINT FP_WRITE,"  while((ULONGLONG)ul & 3)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      ul++;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  return (LPWORD)ul;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Center THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Center"
    FPRINT FP_WRITE,"void Center (HWND hwnd, HWND Xhwnd, HWND Yhwnd)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  RECT rect, rectP;"
    FPRINT FP_WRITE,"  int  x, y, width, height;"
    FPRINT FP_WRITE,"  int  screenwidth, screenheight;"
    FPRINT FP_WRITE,"  if(Xhwnd==0)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      RECT  DesktopArea;"
    FPRINT FP_WRITE,"      RECT  rc;"
    FPRINT FP_WRITE,"      SystemParametersInfo(SPI_GETWORKAREA,0,&DesktopArea,0);"
    FPRINT FP_WRITE,"      GetWindowRect(hwnd,&rc);"
    FPRINT FP_WRITE,"      SetWindowPos(hwnd,HWND_TOP,"
    FPRINT FP_WRITE,"        ((DesktopArea.right-DesktopArea.left)-(rc.right-rc.left))/2+"
    FPRINT FP_WRITE,"          DesktopArea.left,((DesktopArea.bottom-DesktopArea.top)-"
    FPRINT FP_WRITE,"         (rc.bottom-rc.top))/2 + DesktopArea.top,0,0,SWP_NOSIZE);"
    FPRINT FP_WRITE,"      return;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  GetWindowRect (hwnd,&rect);"
    FPRINT FP_WRITE,"  GetWindowRect (Xhwnd,&rectP);"
    FPRINT FP_WRITE,"  width = rect.right-rect.left;"
    FPRINT FP_WRITE,"  x = ((rectP.right-rectP.left)-width)/2 + rectP.left;"
    FPRINT FP_WRITE,"  if(Yhwnd==NULL)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      height = rect.bottom-rect.top;"
    FPRINT FP_WRITE,"      y = ((rectP.bottom-rectP.top)-height)/2 + rectP.top;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      GetWindowRect(Yhwnd,&rectP);"
    FPRINT FP_WRITE,"      height = rect.bottom-rect.top;"
    FPRINT FP_WRITE,"      y = ((rectP.bottom-rectP.top)-height)/2+rectP.top;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  screenwidth = GetSystemMetrics(SM_CXSCREEN);"
    FPRINT FP_WRITE,"  screenheight = GetSystemMetrics(SM_CYSCREEN);"
    FPRINT FP_WRITE,"  if ((x<0)) x=0;"
    FPRINT FP_WRITE,"  if ((y<0)) y=0;"
    FPRINT FP_WRITE,"  if ((x+width>screenwidth))   x = screenwidth-width;"
    FPRINT FP_WRITE,"  if ((y+height>screenheight)) y = screenheight-height;"
    FPRINT FP_WRITE,"  MoveWindow (hwnd, x, y, width, height, FALSE);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_Colordlg THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_ColorDlg"
    FPRINT FP_WRITE,"int BCX_ColorDlg (COLORREF defcolor,HWND hWnd)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  static COLORREF  CustColors[16];"
    FPRINT FP_WRITE,"  CHOOSECOLOR cc;"
    FPRINT FP_WRITE,"  memset(&cc,0,sizeof(cc));"
    FPRINT FP_WRITE,"  cc.lStructSize=sizeof(CHOOSECOLOR);"
    FPRINT FP_WRITE,"  cc.hwndOwner=hWnd;"
    FPRINT FP_WRITE,"  cc.rgbResult=defcolor;"
    FPRINT FP_WRITE,"  cc.lpCustColors=CustColors;"
    FPRINT FP_WRITE,"  cc.Flags=CC_RGBINIT|CC_FULLOPEN;"
    FPRINT FP_WRITE,"  CmDlgHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)SBProc,(HINSTANCE)NULL,GetCurrentThreadId());"
    FPRINT FP_WRITE,"  ChooseColor(&cc);"
    FPRINT FP_WRITE,"  return cc.rgbResult;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_Print THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Print"
    FPRINT FP_WRITE,"int BCX_Print(HWND hWnd, int x, int y, const char *Text, HDC DrawHDC)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int b=0;"
    FPRINT FP_WRITE,"  if(!DrawHDC) DrawHDC=GetDC(hWnd),b=1;"
    FPRINT FP_WRITE,"  int a=TextOut(DrawHDC,x,y,Text,strlen(Text));"
    FPRINT FP_WRITE,"  if(b) ReleaseDC(hWnd,DrawHDC);"
    FPRINT FP_WRITE,"  return a;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCXMDialog THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_MDialog"
    FPRINT FP_WRITE,"INT_PTR BCX_MDialog (DLGPROC DPro,const char* title,HWND hWnd,int X,int Y,int W,int H,int Style,int Exstyle,char *fntface,int fsz)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  LPDLGTEMPLATE  lpdt;"
    FPRINT FP_WRITE,"  LPWORD  lpw;"
    FPRINT FP_WRITE,"  LPVOID tc=calloc(256+(strlen(title)*2),1);"
    FPRINT FP_WRITE,"  lpdt=(LPDLGTEMPLATE)tc;"
    FPRINT FP_WRITE,"  if(!Style)"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"     lpdt->style=WS_POPUP|WS_SYSMENU|DS_MODALFRAME|WS_CAPTION;"
    FPRINT FP_WRITE,"     if(fsz) lpdt->style=lpdt->style|DS_SETFONT;"
    FPRINT FP_WRITE,"   }else{"
    FPRINT FP_WRITE,"     lpdt->style=Style;"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"  lpdt->dwExtendedStyle=Exstyle;"
    FPRINT FP_WRITE,"  lpdt->cdit=0;"
    FPRINT FP_WRITE,"  lpdt->x =X;  lpdt->y =Y;"
    FPRINT FP_WRITE,"  lpdt->cx=W;  lpdt->cy=H;"
    FPRINT FP_WRITE,"  "
    FPRINT FP_WRITE,"  lpw=(LPWORD)(lpdt+1);"
    FPRINT FP_WRITE,"  *lpw++=0; *lpw++=0;"
    FPRINT FP_WRITE,"  lpw+=MultiByteToWideChar(CP_ACP,0,title,-1,(LPWSTR)lpw,2*strlen(title)+1);"
    FPRINT FP_WRITE,"  if(fsz) { *lpw++ = fsz;"
    FPRINT FP_WRITE,"  MultiByteToWideChar(CP_ACP,0,fntface,-1,(LPWSTR)lpw,2*strlen(fntface)+1); }"
    FPRINT FP_WRITE," INT_PTR ret=DialogBoxIndirect(BCX_hInstance,(LPDLGTEMPLATE)tc,hWnd,(DLGPROC)DPro);"
    FPRINT FP_WRITE,"  free(tc);"
    FPRINT FP_WRITE,"  SetDialogScale(0,1);  //restore previous scale"
    FPRINT FP_WRITE,"  return ret;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCXDialog THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Dialog"
    FPRINT FP_WRITE,"HWND BCX_Dialog (DLGPROC DPro,const char* title,HWND hWnd,int X,int Y,int W,int H,int Style,int Exstyle,char *fntface,int fsz)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  static HWND hdlgs[32];"
    FPRINT FP_WRITE,"  static DLGPROC dp[32];"
    FPRINT FP_WRITE,"  int i=-1, nxt=-1;"
    FPRINT FP_WRITE,"  while (++i<32&&dp[i]!=DPro)"
    FPRINT FP_WRITE,"    { if(dp[i]==0&&nxt==-1) nxt=i; }"
    FPRINT FP_WRITE,"  if(i<32) // if < 32 then we have a match"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      if(IsWindow(hdlgs[i])!=0) return 0;"
    FPRINT FP_WRITE,"      if(nxt==-1) nxt=i;"
    FPRINT FP_WRITE,"      dp[i]=0;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  dp[nxt]=DPro;"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"  LPDLGTEMPLATE  lpdt;"
    FPRINT FP_WRITE,"  LPWORD  lpw;"
    FPRINT FP_WRITE,"  LPVOID tc=calloc(256+(strlen((char*)title)*2),1);"
    FPRINT FP_WRITE,"  lpdt=(LPDLGTEMPLATE)tc;"
    FPRINT FP_WRITE,"  if(!Style)"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"     lpdt->style=WS_POPUP|WS_BORDER|WS_SYSMENU|WS_VISIBLE|WS_CAPTION;"
    FPRINT FP_WRITE,"     if(fsz) lpdt->style=lpdt->style|DS_SETFONT;"
    FPRINT FP_WRITE,"   }else{"
    FPRINT FP_WRITE,"     lpdt->style=Style;"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"  lpdt->dwExtendedStyle=Exstyle;"
    FPRINT FP_WRITE,"  lpdt->cdit=0;"
    FPRINT FP_WRITE,"  lpdt->x =X;  lpdt->y =Y;"
    FPRINT FP_WRITE,"  lpdt->cx=W;  lpdt->cy=H;"
    FPRINT FP_WRITE,"  "
    FPRINT FP_WRITE,"  lpw=(LPWORD)(lpdt+1);"
    FPRINT FP_WRITE,"  *lpw++=0; *lpw++=0;"
    FPRINT FP_WRITE,"  lpw+=MultiByteToWideChar(CP_ACP,0,(char*)title,-1,(LPWSTR)lpw,2*strlen((char*)title)+1);"
    FPRINT FP_WRITE,"  if(fsz) { *lpw++ = fsz;"
    FPRINT FP_WRITE,"  MultiByteToWideChar(CP_ACP,0,fntface,-1,(LPWSTR)lpw,2*strlen(fntface)+1); }"
    FPRINT FP_WRITE,"  hdlgs[nxt]=CreateDialogIndirect(BCX_hInstance,(LPDLGTEMPLATE)tc,hWnd,(DLGPROC)DPro);"
    FPRINT FP_WRITE,"  free(tc);"
    FPRINT FP_WRITE,"  SetDialogScale(0,1);  //restore previous scale"
    FPRINT FP_WRITE,"  return hdlgs[nxt];"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

'jcfuller change 10/15/2012
  'IF Use_BCXDialog OR Use_BCXMDialog THEN
   IF Use_BCXDialogCommon THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: SetDialogScale"
    FPRINT FP_WRITE,"void SetDialogScale (HWND hdlg, BOOL Restor)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE," static float BaseX, BaseY;"
    FPRINT FP_WRITE," if(Restor&&BaseX)"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"    BCX_ScaleX=BaseX;"
    FPRINT FP_WRITE,"    BCX_ScaleY=BaseY;"
    FPRINT FP_WRITE,"    BaseX=BaseY=0;"
    FPRINT FP_WRITE,"    return;"
    FPRINT FP_WRITE,"  }"
    FPRINT FP_WRITE," if(!BaseX) { BaseX=BCX_ScaleX; BaseY=BCX_ScaleY; }"
    FPRINT FP_WRITE," BaseX=BCX_ScaleX; BaseY=BCX_ScaleY;  "
    FPRINT FP_WRITE," RECT rc = {0, 0, 4, 8};"
    FPRINT FP_WRITE," MapDialogRect (hdlg, &rc);"
    FPRINT FP_WRITE," BCX_ScaleX = (float)rc.right/4;"
    FPRINT FP_WRITE," BCX_ScaleY = (float)rc.bottom/8;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF
'New fget,fput,fgetc,fseek
	If Use_FGet Then
		FPRINT FP_WRITE,"DWORD FGet(HANDLE hFile, LPVOID  Buf, int bites)"
		FPRINT FP_WRITE,"{"
		FPRINT FP_WRITE,"    DWORD    dwBytesRead = {0};"
		FPRINT FP_WRITE,"    BOOL     retval = {0};"
		'FPRINT FP_WRITE,"    if(_msize(Buf) < bites )"
		FPRINT FP_WRITE,"    if(Buf == 0 )"
		FPRINT FP_WRITE,"    {"
		FPRINT FP_WRITE,"        return 0;"
		FPRINT FP_WRITE,"    }"
		FPRINT FP_WRITE,"    retval = ReadFile( hFile, Buf, bites,  &dwBytesRead, NULL);"
		FPRINT FP_WRITE,"    return dwBytesRead;"
		FPRINT FP_WRITE,"}"
	End If
	
	If Use_FGetC Then
		FPRINT FP_WRITE,"//<---UNICODE AWARE"
		FPRINT FP_WRITE,"char FGetC (HANDLE hFile)"
		FPRINT FP_WRITE,"{"
		FPRINT FP_WRITE,"    BOOL     retval = {0};"
		FPRINT FP_WRITE,"    DWORD    dwBytesRead = {0};"
		FPRINT FP_WRITE,"    char    Buf = {0};"
		FPRINT FP_WRITE,"    retval = ReadFile( hFile,  &Buf, 1,  &dwBytesRead, NULL);"
		FPRINT FP_WRITE,"    return Buf;"
		FPRINT FP_WRITE,"}"
		FPRINT FP_WRITE,"//>---UNICODE AWARE"
	End If
	
	If Use_FPut Then
		FPRINT FP_WRITE,"BOOL FPut (HANDLE hFile, LPVOID  Buf, int bites)"
		FPRINT FP_WRITE,"{"
		FPRINT FP_WRITE,"    BOOL     reval = {0};"
		FPRINT FP_WRITE,"    DWORD    dwBytesWritten = {0};"
		'FPRINT FP_WRITE,"    if(_msize(Buf) < bites )"
		FPRINT FP_WRITE,"    if(Buf == 0 )"
		FPRINT FP_WRITE,"    {"
		FPRINT FP_WRITE,"        return 0;"
		FPRINT FP_WRITE,"    }"
		FPRINT FP_WRITE,"    return WriteFile(hFile, Buf, bites, &dwBytesWritten, NULL);"
		FPRINT FP_WRITE,"}"
	End If
	
	If Use_FSeek Then
		FPRINT FP_WRITE,"void FSeek (HANDLE hFile, int Position)"
		FPRINT FP_WRITE,"{"
		FPRINT FP_WRITE,"    SetFilePointer(hFile, Position, NULL, FILE_BEGIN);"
		FPRINT FP_WRITE,"}"
	End If






  IF Use_GetDimension THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: GetDimension"
    FPRINT FP_WRITE,"int GetDimension (const char * PROPNAME,HWND WINHANDLE,BOOL InPixel)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  RECT  rcc, rcp;"
    FPRINT FP_WRITE,"  int   SX, SY, CAPH, PIX;"
    FPRINT FP_WRITE,"  if(InPixel==TRUE)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      PIX=1;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      PIX=15;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  SX=(GetSystemMetrics(SM_CXSIZEFRAME))*PIX;"
    FPRINT FP_WRITE,"  SY=(GetSystemMetrics(SM_CYSIZEFRAME))*PIX;"
    FPRINT FP_WRITE,"  CAPH=(GetSystemMetrics(SM_CYCAPTION))*PIX;"
    FPRINT FP_WRITE,"  GetWindowRect(WINHANDLE,&rcc);"
    FPRINT FP_WRITE,"  GetWindowRect(GetParent(WINHANDLE),&rcp);"
    FPRINT FP_WRITE,"  if(stricmp(PROPNAME,", ENC$("LEFT"), ")==0)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      return ((rcc.left-rcp.left)*PIX)-SX;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if(stricmp(PROPNAME,", ENC$("TOP"), ")==0)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      return ((rcc.top-rcp.top)*PIX)-CAPH-SY;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if(stricmp(PROPNAME,", ENC$("WIDTH"), ")==0)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      return (rcc.right-rcc.left)*PIX;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if(stricmp(PROPNAME,", ENC$("HEIGHT"), ")==0)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      return (rcc.bottom-rcc.top)*PIX;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  return 0;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_SetDimension THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: SetDimension"
    FPRINT FP_WRITE,"void SetDimension (const char * PROPNAME,int PROPVAL,HWND WINHANDLE,BOOL InPixel)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  RECT  rcc, rcp;"
    FPRINT FP_WRITE,"  int   X, Y, W, H, SX, SY, CAPH, PIX;"
    FPRINT FP_WRITE,"  if(InPixel==TRUE)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      PIX=1;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      PIX=15;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  SX=(GetSystemMetrics(SM_CXSIZEFRAME))*PIX;"
    FPRINT FP_WRITE,"  SY=(GetSystemMetrics(SM_CYSIZEFRAME))*PIX;"
    FPRINT FP_WRITE,"  CAPH=(GetSystemMetrics(SM_CYCAPTION))*PIX;"
    FPRINT FP_WRITE,"  GetWindowRect(WINHANDLE,&rcc);"
    FPRINT FP_WRITE,"  GetWindowRect(GetParent(WINHANDLE),&rcp);"
    FPRINT FP_WRITE,"  X=((rcc.left-rcp.left)*PIX)-SX;"
    FPRINT FP_WRITE,"  Y=((rcc.top-rcp.top)*PIX)-CAPH-SY;"
    FPRINT FP_WRITE,"  W=(rcc.right-rcc.left)*PIX;"
    FPRINT FP_WRITE,"  H=(rcc.bottom-rcc.top)*PIX;"
    FPRINT FP_WRITE,"  if(stricmp(PROPNAME,", ENC$("LEFT"), ")==0)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      X=PROPVAL;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  else if(stricmp(PROPNAME,", ENC$("TOP"), ")==0)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      Y=PROPVAL;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  else if(stricmp(PROPNAME,", ENC$("WIDTH"), ")==0)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      W=PROPVAL;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  else if(stricmp(PROPNAME,", ENC$("HEIGHT"), ")==0)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      H=PROPVAL;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  MoveWindow(WINHANDLE,X/PIX,Y/PIX,W/PIX,H/PIX,TRUE);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  If Use_DlgWin Then
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Form"
    FPRINT FP_WRITE,"HWND BC9_DlgWin(int Id)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"return CreateDialogParam(BCX_hInstance, MAKEINTRESOURCE(Id), 0, 0, 0);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  End If
  IF Use_Form THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Form"
    FPRINT FP_WRITE,"HWND BCX_Form(const char *Caption,int X,int Y,int W,int H,int Style,int Exstyle)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  if(Style==-1)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"       Style= WS_MINIMIZEBOX | WS_SIZEBOX | WS_CAPTION |"
    FPRINT FP_WRITE,"              WS_MAXIMIZEBOX | WS_POPUP   | WS_SYSMENU;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  HWND A = CreateWindowEx(Exstyle,BCX_ClassName,(char*)Caption,Style,"
    FPRINT FP_WRITE,"                          X*BCX_ScaleX,Y*BCX_ScaleY,(4+W)*BCX_ScaleX,(12+H)*BCX_ScaleY,"
    FPRINT FP_WRITE,"                          NULL,(HMENU)NULL,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"  SendMessage(A,(UINT)WM_SETFONT,(WPARAM)DefaultFont,(LPARAM)MAKELPARAM(FALSE,0));"
    FPRINT FP_WRITE,"  return A;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Status THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Status"
    FPRINT FP_WRITE,"HWND BCX_Status (const char *Text, HWND hWnd, int ID, int numparts, int *parts)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HWND A = "
    FPRINT FP_WRITE,"  CreateStatusWindow(WS_CHILD | WS_BORDER | WS_VISIBLE | SBS_SIZEGRIP, Text, hWnd, ID);"
    FPRINT FP_WRITE,"  int pts[] = {-1};"
    FPRINT FP_WRITE,"  if(!parts) parts=pts;"
    FPRINT FP_WRITE,"  SendMessage(A,(UINT)SB_SETPARTS,(WPARAM)numparts,(LPARAM)parts);"
    FPRINT FP_WRITE,"  return A;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Modstyle THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: ModStyle"
    FPRINT FP_WRITE,"BOOL ModStyle(HWND hWnd, DWORD dwAdd, DWORD dwRemove, BOOL bEx)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  SetLastError(0);"
'jcfuller would not compile for 64bit
'    FPRINT FP_WRITE,"  DWORD dwStyle = (DWORD)PtrToUlong(GetWindowLongPtr(hWnd,(bEx ? GWL_EXSTYLE:GWL_STYLE)));"
    'FPRINT FP_WRITE,"  DWORD dwStyle = (DWORD)PtrToUlong((const void*)GetWindowLongPtr(hWnd,(bEx ? GWL_EXSTYLE:GWL_STYLE)));"
'Robert's fix ala bcx 7.0.1
	FPRINT FP_WRITE,"  DWORD dwStyle = (ULONG_PTR)GetWindowLongPtr(hWnd,(bEx ? GWL_EXSTYLE:GWL_STYLE));"

    FPRINT FP_WRITE,"  DWORD dwNewStyle = (dwStyle & (~dwRemove)) | dwAdd;"
    FPRINT FP_WRITE,"  SetWindowLongPtr(hWnd, (bEx ? GWL_EXSTYLE : GWL_STYLE),(LONG_PTR)dwNewStyle);"
    FPRINT FP_WRITE,"  SetWindowPos(hWnd,NULL,0,0,0,0,"
    FPRINT FP_WRITE,"               SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_FRAMECHANGED);"
    FPRINT FP_WRITE,"  return (GetLastError() == 0);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Button THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Button"
    FPRINT FP_WRITE,"HWND BCX_Button(const char* Text,HWND hWnd,int id,int X,int Y,int W,int H,int Style,int Exstyle)"
    FPRINT FP_WRITE,"{ "
    FPRINT FP_WRITE,"  if(!Style)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      Style=WS_CHILD | WS_VISIBLE | BS_MULTILINE | BS_PUSHBUTTON | WS_TABSTOP;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if(Exstyle==-1)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      Exstyle=WS_EX_STATICEDGE;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  HWND A = CreateWindowEx(Exstyle,"; ENC$("button") ; ",Text,Style,"
    FPRINT FP_WRITE,"                          X*BCX_ScaleX, Y*BCX_ScaleY, W*BCX_ScaleX, H*BCX_ScaleY,"
    'jcfuller added (INT_PTR)
    FPRINT FP_WRITE,"                          hWnd,(HMENU)(INT_PTR)id,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"  SendMessage(A,(UINT)WM_SETFONT,(WPARAM)DefaultFont,(LPARAM)MAKELPARAM(FALSE,0));"
    FPRINT FP_WRITE,"  if (W==0)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      SIZE*  size=GetTextSize(Text,A,0);"
    FPRINT FP_WRITE,"      MoveWindow(A,X*BCX_ScaleX,Y*BCX_ScaleY,size->cx+24,size->cy+12,TRUE);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  return A;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BmpButton THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_BmpButton"
    FPRINT FP_WRITE,"HWND BCX_BmpButton(const char* Text,HWND hWnd,int id,int X,int Y,int W,int H,int Res,int Style,int Exstyle)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HWND    A;"
    FPRINT FP_WRITE,"  HBITMAP hBmp;"
    FPRINT FP_WRITE,"  if(!Style)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      Style=WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_BITMAP;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if(Exstyle==-1)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"       Exstyle=WS_EX_STATICEDGE;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  A = CreateWindowEx(Exstyle,"; ENC$("button");","; DDQ$; ",Style,"
    FPRINT FP_WRITE,"      X*BCX_ScaleX, Y*BCX_ScaleY, W*BCX_ScaleX, H*BCX_ScaleY,"
    'jcfuller added (INT_PTR)
    FPRINT FP_WRITE,"      hWnd,(HMENU)(INT_PTR)id,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"  SendMessage(A,(UINT)WM_SETFONT,(WPARAM)DefaultFont,(LPARAM)MAKELPARAM(FALSE,0));"
    FPRINT FP_WRITE,"  if(!Res)"
    FPRINT FP_WRITE,"     hBmp = (HBITMAP)LoadImage(0,Text,IMAGE_BITMAP,"
    FPRINT FP_WRITE,"     W*BCX_ScaleX, H*BCX_ScaleY,LR_LOADFROMFILE);"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"     hBmp=(HBITMAP)LoadImage(GetModuleHandle(0),MAKEINTRESOURCE(Res),"
    FPRINT FP_WRITE,"     IMAGE_BITMAP,W*BCX_ScaleX, H*BCX_ScaleY,0);"
    FPRINT FP_WRITE," if(!W && !H)"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"      BITMAP B;"
    FPRINT FP_WRITE,"      GetObject(hBmp,sizeof(BITMAP),&B);"
    FPRINT FP_WRITE,"      SetWindowPos(A,0,0,0,B.bmWidth,B.bmHeight,SWP_NOMOVE|SWP_FRAMECHANGED);"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"  SendMessage (A,(UINT)BM_SETIMAGE,(WPARAM)IMAGE_BITMAP,(LPARAM)hBmp);"
    FPRINT FP_WRITE,"  return A;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Edit THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Edit"
    FPRINT FP_WRITE,"HWND BCX_Edit(const char* Text,HWND hWnd,int id,int X,int Y,int W,int H,int Style,int Exstyle)"
    FPRINT FP_WRITE,"{ "
    FPRINT FP_WRITE,"  HWND  A;"
    FPRINT FP_WRITE,"  if(!Style)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      Style = WS_CHILD | WS_VISIBLE | ES_WANTRETURN |"
    FPRINT FP_WRITE,"              WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL | ES_AUTOHSCROLL;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if(Exstyle==-1)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      Exstyle = WS_EX_CLIENTEDGE;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  A = CreateWindowEx(Exstyle,"; ENC$("edit") ; ",Text, Style,"
    FPRINT FP_WRITE,"      X*BCX_ScaleX, Y*BCX_ScaleY, W*BCX_ScaleX, H*BCX_ScaleY,"
    'jcfuller added (INT_PTR)
    FPRINT FP_WRITE,"      hWnd,(HMENU)(INT_PTR)id,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"  SendMessage(A,(UINT)WM_SETFONT,(WPARAM)DefaultFont,(LPARAM)MAKELPARAM(FALSE,0));"
    FPRINT FP_WRITE,"  return A;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Elf THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: EditLoadFile"
    FPRINT FP_WRITE,"void EditLoadFile (HWND hWnd, const char *File)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int FileLen;"
    FPRINT FP_WRITE,"  char *Buff;"
    FPRINT FP_WRITE,"  FILE *FP;"
    FPRINT FP_WRITE,"  if(!Exist(File))"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      MessageBox (GetActiveWindow(), join(2,", ENC$("File Not Found:"), ",File), ", ENC$("Error!"), ",0);"
    FPRINT FP_WRITE,"      return;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if((FP=fopen(File,", ENC$("rb"), "))==0)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      MessageBox (GetActiveWindow(), join(2,", ENC$("Could not read file:"), ",File),", ENC$("Error!"), ",0);"
    FPRINT FP_WRITE,"      return;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  FileLen=lof((char*)File);"
    FPRINT FP_WRITE,"  Buff=(char*)calloc(256+FileLen,1);"
    FPRINT FP_WRITE,"  GET(FP,Buff,FileLen);"
    FPRINT FP_WRITE,"  fclose(FP);"
    FPRINT FP_WRITE,"  SendMessage(hWnd,(UINT)WM_SETTEXT,(WPARAM)0,(LPARAM)Buff);"
    FPRINT FP_WRITE,"  if(Buff)free(Buff);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_ListBoxLoadFile THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: ListBoxLoadFile"
    FPRINT FP_WRITE,"void ListBoxLoadFile (HWND hWnd, const char *A, int apend, int scrol)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  FILE* fp;"
    FPRINT FP_WRITE,"  static int siz;"
    FPRINT FP_WRITE,"  int buflen;"
    FPRINT FP_WRITE,"  char Buff";cSizeOfADefaultString$;";"
    FPRINT FP_WRITE,"  if((fp=fopen(A,", ENC$("r"), "))==0)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      MessageBox (GetActiveWindow(),", ENC$("File Not Found"), ",", ENC$("Error!"), ",0);"
    FPRINT FP_WRITE,"      return;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if(!apend)"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"     siz=0;"
    FPRINT FP_WRITE,"     SendMessage(hWnd,LB_RESETCONTENT,0,0);"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"  while(!feof(fp))"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      *Buff=0;"
    FPRINT FP_WRITE,"      fgets(Buff,";cMaxSrcLen;",fp);"
    'jcfuller -> I'm not sure I like the trim ??
    FPRINT FP_WRITE,"      strcpy(Buff,trim(Buff));"
    FPRINT FP_WRITE,"      buflen=strlen(Buff);"
    FPRINT FP_WRITE,"      if(buflen>siz) siz = buflen;"
    FPRINT FP_WRITE,"      if(buflen)"
    FPRINT FP_WRITE,"      SendMessage(hWnd,(UINT)LB_ADDSTRING, 0,(LPARAM)Buff);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"    if(scrol)"
    FPRINT FP_WRITE,"     {"
    FPRINT FP_WRITE,"       buflen = 10+GetTextSize(stringx(siz,65),hWnd,0)->cx;"
    FPRINT FP_WRITE,"       SendMessage(hWnd,(UINT)LB_SETHORIZONTALEXTENT,(WPARAM)buflen,0);"
    FPRINT FP_WRITE,"     }"
    FPRINT FP_WRITE,"  if(fp) fclose(fp);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_ComboBoxLoadFile THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: ComboBoxLoadFile"
    FPRINT FP_WRITE,"void ComboBoxLoadFile (HWND hWnd, const char *A)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  FILE* fp;"
    FPRINT FP_WRITE,"  char Buff";cSizeOfADefaultString$;";"
    FPRINT FP_WRITE,"  if((fp=fopen(A,", ENC$("r"), "))==0)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      MessageBox (GetActiveWindow(),", ENC$("File Not Found"), ",", ENC$("Error!"), ",0);"
    FPRINT FP_WRITE,"      return;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  SendMessage (hWnd,CB_RESETCONTENT,0,0);"
    FPRINT FP_WRITE,"  while(!feof(fp))"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      *Buff=0;"
    FPRINT FP_WRITE,"      fgets(Buff,";cMaxSrcLen;",fp);"
    FPRINT FP_WRITE,"      if(Buff[strlen(Buff)-1]==10)Buff[strlen(Buff)-1]=0;"
    FPRINT FP_WRITE,"      strcpy(Buff,trim(Buff));"
    FPRINT FP_WRITE,"      if(strlen(Buff))"
    FPRINT FP_WRITE,"      SendMessage(hWnd,(UINT)CB_ADDSTRING,(WPARAM)0,(LPARAM)Buff);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if(fp) fclose(fp);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_Input THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Input"
    FPRINT FP_WRITE,"HWND BCX_Input(const char* Text,HWND hWnd,int id,int X,int Y,int W,int H,int Style,int Exstyle)"
    FPRINT FP_WRITE,"{ "
    FPRINT FP_WRITE,"  HWND  A;"
    FPRINT FP_WRITE,"  if(!Style)"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"     Style = WS_CHILD | WS_VISIBLE | WS_TABSTOP | ES_LEFT | ES_AUTOHSCROLL;"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"  if(Exstyle==-1)"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"      Exstyle = WS_EX_CLIENTEDGE;"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"  A = CreateWindowEx(Exstyle,"; ENC$("edit") ; ",Text,Style,"
    FPRINT FP_WRITE,"      X*BCX_ScaleX, Y*BCX_ScaleY, W*BCX_ScaleX, H*BCX_ScaleY,"
    'jcfuller added (INT_PTR)
    FPRINT FP_WRITE,"      hWnd,(HMENU)(INT_PTR)id,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"  SendMessage(A,(UINT)WM_SETFONT,(WPARAM)DefaultFont,(LPARAM)MAKELPARAM(FALSE,0));"
    FPRINT FP_WRITE,"  return A;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Label THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Label"
    FPRINT FP_WRITE,"HWND BCX_Label(const char* Text,HWND hWnd,int id,int X,int Y,int W,int H,int Style,int Exstyle)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  if(!Style)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      Style=WS_CHILD | SS_NOTIFY | SS_LEFT | WS_VISIBLE;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  HWND A = CreateWindowEx(Exstyle,"; ENC$("static") ; ",(char*)Text,Style,"
    FPRINT FP_WRITE,"                          X*BCX_ScaleX, Y*BCX_ScaleY, W*BCX_ScaleX, H*BCX_ScaleY,"
'jcfuller 9.1.2.1 fix for g++ 64 warning
    'FPRINT FP_WRITE,"                          hWnd,(HMENU)id,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"                          hWnd,(HMENU)(INT_PTR)id,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"  SendMessage(A,(UINT)WM_SETFONT,(WPARAM)DefaultFont,(LPARAM)MAKELPARAM(FALSE,0));"
    FPRINT FP_WRITE,"  if (W==0)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      SIZE*  size=GetTextSize((char*)Text,A,0);"
    FPRINT FP_WRITE,"      MoveWindow(A,X*BCX_ScaleX,Y*BCX_ScaleY,size->cx,size->cy,TRUE);"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"  return A;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Group THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Group"
    FPRINT FP_WRITE,"HWND BCX_Group(const char* Text,HWND hWnd,int id,int X,int Y,int W,int H,int Style,int Exstyle)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HWND  A;"
    FPRINT FP_WRITE,"  if(!Style)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      Style=BS_GROUPBOX | WS_CHILD | WS_VISIBLE;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  A = CreateWindowEx(Exstyle,"; ENC$("button") ; ",Text,Style,"
    FPRINT FP_WRITE,"                     X*BCX_ScaleX, Y*BCX_ScaleY, W*BCX_ScaleX, H*BCX_ScaleY,"
    'jcfuller added (INT_PTR)
    FPRINT FP_WRITE,"                     hWnd,(HMENU)(INT_PTR)id,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"  SendMessage(A,(UINT)WM_SETFONT,(WPARAM)DefaultFont,(LPARAM)MAKELPARAM(FALSE,0));"
    FPRINT FP_WRITE,"  return A;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Checkbox THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Checkbox"
    FPRINT FP_WRITE,"HWND BCX_Checkbox(const char* Text,HWND hWnd,int id,int X,int Y,int W,int H,int Style,int Exstyle)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HWND  A;"
    FPRINT FP_WRITE,"  if(!Style)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      Style=WS_CHILD | WS_VISIBLE | BS_AUTOCHECKBOX | WS_TABSTOP;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  A = CreateWindowEx(Exstyle,"; ENC$("button") ; ",Text,Style,"
    FPRINT FP_WRITE,"                     X*BCX_ScaleX, Y*BCX_ScaleY, W*BCX_ScaleX, H*BCX_ScaleY,"
    'jcfuller added (INT_PTR)
    FPRINT FP_WRITE,"                     hWnd,(HMENU)(INT_PTR)id,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"  SendMessage(A,(UINT)WM_SETFONT,(WPARAM)DefaultFont,(LPARAM)MAKELPARAM(FALSE,0));"
    FPRINT FP_WRITE,"  if (W==0)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      SIZE*  size=GetTextSize(Text,A,0);"
    FPRINT FP_WRITE,"      MoveWindow(A,X*BCX_ScaleX,Y*BCX_ScaleY,size->cx+24,size->cy,TRUE);"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"  return A;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Radio THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Radio"
    FPRINT FP_WRITE,"HWND BCX_Radio(const char* Text,HWND hWnd,int id,int X,int Y,int W,int H,int Style,int Exstyle)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HWND  A;"
    FPRINT FP_WRITE,"  if(!Style)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      Style = Style | WS_CHILD | WS_TABSTOP | WS_VISIBLE | BS_AUTORADIOBUTTON;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  A = CreateWindowEx(Exstyle,"; ENC$("button") ; ",Text,Style,"
    FPRINT FP_WRITE,"                     X*BCX_ScaleX, Y*BCX_ScaleY, W*BCX_ScaleX, H*BCX_ScaleY,"
    'jcfuller added (INT_PTR)
    FPRINT FP_WRITE,"                     hWnd,(HMENU)(INT_PTR)id,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"  SendMessage(A,(UINT)WM_SETFONT,(WPARAM)DefaultFont,(LPARAM)MAKELPARAM(FALSE,0));"
    FPRINT FP_WRITE,"  if (W==0)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      SIZE*  size=GetTextSize(Text,A,0);"
    FPRINT FP_WRITE,"      MoveWindow(A,X*BCX_ScaleX,Y*BCX_ScaleY,size->cx+24,size->cy,TRUE);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  return A;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Combobox THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Combobox"
    FPRINT FP_WRITE,"HWND BCX_Combobox(const char* Text,HWND hWnd,int id,int X,int Y,int W,int H,int Style,int Exstyle)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HWND  A;"
    FPRINT FP_WRITE,"  if(!Style)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      Style=WS_CHILD | WS_VISIBLE | CBS_DROPDOWN|"
    FPRINT FP_WRITE,"            CBS_SORT | WS_VSCROLL | WS_TABSTOP;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if(Exstyle==-1)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      Exstyle=WS_EX_CLIENTEDGE;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  A = CreateWindowEx(Exstyle,"; ENC$("Combobox") ; ",NULL,"; "Style,"
    FPRINT FP_WRITE,"                     X*BCX_ScaleX, Y*BCX_ScaleY, W*BCX_ScaleX, H*BCX_ScaleY,"
    'jcfuller added (INT_PTR)
    FPRINT FP_WRITE,"                     hWnd,(HMENU)(INT_PTR)id,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"  SendMessage(A,(UINT)WM_SETFONT,(WPARAM)DefaultFont,(LPARAM)MAKELPARAM(FALSE,0));"
    FPRINT FP_WRITE,"  return A;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Listbox THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Listbox"
    FPRINT FP_WRITE,"HWND BCX_Listbox(const char* Text,HWND hWnd,int id,int X,int Y,int W,int H,int Style,int Exstyle)"
    FPRINT FP_WRITE,"{ "
    FPRINT FP_WRITE,"  HWND  A;"
    FPRINT FP_WRITE,"  if(!Style)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      Style=LBS_STANDARD | WS_CHILD | WS_VISIBLE |"
    FPRINT FP_WRITE,"            WS_HSCROLL | WS_VSCROLL | WS_TABSTOP;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if(Exstyle==-1)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      Exstyle=WS_EX_CLIENTEDGE;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  A = CreateWindowEx(Exstyle,"; ENC$("Listbox") ; ",NULL,"; "Style,"
    FPRINT FP_WRITE,"                     X*BCX_ScaleX, Y*BCX_ScaleY, W*BCX_ScaleX, H*BCX_ScaleY,"
    'jcfuller added (INT_PTR)
    FPRINT FP_WRITE,"                     hWnd,(HMENU)(INT_PTR)id,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"  SendMessage(A,(UINT)WM_SETFONT,(WPARAM)DefaultFont,(LPARAM)MAKELPARAM(FALSE,0));"
    FPRINT FP_WRITE,"  return A;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Treeview THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Treeview"
    FPRINT FP_WRITE,"HWND BCX_Treeview(const char* Text,HWND hWnd,int id,int X,int Y,int W,int H,int Style,int Exstyle)"
    FPRINT FP_WRITE,"{ "
    FPRINT FP_WRITE,"  HWND  A;"
    FPRINT FP_WRITE,"  if(!Style)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      Style=WS_VISIBLE | WS_CHILD | TVS_HASLINES |"
    FPRINT FP_WRITE,"            TVS_HASBUTTONS | TVS_LINESATROOT;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if(Exstyle==-1)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      Exstyle=WS_EX_CLIENTEDGE;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  A = CreateWindowEx(Exstyle,WC_TREEVIEW,NULL,Style,"
    FPRINT FP_WRITE,"                     X*BCX_ScaleX, Y*BCX_ScaleY, W*BCX_ScaleX, H*BCX_ScaleY,"
    'jcfuller added (INT_PTR)
    FPRINT FP_WRITE,"                     hWnd,(HMENU)(INT_PTR)id,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"  SendMessage(A,(UINT)WM_SETFONT,(WPARAM)DefaultFont,(LPARAM)MAKELPARAM(FALSE,0));"
    FPRINT FP_WRITE,"  return A;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Blackrect THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_BlackRect"
    FPRINT FP_WRITE,"HWND BCX_BlackRect(const char* Text,HWND hWnd,int id,int X,int Y,int W,int H,int Style,int Exstyle)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HWND  A;"
    FPRINT FP_WRITE,"  if(!Style)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      Style=WS_CHILD | SS_NOTIFY | WS_VISIBLE | SS_BLACKRECT;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  A = CreateWindowEx(Exstyle,"; ENC$("static") ; ",NULL,"; "Style,"
    FPRINT FP_WRITE,"                     X*BCX_ScaleX, Y*BCX_ScaleY, W*BCX_ScaleX, H*BCX_ScaleY,"
    'jcfuller added (INT_PTR)
    FPRINT FP_WRITE,"                     hWnd,(HMENU)(INT_PTR)id,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"  SendMessage(A,(UINT)WM_SETFONT,(WPARAM)DefaultFont,(LPARAM)MAKELPARAM(FALSE,0));"
    FPRINT FP_WRITE,"  return A;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Whiterect THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_WhiteRect"
    FPRINT FP_WRITE,"HWND BCX_WhiteRect(const char* Text,HWND hWnd,int id,int X,int Y,int W,int H,int Style,int Exstyle)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HWND  A;"
    FPRINT FP_WRITE,"  if(!Style)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      Style=WS_CHILD | SS_NOTIFY | WS_VISIBLE | SS_WHITERECT;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  A = CreateWindowEx(Exstyle,"; ENC$("static") ; ",NULL,"; "Style,"
    FPRINT FP_WRITE,"                     X*BCX_ScaleX, Y*BCX_ScaleY, W*BCX_ScaleX, H*BCX_ScaleY,"
    'jcfuller added (INT_PTR)
    FPRINT FP_WRITE,"                     hWnd,(HMENU)(INT_PTR)id,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"  SendMessage(A,(UINT)WM_SETFONT,(WPARAM)DefaultFont,(LPARAM)MAKELPARAM(FALSE,0));"
    FPRINT FP_WRITE,"  return A;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Grayrect THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_GrayRect"
    FPRINT FP_WRITE,"HWND BCX_GrayRect(const char* Text,HWND hWnd,int id,int X,int Y,int W,int H,int Style,int Exstyle)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HWND  A;"
    FPRINT FP_WRITE,"  if(!Style)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      Style=WS_CHILD | SS_NOTIFY | WS_VISIBLE | SS_GRAYRECT;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  A = CreateWindowEx(Exstyle,"; ENC$("static") ; ",NULL, Style,"
    FPRINT FP_WRITE,"                     X*BCX_ScaleX, Y*BCX_ScaleY, W*BCX_ScaleX, H*BCX_ScaleY,"
    'jcfuller added (INT_PTR)
    FPRINT FP_WRITE,"                     hWnd,(HMENU)(INT_PTR)id,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"  SendMessage(A,(UINT)WM_SETFONT,(WPARAM)DefaultFont,(LPARAM)MAKELPARAM(FALSE,0));"
    FPRINT FP_WRITE,"  return A;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Datepick THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_DatePick"
    FPRINT FP_WRITE,"HWND BCX_DatePick(const char* Text,HWND hWnd,int id,int X,int Y,int W,int H,int Style,int Exstyle)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HWND  A;"
    FPRINT FP_WRITE,"  if(!Style)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      Style=WS_CHILD | WS_TABSTOP | WS_VISIBLE | DTS_LONGDATEFORMAT;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if(Exstyle==-1)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      Exstyle=WS_EX_CLIENTEDGE;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  A = CreateWindowEx(Exstyle,";
    FPRINT FP_WRITE,                     ENC$("SysDateTimePick32");",NULL, Style,"
    FPRINT FP_WRITE,"                     X*BCX_ScaleX, Y*BCX_ScaleY, W*BCX_ScaleX, H*BCX_ScaleY,"
    'jcfuller added (INT_PTR)
    FPRINT FP_WRITE,"                     hWnd,(HMENU)(INT_PTR)id,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"  SendMessage(A,(UINT)WM_SETFONT,(WPARAM)DefaultFont,(LPARAM)MAKELPARAM(FALSE,0));"
    FPRINT FP_WRITE,"  return A;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Richedit THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_RichEdit"
    FPRINT FP_WRITE,"HWND BCX_RichEdit(const char* Text,HWND hWnd,int id,int X,int Y,int W,int H,int Style,int Exstyle)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  LoadLibrary("; ENC$("RICHED20.DLL") ; ");"
    FPRINT FP_WRITE,"  HWND  A;"
    FPRINT FP_WRITE,"  if(!Style)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      Style=WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE   |"
    FPRINT FP_WRITE,"            WS_HSCROLL     | WS_VSCROLL      | ES_MULTILINE |"
    FPRINT FP_WRITE,"            ES_AUTOVSCROLL | ES_AUTOHSCROLL  | ES_WANTRETURN;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if(Exstyle==-1)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      Exstyle=WS_EX_CLIENTEDGE;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  A=CreateWindowEx(Exstyle,RICHEDIT_CLASS,NULL,Style,"
    FPRINT FP_WRITE,"                   X*BCX_ScaleX, Y*BCX_ScaleY, W*BCX_ScaleX, H*BCX_ScaleY,"
    'jcfuller added (INT_PTR)
    FPRINT FP_WRITE,"                   hWnd,(HMENU)(INT_PTR)id,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"  SendMessage(A,EM_EXLIMITTEXT,0,";cMaxSrcLen;"); // Increase size to 1 MB"
    FPRINT FP_WRITE,"  SetWindowRTFText(A,Text);"
    FPRINT FP_WRITE,"  return A;"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"void SetWindowRTFText (HWND hWnd, const char *Text)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  typedef struct _SETTEXTEX"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"    UINT  codepage;"
    FPRINT FP_WRITE,"    DWORD flags;"
    FPRINT FP_WRITE,"  }SETTEXTEX, *LPSETTEXTEX;"
    FPRINT FP_WRITE,"  SETTEXTEX  Rtb;"
    FPRINT FP_WRITE,"  Rtb.flags=2; //ST_SELECTION;"
    FPRINT FP_WRITE,"  Rtb.codepage=CP_ACP;"
    FPRINT FP_WRITE,"  SendMessage(hWnd,(UINT)EM_SETTEXTEX,(WPARAM)&Rtb,(LPARAM)Text);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Bitmap THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Bitmap"
    FPRINT FP_WRITE,"HWND BCX_Bitmap(const char* Text,HWND hWnd,int id,int X,int Y,int W,int H,int Res,int Style,int Exstyle)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HWND A;"
    FPRINT FP_WRITE,"  HBITMAP hBitmap=NULL;"
    FPRINT FP_WRITE,"   if(!Style) Style=WS_CLIPSIBLINGS|WS_CHILD|WS_VISIBLE|SS_BITMAP|WS_TABSTOP;"
    FPRINT FP_WRITE,"   A = CreateWindowEx(Exstyle,"; ENC$("static"); ",NULL,Style,"
    FPRINT FP_WRITE,"                      X*BCX_ScaleX, Y*BCX_ScaleY,W*BCX_ScaleX, H*BCX_ScaleY,"
    'jcfuller added (INT_PTR)
    FPRINT FP_WRITE,"                      hWnd,(HMENU)(INT_PTR)id,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"   if(Res)"
    FPRINT FP_WRITE,"      hBitmap=(HBITMAP)LoadImage(GetModuleHandle(0),MAKEINTRESOURCE(Res),IMAGE_BITMAP,"
    FPRINT FP_WRITE,"                                 W*BCX_ScaleX,H*BCX_ScaleY,LR_CREATEDIBSECTION);"
    FPRINT FP_WRITE,"   else if(Text!=NULL)"
    FPRINT FP_WRITE,"     {"
    FPRINT FP_WRITE,"       if(*Text)"
    FPRINT FP_WRITE,"         hBitmap=(HBITMAP)LoadImage(0,Text,IMAGE_BITMAP,W*BCX_ScaleX,H*BCX_ScaleY,"
    FPRINT FP_WRITE,"                                    LR_LOADFROMFILE|LR_CREATEDIBSECTION);"
    FPRINT FP_WRITE,"     }"
    FPRINT FP_WRITE,"   if(hBitmap)"
    FPRINT FP_WRITE,"     SendMessage(A,(UINT)STM_SETIMAGE,(WPARAM)IMAGE_BITMAP,(LPARAM)hBitmap);"
    FPRINT FP_WRITE,"  return A;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_OlePicture THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_OlePicture"
    FPRINT FP_WRITE,"HWND BCX_OlePicture(const char* szFile,HWND hWnd,int id,int X,int Y,int W,int H,int Res,int Style,int Exstyle)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HWND       A;"
    FPRINT FP_WRITE,"  HBITMAP    hBitmap;"
    FPRINT FP_WRITE,"  BITMAP     bm;"
    FPRINT FP_WRITE,"  DWORD      dwFileSize;"
    FPRINT FP_WRITE,"  DWORD      dwBytesRead;"
    FPRINT FP_WRITE,"  HANDLE     hFile;"
    FPRINT FP_WRITE,"  LPPICTURE  gpPicture;"
    FPRINT FP_WRITE,"  LPVOID     lpPicData;"
    FPRINT FP_WRITE,"  LPVOID     pvData;"
    FPRINT FP_WRITE,"  LPSTREAM   pstm;"
    FPRINT FP_WRITE,"  HGLOBAL    hGlobal;"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"  if(!Style) Style=WS_CHILD|WS_VISIBLE|WS_TABSTOP|SS_BITMAP;"
    'FPRINT FP_WRITE,"  A=CreateWindowEx(Exstyle,", ENC$("static"), ",NULL,Style,X*BCX_ScaleX,Y*BCX_ScaleY,0,0,hWnd,(HMENU)(HMENU)id,BCX_hInstance,NULL);"
    'jcfuller changed 2/18/2013
    FPRINT FP_WRITE,"  A=CreateWindowEx(Exstyle,", ENC$("static"), ",NULL,Style,X*BCX_ScaleX,Y*BCX_ScaleY,0,0,hWnd,(HMENU)(INT_PTR)id,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"  if(Res)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      lpPicData=GetResource(Res,RT_RCDATA,&dwFileSize);"
    FPRINT FP_WRITE,"      if(lpPicData==NULL) return 0;"
    FPRINT FP_WRITE,"      hGlobal=GlobalAlloc(GMEM_MOVEABLE,dwFileSize);"
    FPRINT FP_WRITE,"      pvData=GlobalLock(hGlobal);"
    FPRINT FP_WRITE,"      CopyMemory(pvData,lpPicData,dwFileSize);"
    FPRINT FP_WRITE,"      GlobalUnlock(hGlobal);"
    FPRINT FP_WRITE,"    } else {"
    FPRINT FP_WRITE,"      hFile=CreateFile(szFile,GENERIC_READ,0,NULL,OPEN_EXISTING,0,NULL);"
    FPRINT FP_WRITE,"      dwFileSize=GetFileSize(hFile,NULL);"
    'comparing unsigned data type (DWORD) with -1
    'FPRINT FP_WRITE,"      if(dwFileSize==-1)"
    FPRINT FP_WRITE,"      if(dwFileSize==0xFFFFFFFF)"
    FPRINT FP_WRITE,"        return NULL;"
    FPRINT FP_WRITE,"      hGlobal=GlobalAlloc(GMEM_MOVEABLE,dwFileSize);"
    FPRINT FP_WRITE,"      pvData=GlobalLock(hGlobal);"
    FPRINT FP_WRITE,"      ReadFile(hFile,pvData,dwFileSize,&dwBytesRead,NULL);"
    FPRINT FP_WRITE,"      GlobalUnlock(hGlobal);"
    FPRINT FP_WRITE,"      CloseHandle(hFile);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE," CreateStreamOnHGlobal(hGlobal,TRUE,&pstm);"
    FPRINT FP_WRITE,"#ifndef __cplusplus"
    FPRINT FP_WRITE," OleLoadPicture(pstm,0,FALSE,&IID_IPicture,(LPVOID*)&gpPicture);"
    FPRINT FP_WRITE," pstm->lpVtbl->Release(pstm);"
    FPRINT FP_WRITE," gpPicture->lpVtbl->get_Handle(gpPicture,(OLE_HANDLE*)&hBitmap);"
    FPRINT FP_WRITE,"#else"
    FPRINT FP_WRITE," OleLoadPicture(pstm,0,FALSE,IID_IPicture,(LPVOID*)&gpPicture);"
    FPRINT FP_WRITE," pstm->Release();"
    FPRINT FP_WRITE," gpPicture->get_Handle((OLE_HANDLE*)&hBitmap);"
    FPRINT FP_WRITE,"#endif"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE," GetObject(hBitmap,sizeof(bm),&bm);"
    FPRINT FP_WRITE," SetWindowLongPtr(A,GWLP_USERDATA,(LONG_PTR)MAKELONG(bm.bmWidth,bm.bmHeight));"
    FPRINT FP_WRITE," hBitmap = (HBITMAP)CopyImage(hBitmap,IMAGE_BITMAP,W*BCX_ScaleX,H*BCX_ScaleY,0);"
    FPRINT FP_WRITE," SendMessage(A,(UINT)STM_SETIMAGE,(WPARAM)IMAGE_BITMAP,(LPARAM)hBitmap);"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"#ifndef __cplusplus"
    FPRINT FP_WRITE," gpPicture->lpVtbl->Release(gpPicture);"
    FPRINT FP_WRITE,"#else"
    FPRINT FP_WRITE," gpPicture->Release();"
    FPRINT FP_WRITE,"#endif"
    FPRINT FP_WRITE," return A;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Icon THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Icon"
    FPRINT FP_WRITE,"HWND BCX_Icon(const char* Text,HWND hWnd,int id,int X,int Y,int W,int H,int Res,int Style,int Exstyle)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HICON hIcon;"
    FPRINT FP_WRITE,"  DWORD dwSize;"
    FPRINT FP_WRITE,"  LPBYTE pBytes;"
    FPRINT FP_WRITE,"  if(!Style) Style=WS_CHILD | WS_VISIBLE | SS_ICON | WS_TABSTOP;"
    FPRINT FP_WRITE,"  HWND A = CreateWindowEx(Exstyle,"; ENC$("static"); ",NULL,Style,"
    FPRINT FP_WRITE,"           X*BCX_ScaleX, Y*BCX_ScaleY, 0, 0,"
    'jcfuller added (INT_PTR)
    FPRINT FP_WRITE,"           hWnd,(HMENU)(INT_PTR)id,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"  if(!Res)"
    FPRINT FP_WRITE,"    hIcon=(HICON)LoadImage(0,Text,IMAGE_ICON,W,H,LR_LOADFROMFILE);"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"     pBytes=(PBYTE)GetResource(Res,RT_ANICURSOR,&dwSize);"
    FPRINT FP_WRITE,"     if(pBytes==NULL)"
    FPRINT FP_WRITE,"       hIcon=(HICON)LoadImage"
    FPRINT FP_WRITE,"             (BCX_hInstance,MAKEINTRESOURCE(Res),IMAGE_ICON,W,H,0);"
    FPRINT FP_WRITE,"     else"
    FPRINT FP_WRITE,"       hIcon=CreateIconFromResourceEx"
    FPRINT FP_WRITE,"             (pBytes,dwSize,FALSE,0x00030000,W,H,LR_DEFAULTCOLOR);"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"  SendMessage(A,(UINT)STM_SETIMAGE,(WPARAM)IMAGE_ICON,(LPARAM)hIcon);"
    FPRINT FP_WRITE,"  return A;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Listview THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_ListView"
    FPRINT FP_WRITE,"HWND BCX_ListView(const char* Text,HWND hWnd,int id,int X,int Y,int W,int H,int Style,int Exstyle, int Cols)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HWND A;"
    FPRINT FP_WRITE,"  LV_COLUMN lvCol ="
    'FPRINT FP_WRITE,"  { LVCF_FMT|LVCF_WIDTH|LVCF_TEXT|LVCF_SUBITEM, LVCFMT_LEFT, 65, ",DDQ$,", 0, 0 };\n"
    FPRINT FP_WRITE,"  { LVCF_FMT|LVCF_WIDTH|LVCF_TEXT|LVCF_SUBITEM, LVCFMT_LEFT, 65, (char*)",DDQ$,", 0, 0 };\n"
    FPRINT FP_WRITE,"  // Note: 0x241 = LVS_REPORT | LVS_SHAREIMAGELISTS | LVS_EDITLABELS"
    FPRINT FP_WRITE,"  if(!Style) Style=WS_CHILD | WS_TABSTOP | WS_VISIBLE | 0x241 | WS_BORDER;"
    FPRINT FP_WRITE,"  if(Exstyle==-1) Exstyle=WS_EX_CLIENTEDGE;"
    FPRINT FP_WRITE,"  A = CreateWindowEx(Exstyle," ; ENC$("SysListView32");",NULL,Style,"
    FPRINT FP_WRITE,"      X*BCX_ScaleX, Y*BCX_ScaleY, W*BCX_ScaleX, H*BCX_ScaleY,"
    'jcfuller added (INT_PTR)
    FPRINT FP_WRITE,"      hWnd,(HMENU)(INT_PTR)id,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"  SendMessage(A,(UINT)WM_SETFONT,(WPARAM)DefaultFont,(LPARAM)MAKELPARAM(FALSE,0));"
    FPRINT FP_WRITE,"  Style=LVS_EX_GRIDLINES|LVS_EX_FULLROWSELECT;"
    FPRINT FP_WRITE,"  SendMessage(A,(UINT)LVM_SETEXTENDEDLISTVIEWSTYLE,(WPARAM)0,(LPARAM)Style);"
    FPRINT FP_WRITE,"  for(;lvCol.iSubItem<Cols;lvCol.iSubItem+=1)"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"    ListView_InsertColumn(A,0,&lvCol);"
    FPRINT FP_WRITE,"  }"
    FPRINT FP_WRITE,"  return A;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_Control THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Control"
    FPRINT FP_WRITE,"HWND BCX_Control(const char *Class,HWND hWnd,const char *Caption,int id,int x,int y,int w,int h,int Style,int Exstyle)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HWND A;"
    FPRINT FP_WRITE,"  if(!Style)Style = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;"
    FPRINT FP_WRITE,"  A=CreateWindowEx(Exstyle,Class,Caption,Style,"
    FPRINT FP_WRITE,"    x*BCX_ScaleX, y*BCX_ScaleY, w*BCX_ScaleX, h*BCX_ScaleY,"
    'jcfuller added (INT_PTR)
    FPRINT FP_WRITE,"    hWnd,(HMENU)(INT_PTR)id, BCX_hInstance, NULL);"
    FPRINT FP_WRITE,"  SendMessage(A,(UINT)WM_SETFONT,(WPARAM)DefaultFont,(LPARAM)MAKELPARAM(FALSE,0));"
    FPRINT FP_WRITE,"  return A;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_ProgressBar THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_ProgressBar"
    FPRINT FP_WRITE,"HWND BCX_ProgressBar(const char* Text,HWND hWnd,int id,int X,int Y,int W,int H,int Style,int Exstyle)"
    FPRINT FP_WRITE,"{ "
    FPRINT FP_WRITE,"  HWND A;"
    FPRINT FP_WRITE,"  if(!Style) Style=WS_CHILD|WS_VISIBLE;"
    FPRINT FP_WRITE,"  if(Exstyle==-1) Exstyle=WS_EX_CLIENTEDGE;"
    FPRINT FP_WRITE,"  A = CreateWindowEx(Exstyle,"; ENC$("msctls_progress32") ; ",Text,Style,"
    'jcfuller added (INT_PTR)
    FPRINT FP_WRITE,"  X*BCX_ScaleX, Y*BCX_ScaleY, W*BCX_ScaleX, H*BCX_ScaleY, hWnd,(HMENU)(INT_PTR)id,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"  SendMessage(A,PBM_SETRANGE,0,MAKELONG(0,100));"
    FPRINT FP_WRITE,"  SendMessage(A,PBM_SETSTEP,1,0 );"
    FPRINT FP_WRITE,"  return A;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_GetResource THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: GetResource"
    FPRINT FP_WRITE,"LPVOID GetResource(int Res, const char *ResType, DWORD *ResSize)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HRSRC hRes;"
    FPRINT FP_WRITE,"  HMODULE hMod=GetModuleHandle(NULL);"
    FPRINT FP_WRITE,"  hRes=FindResource(hMod,MAKEINTRESOURCE(Res),ResType);"
    FPRINT FP_WRITE,"  if(hRes==NULL) return 0;"
    FPRINT FP_WRITE,"  if(ResSize) *ResSize=SizeofResource(hMod,hRes);"
    FPRINT FP_WRITE,"  return LockResource(LoadResource(hMod,hRes));"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_GetSpecialFolder THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: GetSpecialFolder"
    FPRINT FP_WRITE,"char *GetSpecialFolder (int nFolder, int bCreate, HWND hWnd)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *BCX_RetStr=BCX_TmpStr(MAX_PATH,1,1);"
    FPRINT FP_WRITE,"  if(!SHGetSpecialFolderPath(hWnd,BCX_RetStr,nFolder,bCreate))"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      BCX_RetStr[0]=0;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  return BCX_RetStr;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_GetTextSize THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: GetTextSize"
    FPRINT FP_WRITE,"SIZE* GetTextSize(const char* text, HWND hWnd, HFONT fnt)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HDC  hdc=GetDC(hWnd);"
    FPRINT FP_WRITE,"  if(!fnt) fnt=(HFONT)SendMessage(hWnd,WM_GETFONT,0,0);"
    FPRINT FP_WRITE,"  HFONT sobj=(HFONT)SelectObject(hdc,fnt);"
    FPRINT FP_WRITE,"  static SIZE sz;"
    FPRINT FP_WRITE,"  GetTextExtentPoint32(hdc,text,strlen((char*)text),&sz);"
    FPRINT FP_WRITE,"  SelectObject(hdc,sobj);"
    FPRINT FP_WRITE,"  ReleaseDC(hWnd,hdc);"
    FPRINT FP_WRITE,"  return (&sz);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_Slider THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Slider"
    FPRINT FP_WRITE,"HWND BCX_Slider(const char* Text,HWND hWnd,int id,int X,int Y,int W,int H,int orient,int Style,int Exstyle)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HWND  A,B;"
    FPRINT FP_WRITE,"  if(Style==0||Style==TBS_VERT)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      Style=Style|WS_CHILD | WS_VISIBLE | TBS_AUTOTICKS | WS_TABSTOP;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  A = CreateWindowEx(Exstyle,TRACKBAR_CLASS,(char*)Text,Style,"
    FPRINT FP_WRITE,"      X*BCX_ScaleX, Y*BCX_ScaleY, W*BCX_ScaleX, H*BCX_ScaleY,"
    'jcfuller added (INT_PTR)
    FPRINT FP_WRITE,"      hWnd,(HMENU)(INT_PTR)id,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"  if(*Text==0) return A;"
    FPRINT FP_WRITE,"  SIZE*  size=GetTextSize((char*)Text,0,(HFONT)DefaultFont);"
    FPRINT FP_WRITE,"  size->cy+=4; size->cx+=4;"
    FPRINT FP_WRITE,"  if(orient==0||orient>3) {X=X+(W-size->cx)*.5; Y=Y+H+2;}" 'Bottom
    FPRINT FP_WRITE,"  if(orient==1) {X=X+(W-size->cx)*.5; Y=Y-size->cy;}"      'Top
    FPRINT FP_WRITE,"  if(orient==2) {X=X-size->cx; Y=Y+(H-size->cy)*.5;}"      'Left
    FPRINT FP_WRITE,"  if(orient==3) {X=X+W+4; Y=Y+(H-size->cy)*.5;}"           'Right
    FPRINT FP_WRITE,"  B = BCX_Label(Text,hWnd,0,X,Y,size->cx,size->cy,WS_CHILD|WS_VISIBLE|SS_CENTER);"
    FPRINT FP_WRITE,"  SetWindowLongPtr(A,GWLP_USERDATA,(LONG_PTR)B);"
    FPRINT FP_WRITE,"  return A;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_Splitter THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Splitter"
    FPRINT FP_WRITE,"HWND BCX_Splitter (HWND hWnd,int id,int swsStyle,int splittype,int X,int Y,int W,int H)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  LPSPLITTERINFO  lpsiWndInfo;"
    FPRINT FP_WRITE,"  RECT  rParentRect;"
    FPRINT FP_WRITE,"  static  ATOM  Class;"
    FPRINT FP_WRITE,"  if(!Class)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      static WNDCLASS  wc;"
    FPRINT FP_WRITE,"      wc.style=CS_PARENTDC;"
    FPRINT FP_WRITE,"      wc.lpfnWndProc=(WNDPROC)SplitterWndProc;"
    FPRINT FP_WRITE,"      wc.cbClsExtra=0;"
    FPRINT FP_WRITE,"      wc.cbWndExtra=4;"
    FPRINT FP_WRITE,"      wc.hInstance=BCX_hInstance;"
    FPRINT FP_WRITE,"      wc.hIcon=(HICON)NULL;"
    FPRINT FP_WRITE,"      wc.hCursor=(HCURSOR)NULL;"
    FPRINT FP_WRITE,"      wc.hbrBackground=(HBRUSH)(COLOR_ACTIVEBORDER+1);"
    FPRINT FP_WRITE,"      wc.lpszMenuName=NULL;"
    FPRINT FP_WRITE,"      wc.lpszClassName=";ENC$("SplitterWndClass");";"
    FPRINT FP_WRITE,"      Class=RegisterClass(&wc);"
    FPRINT FP_WRITE,"      if(!Class) return 0;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"  lpsiWndInfo=(LPSPLITTERINFO)GlobalAlloc(GPTR,sizeof(SPLITTERINFO));"
    FPRINT FP_WRITE,"  if(lpsiWndInfo==NULL) return NULL;"
    FPRINT FP_WRITE,"  lpsiWndInfo->swsStyle=swsStyle;"
    FPRINT FP_WRITE,"  lpsiWndInfo->splittype=splittype;"
    FPRINT FP_WRITE,"  lpsiWndInfo->percent=50;"
    FPRINT FP_WRITE,"  if(swsStyle==HS_HORIZONTAL)"
    FPRINT FP_WRITE,"      lpsiWndInfo->hCursor=LoadCursor(NULL,IDC_SIZENS);"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"      lpsiWndInfo->hCursor=LoadCursor(NULL,IDC_SIZEWE);"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"  if(W==0||H==0)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      GetClientRect(hWnd,&rParentRect);"
    FPRINT FP_WRITE,"      X=Y=0;"
    FPRINT FP_WRITE,"      W=rParentRect.right;"
    FPRINT FP_WRITE,"      H=rParentRect.bottom;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  return CreateWindow(";ENC$("SplitterWndClass");",";DDQ$;",WS_CHILD|WS_VISIBLE|WS_CLIPSIBLINGS|WS_CLIPCHILDREN,"
    'jcfuller added (INT_PTR)
    FPRINT FP_WRITE,"                      X*BCX_ScaleX,Y*BCX_ScaleY,W*BCX_ScaleX,H*BCX_ScaleY,hWnd,(HMENU)(INT_PTR)id,BCX_hInstance,lpsiWndInfo);"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"int  BCX_SetSplitPos (HWND hwnd,int nPercentPos,int nNewPos)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  LPSPLITTERINFO  lpsiInfo=(LPSPLITTERINFO)(LONG_PTR)GetWindowLongPtr(hwnd,GWLP_USERDATA);"
    FPRINT FP_WRITE,"  RECT  rcClient;"
    FPRINT FP_WRITE,"  int  nPosMax;"
    FPRINT FP_WRITE,"  int  vhExtent;"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"  if(NULL==lpsiInfo->hwPane1) lpsiInfo->hwPane1=GetWindow(hwnd,GW_CHILD);"
    FPRINT FP_WRITE,"  if(NULL==lpsiInfo->hwPane2&&NULL!=lpsiInfo->hwPane1)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      lpsiInfo->hwPane2=GetWindow(lpsiInfo->hwPane1,GW_HWNDNEXT);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  GetClientRect(hwnd,&rcClient);"
    FPRINT FP_WRITE,"  if(lpsiInfo->swsStyle==HS_HORIZONTAL)"
    FPRINT FP_WRITE,"      vhExtent = rcClient.bottom;"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"      vhExtent = rcClient.right;"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"  if(!nNewPos)"
    FPRINT FP_WRITE,"      nNewPos=(vhExtent*nPercentPos)/100;"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"      nPercentPos = 0;"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"  if(nNewPos<(MIN_PANESIZE+SPLITBAR_SIZE))"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      lpsiInfo->fMovingBar=FALSE;"
    FPRINT FP_WRITE,"      ReleaseCapture();"
    FPRINT FP_WRITE,"      nNewPos=MIN_PANESIZE+SPLITBAR_SIZE;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      nPosMax=vhExtent-(MIN_PANESIZE+SPLITBAR_SIZE);"
    FPRINT FP_WRITE,"      if(nNewPos>nPosMax)"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"          nNewPos=nPosMax;"
    FPRINT FP_WRITE,"          lpsiInfo->fMovingBar=FALSE;"
    FPRINT FP_WRITE,"          ReleaseCapture();"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"  if(!nPercentPos)"
    FPRINT FP_WRITE,"      lpsiInfo->percent=(100*nNewPos)/vhExtent;"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"      lpsiInfo->percent=nPercentPos;"
    FPRINT FP_WRITE," if(lpsiInfo->fMovingBar&&lpsiInfo->splittype) return nNewPos;"
    FPRINT FP_WRITE,"  // ===================================================== "
    FPRINT FP_WRITE,"  //  Redraw Splitter "
    FPRINT FP_WRITE,"  // ===================================================== "
    FPRINT FP_WRITE,"  if(lpsiInfo->swsStyle==HS_HORIZONTAL)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      if(lpsiInfo->hwPane1)"
    FPRINT FP_WRITE,"          MoveWindow(lpsiInfo->hwPane1,0,0,rcClient.right,nNewPos,TRUE);"
    FPRINT FP_WRITE,"      if(lpsiInfo->hwPane2)"
    FPRINT FP_WRITE,"          MoveWindow(lpsiInfo->hwPane2,0,nNewPos+SPLITBAR_SIZE,rcClient.right,rcClient.bottom-(nNewPos+SPLITBAR_SIZE),TRUE);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      if(lpsiInfo->hwPane1)"
    FPRINT FP_WRITE,"          MoveWindow(lpsiInfo->hwPane1,0,0,nNewPos,rcClient.bottom,TRUE);"
    FPRINT FP_WRITE,"      if(lpsiInfo->hwPane2)"
    FPRINT FP_WRITE,"          MoveWindow(lpsiInfo->hwPane2,nNewPos+SPLITBAR_SIZE,0,rcClient.right-(nNewPos+SPLITBAR_SIZE),rcClient.bottom,TRUE);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  return nNewPos;"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"LRESULT CALLBACK SplitterWndProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  LPSPLITTERINFO lpsiInfo=(LPSPLITTERINFO)(LONG_PTR)GetWindowLongPtr(hwnd,GWLP_USERDATA);"
    FPRINT FP_WRITE,"  static RECT rrc;"
    FPRINT FP_WRITE,"  static BOOL neederase;"
    FPRINT FP_WRITE,"  int temppos;\n"
    FPRINT FP_WRITE,"  for(;;)"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"     if(msg==WM_CREATE)"
    FPRINT FP_WRITE,"       {"
    FPRINT FP_WRITE,"         LPCREATESTRUCT  lpCreateStruct=(LPCREATESTRUCT)lParam;"
    FPRINT FP_WRITE,"         SetWindowLongPtr(hwnd,GWLP_USERDATA,(LONG_PTR)lpCreateStruct->lpCreateParams);"
    FPRINT FP_WRITE,"         break;"
    FPRINT FP_WRITE,"       }"
    FPRINT FP_WRITE,"     if(msg==WM_SIZE)"
    FPRINT FP_WRITE,"       {"
    FPRINT FP_WRITE,"         if(wParam!=SIZE_MINIMIZED) BCX_SetSplitPos(hwnd,lpsiInfo->percent,0);"
    FPRINT FP_WRITE,"         break;"
    FPRINT FP_WRITE,"       }"
    FPRINT FP_WRITE,"     if(msg==WM_LBUTTONDOWN)"
    FPRINT FP_WRITE,"       {"
    FPRINT FP_WRITE,"         lpsiInfo->fMovingBar=TRUE;"
    FPRINT FP_WRITE,"         SetCursor(lpsiInfo->hCursor);"
    FPRINT FP_WRITE,"         SetCapture(hwnd);"
    FPRINT FP_WRITE,"         if (lpsiInfo->splittype)"
    FPRINT FP_WRITE,"            GetClientRect(hwnd,&rrc);"
    FPRINT FP_WRITE,"         break;"
    FPRINT FP_WRITE,"       }"
    FPRINT FP_WRITE,"     if(msg==WM_LBUTTONUP)"
    FPRINT FP_WRITE,"       {"
    FPRINT FP_WRITE,"         if(lpsiInfo->fMovingBar)"
    FPRINT FP_WRITE,"           {"
    FPRINT FP_WRITE,"             lpsiInfo->fMovingBar=FALSE;"
    FPRINT FP_WRITE,"             ReleaseCapture();"
    FPRINT FP_WRITE,"           }"
    FPRINT FP_WRITE,"         if(lpsiInfo->splittype)"
    FPRINT FP_WRITE,"           {"
    FPRINT FP_WRITE,"             if(neederase) // Don't redraw(erase) if we never moved the bar"
    FPRINT FP_WRITE,"              {"
    FPRINT FP_WRITE,"                DrawXorBar(hwnd, 0);"
    FPRINT FP_WRITE,"                neederase = FALSE;"
    FPRINT FP_WRITE,"              }"
    FPRINT FP_WRITE,"              BCX_SetSplitPos(hwnd,lpsiInfo->percent,0);"
    FPRINT FP_WRITE,"           }"
    FPRINT FP_WRITE,"         break;"
    FPRINT FP_WRITE,"       }"
    FPRINT FP_WRITE,"     if(msg==WM_MOUSEMOVE)"
    FPRINT FP_WRITE,"       {"
    FPRINT FP_WRITE,"         if(lpsiInfo->fMovingBar)"
    FPRINT FP_WRITE,"           {"
    FPRINT FP_WRITE,"             if(lpsiInfo->swsStyle==HS_HORIZONTAL)"
    FPRINT FP_WRITE,"               {"
    FPRINT FP_WRITE,"                  temppos=BCX_SetSplitPos(hwnd,0,HIWORD(lParam));"
    FPRINT FP_WRITE,"                  rrc.top=temppos-2;"
    FPRINT FP_WRITE,"                  rrc.bottom=temppos+2;"
    FPRINT FP_WRITE,"               }"
    FPRINT FP_WRITE,"             else"
    FPRINT FP_WRITE,"               {"
    FPRINT FP_WRITE,"                  temppos=BCX_SetSplitPos(hwnd,0,LOWORD(lParam));"
    FPRINT FP_WRITE,"                  rrc.left=temppos-2;"
    FPRINT FP_WRITE,"                  rrc.right=temppos+2;"
    FPRINT FP_WRITE,"               }"
    FPRINT FP_WRITE,"             if(lpsiInfo->splittype && lpsiInfo->fMovingBar)"
    FPRINT FP_WRITE,"               {"
    FPRINT FP_WRITE,"                 if(neederase) DrawXorBar(hwnd, 0);"
    FPRINT FP_WRITE,"                 DrawXorBar(hwnd, &rrc);"
    FPRINT FP_WRITE,"                 neederase = TRUE;"
    FPRINT FP_WRITE,"               }"
    FPRINT FP_WRITE,"           }"
    FPRINT FP_WRITE,"         else"
    FPRINT FP_WRITE,"           {"
    FPRINT FP_WRITE,"             SetCursor(lpsiInfo->hCursor);"
    FPRINT FP_WRITE,"           }"
    FPRINT FP_WRITE,"         break;"
    FPRINT FP_WRITE,"       }"
    FPRINT FP_WRITE,"     if(msg==WM_COMMAND||msg==WM_NOTIFY||msg==WM_HSCROLL||msg==WM_VSCROLL||msg==WM_CTLCOLOREDIT||"
    FPRINT FP_WRITE,"     msg==WM_CTLCOLORSTATIC||msg==WM_CTLCOLORBTN||msg==WM_CTLCOLORLISTBOX||msg==WM_CTLCOLORSCROLLBAR)"
    FPRINT FP_WRITE,"       {"
    FPRINT FP_WRITE,"         return SendMessage(GetParent(hwnd),(UINT)msg,(WPARAM)wParam,(LPARAM)lParam);"
    FPRINT FP_WRITE,"       }"
    FPRINT FP_WRITE,"     if(msg==WM_DESTROY)"
    FPRINT FP_WRITE,"       {"
    FPRINT FP_WRITE,"         GlobalFree(lpsiInfo);"
    FPRINT FP_WRITE,"       }       "
    FPRINT FP_WRITE,"     break;"
    FPRINT FP_WRITE,"  }"
    FPRINT FP_WRITE,"  return DefWindowProc(hwnd,msg,wParam,lParam);"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"void DrawXorBar (HWND hWnd, RECT *rc)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  static RECT R;"
    FPRINT FP_WRITE,"  HBITMAP hbm;"
    FPRINT FP_WRITE,"  HBRUSH  hbr, hbrushOld;"
    FPRINT FP_WRITE,"  WORD dotPatternBmp[] = { 170,85,170,85,170,85,170,85 };"
    FPRINT FP_WRITE,"  HDC     hdc=GetDCEx(hWnd,0,DCX_PARENTCLIP);"
    FPRINT FP_WRITE,"  SetTextColor(hdc,SplitBarFG ^ RGB(255,255,255));"
    FPRINT FP_WRITE,"  SetBkColor  (hdc,SplitBarBG ^ RGB(255,255,255));"
    FPRINT FP_WRITE,"  hbm=CreateBitmap(8,8,1,1,dotPatternBmp);"
    FPRINT FP_WRITE,"  hbr=CreatePatternBrush(hbm);"
    FPRINT FP_WRITE,"  if(rc) CopyRect(&R, rc);"
    FPRINT FP_WRITE,"  SetBrushOrgEx(hdc,R.left,R.top,0);"
    FPRINT FP_WRITE,"  hbrushOld=(HBRUSH)SelectObject(hdc,hbr);"
    FPRINT FP_WRITE,"  PatBlt(hdc,R.left,R.top,R.right-R.left,R.bottom-R.top,PATINVERT);"
    FPRINT FP_WRITE,"  SelectObject(hdc,hbrushOld);"
    FPRINT FP_WRITE,"  DeleteObject(hbr);"
    FPRINT FP_WRITE,"  DeleteObject(hbm);"
    FPRINT FP_WRITE,"  ReleaseDC(hWnd,hdc);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_Tab THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Tab"
    FPRINT FP_WRITE,"HWND BCX_Tab (HWND hWnd, int id, int NumTabs, HWND *htab,char Names[]";cSizeOfADefaultString$;",int X,int Y,int W,int H,HIMAGELIST image,int Style,int StyleEx)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int      i;"
    FPRINT FP_WRITE,"  static WNDCLASSEX  twcx;"
    FPRINT FP_WRITE,"  static ATOM Class;"
    FPRINT FP_WRITE,"  if(!Class)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      // Register the Tab page holder windows... "
    FPRINT FP_WRITE,"      twcx.cbSize=sizeof(twcx);"
    FPRINT FP_WRITE,"      twcx.style=CS_PARENTDC;"
    FPRINT FP_WRITE,"      twcx.lpfnWndProc=(WNDPROC)TabPageWndProc;"
    FPRINT FP_WRITE,"      twcx.cbClsExtra=0;"
    FPRINT FP_WRITE,"      twcx.cbWndExtra=4;"
    FPRINT FP_WRITE,"      twcx.hInstance=BCX_hInstance;"
    FPRINT FP_WRITE,"      twcx.hIcon=NULL;"
    FPRINT FP_WRITE,"      twcx.hCursor=LoadCursor(NULL,IDC_ARROW);"
    FPRINT FP_WRITE,"      twcx.hbrBackground=(HBRUSH)(COLOR_BTNFACE+1);"
    FPRINT FP_WRITE,"      twcx.lpszMenuName=NULL;"
    FPRINT FP_WRITE,"      twcx.lpszClassName=", ENC$("TABPAGEHOLDER"), ";"
    FPRINT FP_WRITE,"      twcx.hIconSm=NULL;"
    FPRINT FP_WRITE,"      Class=RegisterClassEx(&twcx);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE," // SubClass tab control parent so we can intercept WM_NOTIFY msgs used to switch pages"
    FPRINT FP_WRITE," if(id>=0)"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"    if(GetProp(hWnd,", ENC$("Wprc"), ")==NULL)"
    FPRINT FP_WRITE,"      {"
    FPRINT FP_WRITE,"         SetProp(hWnd,", ENC$("Wprc"), ",(HANDLE)(LONG_PTR)GetWindowLongPtr(hWnd,GWLP_WNDPROC));"
    FPRINT FP_WRITE,"         SetWindowLongPtr(hWnd,GWLP_WNDPROC,(LONG_PTR)TabCallback);"
    FPRINT FP_WRITE,"      }"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"  if(!Style) Style=WS_CHILD | WS_VISIBLE | WS_TABSTOP | WS_CLIPSIBLINGS |"
    FPRINT FP_WRITE,"                   TCS_TABS | TCS_SINGLELINE | TCS_FOCUSONBUTTONDOWN;"
    FPRINT FP_WRITE,"  HWND hMainTab=CreateWindowEx(StyleEx,", ENC$("SysTabControl32"), ",", DDQ$, ",Style,"
    FPRINT FP_WRITE,"                               X*BCX_ScaleX,Y*BCX_ScaleY,W*BCX_ScaleX,H*BCX_ScaleY,"
'jcfuller change 2/19/2013
'    FPRINT FP_WRITE,"                               hWnd,(HMENU)abs(id),BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"                               hWnd,(HMENU)(INT_PTR)(id),BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"  SendMessage(hMainTab,(UINT)WM_SETFONT,(WPARAM)DefaultFont,(LPARAM)MAKELPARAM(FALSE,0));"
    FPRINT FP_WRITE,"  SetWindowLongPtr(hMainTab,GWLP_USERDATA,(LONG_PTR)htab);"
    FPRINT FP_WRITE,"  SetProp(hMainTab,", ENC$("TabSzWprc"), ",(HANDLE)(LONG_PTR)GetWindowLongPtr(hMainTab,GWLP_WNDPROC));"
    FPRINT FP_WRITE,"  SetWindowLongPtr(hMainTab, GWLP_WNDPROC,(LONG_PTR)TabSizeCallback);"
    FPRINT FP_WRITE,"  "
    FPRINT FP_WRITE,"  // Insert tabs in the tab control... "
    FPRINT FP_WRITE,"  for(i=0; i<NumTabs; i+=1)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      BCX_AddTab(hMainTab,i,Names[i],(image!=NULL?i:-1),1);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if(image) TabCtrl_SetImageList(hMainTab,image);"
    FPRINT FP_WRITE,"  SendMessage(hMainTab,(UINT)WM_SIZE,(WPARAM)SIZE_RESTORED,0);"
    FPRINT FP_WRITE,"  TabCtrl_SetCurSel(hMainTab,0);"
    FPRINT FP_WRITE,"  ShowWindow(htab[0],SW_SHOW);"
    FPRINT FP_WRITE,"  return hMainTab;"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"HWND BCX_AddTab (HWND thwnd,int idx,char * text,int Imgidx,int showhide)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  TC_ITEM  tc;"
    FPRINT FP_WRITE,"  int      i;"
    FPRINT FP_WRITE,"  int      cnt=TabCtrl_GetItemCount(thwnd);"
    FPRINT FP_WRITE,"  HWND     *ptab=(HWND*)(LONG_PTR)GetWindowLongPtr(thwnd,GWLP_USERDATA);"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"  tc.mask=TCIF_TEXT|TCIF_IMAGE;"
    FPRINT FP_WRITE,"  tc.pszText=text;"
    FPRINT FP_WRITE,"  tc.iImage=Imgidx;"
    FPRINT FP_WRITE,"  TabCtrl_InsertItem(thwnd,idx,&tc);"
    FPRINT FP_WRITE,"  for(i=cnt; i>idx; i+=-1)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      ptab[i]=ptab[i-1];"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  ptab[idx]=CreateWindowEx(WS_EX_CONTROLPARENT,", ENC$("TABPAGEHOLDER"), ",", ENC$(""), ",WS_CHILD|WS_CLIPCHILDREN,0,0,10,10,GetParent(thwnd),(HMENU)0,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"  SetWindowPos(ptab[idx],HWND_TOP,0,0,0,0,SWP_NOMOVE|SWP_NOSIZE);"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"  if(showhide==0)"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"     ShowWindow(ptab[TabCtrl_GetCurSel(thwnd)],SW_HIDE);"
    FPRINT FP_WRITE,"     SendMessage(thwnd,(UINT)WM_SIZE,(WPARAM)SIZE_RESTORED,0);"
    FPRINT FP_WRITE,"     TabCtrl_SetCurSel(thwnd,idx);"
    FPRINT FP_WRITE,"     ShowWindow(ptab[idx],SW_SHOW);"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"  return ptab[idx];"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"LRESULT CALLBACK TabSizeCallback(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  WNDPROC old=(WNDPROC)GetProp(hWnd,(LPCSTR)", ENC$("TabSzWprc"),");"
    FPRINT FP_WRITE,"  if(Msg==WM_SIZE&&wParam!=SIZE_MINIMIZED)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      HWND *ptab=(HWND*)(LONG_PTR)GetWindowLongPtr(hWnd,GWLP_USERDATA);"
    FPRINT FP_WRITE,"      RECT  rc2, rc1={0,0,0,0};"
    FPRINT FP_WRITE,"      TabCtrl_AdjustRect(hWnd,TRUE,&rc1);"
    FPRINT FP_WRITE,"      GetClientRect(hWnd,&rc2);"
    FPRINT FP_WRITE,"      MapWindowPoints(hWnd,GetParent(hWnd),(LPPOINT)&rc2,2);"
    FPRINT FP_WRITE,"      rc1.top= -rc1.top; rc1.bottom = -rc1.bottom;"
    FPRINT FP_WRITE,"      rc1.left = -rc1.left; rc1.right = -rc1.right;"
    FPRINT FP_WRITE,"      int page;"
    FPRINT FP_WRITE,"      for(page=0; page<=TabCtrl_GetItemCount(hWnd)-1; page+=1)"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"          MoveWindow(ptab[page],rc2.left+rc1.left,rc2.top+rc1.top,"
    FPRINT FP_WRITE,"          rc1.right-rc1.left+(rc2.right-rc2.left),rc1.bottom-rc1.top+(rc2.bottom-rc2.top),TRUE);"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  else if(Msg==WM_DESTROY)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      SetWindowLongPtr(hWnd,GWLP_WNDPROC,(LONG_PTR)RemoveProp(hWnd,", ENC$("TabSzWprc"), "));"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  return CallWindowProc(old,hWnd,Msg,wParam,lParam);"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"\n#ifndef WM_MOUSEWHEEL"
    FPRINT FP_WRITE,"#define WM_MOUSEWHEEL 0x020A"
    FPRINT FP_WRITE,"#endif\n"
    FPRINT FP_WRITE,"LRESULT CALLBACK TabPageWndProc (HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  if(Msg==WM_COMMAND||Msg==WM_NOTIFY||Msg==WM_HSCROLL||Msg==WM_VSCROLL||Msg==WM_CTLCOLOREDIT||"
    FPRINT FP_WRITE,"  Msg==WM_CTLCOLORSTATIC||Msg==WM_CTLCOLORBTN||Msg==WM_CTLCOLORLISTBOX||Msg==WM_CTLCOLORSCROLLBAR||"
    FPRINT FP_WRITE,"  Msg==WM_DRAWITEM||Msg==WM_MEASUREITEM||Msg==WM_MOUSEWHEEL)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      return SendMessage(GetParent(hWnd),(UINT)Msg,(WPARAM)wParam,(LPARAM)lParam);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  return DefWindowProc(hWnd,Msg,wParam,lParam);"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"int BCX_TabSelect (HWND hWnd, LPARAM lParam)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int PageNo=-1;"
    FPRINT FP_WRITE,"  NMHDR*   ptnmhdr = (NMHDR*) lParam;"
    FPRINT FP_WRITE,"  HWND *ptab=(HWND*)(LONG_PTR)GetWindowLongPtr(ptnmhdr->hwndFrom,GWLP_USERDATA);"
    FPRINT FP_WRITE,"  if(ptab)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      if(ptnmhdr->code==TCN_SELCHANGING)"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"           PageNo=TabCtrl_GetCurSel(ptnmhdr->hwndFrom);"
    FPRINT FP_WRITE,"           if(PageNo!=-1)"
    FPRINT FP_WRITE,"           ShowWindow(ptab[PageNo],SW_HIDE);"
    FPRINT FP_WRITE,"           PageNo+=0xffff;"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"      else if(ptnmhdr->code==TCN_SELCHANGE)"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"           PageNo=TabCtrl_GetCurSel(ptnmhdr->hwndFrom);"
    FPRINT FP_WRITE,"           if(PageNo!=-1)"
    FPRINT FP_WRITE,"           ShowWindow(ptab[PageNo],SW_SHOW);"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  return PageNo;"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"LRESULT CALLBACK TabCallback (HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  WNDPROC old=(WNDPROC)GetProp(hWnd,(LPCSTR)", ENC$("Wprc"), ");"
    FPRINT FP_WRITE,"  if(Msg==WM_DESTROY)"
    FPRINT FP_WRITE,"     SetWindowLongPtr(hWnd,GWLP_WNDPROC,(LONG_PTR)RemoveProp(hWnd,", ENC$("Wprc"), "));"
    FPRINT FP_WRITE,"   else if(Msg==WM_NOTIFY)"
    FPRINT FP_WRITE,"     BCX_TabSelect(hWnd,lParam);"
    FPRINT FP_WRITE,"  return CallWindowProc(old,hWnd,Msg,wParam,lParam);"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"void BCX_RemTab (HWND thwnd, int idx)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int      cur, cnt;"
    FPRINT FP_WRITE,"  HWND*  ptab=(HWND*)(LONG_PTR)GetWindowLongPtr(thwnd,GWLP_USERDATA);"
    FPRINT FP_WRITE,"  cnt=TabCtrl_GetItemCount(thwnd)-1;"
    FPRINT FP_WRITE,"  if(cnt<0||idx>cnt) return;"
    FPRINT FP_WRITE,"    "
    FPRINT FP_WRITE,"  if(TabCtrl_GetCurSel(thwnd)==idx)"
    FPRINT FP_WRITE,"    TabCtrl_SetCurFocus(thwnd,(cnt>idx?idx+1:idx-1));"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"  TabCtrl_DeleteItem(thwnd,idx);"
    FPRINT FP_WRITE,"  DestroyWindow(ptab[idx]);"
    FPRINT FP_WRITE,"  for(cur=idx; cur<cnt; cur+=1)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      ptab[cur]=ptab[cur+1];"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  ptab[cnt]=NULL;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_Toolbar THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Toolbar"
    FPRINT FP_WRITE,"HWND BCX_Toolbar (HWND hwnd,int id,int NumBtns,char * Text,int* Bstyles,void* img,int* imgidx,int bx,int by,int Style,int ExStyle)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  TBBUTTON*  tbb=(TBBUTTON*)calloc(NumBtns+20,sizeof(TBBUTTON));"
    FPRINT FP_WRITE,"  TBADDBITMAP  tbbitmap = {0,0};"
    FPRINT FP_WRITE,"  static  BITMAP  bm;"
    FPRINT FP_WRITE,"  int  seppos=0, absidx=0, index=0, NewIdx;"
    FPRINT FP_WRITE,"  int  txtlen=strlen(Text);"
    FPRINT FP_WRITE,"  if(!Style) Style=WS_CHILD|WS_BORDER;"
    FPRINT FP_WRITE,""
    'jcfuller added (INT_PTR)
    FPRINT FP_WRITE,"  HWND A=CreateWindowEx(ExStyle,TOOLBARCLASSNAME,", DDQ$, ",Style,0,0,0,0,hwnd,(HMENU)(INT_PTR)id,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,"  SendMessage(A,(UINT)TB_BUTTONSTRUCTSIZE,(WPARAM)sizeof(TBBUTTON),(LPARAM)0);"
    FPRINT FP_WRITE,"  SendMessage(A,(UINT)WM_SETFONT,(WPARAM)DefaultFont,(LPARAM)0);"
    FPRINT FP_WRITE,"  if(bx&&by) SendMessage(A,(UINT)TB_SETBUTTONSIZE,(WPARAM)0,(LPARAM)MAKELONG(bx,by));"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"  while(absidx < NumBtns)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"     while(txtlen)"
    FPRINT FP_WRITE,"      {"
    FPRINT FP_WRITE,"        if (Text[seppos] == '|') break;"
    FPRINT FP_WRITE,"        if(!seppos || (seppos==txtlen)) {seppos=0; break;}"
    FPRINT FP_WRITE,"        seppos++;"
    FPRINT FP_WRITE,"      }"
    FPRINT FP_WRITE,"      if(Text[seppos] == '|' && Text[seppos+1] == '|')"
    FPRINT FP_WRITE,"       {"
    FPRINT FP_WRITE,"          tbb[index].fsStyle = TBSTYLE_SEP;"
    FPRINT FP_WRITE,"       }else{"
    FPRINT FP_WRITE,"          if(imgidx)"
    FPRINT FP_WRITE,"              NewIdx = imgidx[absidx];"
    FPRINT FP_WRITE,"           else"
    FPRINT FP_WRITE,"              NewIdx = absidx;"
    FPRINT FP_WRITE,"          tbb[index].iBitmap = NewIdx;"
    FPRINT FP_WRITE,"          tbb[index].idCommand = id+NewIdx+1;"
    FPRINT FP_WRITE,"          tbb[index].fsState = TBSTATE_ENABLED;"
    FPRINT FP_WRITE,"          if(Bstyles) tbb[index].fsStyle = Bstyles[NewIdx];"
    FPRINT FP_WRITE,"          tbb[index].iString = NewIdx;"
    FPRINT FP_WRITE,"          absidx++;"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"      seppos++;"
    FPRINT FP_WRITE,"      index++;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  SendMessage(A,(UINT)TB_ADDBUTTONS,(WPARAM)index,(LPARAM)(LPTBBUTTON)tbb);"
    FPRINT FP_WRITE,"  if(img!=0)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      if(img==HINST_COMMCTRL)"
    FPRINT FP_WRITE,"       {"
    FPRINT FP_WRITE,"          tbbitmap.hInst=HINST_COMMCTRL;"
    FPRINT FP_WRITE,"          tbbitmap.nID=imgidx[NumBtns];"
    FPRINT FP_WRITE,"          SendMessage(A,(UINT)TB_ADDBITMAP,0,(LPARAM)(LPTBADDBITMAP)&tbbitmap);"
    FPRINT FP_WRITE,"       }else{"
    FPRINT FP_WRITE,"          if(!GetObject((HBITMAP)(img),sizeof(BITMAP),&bm))"
    FPRINT FP_WRITE,"           {"
    FPRINT FP_WRITE,"              SendMessage(A, TB_SETIMAGELIST, 0, (LPARAM)img);"
    FPRINT FP_WRITE,"           }else{"
    FPRINT FP_WRITE,"              tbbitmap.nID=(UINT)(HBITMAP)(img);"
    FPRINT FP_WRITE,"              SendMessage(A,(UINT)TB_SETBITMAPSIZE,(WPARAM)0,(LPARAM)MAKELONG(bm.bmWidth/NumBtns,bm.bmHeight));"
    FPRINT FP_WRITE,"              SendMessage(A,(UINT)TB_ADDBITMAP,(WPARAM)NumBtns,(LPARAM)(LPTBADDBITMAP)&tbbitmap);"
    FPRINT FP_WRITE,"           }"
    FPRINT FP_WRITE,"       }"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if(txtlen && Text[0] != '-')"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      char*  titles;"
    FPRINT FP_WRITE,"      titles=(char*)calloc(2+txtlen,sizeof(char));"
    FPRINT FP_WRITE,"      absidx=0;"
    FPRINT FP_WRITE,"      for(index=0;index<txtlen;index++)"
    FPRINT FP_WRITE,"      {"
    FPRINT FP_WRITE,"        if(Text[index]=='|')"
    FPRINT FP_WRITE,"         {"
    FPRINT FP_WRITE,"            if(Text[index+1]=='|'||titles[0]==0) continue;"
    FPRINT FP_WRITE,"            titles[absidx]=0;"
    FPRINT FP_WRITE,"         }else{"
    FPRINT FP_WRITE,"            titles[absidx]=Text[index];"
    FPRINT FP_WRITE,"         }"
    FPRINT FP_WRITE,"        absidx++;"
    FPRINT FP_WRITE,"      }"
    FPRINT FP_WRITE,"      SendMessage(A,(UINT)TB_ADDSTRING,(WPARAM)0,(LPARAM)titles);"
    FPRINT FP_WRITE,"      free(titles);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  SendMessage(A,(UINT)TB_AUTOSIZE, 0, 0);"
    FPRINT FP_WRITE,"  ShowWindow(A,SW_SHOW);"
    FPRINT FP_WRITE,"  free(tbb);"
    FPRINT FP_WRITE,"  return A;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_UpDown THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_UpDown"
    FPRINT FP_WRITE,"HWND BCX_UpDown (HWND hWnd,int X,int Y,int W,int H,int Lo,int Hi,int Start)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HWND UpDn;"
    FPRINT FP_WRITE,"  HWND Buddy;"
    FPRINT FP_WRITE,"  int  Style = WS_CHILD|WS_VISIBLE|WS_TABSTOP|ES_NUMBER|ES_LEFT|ES_AUTOHSCROLL;"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"  Buddy=CreateWindowEx(WS_EX_CLIENTEDGE,", ENC$("edit"), ",0,Style,"
    FPRINT FP_WRITE,"                       X*BCX_ScaleX,Y*BCX_ScaleY,W*BCX_ScaleX,H*BCX_ScaleY,"
    FPRINT FP_WRITE,"                       hWnd,(HMENU)(HMENU)0,BCX_hInstance,NULL);"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"  SendMessage(Buddy,(UINT)WM_SETFONT,(WPARAM)DefaultFont,(LPARAM)MAKELPARAM(0,0));"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"  UpDn=CreateUpDownControl(WS_CHILD|WS_VISIBLE|WS_TABSTOP|WS_BORDER|"
    FPRINT FP_WRITE,"                           UDS_ARROWKEYS|UDS_SETBUDDYINT|UDS_ALIGNRIGHT,"
    FPRINT FP_WRITE,"                           X*BCX_ScaleX,Y*BCX_ScaleY,W*BCX_ScaleX,H*BCX_ScaleY,"
    FPRINT FP_WRITE,"                           hWnd,0,BCX_hInstance,Buddy,Hi,Lo,Start);"
    FPRINT FP_WRITE,"  return UpDn;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_Get_UpDown THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Get_UpDown"
    FPRINT FP_WRITE,"int BCX_Get_UpDown (HWND hWnd)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *BCX_RetStr={0};"
    FPRINT FP_WRITE,"  HWND  hBuddy;"
    FPRINT FP_WRITE,"  int   k;"
    FPRINT FP_WRITE,"  hBuddy = (HWND)SendMessage(hWnd,(UINT)UDM_GETBUDDY,(WPARAM)0,(LPARAM)0);"
    FPRINT FP_WRITE,"  k = GetWindowTextLength(hBuddy)+1;"
    FPRINT FP_WRITE,"  BCX_RetStr = BCX_TmpStr(1,1,1);"
    FPRINT FP_WRITE,"  GetWindowText(hBuddy,BCX_RetStr,k);"
    FPRINT FP_WRITE,"  return (int)atof(BCX_RetStr);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_Draw THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: StartDraw"
    FPRINT FP_WRITE,"HDC StartDraw (HWND hWnd)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HBITMAP  oldbmp, newbmp;"
    FPRINT FP_WRITE,"  HDC  hDestDC, WinDC;"
    FPRINT FP_WRITE,"  RECT rc;"
    FPRINT FP_WRITE,"  newbmp=(HBITMAP)SendMessage(hWnd,STM_GETIMAGE,0,0);"
    FPRINT FP_WRITE,"  if(newbmp==NULL)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      GetClientRect(hWnd,&rc);"
    FPRINT FP_WRITE,"      WinDC=GetDC(NULL);"
    FPRINT FP_WRITE,"      newbmp=CreateCompatibleBitmap(WinDC,rc.right,rc.bottom);"
    FPRINT FP_WRITE,"      ReleaseDC(NULL,WinDC);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  hDestDC=CreateCompatibleDC(NULL);"
    FPRINT FP_WRITE,"  oldbmp=(HBITMAP)SelectObject(hDestDC,newbmp);"
    FPRINT FP_WRITE,"  SetProp(hWnd,", ENC$("oldbmp"), ",(HANDLE)oldbmp);"
    FPRINT FP_WRITE,"  return hDestDC;"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"HBITMAP EndDraw (HWND hWnd, HDC hDestDC)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HBITMAP  oldbmp, newbmp;"
    FPRINT FP_WRITE,"  oldbmp=(HBITMAP)GetProp(hWnd,", ENC$("oldbmp"), ");"
    FPRINT FP_WRITE,"  newbmp=(HBITMAP)SelectObject(hDestDC,oldbmp);"
    FPRINT FP_WRITE,"  DeleteDC(hDestDC);"
    FPRINT FP_WRITE,"  SendMessage(hWnd,STM_SETIMAGE,IMAGE_BITMAP,(LPARAM)newbmp);"
    FPRINT FP_WRITE,"  return newbmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF



  IF Use_GetText THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Get_Text"
    FPRINT FP_WRITE,"char *BCX_Get_Text(HWND hWnd)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int tmpint;"
    FPRINT FP_WRITE,"  tmpint = 1 + GetWindowTextLength(hWnd);"
    FPRINT FP_WRITE,"  char *strtmp = BCX_TmpStr(tmpint,1,1);"
    FPRINT FP_WRITE,"  GetWindowText(hWnd,strtmp,tmpint);"
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_SetText THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Set_Text"
    FPRINT FP_WRITE,"int BCX_Set_Text(HWND hWnd, const char *Text)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  return SetWindowText(hWnd,Text);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_SetFormColor THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Set_Form_Color"
    FPRINT FP_WRITE,"void BCX_Set_Form_Color (HWND hWnd, COLORREF Kolor)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HBRUSH hbr=CreateSolidBrush(Kolor);"
    FPRINT FP_WRITE,"  DeleteObject((HBRUSH)SetClassLongPtr(hWnd,GCLP_HBRBACKGROUND,(LONG_PTR)hbr));"
    FPRINT FP_WRITE,"  InvalidateRect (hWnd,NULL,TRUE);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_Tile THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Tile"
    FPRINT FP_WRITE,"void BCX_Tile (HWND hWnd, HBITMAP hBmp)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HBRUSH hbr=CreatePatternBrush(hBmp);"
    FPRINT FP_WRITE,"  DeleteObject((HBRUSH)SetClassLongPtr(hWnd,GCLP_HBRBACKGROUND,(LONG_PTR)hbr));"
    FPRINT FP_WRITE,"  RedrawWindow(hWnd,0,0,0);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_SetColor THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Set_Color"
    FPRINT FP_WRITE,"LRESULT Set_Color (int TxtColr,int BkColr,HDC wParam,HWND lParam)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  static HBRUSH  ReUsableBrush;"
    FPRINT FP_WRITE,"  SetTextColor(wParam,TxtColr);"
    FPRINT FP_WRITE,"  if(BkColr==-1)"
    FPRINT FP_WRITE,"  {"
'jcfuller    Does not work for 64bit
    'FPRINT FP_WRITE,"     BkColr=(int)(UINT)PtrToUlong(GetClassLongPtr(GetParent(lParam),GCLP_HBRBACKGROUND));"
    'FPRINT FP_WRITE,"     BkColr=(int)(UINT_PTR)PtrToUlong((const void*)GetClassLongPtr(GetParent(lParam),GCLP_HBRBACKGROUND));"
'Robert's fix ala bcx 7.0.1
    FPRINT FP_WRITE,"     BkColr=(UINT_PTR)GetClassLongPtr(GetParent(lParam),GCLP_HBRBACKGROUND);"

    FPRINT FP_WRITE,"     if((UINT)BkColr>31)"
    FPRINT FP_WRITE,"      { SetBkMode(wParam,TRANSPARENT); return BkColr; }"
    FPRINT FP_WRITE,"     else"
    FPRINT FP_WRITE,"        BkColr=GetSysColor(BkColr-1);"
    FPRINT FP_WRITE,"  }"
    FPRINT FP_WRITE,"  DeleteObject(ReUsableBrush);"
    FPRINT FP_WRITE,"  ReUsableBrush=CreateSolidBrush(BkColr);"
    FPRINT FP_WRITE,"  SetBkColor(wParam,BkColr);"
    FPRINT FP_WRITE,"  return (LRESULT)ReUsableBrush;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_SetFont THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Set_Font"
    FPRINT FP_WRITE,"HFONT BCX_Set_Font (const char *Font,float Size,int Bold,int Italic,int Underline,int StrikeThru,int CharSet)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HDC hDC=GetDC(HWND_DESKTOP);"
    FPRINT FP_WRITE,"  int CyPixels=GetDeviceCaps(hDC,LOGPIXELSY);"
    FPRINT FP_WRITE,"  ReleaseDC(HWND_DESKTOP,hDC);"
    FPRINT FP_WRITE,"  return CreateFont(0-(Size*CyPixels)/72,0,0,0,Bold,Italic,Underline,StrikeThru,"
    FPRINT FP_WRITE,"  CharSet,OUT_TT_PRECIS,CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,FF_DONTCARE,(char*)Font);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_Preset THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Preset"
    FPRINT FP_WRITE,"int BCX_Preset (HWND Wnd,int x,int y,HDC DrawHDC)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int a;"
    FPRINT FP_WRITE,"  int b=0;"
    FPRINT FP_WRITE,"  if(!DrawHDC) DrawHDC=GetDC(Wnd),b=1;"
    FPRINT FP_WRITE,"  a = MoveToEx(DrawHDC,x,y,NULL);"
    FPRINT FP_WRITE,"  if(b) ReleaseDC(Wnd,DrawHDC);"
    FPRINT FP_WRITE,"  return a;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_BCX_Pset THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Pset"
    FPRINT FP_WRITE,"COLORREF BCX_Pset (HWND Wnd,int x,int y,int Pen,HDC DrawHDC)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  COLORREF a;"
    FPRINT FP_WRITE,"  int b=0;"
    FPRINT FP_WRITE,"  HPEN hOPen;"
    FPRINT FP_WRITE,"  HPEN hNPen=CreatePen(PS_SOLID,1,Pen);"
    FPRINT FP_WRITE,"  if(!DrawHDC) DrawHDC=GetDC(Wnd),b=1;"
    FPRINT FP_WRITE,"  hOPen=(HPEN)SelectObject(DrawHDC,hNPen);"
    FPRINT FP_WRITE,"  a = SetPixelV(DrawHDC,x,y,Pen);"
    FPRINT FP_WRITE,"  DeleteObject(SelectObject(DrawHDC,hOPen));"
    FPRINT FP_WRITE,"  if(b) ReleaseDC(Wnd,DrawHDC);"
    FPRINT FP_WRITE,"  return a;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_BCX_Floodfill THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_FloodFill"
    FPRINT FP_WRITE,"int BCX_FloodFill (HWND Wnd,int X,int Y,int Areacolor, int Fillcolor, HDC DrawHDC, int FillType)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int a,b=0;"
    FPRINT FP_WRITE,"  if(!DrawHDC) DrawHDC=GetDC(Wnd),b=1;"
    FPRINT FP_WRITE,"  HPEN hNPen=CreatePen(PS_SOLID,1,Fillcolor);"
    FPRINT FP_WRITE,"  HPEN hOPen=(HPEN)SelectObject(DrawHDC,hNPen);"
    FPRINT FP_WRITE,"  HBRUSH hOldBrush;"
    FPRINT FP_WRITE,"  HBRUSH hNewBrush;"
    FPRINT FP_WRITE,"  hNewBrush=CreateSolidBrush(Fillcolor);"
    FPRINT FP_WRITE,"  hOldBrush=(HBRUSH)SelectObject(DrawHDC,hNewBrush);"
    FPRINT FP_WRITE,"  if(!FillType)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"     a = ExtFloodFill(DrawHDC, X, Y, Areacolor, 0);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"     a = ExtFloodFill(DrawHDC, X, Y, Areacolor, 1);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  DeleteObject(SelectObject(DrawHDC,hOPen));"
    FPRINT FP_WRITE,"  DeleteObject(SelectObject(DrawHDC,hOldBrush));"
    FPRINT FP_WRITE,"  if(b) ReleaseDC(Wnd,DrawHDC);"
    FPRINT FP_WRITE,"  return a;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_BCX_Line THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Line"
    FPRINT FP_WRITE,"int BCX_Line (HWND Wnd,int x1,int y1,int x2,int y2,int Pen,HDC DrawHDC)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int a,b=0;"
    FPRINT FP_WRITE,"  HPEN hOPen;"
    FPRINT FP_WRITE,"  HPEN hNPen=CreatePen(PS_SOLID,1,Pen);"
    FPRINT FP_WRITE,"  if(!DrawHDC) DrawHDC=GetDC(Wnd),b=1;"
    FPRINT FP_WRITE,"  hOPen=(HPEN)SelectObject(DrawHDC,hNPen);"
    FPRINT FP_WRITE,"  MoveToEx(DrawHDC,x1,y1,NULL);"
    FPRINT FP_WRITE,"  a = LineTo(DrawHDC,x2,y2);"
    FPRINT FP_WRITE,"  DeleteObject(SelectObject(DrawHDC,hOPen));"
    FPRINT FP_WRITE,"  if(b) ReleaseDC(Wnd,DrawHDC);"
    FPRINT FP_WRITE,"  return a;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_BCX_Lineto THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Lineto"
    FPRINT FP_WRITE,"int BCX_Lineto (HWND Wnd,int x,int y,int Pen,HDC DrawHDC)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int a,b=0;"
    FPRINT FP_WRITE,"  HPEN hOPen;"
    FPRINT FP_WRITE,"  HPEN hNPen=CreatePen(PS_SOLID,1,Pen);"
    FPRINT FP_WRITE,"  if(!DrawHDC) DrawHDC=GetDC(Wnd),b=1;"
    FPRINT FP_WRITE,"  hOPen=(HPEN)SelectObject(DrawHDC,hNPen);"
    FPRINT FP_WRITE,"  a = LineTo(DrawHDC,x,y);"
    FPRINT FP_WRITE,"  DeleteObject(SelectObject(DrawHDC,hOPen));"
    FPRINT FP_WRITE,"  if(b) ReleaseDC(Wnd,DrawHDC);"
    FPRINT FP_WRITE,"  return a;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_BCX_Polygon THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Polygon"
    FPRINT FP_WRITE,"int BCX_Polygon (HWND Wnd,CONST POINT *lpPoints,int nCount,int Pen,HDC DrawHDC)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int b=0;"
    FPRINT FP_WRITE,"  HPEN hNPen=CreatePen(PS_SOLID,1,Pen);"
    FPRINT FP_WRITE,"  if(!DrawHDC) DrawHDC=GetDC(Wnd),b=1;"
    FPRINT FP_WRITE,"  HPEN hOPen=(HPEN)SelectObject(DrawHDC,hNPen);"
    FPRINT FP_WRITE,"  int a = Polygon(DrawHDC,lpPoints,nCount);"
    FPRINT FP_WRITE,"  SelectObject(DrawHDC,hOPen);"
    FPRINT FP_WRITE,"  DeleteObject(hNPen);"
    FPRINT FP_WRITE,"  if(b) ReleaseDC(Wnd,DrawHDC);"
    FPRINT FP_WRITE,"  return a;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_PolyBezier THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_PolyBezier"
    FPRINT FP_WRITE,"int BCX_PolyBezier (HWND Wnd,CONST POINT *lpPoints,int nCount,int Pen,HDC DrawHDC)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int a,b=0;"
    FPRINT FP_WRITE,"  HPEN hNPen=CreatePen(PS_SOLID,1,Pen);"
    FPRINT FP_WRITE,"  if(!DrawHDC) DrawHDC=GetDC(Wnd),b=1;"
    FPRINT FP_WRITE,"  HPEN hOPen=(HPEN)SelectObject(DrawHDC,hNPen);"
    FPRINT FP_WRITE,"  a = PolyBezier(DrawHDC,lpPoints,nCount);"
    FPRINT FP_WRITE,"  SelectObject(DrawHDC,hOPen);"
    FPRINT FP_WRITE,"  DeleteObject(hNPen);"
    FPRINT FP_WRITE,"  if(b) ReleaseDC(Wnd,DrawHDC);"
    FPRINT FP_WRITE,"  return a;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_Polyline THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Polyline"
    FPRINT FP_WRITE,"int BCX_Polyline (HWND Wnd,CONST POINT *lpPoints,int nCount,int Pen,HDC DrawHDC)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int a,b=0;"
    FPRINT FP_WRITE,"  HPEN hNPen=CreatePen(PS_SOLID,1,Pen);"
    FPRINT FP_WRITE,"  if(!DrawHDC) DrawHDC=GetDC(Wnd),b=1;"
    FPRINT FP_WRITE,"  HPEN hOPen=(HPEN)SelectObject(DrawHDC,hNPen);"
    FPRINT FP_WRITE,"  a = Polyline(DrawHDC,lpPoints,nCount);"
    FPRINT FP_WRITE,"  SelectObject(DrawHDC,hOPen);"
    FPRINT FP_WRITE,"  DeleteObject(hNPen);"
    FPRINT FP_WRITE,"  if(b) ReleaseDC(Wnd,DrawHDC);"
    FPRINT FP_WRITE,"  return a;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_Circle THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Circle"
    FPRINT FP_WRITE,"int BCX_Circle (HWND Wnd,int X,int Y,int R,int Pen,int Fill,HDC DrawHDC)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int a,b=0;"
    FPRINT FP_WRITE,"  if(!DrawHDC) DrawHDC=GetDC(Wnd),b=1;"
    FPRINT FP_WRITE,"  HPEN   hNPen=CreatePen(PS_SOLID,1,Pen);"
    FPRINT FP_WRITE,"  HPEN   hOPen=(HPEN)SelectObject(DrawHDC,hNPen);"
    FPRINT FP_WRITE,"  HBRUSH hOldBrush;"
    FPRINT FP_WRITE,"  HBRUSH hNewBrush;"
    FPRINT FP_WRITE,"  if(Fill)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      hNewBrush=CreateSolidBrush(Pen);"
    FPRINT FP_WRITE,"      hOldBrush=(HBRUSH)SelectObject(DrawHDC,hNewBrush);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      hNewBrush=(HBRUSH)GetStockObject(NULL_BRUSH);"
    FPRINT FP_WRITE,"      hOldBrush=(HBRUSH)SelectObject(DrawHDC,hNewBrush);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  a = Ellipse(DrawHDC,X-R,Y+R,X+R,Y-R);"
    FPRINT FP_WRITE,"  DeleteObject(SelectObject(DrawHDC,hOPen));"
    FPRINT FP_WRITE,"  DeleteObject(SelectObject(DrawHDC,hOldBrush));"
    FPRINT FP_WRITE,"  if(b) ReleaseDC(Wnd,DrawHDC);"
    FPRINT FP_WRITE,"  return a;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_Ellipse THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Elipse"
    FPRINT FP_WRITE,"int BCX_Ellipse (HWND Wnd,int Left,int Top,int Right,int Bottom,int Pen,int Fill,HDC DrawHDC)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int a,b=0;"
    FPRINT FP_WRITE,"  if(!DrawHDC) DrawHDC=GetDC(Wnd),b=1;"
    FPRINT FP_WRITE,"  HPEN   hNPen=CreatePen(PS_SOLID,1,Pen);"
    FPRINT FP_WRITE,"  HPEN   hOPen=(HPEN)SelectObject(DrawHDC,hNPen);"
    FPRINT FP_WRITE,"  HBRUSH hOldBrush;"
    FPRINT FP_WRITE,"  HBRUSH hNewBrush;"
    FPRINT FP_WRITE,"  if(Fill)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      hNewBrush=CreateSolidBrush(Pen);"
    FPRINT FP_WRITE,"      hOldBrush=(HBRUSH)SelectObject(DrawHDC,hNewBrush);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"    else"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      hNewBrush=(HBRUSH)GetStockObject(NULL_BRUSH);"
    FPRINT FP_WRITE,"      hOldBrush=(HBRUSH)SelectObject(DrawHDC,hNewBrush);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  a = Ellipse(DrawHDC,Left,Top,Right,Bottom);"
    FPRINT FP_WRITE,"  DeleteObject(SelectObject(DrawHDC,hOPen));"
    FPRINT FP_WRITE,"  DeleteObject(SelectObject(DrawHDC,hOldBrush));"
    FPRINT FP_WRITE,"  if(b) ReleaseDC(Wnd,DrawHDC);"
    FPRINT FP_WRITE,"  return a;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_Rectangle THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Rectangle"
    FPRINT FP_WRITE,"int BCX_Rectangle (HWND Wnd,int Left,int Top,int Right,int Bottom,int Pen,int Fill,HDC DrawHDC)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int a,b=0;"
    FPRINT FP_WRITE,"  if(!DrawHDC) DrawHDC=GetDC(Wnd),b=1;"
    FPRINT FP_WRITE,"  HPEN   hNPen=CreatePen(PS_SOLID,1,Pen);"
    FPRINT FP_WRITE,"  HPEN   hOPen=(HPEN)SelectObject(DrawHDC,hNPen);"
    FPRINT FP_WRITE,"  HBRUSH hOldBrush;"
    FPRINT FP_WRITE,"  HBRUSH hNewBrush;"
    FPRINT FP_WRITE,"  if(Fill)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      hNewBrush=CreateSolidBrush(Pen);"
    FPRINT FP_WRITE,"      hOldBrush=(HBRUSH)SelectObject(DrawHDC,hNewBrush);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      hNewBrush=(HBRUSH)GetStockObject(NULL_BRUSH);"
    FPRINT FP_WRITE,"      hOldBrush=(HBRUSH)SelectObject(DrawHDC,hNewBrush);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  a = Rectangle(DrawHDC,Left,Top,Right,Bottom);"
    FPRINT FP_WRITE,"  DeleteObject(SelectObject(DrawHDC,hOPen));"
    FPRINT FP_WRITE,"  DeleteObject(SelectObject(DrawHDC,hOldBrush));"
    FPRINT FP_WRITE,"  if(b) ReleaseDC(Wnd,DrawHDC);"
    FPRINT FP_WRITE,"  return a;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_Roundrect THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_RoundRect"
    FPRINT FP_WRITE,"int BCX_Roundrect (HWND Wnd,int Left,int Top,int Right,int Bottom,int W, int H,int Pen,int Fill,HDC DrawHDC)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int a, b=0;"
    FPRINT FP_WRITE,"  if(!DrawHDC) DrawHDC=GetDC(Wnd),b=1;"
    FPRINT FP_WRITE,"  HPEN   hNPen=CreatePen(PS_SOLID,1,Pen);"
    FPRINT FP_WRITE,"  HPEN   hOPen=(HPEN)SelectObject(DrawHDC,hNPen);"
    FPRINT FP_WRITE,"  HBRUSH hOldBrush;"
    FPRINT FP_WRITE,"  HBRUSH hNewBrush;"
    FPRINT FP_WRITE,"  if(Fill)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      hNewBrush=CreateSolidBrush(Pen);"
    FPRINT FP_WRITE,"      hOldBrush=(HBRUSH)SelectObject(DrawHDC,hNewBrush);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      hNewBrush=(HBRUSH)GetStockObject(NULL_BRUSH);"
    FPRINT FP_WRITE,"      hOldBrush=(HBRUSH)SelectObject(DrawHDC,hNewBrush);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  a = RoundRect(DrawHDC,Left,Top,Right,Bottom,W,H);"
    FPRINT FP_WRITE,"  DeleteObject(SelectObject(DrawHDC,hOPen));"
    FPRINT FP_WRITE,"  DeleteObject(SelectObject(DrawHDC,hOldBrush));"
    FPRINT FP_WRITE,"  if(b) ReleaseDC(Wnd,DrawHDC);"
    FPRINT FP_WRITE,"  return a;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_Arc THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Arc"
    FPRINT FP_WRITE,"int BCX_Arc (HWND Wnd,int Left,int Top,int Right,int Bottom,int BCX,int BCY,int ECX,int ECY,int Pen,HDC DrawHDC)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int a, b=0;"
    FPRINT FP_WRITE,"  if(!DrawHDC) DrawHDC=GetDC(Wnd),b=1;"
    FPRINT FP_WRITE,"  HPEN hNPen=CreatePen(PS_SOLID,1,Pen);"
    FPRINT FP_WRITE,"  HPEN hOPen=(HPEN)SelectObject(DrawHDC,hNPen);"
    FPRINT FP_WRITE,"  a = Arc(DrawHDC,Left,Top,Right,Bottom,BCX,BCY,ECX,ECY);"
    FPRINT FP_WRITE,"  DeleteObject(SelectObject(DrawHDC,hOPen));"
    FPRINT FP_WRITE,"  if(b) ReleaseDC(Wnd,DrawHDC);"
    FPRINT FP_WRITE,"  return a;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_Fontdlg THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_FontDlg"
    FPRINT FP_WRITE,"int BCX_FontDlg (BOOL UseBcxFont,HWND hWnd)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE," CHOOSEFONT cf;"
    FPRINT FP_WRITE," memset(&cf,0,sizeof(cf));"
    FPRINT FP_WRITE," if(UseBcxFont)"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"     HDC hdc = GetDC(0);"
    FPRINT FP_WRITE,"     BCX_FONT.lf.lfHeight = -MulDiv(BCX_FONT.SIZE, GetDeviceCaps(hdc, LOGPIXELSY), 72);"
    FPRINT FP_WRITE,"     ReleaseDC(0,hdc);"
    FPRINT FP_WRITE,"     cf.rgbColors=BCX_FONT.RGB;"
    FPRINT FP_WRITE,"  }else{"
    FPRINT FP_WRITE,"     memset(&BCX_FONT.lf,0,sizeof(BCX_FONT.lf));"
    FPRINT FP_WRITE,"     GetObject(GetStockObject(DEFAULT_GUI_FONT),sizeof(BCX_FONT.lf),&BCX_FONT.lf);"
    FPRINT FP_WRITE,"  }"
    FPRINT FP_WRITE," cf.lStructSize=sizeof(CHOOSEFONT);"
    FPRINT FP_WRITE," cf.hwndOwner=hWnd;"
    FPRINT FP_WRITE," cf.lpLogFont=&BCX_FONT.lf;"
    FPRINT FP_WRITE," cf.Flags=CF_INITTOLOGFONTSTRUCT|CF_SCREENFONTS|CF_EFFECTS;"
    FPRINT FP_WRITE," CmDlgHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)SBProc,(HINSTANCE)NULL,GetCurrentThreadId());"
    FPRINT FP_WRITE," int rc=ChooseFont(&cf);"
    FPRINT FP_WRITE," if(rc)"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"     BCX_FONT.SIZE=cf.iPointSize/10;"
    FPRINT FP_WRITE,"     BCX_FONT.RGB=cf.rgbColors;"
    FPRINT FP_WRITE,"  }"
    FPRINT FP_WRITE," return rc;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_Getpixel THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_GetPixel"
    FPRINT FP_WRITE,"COLORREF BCX_Getpixel(HWND Wnd,int X,int Y,HDC DrawHDC)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE," int b=0;"
    FPRINT FP_WRITE," if(!DrawHDC) DrawHDC=GetDC(Wnd),b=1;"
    FPRINT FP_WRITE," int i=GetPixel(DrawHDC,X,Y);"
    FPRINT FP_WRITE," if(b) ReleaseDC(Wnd,DrawHDC);"
    FPRINT FP_WRITE," return i;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_QBColor THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: qbcolor"
    FPRINT FP_WRITE,"int qbcolor (int N)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE," switch (N)"
    FPRINT FP_WRITE," {"
    FPRINT FP_WRITE," case  0 : return RGB(0,0,0);"
    FPRINT FP_WRITE," case  1 : return RGB(0,0,128);"
    FPRINT FP_WRITE," case  2 : return RGB(0,128,0);"
    FPRINT FP_WRITE," case  3 : return RGB(0,128,128);"
    FPRINT FP_WRITE," case  4 : return RGB(196,0,0);"
    FPRINT FP_WRITE," case  5 : return RGB(128,0,128);"
    FPRINT FP_WRITE," case  6 : return RGB(128,64,0);"
    FPRINT FP_WRITE," case  7 : return RGB(196,196,196);"
    FPRINT FP_WRITE," case  8 : return RGB(128,128,128);"
    FPRINT FP_WRITE," case  9 : return RGB(0,0, 255);"
    FPRINT FP_WRITE," case 10 : return RGB(0,255,0);"
    FPRINT FP_WRITE," case 11 : return RGB(0,255,255);"
    FPRINT FP_WRITE," case 12 : return RGB(255,0,0);"
    FPRINT FP_WRITE," case 13 : return RGB(255,0,255);"
    FPRINT FP_WRITE," case 14 : return RGB(255,255,0);"
    FPRINT FP_WRITE," case 15 : return RGB(255,255,255);"
    FPRINT FP_WRITE," case 16 : return RGB(164,164,164);"
    FPRINT FP_WRITE," case 17 : return RGB(128,160,255);"
    FPRINT FP_WRITE," case 18 : return RGB(160,255,160);"
    FPRINT FP_WRITE," case 19 : return RGB(160,255,255);"
    FPRINT FP_WRITE," case 20 : return RGB(255,160,160);"
    FPRINT FP_WRITE," case 21 : return RGB(255,160,255);"
    FPRINT FP_WRITE," case 22 : return RGB(255,255,160);"
    FPRINT FP_WRITE," case 23 : return RGB(212,212,212);"
    FPRINT FP_WRITE," case 24 : return RGB(180,180,180);"
    FPRINT FP_WRITE," case 25 : return RGB(188,220,255);"
    FPRINT FP_WRITE," case 26 : return RGB(220,255,220);"
    FPRINT FP_WRITE," case 27 : return RGB(220,255,255);"
    FPRINT FP_WRITE," case 28 : return RGB(255,220,220);"
    FPRINT FP_WRITE," case 29 : return RGB(255,220,255);"
    FPRINT FP_WRITE," case 30 : return RGB(255,255,220);"
    FPRINT FP_WRITE," case 31 : return RGB(228,228,228);"
    FPRINT FP_WRITE," }"
    FPRINT FP_WRITE,"return 0;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_GetBmp THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: GetBmp"
    FPRINT FP_WRITE,"HDC GetBmp (int Left,int Top,int Width,int Height,HWND hWnd)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE," HDC      HdcSrc = GetDC(hWnd);"
    FPRINT FP_WRITE," HDC      HdcMem = CreateCompatibleDC(HdcSrc);"
    FPRINT FP_WRITE," HBITMAP  hBmp = CreateCompatibleBitmap(HdcSrc,Width,Height);"
    FPRINT FP_WRITE," DeleteObject(SelectObject(HdcMem,hBmp));"
    FPRINT FP_WRITE," BitBlt    (HdcMem,0,0,Width,Height,HdcSrc,Left,Top,SRCCOPY);"
    FPRINT FP_WRITE," ReleaseDC (hWnd,HdcSrc);"
    FPRINT FP_WRITE," return HdcMem;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_SaveBmp THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: SaveBmp"
    'FPRINT FP_WRITE,"void SaveBmp (LPVOID hobj, LPTSTR pszFile)"
    FPRINT FP_WRITE,"void SaveBmp (LPVOID hobj, const char* pszFile)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  BITMAP bmp;"
    FPRINT FP_WRITE,"  PBITMAPINFO pbmi;"
    FPRINT FP_WRITE,"  WORD  cClrBits;"
    FPRINT FP_WRITE,"  HANDLE hf;                // file handle"
    FPRINT FP_WRITE,"  BITMAPFILEHEADER hdr;     // bitmap file-header"
    FPRINT FP_WRITE,"  PBITMAPINFOHEADER pbih;   // bitmap info-header"
    FPRINT FP_WRITE,"  LPBYTE lpBits;            // memory pointer"
    FPRINT FP_WRITE,"  DWORD cb;                 // incremental count of bytes"
    FPRINT FP_WRITE,"  BYTE *hp;                 // byte pointer"
    FPRINT FP_WRITE,"  DWORD dwTmp;"
    FPRINT FP_WRITE,"  HDC hDC=(HDC)hobj;"
    FPRINT FP_WRITE,"  HBITMAP hBmp = (HBITMAP)hobj;"
    FPRINT FP_WRITE,"  if(GetObjectType(hobj) != OBJ_BITMAP)"
    FPRINT FP_WRITE,"     hBmp=(HBITMAP)GetCurrentObject(hDC, OBJ_BITMAP);"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"     hDC=CreateCompatibleDC(NULL);"
    FPRINT FP_WRITE,"  GetObject(hBmp, sizeof(BITMAP), (LPSTR)&bmp);"
    FPRINT FP_WRITE,"  cClrBits = (WORD)(bmp.bmPlanes * bmp.bmBitsPixel);"
    FPRINT FP_WRITE,"  if (cClrBits == 1)"
    FPRINT FP_WRITE,"     cClrBits = 1;"
    FPRINT FP_WRITE,"  else if (cClrBits <= 4)"
    FPRINT FP_WRITE,"     cClrBits = 4;"
    FPRINT FP_WRITE,"  else if (cClrBits <= 8)"
    FPRINT FP_WRITE,"     cClrBits = 8;"
    FPRINT FP_WRITE,"  else if (cClrBits <= 16)"
    FPRINT FP_WRITE,"     cClrBits = 16;"
    FPRINT FP_WRITE,"  else if (cClrBits <= 24)"
    FPRINT FP_WRITE,"     cClrBits = 24;"
    FPRINT FP_WRITE,"  else cClrBits = 32;"
    FPRINT FP_WRITE,"  if (cClrBits != 24)"
    FPRINT FP_WRITE,"      pbmi = (PBITMAPINFO) LocalAlloc(LPTR,"
    FPRINT FP_WRITE,"             sizeof(BITMAPINFOHEADER) +"
    FPRINT FP_WRITE,"             sizeof(RGBQUAD) * (1<< cClrBits));"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"      pbmi = (PBITMAPINFO) LocalAlloc(LPTR,"
    FPRINT FP_WRITE,"             sizeof(BITMAPINFOHEADER));"
    FPRINT FP_WRITE,"  pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);"
    FPRINT FP_WRITE,"  pbmi->bmiHeader.biWidth = bmp.bmWidth;"
    FPRINT FP_WRITE,"  pbmi->bmiHeader.biHeight = bmp.bmHeight;"
    FPRINT FP_WRITE,"  pbmi->bmiHeader.biPlanes = bmp.bmPlanes;"
    FPRINT FP_WRITE,"  pbmi->bmiHeader.biBitCount = bmp.bmBitsPixel;"
    FPRINT FP_WRITE,"  if (cClrBits < 24)"
    FPRINT FP_WRITE,"  pbmi->bmiHeader.biClrUsed = (1<<cClrBits);"
    FPRINT FP_WRITE,"  pbmi->bmiHeader.biCompression = BI_RGB;"
    FPRINT FP_WRITE,"  pbmi->bmiHeader.biSizeImage =";
    FPRINT FP_WRITE,"  ((pbmi->bmiHeader.biWidth * cClrBits +31) & ~31) /8";
    FPRINT FP_WRITE,"  * pbmi->bmiHeader.biHeight; "
    FPRINT FP_WRITE,"  pbmi->bmiHeader.biClrImportant = 0;"
    FPRINT FP_WRITE,"  pbih = (PBITMAPINFOHEADER) pbmi;"
    FPRINT FP_WRITE,"  lpBits=(LPBYTE)GlobalAlloc(GMEM_FIXED, pbih->biSizeImage);"
    FPRINT FP_WRITE,"  GetDIBits(hDC, hBmp,0,(WORD) pbih->biHeight, lpBits, pbmi,"
    FPRINT FP_WRITE,"  DIB_RGB_COLORS);"
    FPRINT FP_WRITE,"  hf = CreateFile(pszFile, GENERIC_READ | GENERIC_WRITE,"
    FPRINT FP_WRITE,"  (DWORD) 0, NULL, CREATE_ALWAYS,"
    FPRINT FP_WRITE,"  FILE_ATTRIBUTE_NORMAL, (HANDLE) NULL);"
    FPRINT FP_WRITE,"  hdr.bfType = 0x4d42;"
    FPRINT FP_WRITE,"  hdr.bfSize = (DWORD) (sizeof(BITMAPFILEHEADER)+"
    FPRINT FP_WRITE,"  pbih->biSize + pbih->biClrUsed *"
    FPRINT FP_WRITE,"  sizeof(RGBQUAD) + pbih->biSizeImage);"
    FPRINT FP_WRITE,"  hdr.bfReserved1 = 0;"
    FPRINT FP_WRITE,"  hdr.bfReserved2 = 0;"
    FPRINT FP_WRITE,"  hdr.bfOffBits = (DWORD) sizeof(BITMAPFILEHEADER)+"
    FPRINT FP_WRITE,"  pbih->biSize + pbih->biClrUsed * sizeof (RGBQUAD);"
    FPRINT FP_WRITE,"  WriteFile(hf, (LPVOID) &hdr, sizeof(BITMAPFILEHEADER),"
    FPRINT FP_WRITE,"  (LPDWORD) &dwTmp,  NULL); "
    FPRINT FP_WRITE,"  WriteFile(hf, (LPVOID) pbih, sizeof(BITMAPINFOHEADER)+"
    FPRINT FP_WRITE,"  pbih->biClrUsed * sizeof(RGBQUAD),(LPDWORD) &dwTmp,(NULL));"
    FPRINT FP_WRITE,"  cb = pbih->biSizeImage;"
    FPRINT FP_WRITE,"  hp = lpBits;"
    FPRINT FP_WRITE,"  WriteFile(hf, (LPSTR) hp,(int) cb,(LPDWORD) &dwTmp,NULL);"
    FPRINT FP_WRITE,"  CloseHandle(hf); "
    FPRINT FP_WRITE,"  GlobalFree((HGLOBAL)lpBits);"
    FPRINT FP_WRITE,"  if(GetObjectType(hobj)==OBJ_BITMAP) DeleteDC(hDC);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Set_BCX_Bitmap THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Set_BCX_Bitmap"
    FPRINT FP_WRITE,"void Set_BCX_Bitmap(HWND hWnd,const char* File,int Res, int W, int H)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HBITMAP Bm_Handle=NULL;"
    FPRINT FP_WRITE,"  if(Res)"
    FPRINT FP_WRITE,"     Bm_Handle=(HBITMAP)LoadImage(GetModuleHandle(0),MAKEINTRESOURCE(Res),"
    FPRINT FP_WRITE,"                IMAGE_BITMAP,W*BCX_ScaleX,H*BCX_ScaleY,LR_CREATEDIBSECTION);"
    FPRINT FP_WRITE,"  else if(File!=NULL)"
    FPRINT FP_WRITE,"     Bm_Handle=(HBITMAP)LoadImage(0,File,IMAGE_BITMAP,"
    FPRINT FP_WRITE,"                W*BCX_ScaleX,H*BCX_ScaleY,LR_LOADFROMFILE|LR_CREATEDIBSECTION);"
    FPRINT FP_WRITE,"  if(Bm_Handle)"
    FPRINT FP_WRITE,"     DeleteObject((HBITMAP)SendMessage(hWnd,(UINT)STM_SETIMAGE,"
    FPRINT FP_WRITE,"                  (WPARAM)IMAGE_BITMAP,(LPARAM)Bm_Handle));"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Set_BCX_Bitmap2 THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Set_BCX_Bitmap2"
    FPRINT FP_WRITE,"HBITMAP Set_BCX_Bitmap2 (HWND hWnd,HBITMAP  Bmp,int DeleteBM)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HBITMAP bm=(HBITMAP)SendMessage(hWnd,STM_SETIMAGE,(WPARAM)IMAGE_BITMAP,(LPARAM)Bmp);"
    FPRINT FP_WRITE,"  if(DeleteBM)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      DeleteObject(bm);"
    FPRINT FP_WRITE,"      return 0;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  return bm;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Set_BCX_BmpButton THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Set_BCX_BmpButton"
    FPRINT FP_WRITE,"void Set_BCX_BmpButton(HWND hWnd,const char* File,int Res)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  RECT rc;"
    FPRINT FP_WRITE,"  GetClientRect(hWnd,&rc);"
    FPRINT FP_WRITE,"  HBITMAP Bm_Handle;"
    FPRINT FP_WRITE,"  if(!Res)"
    FPRINT FP_WRITE,"     Bm_Handle=(HBITMAP)LoadImage(0,File,IMAGE_BITMAP,"
    FPRINT FP_WRITE,"                        rc.right,rc.bottom,LR_LOADFROMFILE);"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"     Bm_Handle=(HBITMAP)LoadImage(GetModuleHandle(0),MAKEINTRESOURCE(Res),"
    FPRINT FP_WRITE,"                        IMAGE_BITMAP,rc.right,rc.bottom,0);"
    FPRINT FP_WRITE,"  DeleteObject((HBITMAP)SendMessage"
    FPRINT FP_WRITE,"  (hWnd,(UINT)BM_SETIMAGE,(WPARAM)IMAGE_BITMAP,(LPARAM)Bm_Handle));"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Set_BCX_Icon THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Set_BCX_Icon"
    FPRINT FP_WRITE,"void Set_BCX_Icon(HWND hWnd,const char* File,int Res,int W,int H)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HICON hIcon;"
    FPRINT FP_WRITE,"  DWORD dwSize;"
    FPRINT FP_WRITE,"  LPBYTE pBytes;"
    FPRINT FP_WRITE,"  if(!Res)"
    FPRINT FP_WRITE,"     hIcon=(HICON)LoadImage(0,File,IMAGE_ICON,W,H,LR_LOADFROMFILE);"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"     pBytes=(PBYTE)GetResource(Res,RT_ANICURSOR,&dwSize);"
    FPRINT FP_WRITE,"     if(pBytes==NULL)"
    FPRINT FP_WRITE,"       hIcon=(HICON)LoadImage"
    FPRINT FP_WRITE,"             (BCX_hInstance,MAKEINTRESOURCE(Res),IMAGE_ICON,W,H,0);"
    FPRINT FP_WRITE,"     else"
    FPRINT FP_WRITE,"       hIcon=CreateIconFromResourceEx"
    FPRINT FP_WRITE,"             (pBytes,dwSize,FALSE,0x00030000,W,H,LR_DEFAULTCOLOR);"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"  DestroyIcon((HICON)SendMessage"
    FPRINT FP_WRITE,"  (hWnd,(UINT)STM_SETIMAGE,(WPARAM)IMAGE_ICON,(LPARAM)hIcon));"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_Put THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Put"
    FPRINT FP_WRITE,"void BCX_Put(HWND DesthWnd, HBITMAP hBitmap, int LtDest, int TopDest,"
    FPRINT FP_WRITE,"             int WidDest, int HgtDest, int Style, HDC DesHDC)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int b=0;"
    FPRINT FP_WRITE,"  if(!DesHDC) DesHDC = GetDC(DesthWnd), b=1;"
    FPRINT FP_WRITE,"  HDC MemHDC = CreateCompatibleDC(DesHDC);"
    FPRINT FP_WRITE,"  HBITMAP OldBmp = (HBITMAP)SelectObject(MemHDC,hBitmap);"
    FPRINT FP_WRITE,"  SetMapMode(MemHDC,GetMapMode(DesHDC));"
    FPRINT FP_WRITE,"  BitBlt (DesHDC,LtDest,TopDest,WidDest,HgtDest,MemHDC,0,0,Style);"
    FPRINT FP_WRITE,"  SelectObject(MemHDC,OldBmp);"
    FPRINT FP_WRITE,"  if(b) ReleaseDC(DesthWnd,DesHDC);"
    FPRINT FP_WRITE,"  DeleteDC(MemHDC);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_Get THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Get"
    FPRINT FP_WRITE,"HBITMAP BCX_Get(HWND hWnd, int Left, int Top,"
    FPRINT FP_WRITE,"                int Width, int Height, int Style, HDC SrcHDC)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int b=0;"
    FPRINT FP_WRITE,"  if(!SrcHDC) SrcHDC=GetDC(hWnd),b=1;"
    FPRINT FP_WRITE,"  HDC MemHDC = CreateCompatibleDC(SrcHDC);"
    FPRINT FP_WRITE,"  HBITMAP OldBMP;"
    FPRINT FP_WRITE,"  static HBITMAP RetBMP;"
    FPRINT FP_WRITE,"  if(RetBMP) DeleteObject(RetBMP);"
    FPRINT FP_WRITE,"  RetBMP = CreateCompatibleBitmap (SrcHDC,Width,Height);"
    FPRINT FP_WRITE,"  OldBMP = (HBITMAP)SelectObject(MemHDC,RetBMP);"
    FPRINT FP_WRITE,"  BitBlt (MemHDC,0,0,Width,Height,SrcHDC,Left,Top,Style);"
    FPRINT FP_WRITE,"  SelectObject(MemHDC,OldBMP);"
    FPRINT FP_WRITE,"  DeleteDC(MemHDC);"
    FPRINT FP_WRITE,"  if(b) ReleaseDC(hWnd,SrcHDC);"
    FPRINT FP_WRITE,"  return RetBMP;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_LoadBMP THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_LoadBMP"
    FPRINT FP_WRITE,"HBITMAP BCX_LoadBMP (const char *F, int i, int t)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE," if(t) t=LR_LOADTRANSPARENT|LR_LOADMAP3DCOLORS;"
    FPRINT FP_WRITE," if(i)"
    FPRINT FP_WRITE,"   return (HBITMAP)LoadImage(GetModuleHandle(0), MAKEINTRESOURCE(i),IMAGE_BITMAP,0,0,t);"
    FPRINT FP_WRITE,"   return (HBITMAP)LoadImage(NULL,F,IMAGE_BITMAP,0,0,LR_LOADFROMFILE|t);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_LoadImage THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_LoadImage"
    FPRINT FP_WRITE,"HBITMAP BCX_LoadImage (const char *szFile, int Res)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HANDLE   hFile;"
    FPRINT FP_WRITE,"  DWORD    dwFileSize;"
    FPRINT FP_WRITE,"  LPVOID   pvData;"
    FPRINT FP_WRITE,"  HGLOBAL  hGlobal;"
    FPRINT FP_WRITE,"  DWORD    dwBytesRead=0;"
    FPRINT FP_WRITE,"  LPSTREAM pstm;"
    FPRINT FP_WRITE,"  HBITMAP  hTempBitmap;"
    FPRINT FP_WRITE,"  LPVOID   lpPicData;"
    FPRINT FP_WRITE,"  LPPICTURE gpPicture;"
    FPRINT FP_WRITE,"  if(Res)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      lpPicData=GetResource(Res,RT_RCDATA,&dwFileSize);"
    FPRINT FP_WRITE,"      if(lpPicData==NULL) return 0;"
    FPRINT FP_WRITE,"      hGlobal=GlobalAlloc(GMEM_MOVEABLE|GMEM_NODISCARD,dwFileSize);"
    FPRINT FP_WRITE,"      pvData=GlobalLock(hGlobal);"
    FPRINT FP_WRITE,"      CopyMemory(pvData,lpPicData,dwFileSize);"
    FPRINT FP_WRITE,"      GlobalUnlock(hGlobal);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      if(GetFileAttributes(szFile)==0xffffffff) return 0;"
    FPRINT FP_WRITE,"      hFile=CreateFile(szFile,GENERIC_READ,0,NULL,OPEN_EXISTING,0,NULL);"
    FPRINT FP_WRITE,"      dwFileSize=GetFileSize(hFile,NULL);"
    FPRINT FP_WRITE,"      hGlobal=GlobalAlloc(GMEM_MOVEABLE|GMEM_NODISCARD,dwFileSize);"
    FPRINT FP_WRITE,"      pvData=GlobalLock(hGlobal);"
    FPRINT FP_WRITE,"      ReadFile(hFile,pvData,dwFileSize,&dwBytesRead,NULL);"
    FPRINT FP_WRITE,"      GlobalUnlock(hGlobal);"
    FPRINT FP_WRITE,"      CloseHandle(hFile);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  pstm=NULL;"
    FPRINT FP_WRITE,"  CreateStreamOnHGlobal(hGlobal,TRUE,&pstm);"
    FPRINT FP_WRITE,"#ifndef __cplusplus"
    FPRINT FP_WRITE,"  OleLoadPicture(pstm,dwFileSize,FALSE,&IID_IPicture,(LPVOID*)&gpPicture);"
    FPRINT FP_WRITE,"  pstm->lpVtbl->Release(pstm);"
    FPRINT FP_WRITE,"  gpPicture->lpVtbl->get_Handle(gpPicture,(OLE_HANDLE*)&hTempBitmap);"
    FPRINT FP_WRITE,"  hTempBitmap=(HBITMAP)CopyImage(hTempBitmap,IMAGE_BITMAP,0,0,LR_COPYRETURNORG);"
    FPRINT FP_WRITE,"  gpPicture->lpVtbl->Release(gpPicture);"
    FPRINT FP_WRITE,"#else"
    FPRINT FP_WRITE,"  OleLoadPicture(pstm,dwFileSize,FALSE,IID_IPicture,(LPVOID*)&gpPicture);"
    FPRINT FP_WRITE,"  pstm->Release();"
    FPRINT FP_WRITE,"  gpPicture->get_Handle((OLE_HANDLE*)&hTempBitmap);"
    FPRINT FP_WRITE,"  hTempBitmap=(HBITMAP)CopyImage(hTempBitmap,IMAGE_BITMAP,0,0,LR_COPYRETURNORG);"
    FPRINT FP_WRITE,"  gpPicture->Release();"
    FPRINT FP_WRITE,"#endif"
    FPRINT FP_WRITE,"  return hTempBitmap;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_DrawTransBMP THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: DrawTransBMP"
    FPRINT FP_WRITE,"void DrawTransBMP (HWND hWnd,HBITMAP hBitmap,COLORREF cTransparentColor,int xStart,int yStart,HDC hdc)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  BITMAP bm;"
    FPRINT FP_WRITE,"  COLORREF cColor;"
    FPRINT FP_WRITE,"  HBITMAP bmAndBack, bmAndObject, bmAndMem,bmSave;"
    FPRINT FP_WRITE,"  HBITMAP bmBackOld, bmObjectOld, bmMemOld,bmSaveOld,hmTMP;"
    FPRINT FP_WRITE,"  HDC hdcMem, hdcBack, hdcObject,hdcTemp, hdcSave;"
    FPRINT FP_WRITE,"  POINT ptSize;"
    FPRINT FP_WRITE,"  int b=0;"
    FPRINT FP_WRITE,"  if(!hdc) hdc=GetDC(hWnd),b=1;"
    FPRINT FP_WRITE,"  hdcTemp = CreateCompatibleDC(hdc);"
    FPRINT FP_WRITE,"  SelectObject(hdcTemp, hBitmap);"
    FPRINT FP_WRITE,"  GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);"
    FPRINT FP_WRITE,"  ptSize.x = bm.bmWidth;"
    FPRINT FP_WRITE,"  ptSize.y = bm.bmHeight;"
    FPRINT FP_WRITE,"  DPtoLP(hdcTemp, &ptSize, 1);"
    FPRINT FP_WRITE,"  hdcBack = CreateCompatibleDC(hdc);"
    FPRINT FP_WRITE,"  hdcObject = CreateCompatibleDC(hdc);"
    FPRINT FP_WRITE,"  hdcMem = CreateCompatibleDC(hdc);"
    FPRINT FP_WRITE,"  hdcSave = CreateCompatibleDC(hdc);"
    FPRINT FP_WRITE,"  bmAndBack = CreateBitmap(ptSize.x,ptSize.y, 1, 1, NULL);"
    FPRINT FP_WRITE,"  bmAndObject = CreateBitmap(ptSize.x,ptSize.y, 1, 1, NULL);"
    FPRINT FP_WRITE,"  bmAndMem = CreateCompatibleBitmap(hdc,ptSize.x, ptSize.y);"
    FPRINT FP_WRITE,"  bmSave = CreateCompatibleBitmap(hdc,ptSize.x, ptSize.y);"
    FPRINT FP_WRITE,"  bmBackOld = (HBITMAP)SelectObject(hdcBack,bmAndBack);"
    FPRINT FP_WRITE,"  bmObjectOld = (HBITMAP)SelectObject(hdcObject,bmAndObject);"
    FPRINT FP_WRITE,"  bmMemOld = (HBITMAP)SelectObject(hdcMem,bmAndMem);"
    FPRINT FP_WRITE,"  bmSaveOld = (HBITMAP)SelectObject(hdcSave,bmSave);"
    FPRINT FP_WRITE,"  SetMapMode(hdcTemp, GetMapMode(hdc));"
    FPRINT FP_WRITE,"  BitBlt(hdcSave, 0, 0, ptSize.x, ptSize.y,hdcTemp, 0, 0, SRCCOPY);"
    FPRINT FP_WRITE,"  cColor = SetBkColor(hdcTemp,cTransparentColor);"
    FPRINT FP_WRITE,"  BitBlt(hdcObject, 0, 0, ptSize.x, ptSize.y,hdcTemp, 0, 0, SRCCOPY);"
    FPRINT FP_WRITE,"  SetBkColor(hdcTemp, cColor);"
    FPRINT FP_WRITE,"  BitBlt(hdcBack, 0, 0, ptSize.x, ptSize.y,hdcObject, 0, 0, NOTSRCCOPY);"
    FPRINT FP_WRITE,"  BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y,hdc, xStart, yStart, SRCCOPY);"
    FPRINT FP_WRITE,"  BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y,hdcObject, 0, 0, SRCAND);"
    FPRINT FP_WRITE,"  BitBlt(hdcTemp, 0, 0, ptSize.x, ptSize.y,hdcBack, 0, 0, SRCAND);"
    FPRINT FP_WRITE,"  BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y,hdcTemp, 0, 0, SRCPAINT);"
    FPRINT FP_WRITE,"  BitBlt(hdc, xStart, yStart, ptSize.x,ptSize.y, hdcMem, 0, 0,SRCCOPY);"
    FPRINT FP_WRITE,"  BitBlt(hdcTemp, 0, 0, ptSize.x, ptSize.y,hdcSave, 0, 0, SRCCOPY);"
    FPRINT FP_WRITE,"  hmTMP = (HBITMAP)SelectObject(hdcBack, bmBackOld);"
    FPRINT FP_WRITE,"  DeleteObject(hmTMP);"
    FPRINT FP_WRITE,"  hmTMP = (HBITMAP)SelectObject(hdcObject,bmObjectOld);"
    FPRINT FP_WRITE,"  DeleteObject(hmTMP);"
    FPRINT FP_WRITE,"  hmTMP = (HBITMAP)SelectObject(hdcMem, bmMemOld);"
    FPRINT FP_WRITE,"  DeleteObject(hmTMP);"
    FPRINT FP_WRITE,"  hmTMP = (HBITMAP)SelectObject(hdcSave, bmSaveOld);"
    FPRINT FP_WRITE,"  DeleteObject(hmTMP);"
    FPRINT FP_WRITE,"  DeleteDC(hdcMem);"
    FPRINT FP_WRITE,"  DeleteDC(hdcBack);"
    FPRINT FP_WRITE,"  DeleteDC(hdcObject);"
    FPRINT FP_WRITE,"  DeleteDC(hdcSave);"
    FPRINT FP_WRITE,"  DeleteDC(hdcTemp);"
    FPRINT FP_WRITE,"  if(b) ReleaseDC(hWnd,hdc);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_BmpWidth THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_BmpWidth"
    FPRINT FP_WRITE,"int BCX_BmpWidth (HBITMAP hBmp)"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"    BITMAP bm;"
    FPRINT FP_WRITE,"    if(hBmp)"
    FPRINT FP_WRITE,"      {"
    FPRINT FP_WRITE,"        GetObject(hBmp,sizeof(bm),&bm);"
    FPRINT FP_WRITE,"        return bm.bmWidth;"
    FPRINT FP_WRITE,"      }"
    FPRINT FP_WRITE,"    return 0;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BCX_BmpHeight THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_BmpHeight"
    FPRINT FP_WRITE,"int BCX_BmpHeight (HBITMAP hBmp)"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"    BITMAP bm;"
    FPRINT FP_WRITE,"    if(hBmp)"
    FPRINT FP_WRITE,"      {"
    FPRINT FP_WRITE,"        GetObject(hBmp,sizeof(bm),&bm);"
    FPRINT FP_WRITE,"        return bm.bmHeight;"
    FPRINT FP_WRITE,"      }"
    FPRINT FP_WRITE,"    return 0;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Cvi THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: CVI"
    FPRINT FP_WRITE,"short CVI (const char *s)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE," return ((short*)s)[0];"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Mki THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: MKI"
    FPRINT FP_WRITE,"char *MKI (short cvt)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  static char temp[3];"
    FPRINT FP_WRITE,"  return (char *)memmove(temp,&cvt,2);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Cvl THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: CVL"
    FPRINT FP_WRITE,"long CVL (char *s)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE," return ((long*)s)[0];"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Mkl THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: MKL"
    FPRINT FP_WRITE,"char *MKL (int cvt)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  static char temp[5];"
    FPRINT FP_WRITE,"  return (char *) memmove(temp,&cvt,4);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Cvs THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: CVS"
    FPRINT FP_WRITE,"float CVS (char *s)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE," return ((float*)s)[0];"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Mks THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: MKS"
    FPRINT FP_WRITE,"char *MKS (float cvt)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  static char temp[5];"
    FPRINT FP_WRITE,"  return (char *) memmove(temp,&cvt,4);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Cvd THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: CVD"
    FPRINT FP_WRITE,"double CVD (char *s)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE," return ((double*)s)[0];"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Cvld THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: CVLD"
    FPRINT FP_WRITE,"long double CVLD (char *s)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE," return ((long double*)s)[0];"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Mkd THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: MKD"
    FPRINT FP_WRITE,"char *MKD (double cvt)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  static char temp[9];"
    FPRINT FP_WRITE,"  return (char *) memmove(temp,&cvt,8);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Mkld THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: MKLD"
    FPRINT FP_WRITE,"char *MKLD (long double cvt)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  static char temp[11];"
    FPRINT FP_WRITE,"  return (char *) memmove(temp,&cvt,10);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Dynacall OR Use_DynacallA THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_LoadDll"
    FPRINT FP_WRITE,"HINSTANCE BCX_LoadDll (const char *DllName)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  static int DllCnt;"
    FPRINT FP_WRITE,"  static int RegUnload;"
    FPRINT FP_WRITE,"  if (!RegUnload) RegUnload=!atexit(BCX_UnloadDll);"
    FPRINT FP_WRITE,"  DllCnt=(DllCnt+1) & 255;"
    FPRINT FP_WRITE,"  FreeLibrary(BCX_DllStore[DllCnt]);"
    FPRINT FP_WRITE,"  return BCX_DllStore[DllCnt]=LoadLibrary(DllName);"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"void BCX_UnloadDll (void)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  register int i;"
    FPRINT FP_WRITE,"  int i;"
    FPRINT FP_WRITE,"  for(i=255;i>=0;i--)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      FreeLibrary(BCX_DllStore[i]);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,sENDBCXRTLIB$

    IF Use_Dynacall THEN
      IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_DynaCallB"
      FPRINT FP_WRITE,"int BCX_DynaCallB (const char *FuncName, const char *DllName, int nArgs, ...)"
      FPRINT FP_WRITE,"{"
      'FPRINT FP_WRITE,"  register int i;"
      FPRINT FP_WRITE,"  int i;"
      FPRINT FP_WRITE,"  HINSTANCE  hInst=0;"
      FPRINT FP_WRITE,"  DYNACALL1 lpAddr=0;"
      FPRINT FP_WRITE,"  int arg, result =0;"
      FPRINT FP_WRITE,"  int p =0;"
      FPRINT FP_WRITE,"  int *argtable = (int*)malloc(nArgs * sizeof (*argtable));"
      FPRINT FP_WRITE,"  char buff[256];"
      FPRINT FP_WRITE,"  va_list ap;\n"
      FPRINT FP_WRITE,"  hInst=GetModuleHandle(DllName);"
      FPRINT FP_WRITE,"  if(hInst==NULL)"
      FPRINT FP_WRITE,"  {"
      FPRINT FP_WRITE,"      hInst=BCX_LoadDll(DllName);"
      FPRINT FP_WRITE,"  }"
      FPRINT FP_WRITE,"  lpAddr=(DYNACALL1)GetProcAddress(hInst,FuncName);"
      FPRINT FP_WRITE,"  if(lpAddr==NULL)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      sprintf(buff,",S2$,",FuncName,",DQ$,"A",DQ$,");"
      FPRINT FP_WRITE,"      lpAddr=(DYNACALL1)GetProcAddress(hInst,buff);"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"  if(lpAddr==NULL)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      sprintf(buff,",S2$,",",DQ$,"_",DQ$,",FuncName);"
      FPRINT FP_WRITE,"      lpAddr=(DYNACALL1)GetProcAddress(hInst,buff);"
      FPRINT FP_WRITE,"    }"
'jcfuller 2/10/2013
      FPRINT FP_WRITE,"  if(lpAddr==NULL)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"       for(p=4; p<=128; p+=4)"
      FPRINT FP_WRITE,"       {"
      FPRINT FP_WRITE,"         sprintf(buff,",DQ$,"%s%s%s%i",DQ$,",",DQ$,"_",DQ$,",FuncName,",DQ$,"@",DQ$,",p);"
      FPRINT FP_WRITE,"         lpAddr=(DYNACALL1)GetProcAddress(hInst,buff);"
      FPRINT FP_WRITE,"         if (lpAddr) break;"
      FPRINT FP_WRITE,"       }"
      FPRINT FP_WRITE,"    }"

      FPRINT FP_WRITE,"  if (lpAddr)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      va_start(ap,nArgs);"
      FPRINT FP_WRITE,"      for (i=0; i<nArgs;i++)"
      FPRINT FP_WRITE,"        {"
      FPRINT FP_WRITE,"          argtable[i] = va_arg(ap,int);"
      FPRINT FP_WRITE,"        }"
      FPRINT FP_WRITE,"      va_end(ap);"
      FPRINT FP_WRITE,"      while (--nArgs >= 0)"
      FPRINT FP_WRITE,"        {"
      FPRINT FP_WRITE,"          arg = argtable[nArgs];"
      FPRINT FP_WRITE,"          #if defined( __LCC__ )"
      FPRINT FP_WRITE,"          _asm(",ENC$("pushl %arg"),")"
      FPRINT FP_WRITE,"          #elif defined( __MINGW32__ ) || defined( __TINYC__)"
'      FPRINT FP_WRITE,"          __asm__(",ENC$("pushl %0")," : : ",ENC$("r")," (arg));"
      FPRINT FP_WRITE,"          __asm__(",ENC$("pushl %0"),"::",ENC$("r"),"(arg));"
      FPRINT FP_WRITE,"          #elif defined( __BCPLUSPLUS__ ) "
      FPRINT FP_WRITE,"            asm push arg"
      FPRINT FP_WRITE,"          #else"
      FPRINT FP_WRITE,"          __asm{push arg}"
      FPRINT FP_WRITE,"          #endif"
      FPRINT FP_WRITE,"        }"
      FPRINT FP_WRITE,"      result = (int)lpAddr();"
      FPRINT FP_WRITE,"  }"
      FPRINT FP_WRITE,"  free(argtable);"
      FPRINT FP_WRITE,"  return result;"
      FPRINT FP_WRITE,sENDBCXRTLIB$
    END IF

    IF Use_DynacallA THEN
      IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_DynaCallA"
      FPRINT FP_WRITE,"int BCX_DynaCallA (const char *DllName, const char *FuncName, int nArgs, int argtable[])"
      FPRINT FP_WRITE,"{"
      FPRINT FP_WRITE,"  HINSTANCE  hInst=0;"
      FPRINT FP_WRITE,"  DYNACALL1 lpAddr=0;"
      FPRINT FP_WRITE,"  int arg, result =0;"
      FPRINT FP_WRITE,"  char buff[256];"
      FPRINT FP_WRITE,"  hInst=GetModuleHandle(DllName);"
      FPRINT FP_WRITE,"  if(hInst==NULL)"
      FPRINT FP_WRITE,"  {"
      FPRINT FP_WRITE,"      hInst=BCX_LoadDll(DllName);"
      FPRINT FP_WRITE,"  }"
      FPRINT FP_WRITE,"  lpAddr=(DYNACALL1)GetProcAddress(hInst,FuncName);"
      FPRINT FP_WRITE,"  if(lpAddr==NULL)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      sprintf(buff,",S2$,",FuncName,",DQ$,"A",DQ$,");"
      FPRINT FP_WRITE,"      lpAddr=(DYNACALL1)GetProcAddress(hInst,buff);"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"  if(lpAddr==NULL)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      sprintf(buff,",S2$,",",DQ$,"_",DQ$,",FuncName);"
      FPRINT FP_WRITE,"      lpAddr=(DYNACALL1)GetProcAddress(hInst,buff);"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"  if (lpAddr)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      while (--nArgs >= 0)"
      FPRINT FP_WRITE,"        {"
      FPRINT FP_WRITE,"          arg = argtable[nArgs];"
      FPRINT FP_WRITE,"          #if defined( __LCC__ )"
      FPRINT FP_WRITE,"          _asm(",ENC$("pushl %arg"),")"
      FPRINT FP_WRITE,"          #elif defined( __MINGW32__ ) || defined( __TINYC__)"
      FPRINT FP_WRITE,"          __asm__(",ENC$("pushl %0")," : : ",ENC$("r")," (arg));"
      FPRINT FP_WRITE,"          #elif defined( __BCPLUSPLUS__ ) "
      FPRINT FP_WRITE,"            asm push arg"
      FPRINT FP_WRITE,"          #else"
      FPRINT FP_WRITE,"          __asm{push arg}"
      FPRINT FP_WRITE,"          #endif"
      FPRINT FP_WRITE,"        }"
      FPRINT FP_WRITE,"      result = (int)lpAddr();"
      FPRINT FP_WRITE,"  }"
      FPRINT FP_WRITE,"  return result;"
      FPRINT FP_WRITE,sENDBCXRTLIB$
    END IF
  END IF


  IF Use_Bff THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BFF"
    FPRINT FP_WRITE,"char *BFF(const char* Instructions,int BIF_Flags,const char* InitPath)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *BCX_RetStr=BCX_TmpStr(";cDefaultStringSize;",1,1);"
    'FPRINT FP_WRITE,"  char *BCX_RetVar=BCX_TmpStr(";cDefaultStringSize;");"
    FPRINT FP_WRITE,"  BROWSEINFO tBFF={0,0,0,0,0,NULL,0,0};"
    FPRINT FP_WRITE,"  LPITEMIDLIST lpIDList={0};"
    FPRINT FP_WRITE,"  tBFF.hwndOwner=GetActiveWindow();"
    FPRINT FP_WRITE,"  tBFF.lpszTitle=(char*)Instructions;"
    FPRINT FP_WRITE,"  tBFF.ulFlags=BIF_Flags;"
    FPRINT FP_WRITE,"  if(InitPath)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      tBFF.lpfn=BFFCallBack;"
    FPRINT FP_WRITE,"      tBFF.lParam=(LPARAM)InitPath;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  lpIDList=SHBrowseForFolder(&tBFF);"
    FPRINT FP_WRITE,"  if(lpIDList!=NULL)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      SHGetPathFromIDList((LPITEMIDLIST)lpIDList,BCX_RetStr);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  CoTaskMemFree(lpIDList);"
    FPRINT FP_WRITE,"  return BCX_RetStr;"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"int CALLBACK BFFCallBack (HWND hWnd, UINT Msg, LPARAM wParam, LPARAM lParam)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  if(Msg==BFFM_INITIALIZED)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      if(GetFileAttributes((char*)lParam)!=0xffffffff)"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"          SendMessage(hWnd,(UINT)BFFM_SETSELECTION,(WPARAM)TRUE,(LPARAM)(char*)lParam);"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  return 0;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_BcxSplitPath THEN

	  IF TargetOS = TNIX THEN
		FPRINT FP_WRITE,"char *BcxSplitPath (const char *FPath, int mask)"
		FPRINT FP_WRITE,"{"
		FPRINT FP_WRITE,"  if(!FPath) return BCX_TmpStr(1,1,1);"
		FPRINT FP_WRITE,"  char *BCX_RetStr=BCX_TmpStr(strlen(FPath),1,1);"
		FPRINT FP_WRITE,"  char tmp[MAX_PATH*4];"
		FPRINT FP_WRITE,"  _splitpath(FPath,tmp,&tmp[MAX_PATH],&tmp[MAX_PATH*2],&tmp[MAX_PATH*3]);"
		FPRINT FP_WRITE,"  if(mask & FDRV) strcat(BCX_RetStr,tmp);"
		FPRINT FP_WRITE,"  if(mask & FPATH)strcat(BCX_RetStr,&tmp[MAX_PATH]);"
		FPRINT FP_WRITE,"  if(mask & FNAME)strcat(BCX_RetStr,&tmp[MAX_PATH*2]);"
		FPRINT FP_WRITE,"  if(mask & FEXT) strcat(BCX_RetStr,&tmp[MAX_PATH*3]);"
		FPRINT FP_WRITE,"  return BCX_RetStr;"
		FPRINT FP_WRITE,"}\n\n"
		FPRINT FP_WRITE," void _splitpath(const char* path, char* drv, char* dir, char* name, char* ext)"
		FPRINT FP_WRITE," {"
		FPRINT FP_WRITE,"     const char* pend; /* end of processed string */"
		FPRINT FP_WRITE,"     const char* p;   /* search pointer */"
		FPRINT FP_WRITE,"     const char* s;   /* copy pointer */"
		FPRINT FP_WRITE," "
		FPRINT FP_WRITE,"     /* extract drive name */"
		FPRINT FP_WRITE,"     if (path[0] && path[1]==':') {"
		FPRINT FP_WRITE,"         if (drv) {"
		FPRINT FP_WRITE,"             *drv++ = *path++;"
		FPRINT FP_WRITE,"             *drv++ = *path++;"
		FPRINT FP_WRITE,"             *drv = 0;"
		FPRINT FP_WRITE,"         }"
		FPRINT FP_WRITE,"     } else if (drv)"
		FPRINT FP_WRITE,"         *drv = 0;"
		FPRINT FP_WRITE," "
		FPRINT FP_WRITE,"     /* search for end of string or stream separator */"
		FPRINT FP_WRITE,"     for(pend=path; *pend && *pend!=':'; )"
		FPRINT FP_WRITE,"         pend++;"
		FPRINT FP_WRITE," "
		FPRINT FP_WRITE,"     /* search for begin of file extension */"
		FPRINT FP_WRITE,"     for(p=pend; p > path && *--p != '\\\\' && *p!='/'; )"
		FPRINT FP_WRITE,"         if (*p == '.') {"
		FPRINT FP_WRITE,"             pend = p;"
		FPRINT FP_WRITE,"             break;"
		FPRINT FP_WRITE,"         }"
		FPRINT FP_WRITE," "
		FPRINT FP_WRITE,"     if (ext)"
		FPRINT FP_WRITE,"     {"
		FPRINT FP_WRITE,"         s=pend;"
		FPRINT FP_WRITE,"         do{ *ext++ = *s; } while(*s++);"
		FPRINT FP_WRITE,"     }"
		FPRINT FP_WRITE,"     /* search for end of directory name */"
		FPRINT FP_WRITE,"     for(p=pend; p > path; )"
		FPRINT FP_WRITE,"         if (*--p == '\\\\' || *p == '/') {"
		FPRINT FP_WRITE,"             p++;"
		FPRINT FP_WRITE,"             break;"
		FPRINT FP_WRITE,"         }"
		FPRINT FP_WRITE," "
		FPRINT FP_WRITE,"     if (name) {"
		FPRINT FP_WRITE,"         for(s=p; s<pend; )"
		FPRINT FP_WRITE,"             *name++ = *s++;"
		FPRINT FP_WRITE," "
		FPRINT FP_WRITE,"         *name = 0;"
		FPRINT FP_WRITE,"     }"
		FPRINT FP_WRITE," "
		FPRINT FP_WRITE,"     if (dir) {"
		FPRINT FP_WRITE,"         for(s=path; s<p; )"
		FPRINT FP_WRITE,"             *dir++ = *s++;"
		FPRINT FP_WRITE," "
		FPRINT FP_WRITE,"         *dir = 0;"
		FPRINT FP_WRITE,"     }"
		FPRINT FP_WRITE," }\n"

	  ELSE
	    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BcxSplitPath"
	    FPRINT FP_WRITE,"char *BcxSplitPath (const char *FPath, int mask)"
	    FPRINT FP_WRITE,"{"
	    FPRINT FP_WRITE,"  if(!FPath) return BCX_TmpStr(1,1,1);"
	    FPRINT FP_WRITE,"  char *BCX_RetStr=BCX_TmpStr(strlen(FPath),1,1);"
	    FPRINT FP_WRITE,"  char tmp[MAX_PATH*4];"
	    FPRINT FP_WRITE,"  _splitpath(FPath,tmp,&tmp[MAX_PATH],&tmp[MAX_PATH*2],&tmp[MAX_PATH*3]);"
	    FPRINT FP_WRITE,"  if(mask & FDRV) strcat(BCX_RetStr,tmp);"
	    FPRINT FP_WRITE,"  if(mask & FPATH)strcat(BCX_RetStr,&tmp[MAX_PATH]);"
	    FPRINT FP_WRITE,"  if(mask & FNAME)strcat(BCX_RetStr,&tmp[MAX_PATH*2]);"
	    FPRINT FP_WRITE,"  if(mask & FEXT) strcat(BCX_RetStr,&tmp[MAX_PATH*3]);"
	    FPRINT FP_WRITE,"  return BCX_RetStr;"
	    FPRINT FP_WRITE,sENDBCXRTLIB$
	  END IF
  END IF

  IF Use_BCX_Path THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BcxPath"
    FPRINT FP_WRITE,"char *BcxPath (void)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *BCX_RegPath=BCX_TmpStr(";cDefaultStringSize;",1,1);"
    FPRINT FP_WRITE,"  strcpy(BCX_RegPath,RegString"
    'FPRINT FP_WRITE,"  (HKEY_LOCAL_MACHINE,", ENC$("Software\\\\Bcx-32\\\\Bcx\\\\Settings"), ",", ENC$("Path"), "));"
    FPRINT FP_WRITE,"  (HKEY_LOCAL_MACHINE,","(char*)", ENC$("Software\\\\Bcx-32\\\\Bcx\\\\Settings"), ",", "(char*)",ENC$("Path"), "));"
    FPRINT FP_WRITE,"  if(BCX_RegPath[0]==0)"
    FPRINT FP_WRITE,"    strcpy(BCX_RegPath,RegString"
    FPRINT FP_WRITE,"    (HKEY_CURRENT_USER,", "(char*)",ENC$("Software\\\\Bcx-32\\\\Bcx\\\\Settings"), ",","(char*)", ENC$("Path"), "));"
    FPRINT FP_WRITE,"  if(BCX_RegPath[0]==0)"
    FPRINT FP_WRITE,"    return strcpy(BCX_RegPath,", ENC$("Not Found"), ");"
    FPRINT FP_WRITE,"    return BCX_RegPath;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_LccPath THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: LccPath"
    FPRINT FP_WRITE,"char *LccPath (void)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *BCX_RetStr={0};"
    FPRINT FP_WRITE,"  static char LCC_Reg";cSizeOfADefaultString$;";"
    FPRINT FP_WRITE,"  static char LCC_RegPath";cSizeOfADefaultString$;";"
    FPRINT FP_WRITE,"  strcpy(LCC_Reg,",ENC$("Software\\\\lcc\\\\lcclnk\\\\"), ");"
    FPRINT FP_WRITE,"  strcpy(LCC_RegPath,(char*)RegString(HKEY_LOCAL_MACHINE,LCC_Reg,","(char*)", ENC$("libpath"), "));"
    FPRINT FP_WRITE,"  if(LCC_RegPath[0]==0)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      strcpy(LCC_RegPath,(char*)RegString(HKEY_CURRENT_USER,LCC_Reg,","(char*)", ENC$("libpath"), "));"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if(strcmp(LCC_RegPath,", DDQ$, ")!=0)"
    FPRINT FP_WRITE,"     {"
    FPRINT FP_WRITE,"        BCX_RetStr=BCX_TmpStr(256,1,1);"
    FPRINT FP_WRITE,"        return strcpy(BCX_RetStr,(char*)left(LCC_RegPath,InstrRev(LCC_RegPath,","(char*)", ENC$("\\\\"), ",0,0)));"
    FPRINT FP_WRITE,"     }"
    FPRINT FP_WRITE,"  else"
    FPRINT FP_WRITE,"     {"
    FPRINT FP_WRITE,"        BCX_RetStr=BCX_TmpStr(strlen(LCC_RegPath),1,1);"
    FPRINT FP_WRITE,"        return strcpy(BCX_RetStr,LCC_RegPath);"
    FPRINT FP_WRITE,"     }"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_PellesPath THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: PellesPath"
    FPRINT FP_WRITE,"char *PellesPath (void)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *BCX_RetStr={0};"
    FPRINT FP_WRITE,"  static char Pelles_Reg";cSizeOfADefaultString$;";"
    FPRINT FP_WRITE,"  static char Pelles_RegPath";cSizeOfADefaultString$;";"
    FPRINT FP_WRITE,"  strcpy(Pelles_Reg,", ENC$("Software\\\\Pelle Orinius\\\\PellesC\\\\Directories\\\\"), ");"
    FPRINT FP_WRITE,"  strcpy(Pelles_RegPath,(char*)RegString(HKEY_LOCAL_MACHINE,Pelles_Reg,","(char*)", ENC$("PathDirs"), "));"
    FPRINT FP_WRITE,"  if(Pelles_RegPath[0]==0)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      strcpy(Pelles_RegPath,(char*)RegString(HKEY_CURRENT_USER,Pelles_Reg,","(char*)", ENC$("PathDirs"), "));"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if(strcmp(Pelles_RegPath,", DDQ$, ")!=0)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      BCX_RetStr=BCX_TmpStr(256,1,1);"
    FPRINT FP_WRITE,"      return strcpy(BCX_RetStr,(char*)left(Pelles_RegPath,InstrRev(Pelles_RegPath,","(char*)", ENC$("\\\\"), ",0,0)));"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE," else"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      BCX_RetStr=BCX_TmpStr(strlen(Pelles_RegPath),1,1);"
    FPRINT FP_WRITE,"      return strcpy(BCX_RetStr,Pelles_RegPath);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_RegExist THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: RegExist"
    'FPRINT FP_WRITE,"long RegExist (HKEY HK,PCHAR Key,PCHAR SubKey)"
    FPRINT FP_WRITE,"long RegExist (HKEY HK,CCPTR Key,CCPTR SubKey)" 'CCPTR -> const char*
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HKEY     hKey;"
    FPRINT FP_WRITE,"  long     Result;"
    FPRINT FP_WRITE,"  Result= RegOpenKeyEx( HK, Key, 0, KEY_QUERY_VALUE,  &hKey);"
    FPRINT FP_WRITE,"  if(Result==ERROR_SUCCESS)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      static char    SubKeyResult";cSizeOfADefaultString$;";"
    FPRINT FP_WRITE,"      memset(&SubKeyResult,0,sizeof(SubKeyResult));"
    FPRINT FP_WRITE,"      int     BufferLen=sizeof(SubKeyResult);"
    FPRINT FP_WRITE,"      Result = -RegQueryValueEx( hKey, SubKey, 0, 0,( LPBYTE) SubKeyResult,( LPDWORD)& BufferLen);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  RegCloseKey(hKey);"
    FPRINT FP_WRITE,"  return Result;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_RegString THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: RegString"
    FPRINT FP_WRITE,"char *RegString (HKEY hKey, CCPTR RegPath, CCPTR SubKey)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *Result=BCX_TmpStr(";cDefaultStringSize;",1,1);"
    FPRINT FP_WRITE,"  int BufferLen=";cDefaultStringSize;";"
    FPRINT FP_WRITE,"  if(!RegOpenKeyEx(hKey,RegPath,0,KEY_QUERY_VALUE,&hKey))"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"   RegQueryValueEx(hKey,SubKey,0,0,(LPBYTE)Result,(LPDWORD)&BufferLen);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  RegCloseKey(hKey);"
    FPRINT FP_WRITE,"  return Result;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_CreateRegString THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: CreateRegString"
    FPRINT FP_WRITE,"void CreateRegString (HKEY HK, const char *Key, const char *VarName, const char *Value)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HKEY  hKey;"
    FPRINT FP_WRITE,"  char  Buff[100]={0};"
    FPRINT FP_WRITE,"  DWORD  Result;"
    FPRINT FP_WRITE,"  RegCreateKeyEx(HK,Key,0,Buff,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,0,&hKey,&Result);"
    FPRINT FP_WRITE,"  RegSetValueEx(hKey,VarName,0,REG_SZ,(LPBYTE)Value,(DWORD)lstrlen(Value)+1);"
    FPRINT FP_WRITE,"  RegCloseKey(hKey);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF
'jcfuller added
  IF Use_StrUpLow THEN
	IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: StrUpLow"
    FPRINT FP_WRITE,"char *_strupr_(char *string)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"   char *s;"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"   if (string)"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"      for(s = string; *s; ++s)"
    FPRINT FP_WRITE,"         *s = toupper(*s);"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"   return string;"
    FPRINT FP_WRITE,"}\n"
    FPRINT FP_WRITE,"char *_strlwr_(char *string)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"    char *s;"
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"    if (string)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"       for (s = string; *s; ++s)"
    FPRINT FP_WRITE,"           *s = tolower(*s);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"    return string;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF




  IF Use_Strtoken THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: StrToken"
    FPRINT FP_WRITE,"char * StrToken (const char *Source, const char *TokenChar, int n)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *BCX_RetStr={0};"
    FPRINT FP_WRITE,"  char *RetVal;"
    FPRINT FP_WRITE,"  char *Copy;"
    FPRINT FP_WRITE,"  int   Posn=0;"
    FPRINT FP_WRITE,"  int   Find=0;"
    FPRINT FP_WRITE,"  int   LenSrc=strlen(Source);"
    FPRINT FP_WRITE,"  RetVal=(char*)calloc(LenSrc+1,sizeof(char));"
    FPRINT FP_WRITE,"  Copy=(char*)Source;"
    FPRINT FP_WRITE,"  if(tally(Source,TokenChar,0)==0)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      BCX_RetStr=BCX_TmpStr(1,1,1);"
    FPRINT FP_WRITE,"      if(RetVal)free(RetVal);"
    FPRINT FP_WRITE,"      return BCX_RetStr;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if(n==1)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      BCX_RetStr=BCX_TmpStr(LenSrc,1,1);"
    FPRINT FP_WRITE,"      strcpy(BCX_RetStr,(char*)extract(Source,TokenChar));"
    FPRINT FP_WRITE,"      if(RetVal)free(RetVal);"
    FPRINT FP_WRITE,"      return BCX_RetStr;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if(n>tally(Source,TokenChar,0)+1)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      BCX_RetStr=BCX_TmpStr(1,1,1);"
    FPRINT FP_WRITE,"      if(RetVal)free(RetVal);"
    FPRINT FP_WRITE,"      return BCX_RetStr;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  while(*Copy)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      if(*Copy==TokenChar[0]) Find++;"
    FPRINT FP_WRITE,"      if(Find==n) break;"
    FPRINT FP_WRITE,"      Copy++;"
    FPRINT FP_WRITE,"      Posn++;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if(n==tally(Source,TokenChar,0)+1)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      Posn=LenSrc;"
    FPRINT FP_WRITE,"      Copy=(char*)Source+Posn;"
    FPRINT FP_WRITE,"      while(*Copy&&Source[Posn]!=TokenChar[0])"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"          Posn--;"
    FPRINT FP_WRITE,"          Copy--;"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  strcpy(RetVal,(char*)mid(Source,1,Posn));"
    'jcfuller changed
    'FPRINT FP_WRITE,"  strcpy(RetVal,(char*)mid(RetVal,InstrRev(RetVal,TokenChar)));"
    FPRINT FP_WRITE,"  strcpy(RetVal,(char*)mid(RetVal,InstrRev(RetVal,TokenChar,0,0),-1));"
    FPRINT FP_WRITE,"  BCX_RetStr=BCX_TmpStr(LenSrc,1,1);"
    FPRINT FP_WRITE,"  strcpy(BCX_RetStr,(char*)RemoveStr(RetVal,TokenChar));"
    FPRINT FP_WRITE,"  if(RetVal)free(RetVal);"
    FPRINT FP_WRITE,"  return BCX_RetStr;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_DeleteRegKey THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: DeleteRegKey"
    FPRINT FP_WRITE,"void DeleteRegKey (HKEY HK, CCPTR Key)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  RegDeleteKey(HK,(char*)Key);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_CreateRegInt THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: CreateRegInt"
    FPRINT FP_WRITE,"void CreateRegInt (HKEY HK, CCPTR Key, CCPTR VarName, int Value)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char  Buf[100]={0};"
    FPRINT FP_WRITE,"  DWORD Result;"
    FPRINT FP_WRITE,"  HKEY  hKey;"
    FPRINT FP_WRITE,"  RegCreateKeyEx(HK,(char*)Key,0,Buf,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,0,&hKey,&Result);"
    FPRINT FP_WRITE,"  RegSetValueEx(hKey,(char*)VarName,0,REG_DWORD,(BYTE*)&Value,sizeof(int));"
    FPRINT FP_WRITE,"  RegCloseKey(hKey);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_RegInt THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: RegInt"
    FPRINT FP_WRITE,"int RegInt(HKEY HK,CCPTR Key, CCPTR SubKey)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HKEY  hKey   =  0;"
    FPRINT FP_WRITE,"  DWORD Result =  0;"
    FPRINT FP_WRITE,"  DWORD Size   =  sizeof(DWORD);"
    FPRINT FP_WRITE,"  RegOpenKeyEx    (HK,(char*)Key,0,KEY_QUERY_VALUE,&HK);"
    FPRINT FP_WRITE,"  RegQueryValueEx (HK,(char*)SubKey,0,0,(LPBYTE)&Result,&Size);"
    FPRINT FP_WRITE,"  RegCloseKey     (hKey);"
    FPRINT FP_WRITE,"  return Result;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_iReplace THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: iReplace"
    If UseCpphdr And Not Use_TCLib Then
    	Prepend FPRINT FP_WRITE,
          "stdstr iReplace(stdstr & mane,stdstr match,stdstr change,int f)"
          "{"
          "  char* m;"
          "  char* mt;"
          "  char* c;"
          "  char* rv;"
          "  stdstr s;"
          "  m = (char*)mane.c_str();"
          "  mt = (char*)match.c_str();"
          "  c = (char*)change.c_str();"
          "  rv = iReplace(m,mt,c);"
          "  s = rv;"
          "  if(f) m = rv;"
          "  return rv;"
          "}"
    	End Prepend

    End If

    FPRINT FP_WRITE,"char *iReplace (const char *src, const char *pat, const char *rep)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  size_t patsz, repsz, tmpsz, delta;"
    FPRINT FP_WRITE,"  char *strtmp, *p, *q, *r;"
    FPRINT FP_WRITE,"  if (!pat || !*pat)"
    FPRINT FP_WRITE,"   {"
    FPRINT FP_WRITE,"     strtmp = BCX_TmpStr(strlen(src),1,1);"
    FPRINT FP_WRITE,"     if (!strtmp) return NULL;"
    FPRINT FP_WRITE,"     return strcpy(strtmp, src);"
    FPRINT FP_WRITE,"   }"
    FPRINT FP_WRITE,"  repsz = strlen(rep);"
    FPRINT FP_WRITE,"  patsz = strlen(pat);"
    FPRINT FP_WRITE,"  for (tmpsz=0, p=(char*)src;(q=_stristr_(p,(char*)pat))!=0; p=q+patsz)"
    FPRINT FP_WRITE,"    tmpsz += (size_t) (q - p) + repsz;"
    FPRINT FP_WRITE,"    tmpsz += strlen(p);"
    FPRINT FP_WRITE,"    strtmp = BCX_TmpStr(tmpsz,1,1);"
    FPRINT FP_WRITE,"    if (!strtmp) return NULL;"
    FPRINT FP_WRITE,"    for (r=strtmp,p=(char*)src;(q=_stristr_(p,(char*)pat))!=0;p=q+patsz)"
    FPRINT FP_WRITE,"     {"
    FPRINT FP_WRITE,"       delta = (size_t) (q-p);"
    FPRINT FP_WRITE,"       memcpy(r,p,delta); r += delta;"
    FPRINT FP_WRITE,"       strcpy(r,rep);      r += repsz;"
    FPRINT FP_WRITE,"     }"
    FPRINT FP_WRITE,"  strcpy(r,p);"
    FPRINT FP_WRITE,"  return strtmp;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Printer THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: PrinterOpen"
    FPRINT FP_WRITE,"int PrinterOpen (char * fontname,int PointSize,int charset)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char zPrinter";cSizeOfADefaultString$;";"
    FPRINT FP_WRITE,"  GetProfileString(", ENC$("WINDOWS"), ",", ENC$("DEVICE"), ",", DDQ$, ",zPrinter,127);"
    FPRINT FP_WRITE,"  strcpy(zPrinter,(char*)extract(zPrinter,", ENC$(","), "));"
    FPRINT FP_WRITE,"  strcpy(BcxPtr_Text,", ENC$("Printing ..."), ");"
    FPRINT FP_WRITE,"  BcxPtr_hDC=CreateDC(", DDQ$, ",zPrinter,", DDQ$, ",0);"
    FPRINT FP_WRITE,"  if(!BcxPtr_hDC) return 0;"
    FPRINT FP_WRITE,"  BcxPtr_di.cbSize=sizeof(BcxPtr_di);"
    FPRINT FP_WRITE,"  BcxPtr_di.lpszDocName=BcxPtr_Text;"
    FPRINT FP_WRITE,"  StartDoc(BcxPtr_hDC,&BcxPtr_di);"
    FPRINT FP_WRITE,"  StartPage(BcxPtr_hDC);"
    FPRINT FP_WRITE,"  SetTextAlign(BcxPtr_hDC,TA_BASELINE | TA_NOUPDATECP | TA_LEFT);"
    FPRINT FP_WRITE,"  SetBkMode(BcxPtr_hDC,TRANSPARENT);"
    FPRINT FP_WRITE,"  BcxPtr_Lf.lfHeight=PointSize*GetDeviceCaps(BcxPtr_hDC,LOGPIXELSY)/72;"
    FPRINT FP_WRITE,"  BcxPtr_Lf.lfWidth=0;"
    FPRINT FP_WRITE,"  BcxPtr_Lf.lfEscapement=0;"
    FPRINT FP_WRITE,"  BcxPtr_Lf.lfOrientation=0;"
    FPRINT FP_WRITE,"  BcxPtr_Lf.lfWeight=FW_NORMAL;"
    FPRINT FP_WRITE,"  BcxPtr_Lf.lfItalic=0;"
    FPRINT FP_WRITE,"  BcxPtr_Lf.lfUnderline=0;"
    FPRINT FP_WRITE,"  BcxPtr_Lf.lfStrikeOut=0;"
    FPRINT FP_WRITE,"  BcxPtr_Lf.lfCharSet=charset;"
    FPRINT FP_WRITE,"  BcxPtr_Lf.lfOutPrecision=OUT_DEFAULT_PRECIS;"
    FPRINT FP_WRITE,"  BcxPtr_Lf.lfClipPrecision=CLIP_DEFAULT_PRECIS;"
    FPRINT FP_WRITE,"  BcxPtr_Lf.lfQuality=PROOF_QUALITY;"
    FPRINT FP_WRITE,"  BcxPtr_Lf.lfPitchAndFamily=VARIABLE_PITCH | FF_ROMAN;"
    FPRINT FP_WRITE,"  strcpy(BcxPtr_Lf.lfFaceName,fontname); "
    'FPRINT FP_WRITE,"  strcpy(BcxPtr_Lf.lfFaceName,TEXT(", ENC$("Courier New"), "));"
    FPRINT FP_WRITE,"  BcxPtr_hFont=CreateFontIndirect(&BcxPtr_Lf);"
    FPRINT FP_WRITE,"  BcxPtr_hFontOld=(HFONT)SelectObject(BcxPtr_hDC,BcxPtr_hFont);"
    FPRINT FP_WRITE,"  GetTextMetrics(BcxPtr_hDC,&BcxPtr_tm);"
    FPRINT FP_WRITE,"  BcxPtr_FontMetrix=BcxPtr_Lf.lfHeight;"
    FPRINT FP_WRITE,"  BcxPtr_PrinterOn=1;"
    FPRINT FP_WRITE,"  return   1;"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"void PrinterWrite (char *TextIn, int CPL, int LPP)"
    FPRINT FP_WRITE,"{"
    'FPRINT FP_WRITE,"  int LPP=60;"
    'FPRINT FP_WRITE,"  int CPL=80;"
    FPRINT FP_WRITE,"  char sTemp";cSizeOfADefaultString$;"={0};"
    FPRINT FP_WRITE,"  if(!BcxPtr_PrinterOn)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      MessageBox (GetActiveWindow(),", ENC$("Problem with Printer"), ",", DDQ$, ",0);"
    FPRINT FP_WRITE,"      return;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  strcpy(sTemp,TextIn);"
    FPRINT FP_WRITE,"  for(;;)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      if(strlen(sTemp)>CPL)"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"          strcpy(BcxPtr_Text,(char*)left(sTemp,CPL));"
    'jcfuller changed
'    FPRINT FP_WRITE,"          strcpy(sTemp,(char*)mid(sTemp,CPL+1));"
	FPRINT FP_WRITE,"          strcpy(sTemp,(char*)mid(sTemp,CPL+1,-1));"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"      else"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"          strcpy(BcxPtr_Text,sTemp);"
    FPRINT FP_WRITE,"          *sTemp=0;"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"      if(BcxPtr_LineCtr>LPP)"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"          EndPage(BcxPtr_hDC);"
    FPRINT FP_WRITE,"          BcxPtr_LineCtr=0;"
    FPRINT FP_WRITE,"          StartPage(BcxPtr_hDC);"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"      BcxPtr_LineCtr+=1;"
    FPRINT FP_WRITE,"      TextOut(BcxPtr_hDC,20,BcxPtr_FontMetrix*BcxPtr_LineCtr,BcxPtr_Text,strlen(BcxPtr_Text));"
    FPRINT FP_WRITE,"      if(sTemp[0]==0) break;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"void PrinterClose (void)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  if(!BcxPtr_PrinterOn) return;"
    FPRINT FP_WRITE,"  SelectObject(BcxPtr_hDC,BcxPtr_hFontOld);"
    FPRINT FP_WRITE,"  DeleteObject(BcxPtr_hFont);"
    FPRINT FP_WRITE,"  EndPage(BcxPtr_hDC);"
    FPRINT FP_WRITE,"  EndDoc(BcxPtr_hDC);"
    FPRINT FP_WRITE,"  DeleteDC(BcxPtr_hDC);"
    FPRINT FP_WRITE,"  BcxPtr_LineCtr=0;"
    FPRINT FP_WRITE,"  BcxPtr_PrinterOn=0;"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"void EjectPage(void)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  EndPage(BcxPtr_hDC);"
    FPRINT FP_WRITE,"  BcxPtr_LineCtr=0;"
    FPRINT FP_WRITE,"  StartPage(BcxPtr_hDC);"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_WideToAnsi THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: WideToAnsi"
    FPRINT FP_WRITE,"char* WideToAnsi (BSTR WideStr, UINT CodePage,DWORD dwFlags)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *BCX_RetStr={0};"
    FPRINT FP_WRITE,"  UINT uLen;"
    FPRINT FP_WRITE,"  uLen=WideCharToMultiByte(CodePage,dwFlags,WideStr,-1,0,0,0,0);"
    FPRINT FP_WRITE,"  BCX_RetStr=(char*)BCX_TmpStr(uLen,1,1);"
    FPRINT FP_WRITE,"  WideCharToMultiByte(CodePage,dwFlags,WideStr,-1,BCX_RetStr,uLen,0,0);"
    FPRINT FP_WRITE,"  return BCX_RetStr;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_SysStr THEN
    If Use_UNICODE_Switch AND UseCpp Then
		FPRINT FP_WRITE,"BSTR SysStr (const _TCHAR * szIn, int b_free)"
		FPRINT FP_WRITE,"{"
		FPRINT FP_WRITE,"    static  BSTR  bStr[32];"
		FPRINT FP_WRITE,"    static  int   index;"
		FPRINT FP_WRITE,"    if(b_free)"
		FPRINT FP_WRITE,"    {"
		FPRINT FP_WRITE,"        for(index = 0; index < 32; index += 1)"
		FPRINT FP_WRITE,"            SysFreeString(bStr[index]);"
		FPRINT FP_WRITE,"        return 0;"
		FPRINT FP_WRITE,"    }"
		FPRINT FP_WRITE,"    index = (++index & 31);"
		FPRINT FP_WRITE,"    SysFreeString(bStr[index]);"
		FPRINT FP_WRITE,"    bStr[index] = SysAllocString(szIn);"
		FPRINT FP_WRITE,"    return bStr[index];"
		FPRINT FP_WRITE,"}"
    Else
		IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: SysStr"
		FPRINT FP_WRITE,"//<---UNICODE AWARE"
		FPRINT FP_WRITE,"BSTR SysStr (const char * szIn, int widstr, int b_free)"
		FPRINT FP_WRITE,"{"
		FPRINT FP_WRITE,"  static  BSTR  bStr[32];"
		FPRINT FP_WRITE,"  static  int   index;"
		FPRINT FP_WRITE,"  if(b_free)"
		FPRINT FP_WRITE,"    {"
		FPRINT FP_WRITE,"      for(index=0; index<32; index+=1) "
		FPRINT FP_WRITE,"        SysFreeString(bStr[index]);"
		FPRINT FP_WRITE,"      return 0;"
		FPRINT FP_WRITE,"    }"
		FPRINT FP_WRITE,"  index=(++index & 31);"
		FPRINT FP_WRITE,"  SysFreeString(bStr[index]);"
		FPRINT FP_WRITE,"  int   length=strlen(szIn);"
		FPRINT FP_WRITE,"  if(widstr)"
		FPRINT FP_WRITE,"   {"
		FPRINT FP_WRITE,"     bStr[index]=SysAllocStringLen(NULL, (2*length));"
		FPRINT FP_WRITE,"     MultiByteToWideChar(CP_ACP,0,szIn,-1,bStr[index],(2*length+1));"
		FPRINT FP_WRITE,"   }else{"
		FPRINT FP_WRITE,"     bStr[index]=SysAllocStringByteLen(szIn, length);"
		FPRINT FP_WRITE,"   }"
		FPRINT FP_WRITE,"  return bStr[index];"
		FPRINT FP_WRITE,sENDBCXRTLIB$
		FPRINT FP_WRITE,"//>---UNICODE AWARE"
	End If	
  END IF


  IF Use_AnsiToWide THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: AnsiToWide"
      IF Use_UNICODE_Switch Then
        FPRINT FP_WRITE, "//<---UNICODE AWARE"
      END IF
    
    FPRINT FP_WRITE,"LPOLESTR AnsiToWide (const char *AnsiStr, UINT CodePage,DWORD dwFlags)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  UINT uLen;"
    FPRINT FP_WRITE,"  BSTR WideStr;"
    FPRINT FP_WRITE,"  uLen=MultiByteToWideChar(CodePage,dwFlags,AnsiStr,-1,0,0);"
    FPRINT FP_WRITE,"  if(uLen<=1) return (BSTR) BCX_TmpStr(2,1,1);"
    FPRINT FP_WRITE,"  WideStr=(BSTR) BCX_TmpStr(2*uLen,1,1);"
    FPRINT FP_WRITE,"  MultiByteToWideChar(CodePage,dwFlags,AnsiStr,uLen,WideStr,uLen);"
    FPRINT FP_WRITE,"  return WideStr;"
      IF Use_UNICODE_Switch Then
        FPRINT FP_WRITE, "//>---UNICODE AWARE"
      END IF
    
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_SafeArrays THEN Emit_For_BCX_SAFEARRAY(FP_WRITE)

  IF Use_COM THEN
    'IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_COM_Support"
    CALL Emit_For_BCX_COM_StandardSet(FP_WRITE)
    IF build_com_trace_code OR Use_Library  THEN CALL Emit_For_BCX_COM_TraceCalls(FP_WRITE)
    IF Use_BCX_COM_CreateObject             THEN CALL Emit_For_BCX_COM_CreateObject(FP_WRITE)
    IF Use_BCX_COM_GetObject                THEN CALL Emit_For_BCX_COM_GetObject(FP_WRITE)
    IF Use_BCX_COM_DispatchObject           THEN CALL Emit_For_BCX_COM_DispatchObject(FP_WRITE)
    IF Use_BCX_COM_SafeArray                THEN CALL Emit_For_BCX_COM_SafeArray(FP_WRITE)
    IF Use_BCX_COM_UsesConversion           THEN CALL Emit_For_BCX_COM_UsesConversion(FP_WRITE)

    ' not currently used, reserved for future use.
    IF Use_BCX_COM_GetProperty              THEN CALL Emit_For_BCX_COM_GetProperty(FP_WRITE)
    IF Use_BCX_COM_SetProperty              THEN CALL Emit_For_BCX_COM_SetProperty(FP_WRITE)
    IF Use_BCX_COM_InvokeMethod             THEN CALL Emit_For_BCX_COM_InvokeMethod(FP_WRITE)
    'IF Use_Library THEN CALL FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_VBS THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: VBS_START"
    FPRINT FP_WRITE,"BOOL VBS_START (void)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  HRESULT  hResult;"
    FPRINT FP_WRITE,"  GUID  clsid;"
    FPRINT FP_WRITE,"  BSTR  Language;"
    FPRINT FP_WRITE,"  OLE_ERROR_S=FALSE;"
    FPRINT FP_WRITE,"  if(S_OK!=OleInitialize(0))"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      MessageBox(NULL,", ENC$("Couldn't initialize OLE!"), ",NULL,MB_OK);"
    FPRINT FP_WRITE,"      PostQuitMessage(0);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  #ifdef __BCX_MULTITHREADED__"
    FPRINT FP_WRITE,"  CoInitializeEx(NULL,COINIT_MULTITHREADED);"
    FPRINT FP_WRITE,"  #else"
    FPRINT FP_WRITE,"  CoInitializeEx(NULL,COINIT_APARTMENTTHREADED);"
    FPRINT FP_WRITE,"  #endif"
    FPRINT FP_WRITE,"  hResult=CLSIDFromProgID(OLESTR(", ENC$("MSScriptControl.ScriptControl"), "),&clsid);"
    FPRINT FP_WRITE,"  if(hResult!=S_OK)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      for(;;)"
    FPRINT FP_WRITE,"      {"
    FPRINT FP_WRITE,"      if(hResult==REGDB_E_CLASSNOTREG)"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"          OleUninitialize();"
    FPRINT FP_WRITE,"          MessageBox (GetActiveWindow(),", ENC$("MSScriptControl::Class not registered"), ",", ENC$("Error"), ",MB_SETFOREGROUND);"
    FPRINT FP_WRITE,"          PostQuitMessage(0);"
    FPRINT FP_WRITE,"          break;"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"      if(hResult==CLASS_E_NOAGGREGATION)"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"          OleUninitialize();"
    FPRINT FP_WRITE,"          MessageBox (GetActiveWindow(),", ENC$("MSScriptControl::Class not created"), ",", ENC$("Error"), ",MB_SETFOREGROUND);"
    FPRINT FP_WRITE,"          PostQuitMessage(0);"
    FPRINT FP_WRITE,"          break;"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"      if(hResult==CLASS_E_CLASSNOTAVAILABLE)"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"          OleUninitialize();"
    FPRINT FP_WRITE,"          MessageBox (GetActiveWindow(),", ENC$("MSScriptControl::Class not available"), ",", ENC$("Error"), ",MB_SETFOREGROUND);"
    FPRINT FP_WRITE,"          PostQuitMessage(0);"
    FPRINT FP_WRITE,"          break;"
    FPRINT FP_WRITE,"          }"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"        VBS_STOP();"
    FPRINT FP_WRITE,"        MessageBox (GetActiveWindow(),", ENC$("MSScriptControl::Unknown error"), ",", ENC$("Error"), ",MB_SETFOREGROUND);"
    FPRINT FP_WRITE,"        PostQuitMessage(0);"
    FPRINT FP_WRITE,"      }"
    FPRINT FP_WRITE,"    break;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"}"
    FPRINT FP_WRITE,"#ifndef __cplusplus"
    FPRINT FP_WRITE,"hResult=CoCreateInstance(&clsid,0,CLSCTX_SERVER,&IID_IScriptControl,(void**)&pSC);"
    FPRINT FP_WRITE,"#else"
    FPRINT FP_WRITE,"hResult=CoCreateInstance(clsid,0,CLSCTX_SERVER,IID_IScriptControl,(void**)&pSC);"
    FPRINT FP_WRITE,"#endif"
    FPRINT FP_WRITE,"Language=SysAllocString(OLESTR(", ENC$("VBScript"), "));"
    FPRINT FP_WRITE,"#ifndef __cplusplus"
    FPRINT FP_WRITE,"hResult=pSC->lpVtbl->put_Language(pSC,Language);"
    FPRINT FP_WRITE,"#else"
    FPRINT FP_WRITE,"hResult=pSC->put_Language(Language);"
    FPRINT FP_WRITE,"#endif"
    FPRINT FP_WRITE,"SysFreeString(Language);;"
    FPRINT FP_WRITE,"if(hResult!=S_OK)"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"    VBS_STOP();"
    FPRINT FP_WRITE,"    MessageBox (GetActiveWindow(),", ENC$("Could not start ScriptControl"), ",", ENC$("Error"), ",MB_SETFOREGROUND);"
    FPRINT FP_WRITE,"    PostQuitMessage(0);"
    FPRINT FP_WRITE,"  }"
    FPRINT FP_WRITE,"return TRUE;"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"void VBS_STOP (void)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"#ifndef __cplusplus"
    FPRINT FP_WRITE,"  pSC->lpVtbl->Release(pSC);"
    FPRINT FP_WRITE,"#else"
    FPRINT FP_WRITE,"  pSC->Release();"
    FPRINT FP_WRITE,"#endif"
    FPRINT FP_WRITE,"  pSC=0;;"
    FPRINT FP_WRITE,"  OleUninitialize();"
    ' next line commented out - OleUninitialize calls CoUninitialize
    'FPRINT FP_WRITE,"  CoUninitialize();"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"void VBS_RESET (void)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"#ifndef __cplusplus"
    FPRINT FP_WRITE,"  pSC->lpVtbl->Reset(pSC);"
    FPRINT FP_WRITE,"#else"
    FPRINT FP_WRITE,"  pSC->Reset();"
    FPRINT FP_WRITE,"#endif"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"HRESULT VBS_RUN_SCRIPT (char *VB_SCRIPT)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  BSTR  MyCode;"
    FPRINT FP_WRITE,"  HRESULT  hResult;"
    FPRINT FP_WRITE,"  MyCode=SysAllocString(AnsiToWide(VB_SCRIPT,CP_ACP,MB_PRECOMPOSED));"
    FPRINT FP_WRITE,"#ifndef __cplusplus"
    FPRINT FP_WRITE,"  hResult=pSC->lpVtbl->ExecuteStatement(pSC,MyCode);"
    FPRINT FP_WRITE,"#else"
    FPRINT FP_WRITE,"  hResult=pSC->ExecuteStatement(MyCode);"
    FPRINT FP_WRITE,"#endif"
    FPRINT FP_WRITE,"  SysFreeString(MyCode);"
    FPRINT FP_WRITE,"  return SUCCEEDED(hResult);"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"HRESULT VBS_ADDCODE (char *Code)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  int CodeLen;"
    FPRINT FP_WRITE,"  wchar_t* Buf;"
    FPRINT FP_WRITE,"  BSTR Bbuf;"
    FPRINT FP_WRITE,"  HRESULT hResult;"
    FPRINT FP_WRITE,"  CodeLen=strlen(Code);"
    FPRINT FP_WRITE,"  Buf=(wchar_t*)calloc(2*(CodeLen+1),sizeof(wchar_t));"
    FPRINT FP_WRITE,"  mbstowcs(Buf,Code,CodeLen);"
    FPRINT FP_WRITE,"  Bbuf=SysAllocString(Buf);"
    FPRINT FP_WRITE,"  free((Buf));"
    FPRINT FP_WRITE,"#ifndef __cplusplus"
    FPRINT FP_WRITE,"  hResult=pSC->lpVtbl->AddCode(pSC,Bbuf);"
    FPRINT FP_WRITE,"#else"
    FPRINT FP_WRITE,"  hResult=pSC->AddCode(Bbuf);"
    FPRINT FP_WRITE,"#endif"
    FPRINT FP_WRITE,"  SysFreeString(Bbuf);"
    FPRINT FP_WRITE,"  return SUCCEEDED(hResult);"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"double VBS_EVAL_NUM (char* VB_SCRIPT)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  BSTR  MyCode;"
    FPRINT FP_WRITE,"  HRESULT HResult;"
    FPRINT FP_WRITE,"  VARIANT vResult;"
    FPRINT FP_WRITE,"  MyCode=SysAllocString(AnsiToWide(VB_SCRIPT,CP_ACP,MB_PRECOMPOSED));"
    FPRINT FP_WRITE,"#ifndef __cplusplus"
    FPRINT FP_WRITE,"  HResult=pSC->lpVtbl->Eval(pSC,MyCode,&vResult);"
    FPRINT FP_WRITE,"#else"
    FPRINT FP_WRITE,"  HResult=pSC->Eval(MyCode,&vResult);"
    FPRINT FP_WRITE,"#endif"
    FPRINT FP_WRITE,"  SysFreeString(MyCode);"
    FPRINT FP_WRITE,"  if(SUCCEEDED(HResult))"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      HResult=VariantChangeType(&vResult,&vResult,0,VT_R8);"
    FPRINT FP_WRITE,"      return vResult.dblVal;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  return 0;"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"char* VBS_ERROR(void)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *BCX_RetStr={0};"
    FPRINT FP_WRITE,"  IScriptError* pScriptError;"
    FPRINT FP_WRITE,"  HRESULT HResult;"
    FPRINT FP_WRITE,"  long  ErrNumber;"
    FPRINT FP_WRITE,"  BSTR  ErrDescription = NULL;"
    FPRINT FP_WRITE,"  BSTR  ErrText = NULL;"
    FPRINT FP_WRITE,"  long  ErrLine;"
    FPRINT FP_WRITE,"  long  ErrColumn;"
    FPRINT FP_WRITE,"  UINT  Errdesclen;"
    FPRINT FP_WRITE,"#ifndef __cplusplus"
    FPRINT FP_WRITE,"  HResult = pSC->lpVtbl->get_Error(pSC, &pScriptError);"
    FPRINT FP_WRITE,"#else"
    FPRINT FP_WRITE,"  HResult = pSC->get_Error( &pScriptError);"
    FPRINT FP_WRITE,"#endif"
    FPRINT FP_WRITE,"  if FAILED(HResult)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      *BCX_RetStr=0;"
    FPRINT FP_WRITE,"      return BCX_RetStr;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if (pScriptError)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"#ifndef __cplusplus"
    FPRINT FP_WRITE,"      pScriptError->lpVtbl->Get_Number(pScriptError,&ErrNumber);"
    FPRINT FP_WRITE,"      pScriptError->lpVtbl->Get_Description(pScriptError, &ErrDescription);"
    FPRINT FP_WRITE,"      pScriptError->lpVtbl->Get_Text(pScriptError, &ErrText);"
    FPRINT FP_WRITE,"      pScriptError->lpVtbl->Get_Line(pScriptError, &ErrLine);"
    FPRINT FP_WRITE,"      pScriptError->lpVtbl->Get_Column(pScriptError, &ErrColumn);"
    FPRINT FP_WRITE,"#else"
    FPRINT FP_WRITE,"      pScriptError->Get_Number(&ErrNumber);"
    FPRINT FP_WRITE,"      pScriptError->Get_Description(&ErrDescription);"
    FPRINT FP_WRITE,"      pScriptError->Get_Text(&ErrText);"
    FPRINT FP_WRITE,"      pScriptError->Get_Line(&ErrLine);"
    FPRINT FP_WRITE,"      pScriptError->Get_Column(&ErrColumn);"
    FPRINT FP_WRITE,"#endif"
    FPRINT FP_WRITE,"      if (NULL == ErrDescription)"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"          ErrDescription = SysAllocString(OLESTR(", ENC$("No description available."), "));"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"      if (NULL == ErrText)"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"          ErrText = SysAllocString(OLESTR(", ENC$("No extra error info available."), "));"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"      Errdesclen =  SysStringLen(ErrDescription) + SysStringLen(ErrText) + 512;"
    FPRINT FP_WRITE,"      BCX_RetStr=BCX_TmpStr(Errdesclen,1,1);"
    FPRINT FP_WRITE,"      sprintf(BCX_RetStr," , ENC$("VBScript error 0x%lX\\nline:%d, column:%d\\nDescription: %s\\nError text: %s") , ", ErrNumber, ErrLine, ErrColumn,WideToAnsi(ErrDescription,CP_ACP,0),WideToAnsi(ErrText,CP_ACP,0));"
    FPRINT FP_WRITE,"      SysFreeString(ErrDescription);"
    FPRINT FP_WRITE,"      SysFreeString(ErrText);"
    FPRINT FP_WRITE,"#ifndef __cplusplus"
    FPRINT FP_WRITE,"      pScriptError->lpVtbl->Release(pScriptError);"
    FPRINT FP_WRITE,"#else"
    FPRINT FP_WRITE,"      pScriptError->Release();"
    FPRINT FP_WRITE,"#endif"
    FPRINT FP_WRITE,"      return BCX_RetStr;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  *BCX_RetStr=0;"
    FPRINT FP_WRITE,"  return BCX_RetStr;"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"char* VBS_EVAL_STR(char* VB_SCRIPT)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  char *BCX_RetStr={0};"
    FPRINT FP_WRITE,"  BSTR  MyCode;"
    FPRINT FP_WRITE,"  HRESULT HResult;"
    FPRINT FP_WRITE,"  VARIANT vResult;"
    FPRINT FP_WRITE,"  MyCode=SysAllocString(AnsiToWide(VB_SCRIPT,CP_ACP,MB_PRECOMPOSED));"
    FPRINT FP_WRITE,"#ifndef __cplusplus"
    FPRINT FP_WRITE,"  HResult=pSC->lpVtbl->Eval(pSC,MyCode,&vResult);"
    FPRINT FP_WRITE,"#else"
    FPRINT FP_WRITE,"  HResult=pSC->Eval(MyCode,&vResult);"
    FPRINT FP_WRITE,"#endif"
    FPRINT FP_WRITE,"  SysFreeString(MyCode);"
    FPRINT FP_WRITE,"  if(SUCCEEDED(HResult))"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      HResult=VariantChangeType(&vResult,&vResult,0,VT_BSTR);"
    FPRINT FP_WRITE,"      BCX_RetStr=BCX_TmpStr(strlen(WideToAnsi(vResult.bstrVal,CP_ACP,0)),1,1);"
    FPRINT FP_WRITE,"      strcpy(BCX_RetStr,(char*)WideToAnsi(vResult.bstrVal,CP_ACP,0));"
    FPRINT FP_WRITE,"      return BCX_RetStr;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  *BCX_RetStr=0;"
    FPRINT FP_WRITE,"  return BCX_RetStr;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_FileLocked THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: FileLocked"
    FPRINT FP_WRITE,"int FileLocked (CCPTR Filename)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  FILE *FP=fopen((char*)Filename,", ENC$("rb+"), ");"
    FPRINT FP_WRITE,"  if(FP==0) return 1;"
    FPRINT FP_WRITE,"  fclose(FP);"
    FPRINT FP_WRITE,"  return 0;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF


  IF Use_Sound THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: Sound"
    FPRINT FP_WRITE,"int Sound (float Freq,int Dura,int Vol,int Voice,float Tempo)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  DWORD  dwThreadId;"
    FPRINT FP_WRITE,"  if(Freq==0&&Dura<1) return gTenter-gTexit;"
    FPRINT FP_WRITE,"  if(Freq==0) Vol=0;"
    FPRINT FP_WRITE,"  if(Dura<5)  Dura=5;"
    FPRINT FP_WRITE,"  gTenter++;"
    FPRINT FP_WRITE,"  gTsig=FALSE;"
    FPRINT FP_WRITE,"  if(gTenter>=SNDQUE) gTarray=gTenter % SNDQUE+1;"
    FPRINT FP_WRITE,"  else                gTarray=gTenter;"
    FPRINT FP_WRITE,"  SndPmtr[gTarray].Freq=Freq;"
    FPRINT FP_WRITE,"  SndPmtr[gTarray].Dura=Dura;"
    FPRINT FP_WRITE,"  SndPmtr[gTarray].Tempo=Tempo;"
    FPRINT FP_WRITE,"  SndPmtr[gTarray].Vol=Vol;"
    FPRINT FP_WRITE,"  SndPmtr[gTarray].Voice=Voice;"
    FPRINT FP_WRITE,"  SndPmtr[gTarray].sndTid=gTenter;"
    FPRINT FP_WRITE,"  if(gSThread==NULL&&(Freq==fabsf(Freq)||Freq==0))"
    FPRINT FP_WRITE,"    {"
    ' added (LPSTR) to satisfy GCC, picky, picky, picky :~(
    FPRINT FP_WRITE,"      gSThread=CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)PlaySnd,(LPSTR)";ENC$("PlaySnd");",0,&dwThreadId);"
    FPRINT FP_WRITE,"      Sleep(1);"
    FPRINT FP_WRITE,"      return 0;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  if(Freq!=fabsf(Freq))"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      if(Freq==-1)"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"          Freq=0;"
    FPRINT FP_WRITE,"          SndPmtr[gTarray].Vol=0;"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"      SndPmtr[gTarray].Freq=fabsf(Freq);"
    FPRINT FP_WRITE,"      gTsig=TRUE;"
    FPRINT FP_WRITE,"      while(gSThread!=NULL)"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"         Sleep(10);"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"      gTexit=gTenter-1;"
    FPRINT FP_WRITE,"      gTwait=gTenter-1;"
    FPRINT FP_WRITE,"      gTsig=FALSE;"
    FPRINT FP_WRITE,"      return PlaySnd();"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  return 0;"
    FPRINT FP_WRITE,"}\n\n"
    FPRINT FP_WRITE,"int PlaySnd (void)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"  soundtype  LocSndPar;"
    FPRINT FP_WRITE,"  UINT  lTarray;"
    FPRINT FP_WRITE,"  while(gTenter>gTexit&&gTsig==FALSE)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      gTwait++;"
    FPRINT FP_WRITE,"      if(gTwait>=SNDQUE)"
    FPRINT FP_WRITE,"          lTarray=gTwait % SNDQUE+1;"
    FPRINT FP_WRITE,"      else"
    FPRINT FP_WRITE,"          lTarray=gTwait;"
    FPRINT FP_WRITE,"      LocSndPar=SndPmtr[lTarray];"
    FPRINT FP_WRITE,"      int       Note=0;"
    FPRINT FP_WRITE,"      int       Phrase=0;"
    FPRINT FP_WRITE,"      HMIDIOUT hMidi;"
    FPRINT FP_WRITE,"      midiOutOpen(&hMidi,(UINT)-1,0,0,CALLBACK_NULL);"
    FPRINT FP_WRITE,"      midiOutShortMsg(hMidi,(256*LocSndPar.Voice)+192);"
    FPRINT FP_WRITE,"      Note=Round((log((double) LocSndPar.Freq)- log((double)440.0))/ log((double)2)*12+69,0);"
    FPRINT FP_WRITE,"      Phrase=(LocSndPar.Vol*256+Note)*256+144;"
    FPRINT FP_WRITE,"      midiOutShortMsg(hMidi,Phrase);"
    FPRINT FP_WRITE,"      Sleep(LocSndPar.Dura*(1/LocSndPar.Tempo+0.0001));"
    FPRINT FP_WRITE,"      Phrase=(LocSndPar.Vol*256+Note)*256+128;"
    FPRINT FP_WRITE,"      midiOutShortMsg(hMidi,Phrase);"
    FPRINT FP_WRITE,"      midiOutClose(hMidi);"
    FPRINT FP_WRITE,"      gTexit++;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  CloseHandle(gSThread);"
    FPRINT FP_WRITE,"  gSThread=NULL;"
    FPRINT FP_WRITE,"  return 0;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  'IF Use_OSVersion THEN
    'IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: OSVersion"
    'FPRINT FP_WRITE,"int OSVersion (void) {"
    'FPRINT FP_WRITE,"    OSVERSIONINFO  osvi={0};"
    'FPRINT FP_WRITE,"    osvi.dwOSVersionInfoSize=sizeof(osvi);"
    'FPRINT FP_WRITE,"    if(GetVersionEx(&osvi)==ERROR_OLD_WIN_VERSION) return -1;"
    'FPRINT FP_WRITE,"    switch (osvi.dwPlatformId)"
    'FPRINT FP_WRITE,"    {"
    'FPRINT FP_WRITE,"    case VER_PLATFORM_WIN32_NT:"
    'FPRINT FP_WRITE,"        if(osvi.dwMajorVersion==3 && osvi.dwMinorVersion==51)   return 4;"
    'FPRINT FP_WRITE,"        if(osvi.dwMajorVersion==4 && osvi.dwMinorVersion==0)    return 5;"
    'FPRINT FP_WRITE,"        if(osvi.dwMajorVersion==5 && osvi.dwMinorVersion==0)    return 6;"
    'FPRINT FP_WRITE,"        if(osvi.dwMajorVersion==5 && osvi.dwMinorVersion==1)    return 7;"
    'FPRINT FP_WRITE,"        if(osvi.dwMajorVersion>=5 && osvi.dwMinorVersion>=2)    return 8;"
    'FPRINT FP_WRITE,"        if(osvi.dwMajorVersion==6 && osvi.dwMinorVersion==0)    return 9;"
    'FPRINT FP_WRITE,"        if(osvi.dwMajorVersion==6 && osvi.dwMinorVersion==1)    return 10;"
    'FPRINT FP_WRITE,"    case VER_PLATFORM_WIN32_WINDOWS:"
    'FPRINT FP_WRITE,"        if((osvi.dwMajorVersion==4 && osvi.dwMinorVersion==0))  return 1;"
    'FPRINT FP_WRITE,"        if((osvi.dwMajorVersion==4 && osvi.dwMinorVersion==10)) return 2;"
    'FPRINT FP_WRITE,"        if((osvi.dwMajorVersion==4 && osvi.dwMinorVersion==90)) return 3;"
    'FPRINT FP_WRITE,"    case VER_PLATFORM_WIN32s:"
    'FPRINT FP_WRITE,"         return 0;"
    'FPRINT FP_WRITE,"    }"
    'FPRINT FP_WRITE,"  return -1;"
    'FPRINT FP_WRITE,sENDBCXRTLIB$
  'END IF

'jcfuller changed 9/14/2013 from bcx 7.0.8
  IF Use_OSVersion THEN
    IF Use_Library THEN FPRINT FP_WRITE, "// BCXRTLIB: OSVersion"
    FPRINT FP_WRITE, "int OSVersion (void) {"
    FPRINT FP_WRITE, "  OSVERSIONINFOEX  osvi={0};"
    FPRINT FP_WRITE, "  osvi.dwOSVersionInfoSize=sizeof(osvi);"
    FPRINT FP_WRITE, "  if(GetVersionEx((LPOSVERSIONINFO)&osvi)==ERROR_OLD_WIN_VERSION) return OSError;"
    FPRINT FP_WRITE, ""
    FPRINT FP_WRITE, "  switch (osvi.dwPlatformId)"
    FPRINT FP_WRITE, "    {"
    FPRINT FP_WRITE, "    case VER_PLATFORM_WIN32_NT:"
    FPRINT FP_WRITE, "      if(osvi.dwMajorVersion==6 && osvi.dwMinorVersion==2)"
    FPRINT FP_WRITE, "        {"
    FPRINT FP_WRITE, "        if(osvi.wProductType == VER_NT_WORKSTATION)           return  OS_Win_8;"
    FPRINT FP_WRITE, "        return  OS_Server_2012;"
    FPRINT FP_WRITE, "        }"
    FPRINT FP_WRITE, ""
    FPRINT FP_WRITE, "      if(osvi.dwMajorVersion==6 && osvi.dwMinorVersion==1)"
    FPRINT FP_WRITE, "        {"
    FPRINT FP_WRITE, "        if(osvi.wProductType == VER_NT_WORKSTATION)            return OS_Win_7;"
    FPRINT FP_WRITE, "        return OS_Server_2008_R2;"
    FPRINT FP_WRITE, "        }"
    FPRINT FP_WRITE, ""
    FPRINT FP_WRITE, "      if(osvi.dwMajorVersion==6 && osvi.dwMinorVersion==0)"
    FPRINT FP_WRITE, "        {"
    FPRINT FP_WRITE, "        if(osvi.wProductType != VER_NT_WORKSTATION)             return OS_Server_2008;"
    FPRINT FP_WRITE, "        return OS_Vista;"
    FPRINT FP_WRITE, "        }"
    FPRINT FP_WRITE, ""
    FPRINT FP_WRITE, "      if(osvi.dwMajorVersion>=5 && osvi.dwMinorVersion>=2)"
    FPRINT FP_WRITE, "        {"
    FPRINT FP_WRITE, "        int iTestForSM_SERVERR2;"
    FPRINT FP_WRITE, "        iTestForSM_SERVERR2 = GetSystemMetrics(SM_SERVERR2);"
    FPRINT FP_WRITE, "        if(iTestForSM_SERVERR2 != 0)                            return OS_Server_2003_R2;"
    FPRINT FP_WRITE, "        if((osvi.wSuiteMask & VER_SUITE_WH_SERVER) != 0)        return OS_Home_Server;"
    FPRINT FP_WRITE, "        if (iTestForSM_SERVERR2 == 0)                           return OS_Server_2003;"
    FPRINT FP_WRITE, "        SYSTEM_INFO siSysInfo;"
    FPRINT FP_WRITE, "        GetSystemInfo(&siSysInfo); "
    FPRINT FP_WRITE, "        if((osvi.wProductType == VER_NT_WORKSTATION) && (siSysInfo.wProcessorArchitecture==PROCESSOR_ARCHITECTURE_AMD64)) return OS_XP_Pro_x64;"
    FPRINT FP_WRITE, "        return OSUnknown;"
    FPRINT FP_WRITE, "        }"
    FPRINT FP_WRITE, ""
    FPRINT FP_WRITE, "      if(osvi.dwMajorVersion==5 && osvi.dwMinorVersion==1)      return OS_XP;"
    FPRINT FP_WRITE, ""
    FPRINT FP_WRITE, "      if(osvi.dwMajorVersion==5 && osvi.dwMinorVersion==0)      return OS_2000;"
    FPRINT FP_WRITE, ""
    FPRINT FP_WRITE, "      if(osvi.dwMajorVersion==3 && osvi.dwMinorVersion==51)     return OS_NT3;"
    FPRINT FP_WRITE, "      return OSUnknown;"
    FPRINT FP_WRITE, ""
    FPRINT FP_WRITE, "    case VER_PLATFORM_WIN32_WINDOWS:"
    FPRINT FP_WRITE, "      if((osvi.dwMajorVersion==4 && osvi.dwMinorVersion==90))   return OS_ME;"
    FPRINT FP_WRITE, "      if((osvi.dwMajorVersion==4 && osvi.dwMinorVersion==10))   return OS_98;"
    FPRINT FP_WRITE, "      if((osvi.dwMajorVersion==4 && osvi.dwMinorVersion==0))    return OS_95;"
    FPRINT FP_WRITE, "      return OSUnknown;"
    FPRINT FP_WRITE, ""
    FPRINT FP_WRITE, "    case VER_PLATFORM_WIN32s:"
    FPRINT FP_WRITE, "      return OS_3x;"
    FPRINT FP_WRITE, "    }"
    FPRINT FP_WRITE, "  return OSUnknown;"
    FPRINT FP_WRITE, sENDBCXRTLIB$
  END IF


  IF Use_ContainedIn THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: containedin"
    FPRINT FP_WRITE,"int containedin(const char * Token,const char **Contain ,int c)"
    'FPRINT FP_WRITE,"int containedin(char * Token, char **Contain ,int c)"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"    int i=0;"
    FPRINT FP_WRITE,"    while(Contain[i][0])"
    FPRINT FP_WRITE,"      {"
    FPRINT FP_WRITE,"        if(0 == ((c == 0 || c == 2) ? strcmp(Contain[i],Token) : stricmp(Contain[i],Token)))"
    FPRINT FP_WRITE,"          {"
    FPRINT FP_WRITE,"            return ((c < 2) ? 0 : i);"
    FPRINT FP_WRITE,"          }"
    FPRINT FP_WRITE,"        i++;"
    FPRINT FP_WRITE,"      }"
    FPRINT FP_WRITE,"    return -1;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_FindInType THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: FindInType"
    FPRINT FP_WRITE,"int FindInType(const char *Token,const char *StOffset,int StSize,int start,int finish,int c,int *idx)"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"    int j;"
    FPRINT FP_WRITE,"    char *Srch;"
    FPRINT FP_WRITE,"    int (*cmp)(const char*,const char*);"
    FPRINT FP_WRITE,"    cmp = ((c == 0 || c == 2) ? strcmp : stricmp);"
    FPRINT FP_WRITE,"    for(j=start; j<=finish; j++)"
    FPRINT FP_WRITE,"      {"
    FPRINT FP_WRITE,"        Srch = (char*)StOffset + ((idx==0) ? j*StSize : idx[j]*StSize);"
    FPRINT FP_WRITE,"        if(cmp(Srch,Token)==0)"
    FPRINT FP_WRITE,"          {"
    FPRINT FP_WRITE,"            return ((c < 2) ? 0 : j);"
    FPRINT FP_WRITE,"          }"
    FPRINT FP_WRITE,"      }"
    FPRINT FP_WRITE,"    return -1;"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_Hscroll OR Use_Vscroll THEN
    IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Scroll"
    FPRINT FP_WRITE,"void BCX_Scroll (HWND hWnd, int Msg, int wParam, int lParam, int BCX_LargeChangeX,"
    FPRINT FP_WRITE,"int  BCX_LargeChangeY, int BCX_SmallChangeX, int BCX_SmallChangeY, int BCX_ViewWidth,"
    FPRINT FP_WRITE,"int  BCX_ViewHeight, int BCX_DynaScroll)"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"    static int oldX;"
    FPRINT FP_WRITE,"    static int oldY;"
    FPRINT FP_WRITE,"    static RECT Rc;"
    FPRINT FP_WRITE,"    for(;;)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"    if(Msg==WM_VSCROLL)"
    FPRINT FP_WRITE,"      {"
    FPRINT FP_WRITE,"        int yChange;"
    FPRINT FP_WRITE,"        int yPos;"
    FPRINT FP_WRITE,"        int LowWp=LOWORD(wParam);"
    FPRINT FP_WRITE,"        for(;;)"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"        if(LowWp==SB_LINEUP)"
    FPRINT FP_WRITE,"          {"
    FPRINT FP_WRITE,"            yPos=BCX_siY.nPos-BCX_SmallChangeY;"
    FPRINT FP_WRITE,"            break;"
    FPRINT FP_WRITE,"          }"
    FPRINT FP_WRITE,"        if(LowWp==SB_LINEDOWN)"
    FPRINT FP_WRITE,"          {"
    FPRINT FP_WRITE,"            yPos=BCX_siY.nPos+BCX_SmallChangeY;"
    FPRINT FP_WRITE,"            break;"
    FPRINT FP_WRITE,"          }"
    FPRINT FP_WRITE,"        if(LowWp==SB_PAGEUP)"
    FPRINT FP_WRITE,"          {"
    FPRINT FP_WRITE,"            yPos=BCX_siY.nPos-BCX_LargeChangeY;"
    FPRINT FP_WRITE,"            break;"
    FPRINT FP_WRITE,"          }"
    FPRINT FP_WRITE,"        if(LowWp==SB_PAGEDOWN)"
    FPRINT FP_WRITE,"          {"
    FPRINT FP_WRITE,"            yPos=BCX_siY.nPos+BCX_LargeChangeY;"
    FPRINT FP_WRITE,"            break;"
    FPRINT FP_WRITE,"          }"
    FPRINT FP_WRITE,"        if(LowWp==SB_THUMBPOSITION)"
    FPRINT FP_WRITE,"          {"
    FPRINT FP_WRITE,"            yPos=HIWORD(wParam);"
    FPRINT FP_WRITE,"            if(yPos+(int)BCX_siY.nPage>=BCX_siY.nMax)"
    FPRINT FP_WRITE,"              {"
    FPRINT FP_WRITE,"                yPos=BCX_siY.nMax;"
    FPRINT FP_WRITE,"              }"
    FPRINT FP_WRITE,"            break;"
    FPRINT FP_WRITE,"            }"
    FPRINT FP_WRITE,"          {"
    FPRINT FP_WRITE,"          yPos=BCX_siY.nPos;"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"      break;"
    FPRINT FP_WRITE,"      }"
    FPRINT FP_WRITE,"    yPos=MAX(0,yPos);"
    FPRINT FP_WRITE,"    yPos=MIN(BCX_siY.nMax,yPos);"
    FPRINT FP_WRITE,"    if(yPos==BCX_siY.nPos) return;"
    FPRINT FP_WRITE,"    yChange=yPos-BCX_siY.nPos;"
    FPRINT FP_WRITE,"    BCX_siY.nPos=yPos;"
    FPRINT FP_WRITE,"    ScrollWindowEx(hWnd,0,-yChange,0,0,0,0,SW_SCROLLCHILDREN | SW_ERASE | SW_INVALIDATE);"
    FPRINT FP_WRITE,"    SetScrollInfo(hWnd,SB_VERT,&BCX_siY,TRUE);"
    FPRINT FP_WRITE,"    break;"
    FPRINT FP_WRITE,"  }"
    FPRINT FP_WRITE,"if(Msg==WM_HSCROLL)"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"    int xChange;"
    FPRINT FP_WRITE,"    int xPos;"
    FPRINT FP_WRITE,"    int LowWp=LOWORD(wParam);"
    FPRINT FP_WRITE,"    for(;;)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"    if(LowWp==SB_LINELEFT)"
    FPRINT FP_WRITE,"      {"
    FPRINT FP_WRITE,"        xPos=BCX_siX.nPos-BCX_SmallChangeX;"
    FPRINT FP_WRITE,"        break;"
    FPRINT FP_WRITE,"      }"
    FPRINT FP_WRITE,"    if(LowWp==SB_LINERIGHT)"
    FPRINT FP_WRITE,"      {"
    FPRINT FP_WRITE,"        xPos=BCX_siX.nPos+BCX_SmallChangeX;"
    FPRINT FP_WRITE,"        break;"
    FPRINT FP_WRITE,"      }"
    FPRINT FP_WRITE,"    if(LowWp==SB_PAGEUP)"
    FPRINT FP_WRITE,"      {"
    FPRINT FP_WRITE,"        xPos=BCX_siX.nPos-BCX_LargeChangeX;"
    FPRINT FP_WRITE,"        break;"
    FPRINT FP_WRITE,"      }"
    FPRINT FP_WRITE,"    if(LowWp==SB_PAGEDOWN)"
    FPRINT FP_WRITE,"      {"
    FPRINT FP_WRITE,"        xPos=BCX_siX.nPos+BCX_LargeChangeX;"
    FPRINT FP_WRITE,"        break;"
    FPRINT FP_WRITE,"      }"
    FPRINT FP_WRITE,"    if(LowWp==SB_THUMBPOSITION)"
    FPRINT FP_WRITE,"      {"
    FPRINT FP_WRITE,"        xPos=HIWORD(wParam);"
    FPRINT FP_WRITE,"        if(xPos+(int)BCX_siX.nPage>=BCX_siX.nMax)"
    FPRINT FP_WRITE,"          {"
    FPRINT FP_WRITE,"            xPos=BCX_siX.nMax;"
    FPRINT FP_WRITE,"          }"
    FPRINT FP_WRITE,"        break;"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"      {"
    FPRINT FP_WRITE,"      xPos=BCX_siX.nPos;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  break;"
    FPRINT FP_WRITE,"  }"
    FPRINT FP_WRITE,"xPos=MAX(0,xPos);"
    FPRINT FP_WRITE,"xPos=MIN(BCX_siX.nMax,xPos);"
    FPRINT FP_WRITE,"if(xPos==BCX_siX.nPos) return;"
    FPRINT FP_WRITE,"xChange=xPos-BCX_siX.nPos;"
    FPRINT FP_WRITE,"BCX_siX.nPos=xPos;"
    FPRINT FP_WRITE,"ScrollWindowEx(hWnd,-xChange,0,0,0,0,0,SW_SCROLLCHILDREN | SW_ERASE | SW_INVALIDATE);"
    FPRINT FP_WRITE,"SetScrollInfo(hWnd,SB_HORZ,&BCX_siX,TRUE);"
    FPRINT FP_WRITE,"break;"
    FPRINT FP_WRITE,"}"
    FPRINT FP_WRITE,"if(Msg==WM_SIZE)"
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"    if(BCX_DynaScroll)"
    FPRINT FP_WRITE,"      {"
    FPRINT FP_WRITE,"        int xNewSize;"
    FPRINT FP_WRITE,"        int yNewSize=HIWORD(lParam);"
    FPRINT FP_WRITE,"        int offsetX=0;"
    FPRINT FP_WRITE,"        int offsetY=0;"
    FPRINT FP_WRITE,"        xNewSize=(GetSystemMetrics(SM_CXFRAME)*2)+(GetSystemMetrics(SM_CXBORDER)*2);"
    FPRINT FP_WRITE,"        GetWindowRect(hWnd,&Rc);"
    FPRINT FP_WRITE,"        xNewSize=(Rc.right-Rc.left)-xNewSize-GetSystemMetrics(SM_CXVSCROLL);"
    FPRINT FP_WRITE,"        if(xNewSize>BCX_ViewWidth-BCX_siX.nPos&&BCX_siX.nPos>0)"
    FPRINT FP_WRITE,"          {"
    FPRINT FP_WRITE,"            offsetX=MAX(0,MIN(xNewSize-oldX,BCX_siX.nPos));"
    FPRINT FP_WRITE,"            BCX_siX.nPos=MAX(0,BCX_siX.nPos-offsetX);"
    FPRINT FP_WRITE,"          }"
    FPRINT FP_WRITE,"        if(yNewSize>BCX_ViewHeight-BCX_siY.nPos&&BCX_siY.nPos>0)"
    FPRINT FP_WRITE,"          {"
    FPRINT FP_WRITE,"            offsetY=MAX(0,MIN(yNewSize-oldY,BCX_siY.nPos));"
    FPRINT FP_WRITE,"            BCX_siY.nPos=MAX(0,BCX_siY.nPos-offsetY);"
    FPRINT FP_WRITE,"          }"
    FPRINT FP_WRITE,"        if(offsetX||offsetY)"
    FPRINT FP_WRITE,"          {"
    FPRINT FP_WRITE,"            ScrollWindowEx(hWnd,offsetX,offsetY,0,0,0,0,SW_SCROLLCHILDREN | SW_ERASE | SW_INVALIDATE);"
    FPRINT FP_WRITE,"          }"
    FPRINT FP_WRITE,"        BCX_siX.nMax=MAX(BCX_ViewWidth-xNewSize,0);"
    FPRINT FP_WRITE,"        BCX_siX.nPage=MAX(BCX_siX.nMax/BCX_LargeChangeX,0);"
    FPRINT FP_WRITE,"        BCX_siX.nPos=MIN(BCX_siX.nPos,BCX_siX.nMax);"
    FPRINT FP_WRITE,"        SetScrollInfo(hWnd,SB_HORZ,&BCX_siX,TRUE);"
    FPRINT FP_WRITE,"        BCX_siY.nMax=MAX(BCX_ViewHeight-yNewSize,0);"
    FPRINT FP_WRITE,"        BCX_siY.nPage=MAX(BCX_siY.nMax/BCX_LargeChangeY,0);"
    FPRINT FP_WRITE,"        BCX_siY.nPos=MIN(BCX_siY.nPos,BCX_siY.nMax);"
    FPRINT FP_WRITE,"        SetScrollInfo(hWnd,SB_VERT,&BCX_siY,TRUE);"
    FPRINT FP_WRITE,"        oldX=xNewSize;"
    FPRINT FP_WRITE,"        oldY=yNewSize;"
    FPRINT FP_WRITE,"      }"
    FPRINT FP_WRITE,"  }"
    FPRINT FP_WRITE,"break;"
    FPRINT FP_WRITE,"}"
    FPRINT FP_WRITE,sENDBCXRTLIB$
  END IF

  IF Use_StartupCode THEN
    FPRINT FP_WRITE,"int BCX_StartupCode_(void)"
    FPRINT FP_WRITE,"{"
    FOR INTEGER i = 1 TO StartNdx
      FPRINT FP_WRITE,"  ";StartSub$[i];"();"
    NEXT
    FPRINT FP_WRITE,"  return 1;"
    FPRINT FP_WRITE,"}\n\n"
  END IF

  IF Use_ExitCode THEN
    FPRINT FP_WRITE,"int BCX_ExitCode_(void)"
    FPRINT FP_WRITE,"{"
    FOR INTEGER i = 1 TO ExitNdx
      FPRINT FP_WRITE,"  atexit(";ExitSub$[i];");"
    NEXT
    FPRINT FP_WRITE,"  return 1;"
    FPRINT FP_WRITE,"}\n\n"
  END IF
  'Might need normal bc9 strings AND fstrings in same app
  If Use_fprintS Then
	If Use_TCLib Then
		FPRINT FP_WRITE,"int fPrintS(HANDLE hFile, fstring*  sBuffer)"
		'FPRINT FP_WRITE,"int fPrintS(HANDLE hFile, fstring&  sBuffer)"
		FPRINT FP_WRITE,"{"
		FPRINT FP_WRITE,"    UINT     uLen = {0};"
		FPRINT FP_WRITE,"    DWORD    dwBytesWritten = {0};"
		FPRINT FP_WRITE,"    BOOL     bErrorFlag = {0};"
		FPRINT FP_WRITE,"    uLen = WideCharToMultiByte( CP_ACP, 0, sBuffer->lpStr(), - 1, 0, 0, 0, 0);"
		'FPRINT FP_WRITE,"    uLen = WideCharToMultiByte( CP_ACP, 0, sBuffer.lpStr(), - 1, 0, 0, 0, 0);"
		FPRINT FP_WRITE,"    _char*   szTo = new _char[uLen + 2];"
		FPRINT FP_WRITE,"    WideCharToMultiByte(CP_ACP, 0, sBuffer->lpStr(), -1, szTo, uLen, NULL, NULL);"
		'FPRINT FP_WRITE,"    WideCharToMultiByte(CP_ACP, 0, sBuffer.lpStr(), -1, szTo, uLen, NULL, NULL);"
		FPRINT FP_WRITE,"    szTo[uLen - 1] = 13;"
		FPRINT FP_WRITE,"    szTo[uLen]  = 10;"
		FPRINT FP_WRITE,"    bErrorFlag = WriteFile( hFile, szTo, uLen + 1,  &dwBytesWritten, NULL);"
		FPRINT FP_WRITE,"    delete []szTo;"
		FPRINT FP_WRITE,"    return 0;"
		FPRINT FP_WRITE,"}"
		FPRINT FP_WRITE,"//------------------------------------------------------------------------------"
		
		'FPRINT FP_WRITE,"int fPrintS(HANDLE hFile, fstring*  sBuffer)"
		FPRINT FP_WRITE,"int fPrintS(HANDLE hFile, fstring  sBuffer)"
		FPRINT FP_WRITE,"{"
		FPRINT FP_WRITE,"    UINT     uLen = {0};"
		FPRINT FP_WRITE,"    DWORD    dwBytesWritten = {0};"
		FPRINT FP_WRITE,"    BOOL     bErrorFlag = {0};"
		FPRINT FP_WRITE,"    uLen = WideCharToMultiByte( CP_ACP, 0, sBuffer.lpStr(), - 1, 0, 0, 0, 0);"
		'FPRINT FP_WRITE,"    uLen = WideCharToMultiByte( CP_ACP, 0, sBuffer.lpStr(), - 1, 0, 0, 0, 0);"
		FPRINT FP_WRITE,"    _char*   szTo = new _char[uLen + 2];"
		FPRINT FP_WRITE,"    WideCharToMultiByte(CP_ACP, 0, sBuffer.lpStr(), -1, szTo, uLen, NULL, NULL);"
		'FPRINT FP_WRITE,"    WideCharToMultiByte(CP_ACP, 0, sBuffer.lpStr(), -1, szTo, uLen, NULL, NULL);"
		FPRINT FP_WRITE,"    szTo[uLen - 1] = 13;"
		FPRINT FP_WRITE,"    szTo[uLen]  = 10;"
		FPRINT FP_WRITE,"    bErrorFlag = WriteFile( hFile, szTo, uLen + 1,  &dwBytesWritten, NULL);"
		FPRINT FP_WRITE,"    delete []szTo;"
		FPRINT FP_WRITE,"    return 0;"
		FPRINT FP_WRITE,"}"
		FPRINT FP_WRITE,"//------------------------------------------------------------------------------"
		
		
		
		FPRINT FP_WRITE,"int fPrintS(HANDLE hFile, char*  sBuf)"
		'FPRINT FP_WRITE,"int fPrintS(HANDLE hFile, fstring&  sBuffer)"
		FPRINT FP_WRITE,"{"
		FPRINT FP_WRITE,"    UINT     uLen = {0};"
		FPRINT FP_WRITE,"    DWORD    dwBytesWritten = {0};"
		FPRINT FP_WRITE,"    BOOL     bErrorFlag = {0};"
		FPRINT FP_WRITE,"    fstring  sBuffer(sBuf);"
		FPRINT FP_WRITE,"    uLen = WideCharToMultiByte( CP_ACP, 0, sBuffer.lpStr(), - 1, 0, 0, 0, 0);"
		'FPRINT FP_WRITE,"    uLen = WideCharToMultiByte( CP_ACP, 0, sBuffer.lpStr(), - 1, 0, 0, 0, 0);"
		FPRINT FP_WRITE,"    _char*   szTo = new _char[uLen + 2];"
		FPRINT FP_WRITE,"    WideCharToMultiByte(CP_ACP, 0, sBuffer.lpStr(), -1, szTo, uLen, NULL, NULL);"
		'FPRINT FP_WRITE,"    WideCharToMultiByte(CP_ACP, 0, sBuffer.lpStr(), -1, szTo, uLen, NULL, NULL);"
		FPRINT FP_WRITE,"    szTo[uLen - 1] = 13;"
		FPRINT FP_WRITE,"    szTo[uLen]  = 10;"
		FPRINT FP_WRITE,"    bErrorFlag = WriteFile( hFile, szTo, uLen + 1,  &dwBytesWritten, NULL);"
		FPRINT FP_WRITE,"    delete []szTo;"
		FPRINT FP_WRITE,"    return 0;"
		FPRINT FP_WRITE,"}"
		FPRINT FP_WRITE,"//------------------------------------------------------------------------------"
		
	Else
		If Use_UNICODE_Switch Then
			FPRINT FP_WRITE,"int fPrintS(HANDLE hFile, char*  sBuffer)"
			FPRINT FP_WRITE,"{"
			FPRINT FP_WRITE,"    UINT     uLen = {0};"
			FPRINT FP_WRITE,"    DWORD    dwBytesWritten = {0};"
			FPRINT FP_WRITE,"    BOOL     bErrorFlag = {0};"
			FPRINT FP_WRITE,"    uLen = WideCharToMultiByte( CP_ACP, 0, sBuffer, - 1, 0, 0, 0, 0);"
			FPRINT FP_WRITE,"    _char*   szTo = new _char[uLen + 2];"
			FPRINT FP_WRITE,"    WideCharToMultiByte(CP_ACP, 0, sBuffer, -1, szTo, uLen, NULL, NULL);"
			FPRINT FP_WRITE,"    szTo[uLen - 1] = 13;"
			FPRINT FP_WRITE,"    szTo[uLen]  = 10;"
			FPRINT FP_WRITE,"    bErrorFlag = WriteFile( hFile, szTo, uLen + 1,  &dwBytesWritten, NULL);"
			FPRINT FP_WRITE,"    delete []szTo;"
			FPRINT FP_WRITE,"    return 0;"
			FPRINT FP_WRITE,"}"
		Else
			FPRINT FP_WRITE,"int fPrintS(HANDLE hFile, char*  sBuffer)"
			FPRINT FP_WRITE,"{"
			FPRINT FP_WRITE,"    UINT     uLen = {0};"
			FPRINT FP_WRITE,"    DWORD    dwBytesWritten = {0};"
			FPRINT FP_WRITE,"    BOOL     bErrorFlag = {0};"
			FPRINT FP_WRITE,"    uLen = strlen(sBuffer);"
			FPRINT FP_WRITE,"    char*   szTo = new char[uLen+2];"
			FPRINT FP_WRITE,"    CopyMemory(szTo,sBuffer,uLen);"
			FPRINT FP_WRITE,"    szTo[uLen] = 13;"
			FPRINT FP_WRITE,"    szTo[uLen+1] = 10;"
			FPRINT FP_WRITE,"    bErrorFlag = WriteFile( hFile, szTo, uLen + 2,  &dwBytesWritten, NULL);"
			FPRINT FP_WRITE,"    delete []szTo;"
			FPRINT FP_WRITE,"    return 0;"
			FPRINT FP_WRITE,"}"
        End If		
		
	End If	
  End If
  
  
  
  If Use_Tcl_LineInput Then
    FPRINT FP_WRITE,"int LineInput (HANDLE hFile, fstring*  sData,int ReadBufferSize)"
    'FPRINT FP_WRITE,"int LineInput (HANDLE hFile, fstring&  sData)"
    FPRINT FP_WRITE,"{"
    FPRINT FP_WRITE,"    _char*   ReadBuffer = {0};"
    FPRINT FP_WRITE,"    DWORD    dwBytesRead = {0};"
    FPRINT FP_WRITE,"    DWORD    dwPtr = {0};"
    FPRINT FP_WRITE,"    long     where = {0};"
    FPRINT FP_WRITE,"    int      j = {0};"
    'FPRINT FP_WRITE,"    ReadBuffer = new _char[ 1024];"
    FPRINT FP_WRITE,"    ReadBuffer = new _char[ ReadBufferSize];"
    FPRINT FP_WRITE,"    dwPtr = SetFilePointer( hFile, 0, NULL, FILE_CURRENT);"
    'FPRINT FP_WRITE,"    if(FALSE == ReadFile(hFile, ReadBuffer, 1024, &dwBytesRead, NULL))"
    FPRINT FP_WRITE,"    if(FALSE == ReadFile(hFile, ReadBuffer, ReadBufferSize, &dwBytesRead, NULL))"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"        return -3;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"    if(dwBytesRead == 0 )"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"        return -1;"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"        int      i;"
    FPRINT FP_WRITE,"        for(i = 0; i < dwBytesRead; i++)"
    FPRINT FP_WRITE,"        {"
    FPRINT FP_WRITE,"            if(ReadBuffer[i] == 10 )"
    FPRINT FP_WRITE,"            {"
    FPRINT FP_WRITE,"                where = i;"
    FPRINT FP_WRITE,"                j = where;"
    FPRINT FP_WRITE,"                if(ReadBuffer[i - 1] == 13 )"
    FPRINT FP_WRITE,"                {"
    FPRINT FP_WRITE,"                    where = i + 1;"
    FPRINT FP_WRITE,"                    j = i - 1;"
    FPRINT FP_WRITE,"                }"
    FPRINT FP_WRITE,"                break;"
    FPRINT FP_WRITE,"            }"
    FPRINT FP_WRITE,"        }"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"    SetFilePointer(hFile, dwPtr + where, NULL, FILE_BEGIN);"
    FPRINT FP_WRITE,"    ReadBuffer[j]  = 0;"
    FPRINT FP_WRITE,"    wchar_t*  wszTo = new wchar_t[j + 1];"
    FPRINT FP_WRITE,E"    wszTo[j] = L\'\\0\';"
    FPRINT FP_WRITE,"    MultiByteToWideChar(CP_ACP, 0, ReadBuffer, -1, wszTo, (int)j);"
    FPRINT FP_WRITE,"    *sData = wszTo;"
    FPRINT FP_WRITE,"    delete[] wszTo;"
    FPRINT FP_WRITE,"    delete []ReadBuffer;"
    FPRINT FP_WRITE,"    return 0;"
    FPRINT FP_WRITE,"}"
  End If
  
  If Use_LineInput Then
	If Use_UNICODE_Switch Then
		FPRINT FP_WRITE,"int LineInput (HANDLE hFile, char*  sData, int ReadBufferSize)"
		FPRINT FP_WRITE,"{"
		FPRINT FP_WRITE,"    _char*   ReadBuffer = {0};"
		FPRINT FP_WRITE,"    DWORD    dwBytesRead = {0};"
		FPRINT FP_WRITE,"    DWORD    dwPtr = {0};"
		FPRINT FP_WRITE,"    long     where = {0};"
		FPRINT FP_WRITE,"    int      j = {0};"
		'FPRINT FP_WRITE,"    ReadBuffer = new _char[ 1024];"
		FPRINT FP_WRITE,"    ReadBuffer = new _char[ ReadBufferSize];"
		FPRINT FP_WRITE,"    dwPtr = SetFilePointer( hFile, 0, NULL, FILE_CURRENT);"
		'FPRINT FP_WRITE,"    if(FALSE == ReadFile(hFile, ReadBuffer, 1024, &dwBytesRead, NULL))"
		FPRINT FP_WRITE,"    if(FALSE == ReadFile(hFile, ReadBuffer, ReadBufferSize, &dwBytesRead, NULL))"
		FPRINT FP_WRITE,"    {"
		FPRINT FP_WRITE,"        return -3;"
		FPRINT FP_WRITE,"    }"
		FPRINT FP_WRITE,"    if(dwBytesRead == 0 )"
		FPRINT FP_WRITE,"    {"
		FPRINT FP_WRITE,"        return -1;"
		FPRINT FP_WRITE,"    }"
		FPRINT FP_WRITE,"    {"
		FPRINT FP_WRITE,"        int      i;"
		FPRINT FP_WRITE,"        for(i = 0; i < dwBytesRead; i++)"
		FPRINT FP_WRITE,"        {"
		FPRINT FP_WRITE,"            if(ReadBuffer[i] == 10 )"
		FPRINT FP_WRITE,"            {"
		FPRINT FP_WRITE,"                where = i;"
		FPRINT FP_WRITE,"                j = where;"
		FPRINT FP_WRITE,"                if(ReadBuffer[i - 1] == 13 )"
		FPRINT FP_WRITE,"                {"
		FPRINT FP_WRITE,"                    where = i + 1;"
		FPRINT FP_WRITE,"                    j = i - 1;"
		FPRINT FP_WRITE,"                }"
		FPRINT FP_WRITE,"                break;"
		FPRINT FP_WRITE,"            }"
		FPRINT FP_WRITE,"        }"
		FPRINT FP_WRITE,"    }"
		FPRINT FP_WRITE,"    SetFilePointer(hFile, dwPtr + where, NULL, FILE_BEGIN);"
		FPRINT FP_WRITE,"    ReadBuffer[j]  = 0;"
		FPRINT FP_WRITE,"    wchar_t*  wszTo = new wchar_t[j + 1];"
		FPRINT FP_WRITE,E"    wszTo[j] = L\'\\0\';"
		FPRINT FP_WRITE,"    MultiByteToWideChar(CP_ACP, 0, ReadBuffer, -1, wszTo, (int)j);"
		FPRINT FP_WRITE,"    strcpy(sData,wszTo);"
		'FPRINT FP_WRITE,"     CopyMemory(sData,wszTo,j);"
		FPRINT FP_WRITE,"    delete[] wszTo;"
		FPRINT FP_WRITE,"    delete []ReadBuffer;"
		FPRINT FP_WRITE,"    return 0;"
		FPRINT FP_WRITE,"}"
	ELSE
		FPRINT FP_WRITE,"int LineInput (HANDLE hFile, char*  sData, int ReadBufferSize)"
		FPRINT FP_WRITE,"{"
		FPRINT FP_WRITE,"    char*   ReadBuffer = {0};"
		FPRINT FP_WRITE,"    DWORD    dwBytesRead = {0};"
		FPRINT FP_WRITE,"    DWORD    dwPtr = {0};"
		FPRINT FP_WRITE,"    long     where = {0};"
		FPRINT FP_WRITE,"    int      j = {0};"
		'FPRINT FP_WRITE,"    ReadBuffer = new char[ 1024];"
		FPRINT FP_WRITE,"    ReadBuffer = new char[ ReadBufferSize];"
		FPRINT FP_WRITE,"    dwPtr = SetFilePointer( hFile, 0, NULL, FILE_CURRENT);"
		FPRINT FP_WRITE,"    if(FALSE == ReadFile(hFile, ReadBuffer, ReadBufferSize, &dwBytesRead, NULL))"
		FPRINT FP_WRITE,"    {"
		FPRINT FP_WRITE,"        return -3;"
		FPRINT FP_WRITE,"    }"
		FPRINT FP_WRITE,"    if(dwBytesRead == 0 )"
		FPRINT FP_WRITE,"    {"
		FPRINT FP_WRITE,"        return -1;"
		FPRINT FP_WRITE,"    }"
		FPRINT FP_WRITE,"    {"
		FPRINT FP_WRITE,"        int      i;"
		FPRINT FP_WRITE,"        for(i = 0; i < dwBytesRead; i++)"
		FPRINT FP_WRITE,"        {"
		FPRINT FP_WRITE,"            if(ReadBuffer[i] == 10 )"
		FPRINT FP_WRITE,"            {"
		FPRINT FP_WRITE,"                where = i;"
		FPRINT FP_WRITE,"                j = where;"
		FPRINT FP_WRITE,"                if(ReadBuffer[i - 1] == 13 )"
		FPRINT FP_WRITE,"                {"
		FPRINT FP_WRITE,"                    where = i + 1;"
		FPRINT FP_WRITE,"                    j = i - 1;"
		FPRINT FP_WRITE,"                }"
		FPRINT FP_WRITE,"                break;"
		FPRINT FP_WRITE,"            }"
		FPRINT FP_WRITE,"        }"
		FPRINT FP_WRITE,"    }"
		FPRINT FP_WRITE,"    SetFilePointer(hFile, dwPtr + where, NULL, FILE_BEGIN);"
		FPRINT FP_WRITE,"    ReadBuffer[j]  = 0;"
		FPRINT FP_WRITE,"    strcpy(sData,ReadBuffer);"
		FPRINT FP_WRITE,"    delete []ReadBuffer;"
		FPRINT FP_WRITE,"    return 0;"
		FPRINT FP_WRITE,"}"
	End If
  End If
  ' Emit nomain gui/mdigui code here
'std::cout << "RunTimeFunctions" << std::endl
  IF Use_GUINoMain OR Use_MDIGUINoMain OR Use_Wingui OR Use_BC9Dialog THEN

    IF Use_BCX_FrameWnd THEN
      IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_FrameWnd"
      FPRINT FP_WRITE,"HWND BCX_FrameWnd (const char * classname,WNDPROC  FrameWndProc,const char * caption,HMENU  hMenu,int nMenuPos,int x,int y,int w,int h,int nStyle,int nExStyle)"
      FPRINT FP_WRITE,"{"
      FPRINT FP_WRITE,"  HWND  hWnd;"
      FPRINT FP_WRITE,"  if(!BCX_GUI_Init)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      BCX_InitGUI();"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"  BCX_RegWnd(classname,FrameWndProc);"
      FPRINT FP_WRITE,"  if(nStyle==0)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      nStyle=WS_OVERLAPPEDWINDOW;"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"  hWnd=CreateWindowEx(nExStyle,(char*)classname,(char*)caption,nStyle,x*BCX_ScaleX,y*BCX_ScaleY,w*BCX_ScaleX,h*BCX_ScaleY,NULL,(HMENU)hMenu,BCX_hInstance,NULL);"
      FPRINT FP_WRITE,"  SendMessage(hWnd,(UINT)WM_SETFONT,(WPARAM)DefaultFont,(LPARAM)MAKELPARAM(FALSE,0));"
      FPRINT FP_WRITE,"  CLIENTCREATESTRUCT ccs={0,1};"
      FPRINT FP_WRITE,"  //  Find window menu where children will be listed"
      FPRINT FP_WRITE,"  ccs.hWindowMenu=GetSubMenu(GetMenu(hWnd),nMenuPos-1);"
      FPRINT FP_WRITE,"  //  Create the MDI client filling the client area"
      FPRINT FP_WRITE,"  BCX_hwndMDIClient=CreateWindow(", ENC$("MDICLIENT"), ",NULL,WS_CHILD|WS_CLIPCHILDREN|WS_VISIBLE|WS_VSCROLL|WS_HSCROLL,"
      FPRINT FP_WRITE,"                                 0,0,0,0,hWnd,(HMENU)hMenu,BCX_hInstance,(LPVOID)&ccs);"
      FPRINT FP_WRITE,"  return hWnd;"
      FPRINT FP_WRITE,sENDBCXRTLIB$
    END IF

    IF Use_BCX_Wnd THEN
      IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_Wnd"
      FPRINT FP_WRITE,"HWND BCX_Wnd(const char * classname,WNDPROC  wndProc,const char * caption, HWND hParentWnd,int x,int y,int w,int h,int nStyle,int nExStyle,int nID)"
      FPRINT FP_WRITE,"{"
      FPRINT FP_WRITE,"  if(!BCX_GUI_Init)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      BCX_InitGUI();"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"  BCX_SetMetric(";ENC$("pixels");");"
      FPRINT FP_WRITE,"  BCX_RegWnd((char*)classname,wndProc);"
      FPRINT FP_WRITE,"  if(nStyle==0)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      nStyle=WS_OVERLAPPEDWINDOW;"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"  HWND hWnd=CreateWindowEx(nExStyle,(char*)classname,(char*)caption,nStyle,x*BCX_ScaleX,y*BCX_ScaleY,"
      'jcfuller added (INT_PTR)
      FPRINT FP_WRITE,"    w*BCX_ScaleX,h*BCX_ScaleY,hParentWnd,(HMENU)(INT_PTR) nID,BCX_hInstance,NULL);"
      FPRINT FP_WRITE,"  SendMessage(hWnd,(UINT)WM_SETFONT,(WPARAM)DefaultFont,(LPARAM)MAKELPARAM(FALSE,0));"
      FPRINT FP_WRITE,"  return hWnd;"
      FPRINT FP_WRITE,sENDBCXRTLIB$
    END IF

    IF Use_BCX_SetBkGrdBrush THEN
      IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_SetBkGrdBrush"
      FPRINT FP_WRITE,"void BCX_SetBkGrdBrush (HWND hWnd, HBRUSH hBrush)"
      FPRINT FP_WRITE,"{"
      FPRINT FP_WRITE,"  if(!BCX_GUI_Init)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      BCX_InitGUI();"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"  if(!hWnd)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      BCX_WndClass.hbrBackground=hBrush;"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"  if(hWnd)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      SetClassLongPtr(hWnd,GCLP_HBRBACKGROUND,(LONG_PTR)hBrush);"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,sENDBCXRTLIB$
    END IF


    IF Use_BCX_SetClassStyle THEN
      IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_SetClassStyle"
      FPRINT FP_WRITE,"void BCX_SetClassStyle (HWND hWnd, long nNewValue)"
      FPRINT FP_WRITE,"{"
      FPRINT FP_WRITE,"  if(!BCX_GUI_Init)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      BCX_InitGUI();"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"  if(!hWnd)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      BCX_WndClass.style=nNewValue;"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"  if(hWnd)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      SetClassLongPtr(hWnd,GCL_STYLE,(LONG_PTR)nNewValue);"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,sENDBCXRTLIB$
    END IF

    IF Use_BCX_SetIcon THEN
      IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_SetIcon"
      FPRINT FP_WRITE,"void BCX_SetIcon (HWND hWnd, int nRes)"
      FPRINT FP_WRITE,"{"
      FPRINT FP_WRITE,"  if(!BCX_GUI_Init)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      BCX_InitGUI();"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"  if(hWnd==0)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      BCX_WndClass.hIcon=LoadIcon(BCX_hInstance,MAKEINTRESOURCE(nRes));"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"  if(hWnd)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      SetClassLongPtr(hWnd,GCLP_HICON,(LONG_PTR)LoadIcon(BCX_hInstance,MAKEINTRESOURCE(nRes)));"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,sENDBCXRTLIB$
    END IF

    IF Use_BCX_SetIconSm THEN
      IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_SetIconSm"
      FPRINT FP_WRITE,"void BCX_SetIconSm (HWND hWnd, int nRes)"
      FPRINT FP_WRITE,"{"
      FPRINT FP_WRITE,"  if(!BCX_GUI_Init)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      BCX_InitGUI();"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"  if(hWnd==0)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      BCX_WndClass.hIconSm=LoadIcon(BCX_hInstance,MAKEINTRESOURCE(nRes));"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"  if(hWnd)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      SetClassLongPtr(hWnd,GCLP_HICONSM,(LONG_PTR)LoadIcon(BCX_hInstance,MAKEINTRESOURCE(nRes)));"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,sENDBCXRTLIB$
    END IF

    IF Use_BCX_SetCursor THEN
      IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_SetCursor"
      FPRINT FP_WRITE,"void BCX_SetCursor (HWND hWnd, const char *cCursor)"
      FPRINT FP_WRITE,"{"
      FPRINT FP_WRITE,"  if(!BCX_GUI_Init)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      BCX_InitGUI();"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"  if(hWnd==0)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      BCX_WndClass.hCursor=LoadCursor(BCX_hInstance,cCursor);"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"  if(hWnd)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      SetClassLongPtr(hWnd,GCLP_HCURSOR,(LONG_PTR)LoadCursor(BCX_hInstance,cCursor));"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,sENDBCXRTLIB$
    END IF

    IF Use_BCX_SetMetric THEN
      IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_SetMetric"
      FPRINT FP_WRITE,"void BCX_SetMetric (const char *metric)"
      FPRINT FP_WRITE,"{"
      FPRINT FP_WRITE,"  if(!BCX_GUI_Init)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      BCX_InitGUI();"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"  if(stricmp((char*)metric,", ENC$("PIXELS"), ")==0)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      BCX_ScaleX=1;"
      FPRINT FP_WRITE,"      BCX_ScaleY=1;"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"  else if(stricmp((char*)metric,", ENC$("DPI"), ")==0)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      HDC      hDc = GetDC(0);"
      FPRINT FP_WRITE,"      BCX_ScaleX = ( GetDeviceCaps( hDc, LOGPIXELSX) / 96.0f);"
      FPRINT FP_WRITE,"      BCX_ScaleY = ( GetDeviceCaps( hDc, LOGPIXELSY) / 96.0f);"
      FPRINT FP_WRITE,"      ReleaseDC(0, hDc);"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"  else"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      RECT  rc={0,0,4,8};"
      FPRINT FP_WRITE,"      MapDialogRect(NULL,&rc);"
      FPRINT FP_WRITE,"      BCX_ScaleX=rc.right/2;"
      FPRINT FP_WRITE,"      BCX_ScaleY=rc.bottom/4;"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,sENDBCXRTLIB$
    END IF



    IF Use_GUINoMain THEN
      IF Use_BCX_MsgPump THEN
        IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_MsgPump"
        FPRINT FP_WRITE,"int BCX_MsgPump (HACCEL  Accel)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"  MSG  Msg;"
        FPRINT FP_WRITE,"  if(Accel)"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"      while(GetMessage(&Msg,NULL,0,0) > 0)"
        FPRINT FP_WRITE,"        {"
        'FPRINT FP_WRITE,"          if(!TranslateAccelerator(GetActiveWindow(),Accel,&Msg)&&!IsWindow(GetActiveWindow())||!IsDialogMessage(GetActiveWindow(),&Msg))"
        FPRINT FP_WRITE,"          if((!TranslateAccelerator(GetActiveWindow(),Accel,&Msg)&&!IsWindow(GetActiveWindow()))||!IsDialogMessage(GetActiveWindow(),&Msg))"
        FPRINT FP_WRITE,"            {"
        FPRINT FP_WRITE,"              TranslateMessage(&Msg);"
        FPRINT FP_WRITE,"              DispatchMessage(&Msg);"
        FPRINT FP_WRITE,"            }"
        FPRINT FP_WRITE,"        }"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"  else"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"      while(GetMessage(&Msg,NULL,0,0)>0)"
        FPRINT FP_WRITE,"        {"
        FPRINT FP_WRITE,"          if(!IsWindow(GetActiveWindow())||!IsDialogMessage(GetActiveWindow(),&Msg))"
        FPRINT FP_WRITE,"            {"
        FPRINT FP_WRITE,"              TranslateMessage(&Msg);"
        FPRINT FP_WRITE,"              DispatchMessage(&Msg);"
        FPRINT FP_WRITE,"            }"
        FPRINT FP_WRITE,"        }"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"  return Msg.wParam;"
        FPRINT FP_WRITE,sENDBCXRTLIB$
      END IF
    END IF
'jcfuller added 02/02/2015
	If Use_BC9_ResDlg Then
        FPRINT FP_WRITE,"HWND BC9_ResDlg (int ResId, DLGPROC  dp, HWND hParent, LPARAM  dwInitParam )"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    return CreateDialogParam(0, MAKEINTRESOURCE(ResId), hParent, dp, dwInitParam);"
        FPRINT FP_WRITE,"}"
	End If
	If Use_BC9_ResMDlg Then
        FPRINT FP_WRITE,"INT_PTR BC9_ResMDlg (int ResId, DLGPROC  dp, HWND hParent , LPARAM  dwInitParam )"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    return DialogBoxParam(0, MAKEINTRESOURCE(ResId), hParent, dp, dwInitParam);"
        FPRINT FP_WRITE,"}"
	End If

	If Use_BC9Dialog Then
        FPRINT FP_WRITE,"PDLGTEMPLATEEX BC9_Dialog (const char*  Caption, int nLeft, int nTop, int nWidth, int nHeight, DWORD Style, DWORD ExStyle, const char*  FontFace, int FontSize, int FontWeight, const char*  Menu, const char*  sClass)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    static PDLGTEMPLATEEX  lpdp;"
        FPRINT FP_WRITE,"    if(!Style )"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"        Style = WS_POPUP | WS_BORDER | WS_SYSMENU | WS_VISIBLE | WS_CAPTION;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    if(FontSize )"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"        Style = Style | DS_SETFONT;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    if(nLeft == 0 && nTop == 0 )"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"        Style = Style | DS_CENTER;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    if(FontWeight == -1)"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"        FontWeight = 400;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    lpdp = DlgTemplate_Create( Style, ExStyle, 0, nLeft, nTop, nWidth, nHeight, Menu, sClass, Caption, FontSize, FontWeight, 0, FontFace);"
        FPRINT FP_WRITE,"    return lpdp;"
        FPRINT FP_WRITE,"}"
	End If
	If Use_BC9DlgShow Then
        FPRINT FP_WRITE,"HWND BC9_DlgShow (PDLGTEMPLATEEX  lpdp, DLGPROC  CallBackProc, HWND hParent, LPARAM lparam)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    HINSTANCE  hInst = GetModuleHandle(NULL);"
        FPRINT FP_WRITE,"    HWND     hDlg = {0};"
        FPRINT FP_WRITE,"    hDlg = CreateDialogIndirectParam( hInst, ( DLGTEMPLATE*) lpdp, hParent, ( DLGPROC) CallBackProc,(LPARAM) lparam);"
        'FPRINT FP_WRITE,"    hDlg = CreateDialogIndirectParam( hInst,"
        'FPRINT FP_WRITE,"                                    #ifndef __POCC__"
        'FPRINT FP_WRITE,"                                            ( DLGTEMPLATE*) lpdp,"
        'FPRINT FP_WRITE,"                                    #else"
        'FPRINT FP_WRITE,"                                            (DLGTEMPLATE*)(&(lpdp->wDlgVer)),"
        'FPRINT FP_WRITE,"                                    #endif"
        'FPRINT FP_WRITE,"                                    0, ( DLGPROC) CallBackProc, (LPARAM) lparam);"
        FPRINT FP_WRITE,"    DlgTemplate_Free(lpdp);"
        FPRINT FP_WRITE,"    return hDlg;"
        FPRINT FP_WRITE,"}"
	End If
	If Use_BC9DlgShowModal Then
        FPRINT FP_WRITE,"INT_PTR BC9_DlgShowModal (PDLGTEMPLATEEX  lpdp, DLGPROC  CallBackProc, HWND hParent, LPARAM lparam)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    INT_PTR rv;"
        FPRINT FP_WRITE,"    HINSTANCE  hInst = GetModuleHandle(NULL);"
        FPRINT FP_WRITE,"    rv = DialogBoxIndirectParam( hInst, ( DLGTEMPLATE*) lpdp, hParent, ( DLGPROC) CallBackProc, (LPARAM) lparam);"
        'FPRINT FP_WRITE,"    rv = DialogBoxIndirectParam( hInst,"
        'FPRINT FP_WRITE,"                                    #ifndef __POCC__"
        'FPRINT FP_WRITE,"                                            ( DLGTEMPLATE*) lpdp,"
        'FPRINT FP_WRITE,"                                    #else"
        'FPRINT FP_WRITE,"                                            (DLGTEMPLATE*)(&(lpdp->wDlgVer)),"
        'FPRINT FP_WRITE,"                                    #endif"
        'FPRINT FP_WRITE,"                                    0, ( DLGPROC) CallBackProc, (LPARAM) lparam);"
        FPRINT FP_WRITE,"    DlgTemplate_Free(lpdp);"
        FPRINT FP_WRITE,"    return rv;"
        FPRINT FP_WRITE,"}"
	End If

	If Use_BC9Control Then
'added  generic BC9_Control 05/01/2015
        FPRINT FP_WRITE,"void BC9_Control (const char* ClassName, PDLGTEMPLATEEX* lpdp, const char* txt, int CtlId, int nLeft, int nTop, int nWidth, int nHeight, int Style, int ExStyle)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    DlgTemplate_AddControl(lpdp, nLeft, nTop, nWidth, nHeight, CtlId, 0, Style, ExStyle, ClassName, txt, 0, 0);"
        FPRINT FP_WRITE,"}"
	End If

	If Use_BC9Button Then
        FPRINT FP_WRITE,"void BC9_Button (const char*  txt, PDLGTEMPLATEEX*  lpdp, int id, int nLeft, int nTop, int nWidth, int nHeight, int Style, int ExStyle)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    if(!Style )"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"        Style = WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | WS_TABSTOP;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    DlgTemplate_AddControl(lpdp, nLeft, nTop, nWidth, nHeight, id, 0, Style, ExStyle, "+DQ$+"BUTTON"+DQ$+", txt, 0, 0);"
        FPRINT FP_WRITE,"}"
	End If
	If Use_BC9Checkbox Then
        FPRINT FP_WRITE,"void BC9_Checkbox (const char*  txt, PDLGTEMPLATEEX*  lpdp, int id, int nLeft, int nTop, int nWidth, int nHeight, int Style, int ExStyle)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    if(!Style )"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"        Style = WS_CHILD | WS_VISIBLE | BS_AUTOCHECKBOX | WS_TABSTOP;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    DlgTemplate_AddControl(lpdp, nLeft, nTop, nWidth, nHeight, id, 0, Style, ExStyle, "+DQ$+"BUTTON"+DQ$+", txt, 0, 0);"
        FPRINT FP_WRITE,"}"
	End If
	If Use_BC9Group Then
        FPRINT FP_WRITE,"void BC9_Group (const char*  txt, PDLGTEMPLATEEX*  lpdp, int id, int nLeft, int nTop, int nWidth, int nHeight, int Style, int ExStyle)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    if(!Style )"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"        Style = BS_GROUPBOX | WS_CHILD | WS_VISIBLE;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    DlgTemplate_AddControl(lpdp, nLeft, nTop, nWidth, nHeight, id, 0, Style, ExStyle, "+DQ$+"BUTTON"+DQ$+", txt, 0, 0);"
        FPRINT FP_WRITE,"}"
	End If
	If Use_BC9Combo Then
        FPRINT FP_WRITE,"void BC9_Combobox (const char*  txt, PDLGTEMPLATEEX*  lpdp, int id, int nLeft, int nTop, int nWidth, int nHeight, int Style, int ExStyle)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    if(!Style )"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"        Style = WS_CHILD | WS_VISIBLE | CBS_DROPDOWN | CBS_SORT | WS_VSCROLL | WS_TABSTOP;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    DlgTemplate_AddControl(lpdp, nLeft, nTop, nWidth, nHeight, id, 0, Style, ExStyle, "+DQ$+"COMBOBOX"+DQ$+", txt, 0, 0);"
        FPRINT FP_WRITE,"}"
	End If
	If Use_BC9BlackRect Then
        FPRINT FP_WRITE,"void BC9_BlackRect (const char*  txt, PDLGTEMPLATEEX*  lpdp, int id, int nLeft, int nTop, int nWidth, int nHeight, int Style, int ExStyle)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    if(!Style )"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"        Style = WS_CHILD | SS_NOTIFY | WS_VISIBLE | SS_BLACKRECT;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    DlgTemplate_AddControl(lpdp, nLeft, nTop, nWidth, nHeight, id, 0, Style, ExStyle, "+DQ$+"STATIC"+DQ$+", txt, 0, 0);"
        FPRINT FP_WRITE,"}"

	End If
	If Use_BC9GrayRect Then
        FPRINT FP_WRITE,"void BC9_GrayRect (const char*  txt, PDLGTEMPLATEEX*  lpdp, int id, int nLeft, int nTop, int nWidth, int nHeight, int Style, int ExStyle)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    if(!Style )"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"        Style = WS_CHILD | SS_NOTIFY | WS_VISIBLE | SS_GRAYRECT;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    DlgTemplate_AddControl(lpdp, nLeft, nTop, nWidth, nHeight, id, 0, Style, ExStyle, "+DQ$+"STATIC"+DQ$+", txt, 0, 0);"
        FPRINT FP_WRITE,"}"
	End If
	If Use_BC9WhiteRect Then
        FPRINT FP_WRITE,"void BC9_WhiteRect (const char*  txt, PDLGTEMPLATEEX*  lpdp, int id, int nLeft, int nTop, int nWidth, int nHeight, int Style, int ExStyle)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    if(!Style )"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"        Style = WS_CHILD | SS_NOTIFY | WS_VISIBLE | SS_WHITERECT;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    DlgTemplate_AddControl(lpdp, nLeft, nTop, nWidth, nHeight, id, 0, Style, ExStyle, "+DQ$+"STATIC"+DQ$+", txt, 0, 0);"
        FPRINT FP_WRITE,"}"

	End If
	If Use_BC9DatePick Then
        FPRINT FP_WRITE,"void BC9_DatePick (const char*  txt, PDLGTEMPLATEEX*  lpdp, int id, int nLeft, int nTop, int nWidth, int nHeight, int Style, int ExStyle)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    if(!Style )"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"        Style = WS_CHILD | WS_TABSTOP | WS_VISIBLE | DTS_LONGDATEFORMAT;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    DlgTemplate_AddControl(lpdp, nLeft, nTop, nWidth, nHeight, id, 0, Style, ExStyle, "+DQ$+"SysDateTimePick32"+DQ$+", txt, 0, 0);"
        FPRINT FP_WRITE,"}"

	End If
	If Use_BC9Edit Then
        FPRINT FP_WRITE,"void BC9_Edit (const char*  txt, PDLGTEMPLATEEX*  lpdp, int id, int nLeft, int nTop, int nWidth, int nHeight, int Style, int ExStyle)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    if(!Style )"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"        Style = WS_CHILD | WS_VISIBLE | ES_WANTRETURN | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL | ES_AUTOHSCROLL;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    if(ExStyle == -1)"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"	     ExStyle = WS_EX_CLIENTEDGE;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    DlgTemplate_AddControl(lpdp, nLeft, nTop, nWidth, nHeight, id, 0, Style, ExStyle, "+DQ$+"EDIT"+DQ$+", txt, 0, 0);"
        FPRINT FP_WRITE,"}"
	End If
	If Use_BC9Input Then
        FPRINT FP_WRITE,"void BC9_Input (const char*  txt, PDLGTEMPLATEEX*  lpdp, int id, int nLeft, int nTop, int nWidth, int nHeight, int Style, int ExStyle)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    if(!Style )"
        FPRINT FP_WRITE,"    {"
        'FPRINT FP_WRITE,"        Style = WS_CHILD | WS_VISIBLE | WS_TABSTOP | ES_LEFT;"
        FPRINT FP_WRITE,"        Style = WS_CHILDWINDOW | WS_VISIBLE | WS_TABSTOP;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    if(ExStyle == -1)"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"	     ExStyle = WS_EX_CLIENTEDGE;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    DlgTemplate_AddControl(lpdp, nLeft, nTop, nWidth, nHeight, id, 0, Style, ExStyle, "+DQ$+"EDIT"+DQ$+", txt, 0, 0);"
        FPRINT FP_WRITE,"}"
	End If
	If Use_BC9Label Then
        FPRINT FP_WRITE,"void BC9_Label (const char*  txt, PDLGTEMPLATEEX*  lpdp, int id, int nLeft, int nTop, int nWidth, int nHeight, int Style, int ExStyle)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    if(!Style )"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"        Style = WS_CHILD | SS_NOTIFY | SS_LEFT | WS_VISIBLE;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    DlgTemplate_AddControl(lpdp, nLeft, nTop, nWidth, nHeight, id, 0, Style, ExStyle, "+DQ$+"STATIC"+DQ$+", txt, 0, 0);"
        FPRINT FP_WRITE,"}"
	End If
	If Use_BC9Listbox Then
        FPRINT FP_WRITE,"void BC9_Listbox (const char*  txt, PDLGTEMPLATEEX*  lpdp, int id, int nLeft, int nTop, int nWidth, int nHeight, int Style, int ExStyle)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    if(!Style )"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"        Style = LBS_STANDARD | WS_CHILD | WS_VISIBLE | LBS_SORT | WS_VSCROLL | WS_TABSTOP;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    if(ExStyle == -1)"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"	     ExStyle = WS_EX_CLIENTEDGE;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    DlgTemplate_AddControl(lpdp, nLeft, nTop, nWidth, nHeight, id, 0, Style, ExStyle, "+DQ$+"LISTBOX"+DQ$+", txt, 0, 0);"
        FPRINT FP_WRITE,"}"
	End If
	If Use_BC9Listview Then
        FPRINT FP_WRITE,"void BC9_Listview (const char*  txt, PDLGTEMPLATEEX*  lpdp, int id, int nLeft, int nTop, int nWidth, int nHeight, int Style, int ExStyle)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    if(!Style )"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"        Style = WS_CHILD | WS_TABSTOP | WS_VISIBLE | 0x241 | WS_BORDER;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    DlgTemplate_AddControl(lpdp, nLeft, nTop, nWidth, nHeight, id, 0, Style, ExStyle, "+DQ$+"SysListView32"+DQ$+", txt, 0, 0);"
        FPRINT FP_WRITE,"}"
	End If
	If Use_BC9Bitmap Then
        FPRINT FP_WRITE,"void BC9_Bitmap (const char*  ResId, PDLGTEMPLATEEX*  lpdp, int id, int nLeft, int nTop, int nWidth, int nHeight, int Style, int ExStyle)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    if(!Style )"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"        Style = WS_CLIPSIBLINGS | WS_CHILD | WS_VISIBLE | SS_BITMAP;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    DlgTemplate_AddControl(lpdp, nLeft, nTop, nWidth, nHeight, id, 0, Style, ExStyle, "+DQ$+"STATIC"+DQ$+", ResId, 0, 0);"
        FPRINT FP_WRITE,"}"
	End If
    If Use_BC9Icon Then
        FPRINT FP_WRITE,"void BC9_Icon (const char*  ResId, PDLGTEMPLATEEX*  lpdp, int id, int nLeft, int nTop, int nWidth, int nHeight, int Style, int ExStyle)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    if(!Style )"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"        Style = WS_CHILD | WS_VISIBLE | SS_ICON;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    DlgTemplate_AddControl(lpdp, nLeft, nTop, nWidth, nHeight, id, 0, Style, ExStyle, "+DQ$+"STATIC"+DQ$+", ResId, 0, 0);"
        FPRINT FP_WRITE,"}"
    End If
    If Use_BC9Radio Then
        FPRINT FP_WRITE,"void BC9_Radio (const char*  txt, PDLGTEMPLATEEX*  lpdp, int id, int nLeft, int nTop, int nWidth, int nHeight, int Style, int ExStyle)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    if(!Style )"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"        Style = WS_CHILD | WS_VISIBLE | BS_AUTORADIOBUTTON | WS_TABSTOP;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    DlgTemplate_AddControl(lpdp, nLeft, nTop, nWidth, nHeight, id, 0, Style, ExStyle, "+DQ$+"BUTTON"+DQ$+", txt, 0, 0);"
        FPRINT FP_WRITE,"}"
    End If
    If Use_BC9RichEdit Then
        FPRINT FP_WRITE,"void BC9_RichEdit (const char*  txt, PDLGTEMPLATEEX*  lpdp, int id, int nLeft, int nTop, int nWidth, int nHeight, int Style, int ExStyle)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    LoadLibrary("+DQ$+"RICHED20.DLL"+DQ$+");"
        FPRINT FP_WRITE,"    if(!Style )"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"        Style = WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL | ES_AUTOHSCROLL | ES_WANTRETURN;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    DlgTemplate_AddControl(lpdp, nLeft, nTop, nWidth, nHeight, id, 0, Style, ExStyle, RICHEDIT_CLASS, txt, 0, 0);"
        FPRINT FP_WRITE,"}"
    End If
    If Use_BC9Status Then
        FPRINT FP_WRITE,"void BC9_Status (const char*  txt, PDLGTEMPLATEEX*  lpdp, int id, int Style)"
        FPRINT FP_WRITE,"{"
'        FPRINT FP_WRITE,"    if(!Style )"
'        FPRINT FP_WRITE,"    {"
'        FPRINT FP_WRITE,"        Style = WS_CHILD | WS_VISIBLE | CCS_BOTTOM;"
'        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    DlgTemplate_AddControl(lpdp, 0, 0, 0, 0, id, 0, Style, 0, "+DQ$+"msctls_statusbar32"+DQ$+", txt, 0, 0);"
        FPRINT FP_WRITE,"}"

        FPRINT FP_WRITE,"void BC9_SetSbParts (HWND sbar, double* sParts)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    int      i;"
        FPRINT FP_WRITE,"    int      j;"
        FPRINT FP_WRITE,"    int      k;"
        FPRINT FP_WRITE,"    RECT     r;"
        'FPRINT FP_WRITE,"    char    t[cSizeOfDefaultString] = {0};"
        FPRINT FP_WRITE,"    int      parts[16] = {0};"
        FPRINT FP_WRITE,"    GetClientRect(sbar, &r);"
        FPRINT FP_WRITE,"    j = 0;"
        FPRINT FP_WRITE,"    i = 0;"
        FPRINT FP_WRITE,"    k = r.right * sParts[0];"
        FPRINT FP_WRITE,"    if(k == 0 )"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"        return;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    parts[i]  = k;"
        FPRINT FP_WRITE,"    for(;;)"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"        i++;"
        FPRINT FP_WRITE,"        j++;"
        FPRINT FP_WRITE,"        if(sParts[j] == 0 )"
        FPRINT FP_WRITE,"        {"
        FPRINT FP_WRITE,"            break;"
        FPRINT FP_WRITE,"        }"
        FPRINT FP_WRITE,"        k = k + ( r.right * sParts[j]);"
        FPRINT FP_WRITE,"        parts[i]  = k;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    SendMessage(sbar, (UINT)SB_SETPARTS, (WPARAM)i, (LPARAM)parts);"
        FPRINT FP_WRITE,"}"
    End If

    If Use_BC9Tab Then
        FPRINT FP_WRITE,"void CenterChildOnTab (HWND hWndChild, HWND hWndTab)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    RECT     WndRectTab = {0};"
        FPRINT FP_WRITE,"    RECT     WndRectChild = {0};"
        FPRINT FP_WRITE,"    int      x = {0};"
        FPRINT FP_WRITE,"    int      y = {0};"
        FPRINT FP_WRITE,"    GetWindowRect(hWndTab, &WndRectTab);"
        FPRINT FP_WRITE,"    TabCtrl_AdjustRect(hWndTab, FALSE, &WndRectTab);"
        FPRINT FP_WRITE,"    MapWindowPoints(0, GetParent(hWndTab), (LPPOINT)&WndRectTab, 2);"
        FPRINT FP_WRITE,"    GetWindowRect(hWndChild, &WndRectChild);"
        FPRINT FP_WRITE,"    MapWindowPoints(0, GetParent(hWndTab), (LPPOINT)&WndRectChild, 2);"
        FPRINT FP_WRITE,"    x = ( RECTWIDTH( WndRectTab) - ( RECTWIDTH( WndRectChild))) / 2;"
        FPRINT FP_WRITE,"    y = ( RECTHEIGHT( WndRectTab) - ( RECTHEIGHT( WndRectChild))) / 2;"
        FPRINT FP_WRITE,"    x += WndRectTab.left;"
        FPRINT FP_WRITE,"    y += WndRectTab.top;"
        FPRINT FP_WRITE,"    MoveWindow(hWndChild, x, y, RECTWIDTH(WndRectChild), RECTHEIGHT(WndRectChild), 1);"
        FPRINT FP_WRITE,"}"

        FPRINT FP_WRITE,"void InitTab (HWND hTab, HWND* hPages, PDLGTEMPLATEEX* Tmpl)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    HWND     hDlg = GetParent(hTab);"
        FPRINT FP_WRITE,"    HWND     hTabStc;"
        FPRINT FP_WRITE,"    TC_ITEM  tc = {0};"
        FPRINT FP_WRITE,"    int      j = {0};"
        FPRINT FP_WRITE,"    int      k = {0};"
        FPRINT FP_WRITE,"    int      ExitFlag = {0};"
        FPRINT FP_WRITE,"    int      Page = {0};"
        FPRINT FP_WRITE,"    char    txt[cSizeOfDefaultString] = {0};"
        FPRINT FP_WRITE,"    char    d[cSizeOfDefaultString] = {0};"
        FPRINT FP_WRITE,"    RECT     WndRectTab = {0};"
        FPRINT FP_WRITE,"    long     x = {0};"
        FPRINT FP_WRITE,"    long     y = {0};"
        FPRINT FP_WRITE,"    tc.mask = TCIF_TEXT;"
        FPRINT FP_WRITE,"    GetWindowText(hTab, txt, sizeof(txt));"
        FPRINT FP_WRITE,"    for(;;)"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"        if(txt[j] == 44 || txt[j] == 0 )"
        FPRINT FP_WRITE,"        {"
        FPRINT FP_WRITE,"            d[k]  = 0;"
        FPRINT FP_WRITE,"            if(txt[j] == 0 )"
        FPRINT FP_WRITE,"            {"
        FPRINT FP_WRITE,"                ExitFlag = 1;"
        FPRINT FP_WRITE,"            }"
        FPRINT FP_WRITE,"            else if(txt[j] == 44 )"
        FPRINT FP_WRITE,"            {"
        FPRINT FP_WRITE,"                ExitFlag = 2;"
        FPRINT FP_WRITE,"            }"
        FPRINT FP_WRITE,"            else"
        FPRINT FP_WRITE,"            {"
        FPRINT FP_WRITE,"                ExitFlag = 0;"
        FPRINT FP_WRITE,"            }"
        FPRINT FP_WRITE,"        }"
        FPRINT FP_WRITE,"        else"
        FPRINT FP_WRITE,"        {"
        FPRINT FP_WRITE,"            d[k]  = txt[ j];"
        FPRINT FP_WRITE,"        }"
        FPRINT FP_WRITE,"        j++;"
        FPRINT FP_WRITE,"        k++;"
        FPRINT FP_WRITE,"        if(ExitFlag )"
        FPRINT FP_WRITE,"        {"
        FPRINT FP_WRITE,"            tc.pszText = d;"
        FPRINT FP_WRITE,"            TabCtrl_InsertItem(hTab, Page, &tc);"
        FPRINT FP_WRITE,"            hPages[Page] = BC9_DlgShow( Tmpl[Page], ( DLGPROC) TabDlgProc, hDlg, 0);"
        FPRINT FP_WRITE,"            CenterChildOnTab(hPages[Page], hTab);"
        FPRINT FP_WRITE,"            if(ExitFlag == 1 )"
        FPRINT FP_WRITE,"            {"
        FPRINT FP_WRITE,"                break;"
        FPRINT FP_WRITE,"            }"
        FPRINT FP_WRITE,"            ExitFlag = 0;"
        FPRINT FP_WRITE,"            Page++;"
        FPRINT FP_WRITE,"            k = 0;"
        FPRINT FP_WRITE,"            d[k]  = 0;"
        FPRINT FP_WRITE,"        }"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    hTabStc = GetDlgItem( hDlg, IDC_TAB_STATIC);"
        FPRINT FP_WRITE,"    SetWindowPos(hTab, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOSIZE |  SWP_NOMOVE);"
        FPRINT FP_WRITE,"    GetWindowRect(hTab, &WndRectTab);"
        FPRINT FP_WRITE,"    TabCtrl_AdjustRect(hTab, FALSE, &WndRectTab);"
        FPRINT FP_WRITE,"    MapWindowPoints(0, hDlg, (LPPOINT)&WndRectTab, 2);"
        FPRINT FP_WRITE,"    x = WndRectTab.left - 1;"
        FPRINT FP_WRITE,"    y = WndRectTab.top;"
        FPRINT FP_WRITE,"    MoveWindow(hTabStc, x, y, RECTWIDTH(WndRectTab), RECTHEIGHT(WndRectTab), 1);"
        FPRINT FP_WRITE,"}"

        FPRINT FP_WRITE,"void BC9_Tab (const char*  txt, PDLGTEMPLATEEX*  lpdp, int id, int nLeft, int nTop, int nWidth, int nHeight, int Style, int ExStyle)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    if(!Style )"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"        Style = WS_CHILD | WS_VISIBLE | WS_TABSTOP | TCS_FOCUSNEVER;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    DlgTemplate_AddControl(lpdp, nLeft, nTop, nWidth, nHeight, id, 0, Style, ExStyle, "+DQ$+"SysTabControl32"+DQ$+", txt, 0, 0);"
        FPRINT FP_WRITE,"    DlgTemplate_AddControl(lpdp, nLeft, nTop, nWidth, nHeight, IDC_TAB_STATIC, 0, WS_CHILD | WS_VISIBLE, 0, "+DQ$+"Static"+DQ$+","+DDQ$+", 0, 0);"
        FPRINT FP_WRITE,"}"

        FPRINT FP_WRITE,"PDLGTEMPLATEEX BC9_TabPage (int nWidth, int nHeight, const char*  FontFace, int FontSize, int FontWeight)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    static PDLGTEMPLATEEX  lpdp;"
        'FPRINT FP_WRITE,"    DWORD    Style = WS_CHILDWINDOW | NOT WS_VISIBLE | WS_CLIPCHILDREN | DS_CONTROL;"
        FPRINT FP_WRITE,"    DWORD    Style = WS_CHILD | WS_CLIPCHILDREN | DS_CONTROL;"
        FPRINT FP_WRITE,"    DWORD    ExStyle = WS_EX_CONTROLPARENT;"
        FPRINT FP_WRITE,"    if(FontSize )"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"        Style = Style | DS_SETFONT;"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"    lpdp = DlgTemplate_Create( Style, ExStyle, 0, 0, 0, nWidth, nHeight, "+DDQ$+", "+DDQ$+", "+DDQ$+", FontSize, 400, 0, FontFace);"
        FPRINT FP_WRITE,"    return lpdp;"
        FPRINT FP_WRITE,"}"

    End If

	If Use_BC9HCenterCtrlOnDialog Then
        FPRINT FP_WRITE,"void BC9_HCenterCtrlOnDialog (HWND hWndCtrl, HWND hDlg)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    RECT     CtrlRect = {0};"
        FPRINT FP_WRITE,"    RECT     DlgRect = {0};"
        FPRINT FP_WRITE,"    GetClientRect(hDlg, &DlgRect);"
        FPRINT FP_WRITE,"    GetWindowRect(hWndCtrl, &CtrlRect);"
        FPRINT FP_WRITE,"    MapWindowPoints(0, hDlg, (LPPOINT)&CtrlRect, 2);"
        FPRINT FP_WRITE,"    MoveWindow(hWndCtrl, CtrlRect.left, (RECTHEIGHT(DlgRect) - RECTHEIGHT(CtrlRect)) / 2, RECTWIDTH(CtrlRect), RECTHEIGHT(CtrlRect), 1);"
        FPRINT FP_WRITE,"}"
	End If

	If Use_BC9VCenterCtrlOnDialog Then
        FPRINT FP_WRITE,"void BC9_VCenterCtrlOnDialog (HWND hWndCtrl, HWND hDlg)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"    RECT     CtrlRect = {0};"
        FPRINT FP_WRITE,"    RECT     DlgRect = {0};"
        FPRINT FP_WRITE,"    GetClientRect(hDlg, &DlgRect);"
        FPRINT FP_WRITE,"    GetWindowRect(hWndCtrl, &CtrlRect);"
        FPRINT FP_WRITE,"    MapWindowPoints(0, hDlg, (LPPOINT)&CtrlRect, 2);"
        FPRINT FP_WRITE,"    MoveWindow(hWndCtrl, (RECTWIDTH(DlgRect) - RECTWIDTH(CtrlRect)) / 2, CtrlRect.top, RECTWIDTH(CtrlRect), RECTHEIGHT(CtrlRect), 1);"
        FPRINT FP_WRITE,"}"
	End If
'jcfuller added 01/27/2015
    If Use_BC9_MsgPump Then
        FPRINT FP_WRITE,"int BC9_MsgPump (HACCEL  Accel)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"  MSG  Msg;"
        FPRINT FP_WRITE,"  if(Accel)"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"      while(GetMessage(&Msg,NULL,0,0) > 0)"
        FPRINT FP_WRITE,"        {"
        FPRINT FP_WRITE,"          if((!TranslateAccelerator(GetActiveWindow(),Accel,&Msg)&&!IsWindow(GetActiveWindow()))||!IsDialogMessage(GetActiveWindow(),&Msg))"
        FPRINT FP_WRITE,"            {"
        FPRINT FP_WRITE,"              TranslateMessage(&Msg);"
        FPRINT FP_WRITE,"              DispatchMessage(&Msg);"
        FPRINT FP_WRITE,"            }"
        FPRINT FP_WRITE,"        }"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"  else"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"      while(GetMessage(&Msg,NULL,0,0)>0)"
        FPRINT FP_WRITE,"        {"
        FPRINT FP_WRITE,"          if(!IsWindow(GetActiveWindow())||!IsDialogMessage(GetActiveWindow(),&Msg))"
        FPRINT FP_WRITE,"            {"
        FPRINT FP_WRITE,"              TranslateMessage(&Msg);"
        FPRINT FP_WRITE,"              DispatchMessage(&Msg);"
        FPRINT FP_WRITE,"            }"
        FPRINT FP_WRITE,"        }"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"  return Msg.wParam;"
        FPRINT FP_WRITE,sENDBCXRTLIB$
    End If

    IF Use_MDIGUINoMain THEN
      IF Use_BCX_MDI_MsgPump THEN
        IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_MDI_MsgPump"
        FPRINT FP_WRITE,"int BCX_MDI_MsgPump (HACCEL  Accel)"
        FPRINT FP_WRITE,"{"
        FPRINT FP_WRITE,"  MSG  Msg;"
        FPRINT FP_WRITE,"  if(Accel)"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"      if(!BCX_hwndMDIClient)"
        FPRINT FP_WRITE,"        {"
        FPRINT FP_WRITE,"          return FALSE;"
        FPRINT FP_WRITE,"        }"
        FPRINT FP_WRITE,"      while(GetMessage(&Msg,NULL,0,0) > 0)"
        FPRINT FP_WRITE,"        {"
        FPRINT FP_WRITE,"          if(!TranslateMDISysAccel(BCX_hwndMDIClient,&Msg))"
        FPRINT FP_WRITE,"            {"
        FPRINT FP_WRITE,"              if(!TranslateAccelerator(GetActiveWindow(),Accel,&Msg))"
        FPRINT FP_WRITE,"                {"
        FPRINT FP_WRITE,"                  TranslateMessage(&Msg);"
        FPRINT FP_WRITE,"                  DispatchMessage(&Msg);"
        FPRINT FP_WRITE,"                }"
        FPRINT FP_WRITE,"            }"
        FPRINT FP_WRITE,"        }"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"  else"
        FPRINT FP_WRITE,"    {"
        FPRINT FP_WRITE,"      if(!BCX_hwndMDIClient)"
        FPRINT FP_WRITE,"        {"
        FPRINT FP_WRITE,"          return FALSE;"
        FPRINT FP_WRITE,"        }"
        FPRINT FP_WRITE,"      while(GetMessage(&Msg,NULL,0,0) > 0)"
        FPRINT FP_WRITE,"        {"
        FPRINT FP_WRITE,"          if(!TranslateMDISysAccel(BCX_hwndMDIClient,&Msg))"
        FPRINT FP_WRITE,"            {"
        FPRINT FP_WRITE,"              TranslateMessage(&Msg);"
        FPRINT FP_WRITE,"              DispatchMessage(&Msg);"
        FPRINT FP_WRITE,"            }"
        FPRINT FP_WRITE,"        }"
        FPRINT FP_WRITE,"    }"
        FPRINT FP_WRITE,"  return Msg.wParam;"
        FPRINT FP_WRITE,sENDBCXRTLIB$
      END IF
    END IF


    IF Use_BCX_RegWnd THEN
      IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_RegWnd"
      FPRINT FP_WRITE,"void BCX_RegWnd (const char *classname, WNDPROC Form_WndProc)"
      FPRINT FP_WRITE,"{"
      FPRINT FP_WRITE,"  if(classname[0]==0)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      MessageBox (GetActiveWindow(),", ENC$("Empty String For BCX_ClassName NOT Allowed"), ",", ENC$("Empty ClassName"), ",0);"

'jcfuller changed. Why when it is a gui app with no console? with it you need to add stdio.h.
'      FPRINT FP_WRITE,"      fflush(stdout);"

      FPRINT FP_WRITE,"      ExitProcess(1);"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"  if(GetClassInfoEx( BCX_hInstance, (char*)classname, &BCX_WndClass)!=0)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      if(!Form_WndProc)"
      FPRINT FP_WRITE,"        {"
      FPRINT FP_WRITE,"          UnregisterClass((char*)classname,BCX_hInstance);"
      FPRINT FP_WRITE,"        }"
      FPRINT FP_WRITE,"      return;"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"  if(!BCX_GUI_Init)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      BCX_InitGUI();"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"  if(BCX_ScaleX==0&&BCX_ScaleY==0)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      BCX_SetMetric(", ENC$("Pixels"), ");"
      FPRINT FP_WRITE,"    }"
      FPRINT FP_WRITE,"  strcpy(BCX_ClassName,(char*)classname);"
      FPRINT FP_WRITE,"  BCX_WndClass.lpfnWndProc=Form_WndProc;"
      FPRINT FP_WRITE,"  BCX_WndClass.hInstance=BCX_hInstance;"
      FPRINT FP_WRITE,"  BCX_WndClass.lpszClassName=(char*)classname;"

      'IF LEN(GUIMenu$) THEN
        'g_ResMenu$=GUIMenu$
      	'FPRINT FP_WRITE,"  BCX_WndClass.lpszMenuName=",GUIMenu$,";"
      'ELSE
        'g_ResMenu$=""
      'END IF
        FPRINT FP_WRITE,"  BCX_WndClass.lpszMenuName=g_ResMenu;"


      FPRINT FP_WRITE,"  RegisterClassEx(&BCX_WndClass);"
      FPRINT FP_WRITE,sENDBCXRTLIB$
    END IF


    IF Use_BCX_InitGUI THEN
      IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_InitGUI"
      FPRINT FP_WRITE,"void BCX_InitGUI (void)"
      FPRINT FP_WRITE,"{"
      FPRINT FP_WRITE,"  INITCOMMONCONTROLSEX  iccex;"
      FPRINT FP_WRITE,"  if(BCX_GUI_Init)"
      FPRINT FP_WRITE,"    {"
      FPRINT FP_WRITE,"      return;"
      FPRINT FP_WRITE,"    }"
      IF UCASE$(GUIMetric$) = "PIXELS" THEN
        FPRINT FP_WRITE,"  BCX_ScaleX=1;"
        FPRINT FP_WRITE,"  BCX_ScaleY=1;"
      ELSEIF UCASE$(GUIMetric$) = "DPI" THEN   
'        FPRINT FP_WRITE,"  BCX_ScaleX=1;"
'        FPRINT FP_WRITE,"  BCX_ScaleY=1;"
         FPRINT FP_WRITE,"      HDC      hDc = GetDC(0);"
         FPRINT FP_WRITE,"      BCX_ScaleX = ( GetDeviceCaps( hDc, LOGPIXELSX) / 96.0f);"
         FPRINT FP_WRITE,"      BCX_ScaleY = ( GetDeviceCaps( hDc, LOGPIXELSY) / 96.0f);"
         FPRINT FP_WRITE,"      ReleaseDC(0, hDc);"
      ELSE
        FPRINT FP_WRITE,"  RECT  rc={0,0,4,8};"
        FPRINT FP_WRITE,"  MapDialogRect(NULL,&rc);"
        FPRINT FP_WRITE,"  BCX_ScaleX=rc.right/2;"
        FPRINT FP_WRITE,"  BCX_ScaleY=rc.bottom/4;"
      END IF
      FPRINT FP_WRITE,"  BCX_hInstance=GetModuleHandle(NULL);"
      FPRINT FP_WRITE,"  BCX_hwndMDIClient=NULL;"
      FPRINT FP_WRITE,"  BCX_WndClass.cbSize=sizeof(BCX_WndClass);"
      FPRINT FP_WRITE,"  BCX_WndClass.style=CS_HREDRAW | CS_VREDRAW | CS_OWNDC;"
      FPRINT FP_WRITE,"  BCX_WndClass.cbClsExtra=0;"
      If DlgWin Then
		FPRINT FP_WRITE,"  BCX_WndClass.cbWndExtra=DLGWINDOWEXTRA;"
      Else
		FPRINT FP_WRITE,"  BCX_WndClass.cbWndExtra=0;"
	  End If
      IF GUIIcon$ = "" THEN GUIIcon$ = " LoadIcon(NULL,IDI_WINLOGO);"
      FPRINT FP_WRITE,"  BCX_WndClass.hIcon=";GUIIcon$;";"
      FPRINT FP_WRITE,"  BCX_WndClass.hCursor=LoadCursor(NULL,IDC_ARROW);"
      FPRINT FP_WRITE,"  BCX_WndClass.hbrBackground=(HBRUSH)(COLOR_BTNFACE+1);"
      IF LEN(GUIMenu$) THEN
        'g_ResMenu$=GUIMenu$
      	'FPRINT FP_WRITE,"  BCX_WndClass.lpszMenuName=",GUIMenu$,";"
      	'! g_ResMenu=NULL;
      'ELSE

      END IF
        'FPRINT FP_WRITE,"  BCX_WndClass.lpszMenuName=NULL;"
       FPRINT FP_WRITE,"  BCX_WndClass.lpszMenuName=g_ResMenu;"

      FPRINT FP_WRITE,"  BCX_WndClass.hIconSm=NULL;"
      FPRINT FP_WRITE,"  iccex.dwSize=sizeof(INITCOMMONCONTROLSEX);"
      FPRINT FP_WRITE,"  iccex.dwICC=ICC_LISTVIEW_CLASSES | ICC_TREEVIEW_CLASSES | ICC_BAR_CLASSES | ICC_TAB_CLASSES | ICC_UPDOWN_CLASS | ICC_PROGRESS_CLASS | ICC_USEREX_CLASSES | ICC_DATE_CLASSES;"
      FPRINT FP_WRITE,"  InitCommonControlsEx(&iccex);"
      'FPRINT FP_WRITE,"  g_argv=NULL;"
      'FPRINT FP_WRITE,"  g_argc=0;"
      FPRINT FP_WRITE,"  BCX_GUI_Init=TRUE;"
      FPRINT FP_WRITE,sENDBCXRTLIB$
    END IF

    IF Use_Library THEN ' add the MDI GUI Code to the BCXRT.LIB
      CALL EmitMDICode(FP_WRITE)
    END IF ' Use_Library
  END IF

END SUB ' RunTimeFunctions



SUB EmitMDI_MsgPump()
  IF LEN(Accelerator$) THEN
    FPRINT Outfile,"  if(!BCX_hwndMDIClient)"
    FPRINT Outfile,"    {"
    FPRINT Outfile,"      return FALSE;"
    FPRINT Outfile,"    }"
    FPRINT Outfile,"  while((GetMessage(&Msg,NULL,0,0)))"
    FPRINT Outfile,"    {"
    FPRINT Outfile,"      HWND hActiveWindow=GetActiveWindow();"
    FPRINT Outfile,"      if((!TranslateMDISysAccel(BCX_hwndMDIClient,&Msg)))"
    FPRINT Outfile,"        {"
    FPRINT Outfile,"          if((!TranslateAccelerator(hActiveWindow,",Accelerator$, ",&Msg)))"
    FPRINT Outfile,"            {"
    FPRINT Outfile,"              TranslateMessage(&Msg);"
    FPRINT Outfile,"              DispatchMessage(&Msg);"
    FPRINT Outfile,"            }"
    FPRINT Outfile,"        }"
    FPRINT Outfile,"    }"
    FPRINT Outfile,"  return Msg.wParam;"
    FPRINT Outfile,"}\n"
  ELSE
    FPRINT Outfile," if(!BCX_hwndMDIClient)"
    FPRINT Outfile," {"
    FPRINT Outfile,"   return FALSE;"
    FPRINT Outfile," }"
    FPRINT Outfile," while((GetMessage(&Msg,NULL,0,0)))"
    FPRINT Outfile,"   {"
    FPRINT Outfile,"   if((!TranslateMDISysAccel(BCX_hwndMDIClient,&Msg)))"
    FPRINT Outfile,"     {"
    FPRINT Outfile,"       TranslateMessage(&Msg);"
    FPRINT Outfile,"       DispatchMessage(&Msg);"
    FPRINT Outfile,"     }"
    FPRINT Outfile,"   }"
    FPRINT Outfile,"return Msg.wParam;"
    FPRINT Outfile,"}\n"
  END IF
END SUB ' EmitMDI_MsgPump



SUB EmitGUI_MsgPump()
  IF LEN(Accelerator$) THEN
    FPRINT Outfile," while(GetMessage(&Msg,NULL,0,0))"
    FPRINT Outfile,"   {"
    FPRINT Outfile,"    HWND hActiveWindow = GetActiveWindow();"
    FPRINT Outfile,"    if(!TranslateAccelerator(hActiveWindow,",Accelerator$,",&Msg) &&"
    FPRINT Outfile,"       !IsDialogMessage(hActiveWindow,&Msg) || !IsWindow(hActiveWindow))"
    FPRINT Outfile,"      {"
    FPRINT Outfile,"        TranslateMessage(&Msg);"
    FPRINT Outfile,"        DispatchMessage(&Msg);"
    FPRINT Outfile,"      }"
    FPRINT Outfile,"   }"
    FPRINT Outfile," return Msg.wParam;"
    FPRINT Outfile,"}\n"
  ELSE
    FPRINT Outfile," while(GetMessage(&Msg,NULL,0,0))"
    FPRINT Outfile,"   {"
    FPRINT Outfile,"    HWND hActiveWindow = GetActiveWindow();"
    FPRINT Outfile,"    if(!IsWindow(hActiveWindow) || !IsDialogMessage(hActiveWindow,&Msg))"
    FPRINT Outfile,"      {"
    FPRINT Outfile,"        TranslateMessage(&Msg);"
    FPRINT Outfile,"        DispatchMessage(&Msg);"
    FPRINT Outfile,"      }"
    FPRINT Outfile,"    }"
    FPRINT Outfile," return Msg.wParam;"
    FPRINT Outfile,"}\n"
  END IF
END SUB



SUB EmitWinGUIMain( classname$, metric$, icon$ )
  FPRINT Outfile,"// **********************************"
  FPRINT Outfile,""
  FPRINT Outfile,"int WINAPI WinMain(HINSTANCE hInst,HINSTANCE hPrev,LPSTR CmdLine,int CmdShow)"
  FPRINT Outfile,"{"
  FPRINT Outfile," MSG      Msg;"
  FPRINT Outfile," strcpy(BCX_ClassName," ; classname$; ");"
  IF LEN(GUIMenu$) THEN
    FPRINT Outfile," strcpy(g_ResMenu," ;GUIMenu$;");"
        'g_ResMenu$=GUIMenu$
  END IF
  FPRINT Outfile," BCX_SetMetric(";ENC$( metric$ );");"
  FPRINT Outfile," BCX_InitGUI();"
  FPRINT Outfile," BCX_hInstance       =  hInst;"
  FPRINT Outfile," BCX_WndClass.hIcon  = " ; icon$
  'jcfuller added 01/19/2105
  If DlgWin Then
	FPRINT Outfile," BCX_RegWnd( BCX_ClassName,";DlgWinProc$;");"
  Else
	FPRINT Outfile," BCX_RegWnd( BCX_ClassName, WndProc );"
  End If
  FPRINT Outfile,"\n"
  FPRINT Outfile," // ******************************************"
  FPRINT Outfile,"                  FormLoad();"
  FPRINT Outfile," // ******************************************\n"
END SUB



SUB EmitMDICode(FP_WRITE AS FILE)
  IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_MDICHILD"
  FPRINT FP_WRITE,"HWND BCX_MDICHILD (const char *title, const char *MdiClassName,int x,int y,int cx,int cy,DWORD style,LPARAM lParam)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  HWND  hwndChild;"
  FPRINT FP_WRITE,"  char rgch";cSizeOfADefaultString$;" ={0};"
  FPRINT FP_WRITE,"  static int cUntitled=1;"
  FPRINT FP_WRITE,"  if(title[0]==0)"
  FPRINT FP_WRITE,"    {"
  FPRINT FP_WRITE,"      sprintf(rgch," &  ENC$("%s%i") & "," & ENC$("Untitled") & ",cUntitled++);"
  FPRINT FP_WRITE,"    }"
  FPRINT FP_WRITE,"  else"
  FPRINT FP_WRITE,"    {"
  FPRINT FP_WRITE,"      strcpy(rgch,title);"
  FPRINT FP_WRITE,"    }"
  FPRINT FP_WRITE,"  //  Create the MDI child window"
  FPRINT FP_WRITE,"  hwndChild = CreateMDIWindow(MdiClassName, rgch, style, x, y,"
  FPRINT FP_WRITE,"              cx, cy, BCX_hwndMDIClient, BCX_hInstance, lParam);"
  FPRINT FP_WRITE,"  return hwndChild;"
  FPRINT FP_WRITE,sENDBCXRTLIB$

  IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_MDICLASS"
  'FPRINT FP_WRITE,"void BCX_MDICLASS (WNDPROC MCWP, const PCHAR ClassName)"
  FPRINT FP_WRITE,"void BCX_MDICLASS (WNDPROC MCWP, const char* ClassName)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  WNDCLASS wc={0};"
  FPRINT FP_WRITE,"  wc.style=0;"
  FPRINT FP_WRITE,"  wc.lpfnWndProc=(WNDPROC)MCWP;"
  FPRINT FP_WRITE,"  wc.cbClsExtra=0;"
  FPRINT FP_WRITE,"  wc.cbWndExtra=20;"
  FPRINT FP_WRITE,"  wc.hInstance=BCX_hInstance;"
  FPRINT FP_WRITE,"  wc.hIcon= " & GUIIcon$
  FPRINT FP_WRITE,"  wc.hCursor=LoadCursor(NULL,IDC_ARROW);"
  FPRINT FP_WRITE,"  wc.hbrBackground=(HBRUSH)(COLOR_WINDOW+1);"
  FPRINT FP_WRITE,"  wc.lpszMenuName=NULL;"
  FPRINT FP_WRITE,"  wc.lpszClassName=ClassName;"
  FPRINT FP_WRITE,"  RegisterClass((LPWNDCLASS)&wc);"
  FPRINT FP_WRITE,sENDBCXRTLIB$


  IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_MDICLIENT"
  FPRINT FP_WRITE,"HWND BCX_MDICLIENT (HWND hwndparent, int icount)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  CLIENTCREATESTRUCT ccs={0,1};"
  FPRINT FP_WRITE,"  //  Find window menu where children will be listed"
  FPRINT FP_WRITE,"  ccs.hWindowMenu=GetSubMenu(GetMenu(hwndparent),icount-1);"
  FPRINT FP_WRITE,"  //  Create the MDI client filling the client area"
  FPRINT FP_WRITE,"  BCX_hwndMDIClient=CreateWindow(", ENC$("MDICLIENT"), ",NULL,WS_CHILD|WS_CLIPCHILDREN|WS_VISIBLE|WS_VSCROLL|WS_HSCROLL,"
  FPRINT FP_WRITE,"                                 0,0,0,0,hwndparent,(HMENU)NULL,BCX_hInstance,(LPVOID)&ccs);"
  FPRINT FP_WRITE,"  return BCX_hwndMDIClient;"
  FPRINT FP_WRITE,sENDBCXRTLIB$
END SUB      ' EmitMDICode



SUB UseAll( bCPP AS BOOLEAN )
  Use_SetDimension           = TRUE
  Use_GetDimension           = TRUE
  UseFlag                    = TRUE
  Use_EmptyTmpStr            = TRUE
  UseLCaseTbl                = TRUE
  'Use_Abs                    = TRUE
  Use_Acosh                  = TRUE
  Use_AnsiToWide             = TRUE
  Use_AppActivate            = TRUE
  Use_AppExeName             = TRUE
  Use_AppExePath             = TRUE
  Use_Asc                    = TRUE
  Use_Asinh                  = TRUE
  Use_Atanh                  = TRUE
  Use_BCXDialog              = TRUE
  Use_BCXMDialog             = TRUE
  Use_BCXDialogCommon        = TRUE
  Use_BCX_Arc                = TRUE
  Use_BCX_BmpHeight          = TRUE
  Use_BCX_BmpWidth           = TRUE
  Use_BCX_COM_CreateObject   = TRUE
  Use_BCX_COM_DispatchObject = TRUE
  Use_BCX_COM_GetObject      = TRUE
  Use_BCX_COM_GetProperty    = TRUE
  Use_BCX_COM_InvokeMethod   = TRUE
  Use_BCX_COM_SafeArray      = TRUE
  Use_BCX_COM_SetProperty    = TRUE
  Use_BCX_COM_UsesConversion = TRUE
  Use_BCX_Circle             = TRUE
  Use_BCX_Class_Info         = TRUE
  Use_BCX_Colordlg           = TRUE
  Use_BCX_Control            = TRUE
  Use_BCX_Ellipse            = TRUE
  Use_BCX_Floodfill          = TRUE
  Use_BCX_Fontdlg            = TRUE
  Use_BCX_FrameWnd           = TRUE
  Use_BCX_Get                = TRUE
  Use_BCX_Get_UpDown         = TRUE
  Use_BCX_Getpixel           = TRUE
  Use_BCX_InitGUI            = TRUE
  Use_BCX_Input              = TRUE
  Use_BCX_Line               = TRUE
  Use_BCX_Lineto             = TRUE
  Use_BCX_LoadBMP            = TRUE
  Use_BCX_LoadImage          = TRUE
  Use_BCX_MDI_MsgPump        = TRUE
  Use_BCX_MsgPump            = TRUE
  Use_BCX_OlePicture         = TRUE
  Use_BCX_Path               = TRUE
  Use_BcxSplitPath           = TRUE
  Use_BCX_PolyBezier         = TRUE
  Use_BCX_Polygon            = TRUE
  Use_BCX_Polyline           = TRUE
  Use_BCX_Preset             = TRUE
  Use_BCX_Print              = TRUE
  Use_BCX_Pset               = TRUE
  Use_BCX_Put                = TRUE
  Use_BCX_Rectangle          = TRUE
  Use_BCX_RegWnd             = TRUE
  Use_BCX_Roundrect          = TRUE
  Use_BCX_SetBkGrdBrush      = TRUE
  Use_BCX_SetClassStyle      = TRUE
  Use_BCX_SetCursor          = TRUE
  Use_BCX_SetIcon            = TRUE
  Use_BCX_SetIconSm          = TRUE
  Use_BCX_SetMetric          = TRUE
  Use_BCX_Slider             = TRUE
  Use_BCX_Splitter           = TRUE
  Use_BCX_Tab                = TRUE
  Use_BCX_Tile               = TRUE
  Use_BCX_Toolbar            = TRUE
  Use_BCX_UpDown             = TRUE
  Use_BCX_Wnd                = TRUE
  Use_BEL                    = TRUE
  Use_BS                     = TRUE
  Use_Bff                    = TRUE
  Use_Bin                    = TRUE
  Use_Bin2dec                = TRUE
  Use_Bitmap                 = TRUE
  Use_Blackrect              = TRUE
  Use_BmpButton              = TRUE
  Use_Boolstr                = TRUE
  Use_Button                 = TRUE
  Use_COM                    = TRUE
  Use_CR                     = TRUE
  Use_Center                 = TRUE
  Use_Checkbox               = TRUE
  Use_Chr                    = TRUE
  Use_Cint                   = TRUE
  Use_Cls                    = TRUE
  Use_Color                  = TRUE
  Use_ComboBoxLoadFile       = TRUE
  Use_Combobox               = TRUE
  Use_Command                = TRUE
  Use_Console                = TRUE
  Use_ContainedIn            = TRUE
  Use_CreateRegInt           = TRUE
  Use_CreateRegString        = TRUE
  Use_Crlf                   = TRUE
  Use_Csrlin                 = TRUE
  Use_Curdir                 = TRUE
  Use_Cvd                    = TRUE
  Use_Cvi                    = TRUE
  Use_Cvl                    = TRUE
  Use_Cvld                   = TRUE
  Use_Cvs                    = TRUE
  Use_DDQ                    = TRUE
  Use_DQ                     = TRUE
  Use_DSplit                 = TRUE
  Use_Date                   = TRUE
  Use_Datepick               = TRUE
  Use_Del                    = TRUE
  Use_DeleteRegKey           = TRUE
  Use_Doevents               = TRUE
  Use_Download               = TRUE
  Use_Draw                   = TRUE
  Use_DrawTransBMP           = TRUE
  Use_DynStrqsorta           = TRUE
  Use_DynStrqsortd           = TRUE
  Use_Dynacall               = TRUE
  Use_DynacallCommon         = TRUE
  Use_DynamicA               = TRUE
  Use_EOF                    = TRUE
  Use_ESC                    = TRUE
  Use_Edit                   = TRUE
  Use_Elf                    = TRUE
  Use_Enclose                = TRUE
  Use_Environ                = TRUE
  Use_Eof                    = TRUE
  Use_Exist                  = TRUE
  Use_Exp                    = TRUE
  Use_Extract                = TRUE
  Use_FF                     = TRUE
  Use_FileLocked             = TRUE
  Use_FillArray              = TRUE
  Use_FindInType             = TRUE
  Use_Findfirst              = TRUE
  Use_Findnext               = TRUE
  Use_FirstInstance          = TRUE
  Use_Form                   = TRUE
  Use_Freefile               = TRUE
  Use_GUINoMain              = TRUE
  Use_GenFree                = TRUE
  Use_GetBmp                 = TRUE
  Use_GetResource            = TRUE
  Use_GetSpecialFolder       = TRUE
  Use_GetText                = TRUE
  Use_GetTextSize            = TRUE
  Use_Getfilename            = TRUE
  Use_GoSub                  = TRUE
  Use_Grayrect               = TRUE
  Use_Group                  = TRUE
  Use_Hex                    = TRUE
  Use_Hex2Dec                = TRUE
  Use_Hook                   = TRUE
  Use_Hscroll                = TRUE
  Use_IRemove                = TRUE
  Use_Icon                   = TRUE
  Use_Idxqsort               = TRUE
  Use_IdxqsortSt             = TRUE
  Use_Iif                    = TRUE
  Use_Inchr                  = TRUE
  Use_Infobox                = TRUE
  Use_BoxCommon              = TRUE
  Use_Inkey                  = TRUE
  Use_InkeyD                 = TRUE
  Use_Inputbox               = TRUE
  Use_Inputbuffer            = TRUE
  Use_Ins                    = TRUE
  Use_Instr                  = TRUE
  Use_Instrrev               = TRUE
  Use_Join                   = TRUE
  Use_Keypress               = TRUE
  Use_LF                     = TRUE
  Use_Label                  = TRUE
  Use_Lcase                  = TRUE
  Use_Left                   = TRUE
  Use_Like                   = TRUE
  Use_ListBoxLoadFile        = TRUE
  Use_Listbox                = TRUE
  Use_Listview               = TRUE
  Use_LoadFile               = TRUE
  Use_Loc                    = TRUE
  Use_Locate                 = TRUE
  Use_Lof                    = TRUE
  Use_Lpad                   = TRUE
  Use_Ltrim                  = TRUE
  Use_MDIGUINoMain           = TRUE
  Use_MainEvent              = TRUE
  Use_Max                    = TRUE
  Use_Mcase                  = TRUE
  Use_Mdigui                 = TRUE
  Use_Mid                    = TRUE
  Use_Midstr                 = TRUE
  Use_Min                    = TRUE
  Use_Mkd                    = TRUE
  Use_Mki                    = TRUE
  Use_Mkl                    = TRUE
  Use_Mkld                   = TRUE
  Use_Mks                    = TRUE
  Use_Modstyle               = TRUE
  Use_Msgbox                 = TRUE
  Use_NUL                    = TRUE
  Use_Now                    = TRUE
  Use_Numqsortadouble        = TRUE
  Use_Numqsortafloat         = TRUE
  Use_Numqsortaint           = TRUE
  Use_Numqsortddouble        = TRUE
  Use_Numqsortdfloat         = TRUE
  Use_Numqsortdint           = TRUE
  Use_OSVersion              = TRUE
  Use_Oct                    = TRUE
  Use_Panel                  = TRUE
  Use_Pause                  = TRUE
  Use_PeekStr                = TRUE
  Use_PlayWav                = TRUE
  Use_Pos                    = TRUE
  Use_Printer                = TRUE
  Use_ProgressBar            = TRUE
  Use_Proto                  = TRUE
  Use_PtrqsortSt             = TRUE
  Use_QBColor                = TRUE
  Use_Radio                  = TRUE
  Use_Randomize              = TRUE
  Use_Rec                    = TRUE
  Use_RecCount               = TRUE
  Use_RegExist               = TRUE
  Use_RegInt                 = TRUE
  Use_RegString              = TRUE
  Use_Remain                 = TRUE
  Use_Remove                 = TRUE
  Use_Repeat                 = TRUE
  Use_Replace                = TRUE
  Use_Retain                 = TRUE
  Use_Reverse                = TRUE
  Use_Richedit               = TRUE
  Use_Right                  = TRUE
  Use_Rnd                    = TRUE
  Use_Round                  = TRUE
  Use_Rpad                   = TRUE
  Use_Rtrim                  = TRUE
  Use_Run                    = TRUE
  Use_SPC                    = TRUE
  Use_SaveBmp                = TRUE
  Use_Scan                   = TRUE
  Use_Screen                 = TRUE
  Use_SearchPath             = TRUE
  Use_SetColor               = TRUE
  Use_SetFont                = TRUE
  Use_SetFormColor           = TRUE
  Use_SetText                = TRUE
  Use_Set_BCX_Bitmap         = TRUE
  Use_Set_BCX_Bitmap2        = TRUE
  Use_Set_BCX_BmpButton      = TRUE
  Use_Set_BCX_Icon           = TRUE
  Use_Sgn                    = TRUE
  Use_Sound                  = TRUE
  Use_Space                  = TRUE
  Use_Split                  = TRUE
  Use_Status                 = TRUE
  Use_Str                    = TRUE
  Use_StrStr                 = TRUE
  Use_Str_Cmp                = TRUE
  Use_Strim                  = TRUE
  Use_String                 = TRUE
  Use_Stristr                = TRUE
  Use_Strl                   = TRUE
  Use_Strqsorta              = TRUE
  Use_Strqsortd              = TRUE
  Use_Strtoken               = TRUE
  Use_Swap                   = TRUE
  Use_SysStr                 = TRUE
  Use_Sysdir                 = TRUE
  Use_SysMacros              = TRUE
  Use_TAB                    = TRUE
  Use_Tally                  = TRUE
  Use_TempFileName           = TRUE
  Use_Tempdir                = TRUE
  Use_Textmode               = TRUE
  Use_Time                   = TRUE
  Use_Timer                  = TRUE
  Use_Treeview               = TRUE
  Use_Trim                   = TRUE
  Use_Ucase                  = TRUE
  Use_Using                  = TRUE
  Use_VBS                    = TRUE
  Use_VChr                   = TRUE
  Use_VT                     = TRUE
  Use_Verify                 = TRUE
  Use_Vscroll                = TRUE
  Use_Whiterect              = TRUE
  Use_WideToAnsi             = TRUE
  Use_Windir                 = TRUE
  Use_Wingui                 = TRUE
  Use_iReplace               = TRUE
  Use_sziif                  = TRUE
  Use_DynAlphaNumericA       = TRUE
  Use_DynAlphaNumericD       = TRUE
  Use_AlphaNumericA          = TRUE
  Use_AlphaNumericD          = TRUE
  Use_AlphaNumeric           = TRUE

  IF bCPP THEN
    UseCpp                   = TRUE
  END IF

  Use_PellesPath             = TRUE
  Use_LccPath                = TRUE

  ' Set Sysmacros

  Use_BCX_Cursor             = TRUE
  Use_Cbool                  = TRUE
  Use_Isptr                  = TRUE
  Use_Band                   = TRUE
  Use_Bor                    = TRUE
  Use_Inp                    = TRUE
  Use_Inpw                   = TRUE
  Use_Outp                   = TRUE
  Use_Outpw                  = TRUE
  Use_Ubound                 = TRUE
  Use_Clear                  = TRUE
  Use_GoSub                  = TRUE
  Use_Imod                   = TRUE
  Use_Show                   = TRUE
  Use_Hide                   = TRUE
  Use_Get                    = TRUE
  Use_Put                    = TRUE
  Use_Strptr                 = TRUE
  Use_Val                    = TRUE
  Use_Vall                   = TRUE
  Use_Getattr                = TRUE
  Use_Setattr                = TRUE
  Use_Fint                   = TRUE
  Use_Frac                   = TRUE
  Use_Fracl                  = TRUE
  Use_Fix                    = TRUE
  Use_Csng                   = TRUE
  Use_Cdbl                   = TRUE
  Use_Cldbl                  = TRUE
  Use_Threads                = TRUE

  GUIIcon$ = " LoadIcon(NULL,IDI_WINLOGO);"

  CALL AddFontVariables()
  CALL AddGlobal("BCX_ClassName",vt_STRVAR, 0,"",0,0,0,0,0)

  SrcTmp$ = "GLOBAL BCX_hwndMDIClient AS HWND"       : CALL XParse(SrcTmp$) : CALL TokenSubstitutions(1) : CALL EmitMain()
  ' already added ??
  'SrcTmp$ = "GLOBAL BCX_hInstance AS HINSTANCE"      : CALL XParse(SrcTmp$) : CALL TokenSubstitutions(1) : CALL EmitMain()
  SrcTmp$ = "GLOBAL BCX_WndClass  AS WNDCLASSEX"     : CALL XParse(SrcTmp$) : CALL TokenSubstitutions(1) : CALL EmitMain()
  SrcTmp$ = "GLOBAL BCX_GUI_Init  AS BOOL"           : CALL XParse(SrcTmp$) : CALL TokenSubstitutions(1) : CALL EmitMain()
  SrcTmp$ = "GLOBAL BcxPtr_hDC        AS HDC"        : CALL XParse(SrcTmp$) : CALL TokenSubstitutions(1) : CALL EmitMain()
  SrcTmp$ = "GLOBAL BcxPtr_FontMetrix AS LONG"       : CALL XParse(SrcTmp$) : CALL TokenSubstitutions(1) : CALL EmitMain()
  SrcTmp$ = "GLOBAL BcxPtr_LineCtr    AS LONG"       : CALL XParse(SrcTmp$) : CALL TokenSubstitutions(1) : CALL EmitMain()
  SrcTmp$ = "GLOBAL BcxPtr_PrinterOn  AS LONG"       : CALL XParse(SrcTmp$) : CALL TokenSubstitutions(1) : CALL EmitMain()
  SrcTmp$ = "GLOBAL BcxPtr_hFont      AS HFONT"      : CALL XParse(SrcTmp$) : CALL TokenSubstitutions(1) : CALL EmitMain()
  SrcTmp$ = "GLOBAL BcxPtr_hFontOld   AS HFONT"      : CALL XParse(SrcTmp$) : CALL TokenSubstitutions(1) : CALL EmitMain()
  SrcTmp$ = "GLOBAL BcxPtr_di         AS DOCINFO"    : CALL XParse(SrcTmp$) : CALL TokenSubstitutions(1) : CALL EmitMain()
  SrcTmp$ = "GLOBAL BcxPtr_Lf         AS LOGFONT"    : CALL XParse(SrcTmp$) : CALL TokenSubstitutions(1) : CALL EmitMain()
  SrcTmp$ = "GLOBAL BcxPtr_tm         AS TEXTMETRIC" : CALL XParse(SrcTmp$) : CALL TokenSubstitutions(1) : CALL EmitMain()
  SrcTmp$ = "GLOBAL BcxPtr_Text$"                    : CALL XParse(SrcTmp$) : CALL TokenSubstitutions(1) : CALL EmitMain()
  SrcTmp$ = "GLOBAL BcxPtr_Buffer$"                  : CALL XParse(SrcTmp$) : CALL TokenSubstitutions(1) : CALL EmitMain()
  SrcTmp$ = "GLOBAL BCX_siX AS SCROLLINFO"           : CALL XParse(SrcTmp$) : CALL TokenSubstitutions(1) : CALL EmitMain()
  SrcTmp$ = "GLOBAL BCX_siY AS SCROLLINFO"           : CALL XParse(SrcTmp$) : CALL TokenSubstitutions(1) : CALL EmitMain()
  SrcTmp$ = "GLOBAL BCX_DynaScroll AS INTEGER"       : CALL XParse(SrcTmp$) : CALL TokenSubstitutions(1) : CALL EmitMain()
  SrcTmp$ = "GLOBAL BCX_ViewWidth AS INTEGER"        : CALL XParse(SrcTmp$) : CALL TokenSubstitutions(1) : CALL EmitMain()
  SrcTmp$ = "GLOBAL BCX_ViewHeight AS INTEGER"       : CALL XParse(SrcTmp$) : CALL TokenSubstitutions(1) : CALL EmitMain()
  SrcTmp$ = "GLOBAL BCX_SmallChangeX AS INTEGER"     : CALL XParse(SrcTmp$) : CALL TokenSubstitutions(1) : CALL EmitMain()
  SrcTmp$ = "GLOBAL BCX_SmallChangeY AS INTEGER"     : CALL XParse(SrcTmp$) : CALL TokenSubstitutions(1) : CALL EmitMain()
  SrcTmp$ = "GLOBAL BCX_LargeChangeX AS INTEGER"     : CALL XParse(SrcTmp$) : CALL TokenSubstitutions(1) : CALL EmitMain()
  SrcTmp$ = "GLOBAL BCX_LargeChangeY AS INTEGER"     : CALL XParse(SrcTmp$) : CALL TokenSubstitutions(1) : CALL EmitMain()
  SrcTmp$ = "GLOBAL BCX_ScrollInit AS INTEGER"       : CALL XParse(SrcTmp$) : CALL TokenSubstitutions(1) : CALL EmitMain()
END SUB ' UseAll


'  Use_DynAlphaNumericA
'  Use_DynAlphaNumericD
'  Use_AlphaNumericA
'  Use_AlphaNumericD
'  Use_AlphaNumeric
SUB SetUsed()
  DIM RAW i,x
  FOR i = 2 TO Ndx
'jcfuller 1/29/2013
    'HFiles$[HFileCnt] = "#include " + DQ$ + EXTRACT$(Stk$[i],".") + ".h" + DQ$
    HFiles$[HFileCnt] = "#include " + DQ$ + RemoveExtension$(Stk$[i]) + ".h" + DQ$
    IF cMaxHFiles = ++HFileCnt THEN CALL Abort("Maximum number of INCLUDE files exceeded.")

    OPEN Stk$[i] FOR INPUT AS fpUse
    WHILE NOT EOF(fpUse)
      LINE INPUT fpUse, Src$
      x = INSTR("ABCDEFGHIJKLMNOPQRSTUVWXYZ",UCASE$(MID$(Src$,5,1)))
      SELECT CASE x
        CASE 1
        'IF Src$ = "Use_Abs" THEN Use_Abs = TRUE
        IF Src$ = "Use_Acosh" THEN Use_Acosh = TRUE
        IF Src$ = "Use_AnsiToWide" THEN Use_AnsiToWide = TRUE
        IF Src$ = "Use_AppActivate" THEN Use_AppActivate = TRUE
        IF Src$ = "Use_AppExeName" THEN Use_AppExeName = TRUE
        IF Src$ = "Use_AppExePath" THEN Use_AppExePath = TRUE
        IF Src$ = "Use_Asc" THEN Use_Asc = TRUE
        IF Src$ = "Use_Asinh" THEN Use_Asinh = TRUE
        IF Src$ = "Use_Atanh" THEN Use_Atanh = TRUE
        CASE  2
        IF Src$ = "Use_BCX_Arc" THEN Use_BCX_Arc = TRUE
        IF Src$ = "Use_BCX_BmpHeight" THEN Use_BCX_BmpHeight = TRUE
        IF Src$ = "Use_BCX_BmpWidth" THEN Use_BCX_BmpWidth = TRUE
        IF Src$ = "Use_BCX_Circle" THEN Use_BCX_Circle = TRUE
        IF Src$ = "Use_BCX_Colordlg" THEN Use_BCX_Colordlg = TRUE
        IF Src$ = "Use_BCX_Control" THEN Use_BCX_Control = TRUE
        IF Src$ = "Use_BCXMDialog" THEN Use_BCXDialogCommon = Use_BCXMDialog = TRUE
        IF Src$ = "Use_BCXDialog" THEN Use_BCXDialogCommon = Use_BCXDialog = TRUE
        IF Src$ = "Use_BCX_Ellipse" THEN Use_BCX_Ellipse = TRUE
        IF Src$ = "Use_BCX_Floodfill" THEN Use_BCX_Floodfill = TRUE
        IF Src$ = "Use_BCX_Fontdlg" THEN Use_BCX_Fontdlg = TRUE
        IF Src$ = "Use_BCX_Get" THEN Use_BCX_Get = TRUE
        IF Src$ = "Use_BCX_Getpixel" THEN Use_BCX_Getpixel = TRUE
        IF Src$ = "Use_BCX_Get_UpDown" THEN Use_BCX_Get_UpDown = TRUE
        IF Src$ = "Use_BCX_Input" THEN Use_BCX_Input = TRUE
        IF Src$ = "Use_BCX_Line" THEN Use_BCX_Line = TRUE
        IF Src$ = "Use_BCX_Lineto" THEN Use_BCX_Lineto = TRUE
        IF Src$ = "Use_BCX_LoadBMP" THEN Use_BCX_LoadBMP = TRUE
        IF Src$ = "Use_BCX_LoadImage" THEN Use_BCX_LoadImage = TRUE
        IF Src$ = "Use_BCX_OlePicture" THEN Use_BCX_OlePicture = TRUE
        IF Src$ = "Use_BCX_Path" THEN Use_BCX_Path = TRUE
        IF Src$ = "Use_BcxSplitPath" THEN Use_BcxSplitPath = TRUE
        IF Src$ = "Use_BCX_PolyBezier" THEN Use_BCX_PolyBezier = TRUE
        IF Src$ = "Use_BCX_Polygon" THEN Use_BCX_Polygon = TRUE
        IF Src$ = "Use_BCX_Polyline" THEN Use_BCX_Polyline = TRUE
        IF Src$ = "Use_BCX_Preset" THEN Use_BCX_Preset = TRUE
        IF Src$ = "Use_BCX_Print" THEN Use_BCX_Print = TRUE
        IF Src$ = "Use_BCX_Pset" THEN Use_BCX_Pset = TRUE
        IF Src$ = "Use_BCX_Put" THEN Use_BCX_Put = TRUE
        IF Src$ = "Use_BCX_Rectangle" THEN Use_BCX_Rectangle = TRUE
        IF Src$ = "Use_BCX_Roundrect" THEN Use_BCX_Roundrect = TRUE
        IF Src$ = "Use_BCX_Tab" THEN Use_BCX_Tab = TRUE
        IF Src$ = "Use_BCX_Toolbar" THEN Use_BCX_Toolbar = TRUE
        IF Src$ = "Use_BCX_Tile" THEN Use_BCX_Tile = TRUE
        IF Src$ = "Use_BCX_UpDown" THEN Use_BCX_UpDown = TRUE
        IF Src$ = "Use_BCX_Slider" THEN Use_BCX_Slider = TRUE
        IF Src$ = "Use_BCX_Splitter" THEN Use_BCX_Splitter = TRUE
        IF Src$ = "Use_Bff" THEN Use_Bff = TRUE
        IF Src$ = "Use_Bin" THEN Use_Bin = TRUE
        IF Src$ = "Use_Bin2dec" THEN Use_Bin2dec = TRUE
        IF Src$ = "Use_Bitmap" THEN Use_Bitmap = TRUE
        IF Src$ = "Use_Blackrect" THEN Use_Blackrect = TRUE
        IF Src$ = "Use_BmpButton" THEN Use_BmpButton = TRUE
        IF Src$ = "Use_Boolstr" THEN Use_Boolstr = TRUE
        IF Src$ = "Use_Button" THEN Use_Button = TRUE
        CASE  3
        IF Src$ = "UseLCaseTbl" THEN UseLCaseTbl = TRUE
        IF Src$ = "Use_Center" THEN Use_Center = TRUE
        IF Src$ = "Use_Checkbox" THEN Use_Checkbox = TRUE
        IF Src$ = "Use_Chr" THEN Use_Chr = TRUE
        IF Src$ = "Use_Cint" THEN Use_Cint = TRUE
        IF Src$ = "Use_Clng" THEN Use_Clng = TRUE
        IF Src$ = "Use_Cls" THEN Use_Cls = TRUE
        IF Src$ = "Use_Color" THEN Use_Color = TRUE
        IF Src$ = "Use_COM" THEN Use_COM = TRUE
        IF Src$ = "Use_Combobox" THEN Use_Combobox = TRUE
        IF Src$ = "Use_ComboBoxLoadFile" THEN Use_ComboBoxLoadFile = TRUE
        IF Src$ = "Use_Command" THEN Use_Command = TRUE
        IF Src$ = "Use_ContainedIn" THEN Use_ContainedIn = TRUE
        IF Src$ = "Use_CreateRegInt" THEN Use_CreateRegInt = TRUE
        IF Src$ = "Use_CreateRegString" THEN Use_CreateRegString = TRUE
        IF Src$ = "Use_Csrlin" THEN Use_Csrlin = TRUE
        IF Src$ = "Use_Curdir" THEN Use_Curdir = TRUE
        IF Src$ = "Use_Cvd" THEN Use_Cvd = TRUE
        IF Src$ = "Use_Cvi" THEN Use_Cvi = TRUE
        IF Src$ = "Use_Cvl" THEN Use_Cvl = TRUE
        IF Src$ = "Use_Cvld" THEN Use_Cvld = TRUE
        IF Src$ = "Use_Cvs" THEN Use_Cvs = TRUE
        CASE  4
        IF Src$ = "Use_Datepick" THEN Use_Datepick = TRUE
        IF Src$ = "Use_Del" THEN Use_Del = TRUE
        IF Src$ = "Use_DeleteRegKey" THEN Use_DeleteRegKey = TRUE
        IF Src$ = "Use_Doevents" THEN Use_Doevents = TRUE
        IF Src$ = "Use_Download" THEN Use_Download = TRUE
        IF Src$ = "Use_Draw" THEN Use_Draw = TRUE
        IF Src$ = "Use_DrawTransBMP" THEN Use_DrawTransBMP = TRUE
        IF Src$ = "Use_DSplit" THEN Use_DSplit = TRUE
        IF Src$ = "Use_Dynacall" THEN Use_DynacallCommon = Use_Dynacall = TRUE
        IF Src$ = "Use_DynamicA" THEN Use_DynamicA = TRUE
        IF Src$ = "Use_DynStrqsorta" THEN Use_DynStrqsorta = TRUE
        IF Src$ = "Use_DynStrqsortd" THEN Use_DynStrqsortd = TRUE
        CASE  5
        IF Src$ = "Use_Edit" THEN Use_Edit = TRUE
        IF Src$ = "Use_Elf" THEN Use_Elf = TRUE
        IF Src$ = "Use_Enclose" THEN Use_Enclose = TRUE
        IF Src$ = "Use_Environ" THEN Use_Environ = TRUE
        IF Src$ = "Use_Eof" THEN Use_Eof = TRUE    'added 7/30/2005
        IF Src$ = "Use_Exist" THEN Use_Exist = TRUE
        IF Src$ = "Use_Exp" THEN Use_Exp = TRUE
        IF Src$ = "Use_Extract" THEN Use_Extract = TRUE
        CASE  6
        IF Src$ = "Use_FileLocked" THEN Use_FileLocked = TRUE
        IF Src$ = "Use_FillArray" THEN Use_FillArray = TRUE
        IF Src$ = "Use_Findfirst" THEN Use_Findfirst = TRUE
        IF Src$ = "Use_Findnext" THEN Use_Findnext = TRUE
        IF Src$ = "Use_FirstInstance" THEN Use_FirstInstance = TRUE
        IF Src$ = "Use_FindInType" THEN Use_FindInType = TRUE
        IF Src$ = "Use_Form" THEN Use_Form = TRUE
        IF Src$ = "Use_Freefile" THEN Use_Freefile = TRUE
        CASE  7
        IF Src$ = "Use_GetBmp" THEN Use_GetBmp = TRUE
        IF Src$ = "Use_GetDimension" THEN Use_GetDimension = TRUE
        IF Src$ = "Use_Getfilename" THEN Use_Getfilename = TRUE
        IF Src$ = "Use_GetSpecialFolder" THEN Use_GetSpecialFolder = TRUE
        IF Src$ = "Use_GetText" THEN Use_GetText = TRUE
        IF Src$ = "Use_GetTextSize" THEN Use_GetTextSize = TRUE
        IF Src$ = "Use_Grayrect" THEN Use_Grayrect = TRUE
        IF Src$ = "Use_Group" THEN Use_Group = TRUE
        CASE  8
        IF Src$ = "Use_Hex" THEN Use_Hex = TRUE
        IF Src$ = "Use_Hex2Dec" THEN Use_Hex2Dec = TRUE
        IF Src$ = "Use_Hook" THEN Use_Hook = TRUE
        IF Src$ = "Use_Hscroll" THEN Use_Hscroll = TRUE
        CASE  9
        IF Src$ = "Use_Icon" THEN Use_Icon = TRUE
        IF Src$ = "Use_Idxqsort" THEN Use_Idxqsort = TRUE
        IF Src$ = "Use_IdxqsortSt" THEN Use_IdxqsortSt = TRUE
        IF Src$ = "Use_Iif" THEN Use_Iif = TRUE					'jcfuller added 07/16/2013
        IF Src$ = "Use_Inchr" THEN Use_Inchr = TRUE
        IF Src$ = "Use_Infobox" THEN Use_BoxCommon = Use_Infobox = TRUE
        IF Src$ = "Use_Inkey" THEN Use_Inkey = TRUE
        IF Src$ = "Use_InkeyD" THEN Use_InkeyD = TRUE
        IF Src$ = "Use_Inputbox" THEN Use_BoxCommon = Use_Inputbox = TRUE
        IF Src$ = "Use_Ins" THEN Use_Ins = TRUE
        IF Src$ = "Use_Instr" THEN Use_Instr = TRUE
        IF Src$ = "Use_Instrrev" THEN Use_Instrrev = TRUE
        IF Src$ = "Use_IRemove" THEN Use_IRemove = TRUE
        IF Src$ = "Use_iReplace" THEN Use_iReplace = TRUE
        CASE  10
        IF Src$ = "Use_Join" THEN Use_Join = TRUE
        CASE  11
        IF Src$ = "Use_Keypress" THEN Use_Keypress = TRUE
        CASE  12
        IF Src$ = "Use_Label" THEN Use_Label = TRUE
        IF Src$ = "UseFlag" THEN UseFlag = TRUE
        IF Src$ = "Use_Lcase" THEN Use_Lcase = TRUE
        IF Src$ = "Use_LccPath" THEN Use_LccPath = TRUE
        IF Src$ = "Use_Left" THEN Use_Left = TRUE
        IF Src$ = "Use_Like" THEN Use_Like = TRUE
        IF Src$ = "Use_Listbox" THEN Use_Listbox = TRUE
        IF Src$ = "Use_ListBoxLoadFile" THEN Use_ListBoxLoadFile = TRUE
        IF Src$ = "Use_Listview" THEN Use_Listview = TRUE
        IF Src$ = "Use_LoadFile" THEN Use_LoadFile = TRUE
        IF Src$ = "Use_Loc" THEN Use_Loc = TRUE
        IF Src$ = "Use_Locate" THEN Use_Locate = TRUE
        IF Src$ = "Use_Lof" THEN Use_Lof = TRUE
        IF Src$ = "Use_Lpad" THEN Use_Lpad = TRUE
        IF Src$ = "Use_Ltrim" THEN Use_Ltrim = TRUE
        CASE  13
        IF Src$ = "Use_Max" THEN Use_Max = TRUE
        IF Src$ = "Use_Mcase" THEN Use_Mcase = TRUE
        IF Src$ = "Use_Mid" THEN Use_Mid = TRUE
        IF Src$ = "Use_Midstr" THEN Use_Midstr = TRUE
        IF Src$ = "Use_Min" THEN Use_Min = TRUE
        IF Src$ = "Use_Mkd" THEN Use_Mkd = TRUE
        IF Src$ = "Use_Mki" THEN Use_Mki = TRUE
        IF Src$ = "Use_Mkl" THEN Use_Mkl = TRUE
        IF Src$ = "Use_Mkld" THEN Use_Mkld = TRUE
        IF Src$ = "Use_Mks" THEN Use_Mks = TRUE
        IF Src$ = "Use_Modstyle" THEN Use_Modstyle = TRUE
        IF Src$ = "Use_Msgbox" THEN Use_Msgbox = TRUE
        CASE  14
        IF Src$ = "Use_Now" THEN Use_Now = TRUE
        IF Src$ = "Use_Numqsortadouble" THEN Use_Numqsortadouble = TRUE
        IF Src$ = "Use_Numqsortafloat" THEN Use_Numqsortafloat = TRUE
        IF Src$ = "Use_Numqsortaint" THEN Use_Numqsortaint = TRUE
        IF Src$ = "Use_Numqsortddouble" THEN Use_Numqsortddouble = TRUE
        IF Src$ = "Use_Numqsortdfloat" THEN Use_Numqsortdfloat = TRUE
        IF Src$ = "Use_Numqsortdint" THEN Use_Numqsortdint = TRUE
        CASE  15
        IF Src$ = "Use_Oct" THEN Use_Oct = TRUE
        IF Src$ = "Use_OSVersion" THEN Use_OSVersion = TRUE
        CASE  16
        IF Src$ = "Use_Panel" THEN Use_Panel = TRUE
        IF Src$ = "Use_Pause" THEN Use_Pause = TRUE
        IF Src$ = "Use_PeekStr" THEN Use_PeekStr = TRUE
        IF Src$ = "Use_PellesPath" THEN Use_PellesPath = TRUE
        IF Src$ = "Use_PlayWav" THEN Use_PlayWav = TRUE
        IF Src$ = "Use_Pos" THEN Use_Pos = TRUE
        IF Src$ = "UseCpp" THEN UseCpp = TRUE
        IF Src$ = "Use_Printer" THEN Use_Printer = TRUE
        IF Src$ = "Use_ProgressBar" THEN Use_ProgressBar = TRUE
        IF Src$ = "Use_PtrqsortSt" THEN Use_PtrqsortSt = TRUE
        CASE  17
        IF Src$ = "Use_QBColor" THEN Use_QBColor = TRUE
        CASE  18
        IF Src$ = "Use_Radio" THEN Use_Radio = TRUE
        IF Src$ = "Use_Randomize" THEN Use_Randomize = TRUE
        IF Src$ = "Use_Rec" THEN Use_Rec = TRUE
        IF Src$ = "Use_RecCount" THEN Use_RecCount = TRUE
        IF Src$ = "Use_RegInt" THEN Use_RegInt = TRUE
        IF Src$ = "Use_RegString" THEN Use_RegString = TRUE
        IF Src$ = "Use_Remain" THEN Use_Remain = TRUE
        IF Src$ = "Use_Remove" THEN Use_Remove = TRUE
        IF Src$ = "Use_Repeat" THEN Use_Repeat = TRUE
        IF Src$ = "Use_Replace" THEN Use_Replace = TRUE
        IF Src$ = "Use_Retain" THEN Use_Retain = TRUE
        IF Src$ = "Use_Reverse" THEN Use_Reverse = TRUE
        IF Src$ = "Use_Richedit" THEN Use_Richedit = TRUE
        IF Src$ = "Use_Right" THEN Use_Right = TRUE
        IF Src$ = "Use_Rnd" THEN Use_Rnd = TRUE
        IF Src$ = "Use_Round" THEN Use_Round = TRUE
        IF Src$ = "Use_Rpad" THEN Use_Rpad = TRUE
        IF Src$ = "Use_Rtrim" THEN Use_Rtrim = TRUE
        IF Src$ = "Use_Run" THEN Use_Run = TRUE
        CASE  19
        IF Src$ = "Use_SaveBmp" THEN Use_SaveBmp = TRUE
        IF Src$ = "Use_Scan" THEN Use_Scan = TRUE
        IF Src$ = "Use_Screen" THEN Use_Screen = TRUE
        IF Src$ = "Use_SearchPath" THEN Use_SearchPath = TRUE
        IF Src$ = "Use_SetColor" THEN Use_SetColor = TRUE
        IF Src$ = "Use_SetDimension" THEN Use_SetDimension = TRUE
        IF Src$ = "Use_SetFont" THEN Use_SetFont = TRUE
        IF Src$ = "Use_SetFormColor" THEN Use_SetFormColor = TRUE
        IF Src$ = "Use_SetText" THEN Use_SetText = TRUE
        IF Src$ = "Use_Set_BCX_Bitmap" THEN Use_Set_BCX_Bitmap = TRUE
        IF Src$ = "Use_Set_BCX_Bitmap2" THEN Use_Set_BCX_Bitmap2 = TRUE
        IF Src$ = "Use_Set_BCX_BmpButton" THEN Use_Set_BCX_BmpButton = TRUE
        IF Src$ = "Use_Set_BCX_Icon" THEN Use_Set_BCX_Icon = TRUE
        IF Src$ = "Use_Sgn" THEN Use_Sgn = TRUE
        IF Src$ = "Use_Sound" THEN Use_Sound = TRUE
        IF Src$ = "Use_Space" THEN Use_Space = TRUE
        IF Src$ = "Use_Split" THEN Use_Split = TRUE
        IF Src$ = "Use_Status" THEN Use_Status = TRUE
        IF Src$ = "Use_Str" THEN Use_Str = TRUE
        IF Src$ = "Use_Strim" THEN Use_Strim = TRUE
        IF Src$ = "Use_String" THEN Use_String = TRUE
        IF Src$ = "Use_StrStr" THEN Use_StrStr = TRUE
        IF Src$ = "Use_Stristr" THEN Use_Stristr = TRUE
        IF Src$ = "Use_Strl" THEN Use_Strl = TRUE
        IF Src$ = "Use_Strqsorta" THEN Use_Strqsorta = TRUE
        IF Src$ = "Use_Strqsortd" THEN Use_Strqsortd = TRUE
        IF Src$ = "Use_Strtoken" THEN Use_Strtoken = TRUE
        IF Src$ = "Use_Str_Cmp" THEN Use_Str_Cmp = TRUE
        IF Src$ = "Use_Swap" THEN Use_Swap = TRUE
        IF Src$ = "Use_Sysdir" THEN Use_Sysdir = TRUE
        IF Src$ = "Use_SysStr" THEN Use_SysStr = TRUE
        IF Src$ = "Use_sziif" THEN Use_sziif = TRUE
        CASE  20
        IF Src$ = "Use_Tally" THEN Use_Tally = TRUE
        IF Src$ = "Use_Tempdir" THEN Use_Tempdir = TRUE
        IF Src$ = "Use_TempFileName" THEN Use_TempFileName = TRUE
        IF Src$ = "Use_Textmode" THEN Use_Textmode = TRUE
        IF Src$ = "Use_Time" THEN Use_Time = TRUE
        IF Src$ = "Use_Timer" THEN Use_Timer = TRUE
        IF Src$ = "Use_Treeview" THEN Use_Treeview = TRUE
        IF Src$ = "Use_Trim" THEN Use_Trim = TRUE
        CASE  21
        IF Src$ = "Use_Ucase" THEN Use_Ucase = TRUE
        IF Src$ = "Use_Using" THEN Use_Using = TRUE
        CASE  22
        IF Src$ = "Use_VBS" THEN Use_VBS = TRUE
        IF Src$ = "Use_VChr" THEN Use_VChr = TRUE
        IF Src$ = "Use_Verify" THEN Use_Verify = TRUE
        CASE  23
        IF Src$ = "Use_Whiterect" THEN Use_Whiterect = TRUE
        IF Src$ = "Use_WideToAnsi" THEN Use_WideToAnsi = TRUE
        IF Src$ = "Use_Windir" THEN Use_Windir = TRUE
      END SELECT
    WEND
    CLOSE fpUse
  NEXT
END SUB ' SetUsed


'  Use_DynAlphaNumericA
'  Use_DynAlphaNumericD
'  Use_AlphaNumericA
'  Use_AlphaNumericD
'  Use_AlphaNumeric
SUB SetFlags()
  OPEN Project$ FOR OUTPUT AS fpFlags
  'IF Use_Abs THEN FPRINT fpFlags, "Use_Abs"
  IF Use_Acosh THEN FPRINT fpFlags, "Use_Acosh"
  IF Use_AnsiToWide THEN FPRINT fpFlags, "Use_AnsiToWide"
  IF Use_AppActivate THEN FPRINT fpFlags, "Use_AppActivate"
  IF Use_AppExeName THEN FPRINT fpFlags, "Use_AppExeName"
  IF Use_AppExePath THEN FPRINT fpFlags, "Use_AppExePath"
  IF Use_Asc THEN FPRINT fpFlags, "Use_Asc"
  IF Use_Asinh THEN FPRINT fpFlags, "Use_Asinh"
  IF Use_Atanh THEN FPRINT fpFlags, "Use_Atanh"
  IF Use_BCX_Arc THEN FPRINT fpFlags, "Use_BCX_Arc"
  IF Use_BCX_BmpHeight THEN FPRINT fpFlags, "Use_BCX_BmpHeight"
  IF Use_BCX_BmpWidth THEN FPRINT fpFlags, "Use_BCX_BmpWidth"
  IF Use_BCX_Circle THEN FPRINT fpFlags, "Use_BCX_Circle"
  IF Use_BCX_Colordlg THEN FPRINT fpFlags, "Use_BCX_Colordlg"
  IF Use_BCX_Control THEN FPRINT fpFlags, "Use_BCX_Control"
  IF Use_BCX_Ellipse THEN FPRINT fpFlags, "Use_BCX_Ellipse"
  IF Use_BCX_Floodfill THEN FPRINT fpFlags, "Use_BCX_Floodfill"
  IF Use_BCX_Fontdlg THEN FPRINT fpFlags, "Use_BCX_Fontdlg"
  IF Use_BCX_Get THEN FPRINT fpFlags, "Use_BCX_Get"
  IF Use_BCX_Getpixel THEN FPRINT fpFlags, "Use_BCX_Getpixel"
  IF Use_BCX_Get_UpDown THEN FPRINT fpFlags, "Use_BCX_Get_UpDown"
  IF Use_BCX_Input THEN FPRINT fpFlags, "Use_BCX_Input"
  IF Use_BCX_Line THEN FPRINT fpFlags, "Use_BCX_Line"
  IF Use_BCX_Lineto THEN FPRINT fpFlags, "Use_BCX_Lineto"
  IF Use_BCX_LoadBMP THEN FPRINT fpFlags, "Use_BCX_LoadBMP"
  IF Use_BCX_LoadImage THEN FPRINT fpFlags, "Use_BCX_LoadImage"
  IF Use_BCX_OlePicture THEN FPRINT fpFlags, "Use_BCX_OlePicture"
  IF Use_BCX_Path THEN FPRINT fpFlags, "Use_BCX_Path"
  IF Use_BcxSplitPath THEN FPRINT fpFlags, "Use_BcxSplitPath"
  IF Use_BCX_PolyBezier THEN FPRINT fpFlags, "Use_BCX_PolyBezier"
  IF Use_BCX_Polygon THEN FPRINT fpFlags, "Use_BCX_Polygon"
  IF Use_BCX_Polyline THEN FPRINT fpFlags, "Use_BCX_Polyline"
  IF Use_BCX_Preset THEN FPRINT fpFlags, "Use_BCX_Preset"
  IF Use_BCX_Print THEN FPRINT fpFlags, "Use_BCX_Print"
  IF Use_BCX_Pset THEN FPRINT fpFlags, "Use_BCX_Pset"
  IF Use_BCX_Put THEN FPRINT fpFlags, "Use_BCX_Put"
  IF Use_BCX_Rectangle THEN FPRINT fpFlags, "Use_BCX_Rectangle"
  IF Use_BCX_Roundrect THEN FPRINT fpFlags, "Use_BCX_Roundrect"
  IF Use_BCX_Tab THEN FPRINT fpFlags, "Use_BCX_Tab"
  IF Use_BCX_Toolbar THEN FPRINT fpFlags, "Use_BCX_Toolbar"
  IF Use_BCX_Tile THEN FPRINT fpFlags, "Use_BCX_Tile"
  IF Use_BCX_UpDown THEN FPRINT fpFlags, "Use_BCX_UpDown"
  IF Use_BCX_Slider THEN FPRINT fpFlags, "Use_BCX_Slider"
  IF Use_BCX_Splitter THEN FPRINT fpFlags, "Use_BCX_Splitter"
  IF Use_Bff THEN FPRINT fpFlags, "Use_Bff"
  IF Use_Bin THEN FPRINT fpFlags, "Use_Bin"
  IF Use_Bin2dec THEN FPRINT fpFlags, "Use_Bin2dec"
  IF Use_Bitmap THEN FPRINT fpFlags, "Use_Bitmap"
  IF Use_Blackrect THEN FPRINT fpFlags, "Use_Blackrect"
  IF Use_BmpButton THEN FPRINT fpFlags, "Use_BmpButton"
  IF Use_Boolstr THEN FPRINT fpFlags, "Use_Boolstr"
  IF Use_Button THEN FPRINT fpFlags, "Use_Button"
  IF Use_Center THEN FPRINT fpFlags, "Use_Center"
  IF Use_Checkbox THEN FPRINT fpFlags, "Use_Checkbox"
  IF Use_Chr THEN FPRINT fpFlags, "Use_Chr"
  IF Use_Cint THEN FPRINT fpFlags, "Use_Cint"
  IF Use_Clng THEN FPRINT fpFlags, "Use_Clng"
  IF Use_Cls THEN FPRINT fpFlags, "Use_Cls"
  IF Use_Color THEN FPRINT fpFlags, "Use_Color"
  IF Use_COM THEN FPRINT fpFlags, "Use_COM"
  IF Use_Combobox THEN FPRINT fpFlags, "Use_Combobox"
  IF Use_ComboBoxLoadFile THEN FPRINT fpFlags, "Use_ComboBoxLoadFile"
  IF Use_Command THEN FPRINT fpFlags, "Use_Command"
  IF Use_ContainedIn THEN FPRINT fpFlags, "Use_ContainedIn"
  IF Use_CreateRegInt THEN FPRINT fpFlags, "Use_CreateRegInt"
  IF Use_CreateRegString THEN FPRINT fpFlags, "Use_CreateRegString"
  IF Use_Csrlin THEN FPRINT fpFlags, "Use_Csrlin"
  IF Use_Curdir THEN FPRINT fpFlags, "Use_Curdir"
  IF Use_Cvd THEN FPRINT fpFlags, "Use_Cvd"
  IF Use_Cvi THEN FPRINT fpFlags, "Use_Cvi"
  IF Use_Cvl THEN FPRINT fpFlags, "Use_Cvl"
  IF Use_Cvld THEN FPRINT fpFlags, "Use_Cvld"
  IF Use_Cvs THEN FPRINT fpFlags, "Use_Cvs"
  IF Use_Datepick THEN FPRINT fpFlags, "Use_Datepick"
  IF Use_Del THEN FPRINT fpFlags, "Use_Del"
  IF Use_DeleteRegKey THEN FPRINT fpFlags, "Use_DeleteRegKey"
  IF Use_BCXMDialog THEN FPRINT fpFlags, "Use_BCXMDialog"
  IF Use_BCXDialog THEN FPRINT fpFlags, "Use_BCXDialog"
  IF Use_Doevents THEN FPRINT fpFlags, "Use_Doevents"
  IF Use_Download THEN FPRINT fpFlags, "Use_Download"
  IF Use_Draw THEN FPRINT fpFlags, "Use_Draw"
  IF Use_DrawTransBMP THEN FPRINT fpFlags, "Use_DrawTransBMP"
  IF Use_DSplit THEN FPRINT fpFlags, "Use_DSplit"
  IF Use_Dynacall AND NOT DllCnt THEN FPRINT fpFlags, "Use_Dynacall"
  IF Use_DynamicA THEN FPRINT fpFlags, "Use_DynamicA"
  IF Use_DynStrqsorta THEN FPRINT fpFlags, "Use_DynStrqsorta"
  IF Use_DynStrqsortd THEN FPRINT fpFlags, "Use_DynStrqsortd"
  IF Use_Edit THEN FPRINT fpFlags, "Use_Edit"
  IF Use_Elf THEN FPRINT fpFlags, "Use_Elf"
  IF Use_Enclose THEN FPRINT fpFlags, "Use_Enclose"
  IF Use_Environ THEN FPRINT fpFlags, "Use_Environ"
  IF Use_Eof THEN FPRINT fpFlags, "Use_Eof"    'added 7/30/2005
  IF Use_Exist THEN FPRINT fpFlags, "Use_Exist"
  IF Use_Exp THEN FPRINT fpFlags, "Use_Exp"
  IF Use_Extract THEN FPRINT fpFlags, "Use_Extract"
  IF Use_FileLocked THEN FPRINT fpFlags, "Use_FileLocked"
  IF Use_FillArray THEN FPRINT fpFlags, "Use_FillArray"
  IF Use_Findfirst THEN FPRINT fpFlags, "Use_Findfirst"
  IF Use_Findnext THEN FPRINT fpFlags, "Use_Findnext"
  IF Use_FirstInstance THEN FPRINT fpFlags, "Use_FirstInstance"
  IF Use_FindInType THEN FPRINT fpFlags, "Use_FindInType"
  IF Use_Form THEN FPRINT fpFlags, "Use_Form"
  IF Use_Freefile THEN FPRINT fpFlags, "Use_Freefile"
  IF Use_GetBmp THEN FPRINT fpFlags, "Use_GetBmp"
  IF Use_GetDimension THEN FPRINT fpFlags,"Use_GetDimension"
  IF Use_Getfilename THEN FPRINT fpFlags, "Use_Getfilename"
  IF Use_GetSpecialFolder THEN FPRINT fpFlags, "Use_GetSpecialFolder"
  IF Use_GetText THEN FPRINT fpFlags, "Use_GetText"
  IF Use_GetTextSize THEN FPRINT fpFlags, "Use_GetTextSize"
  IF Use_Grayrect THEN FPRINT fpFlags, "Use_Grayrect"
  IF Use_Group THEN FPRINT fpFlags, "Use_Group"
  IF Use_Hex THEN FPRINT fpFlags, "Use_Hex"
  IF Use_Hex2Dec THEN FPRINT fpFlags, "Use_Hex2Dec"
  IF Use_Hook THEN FPRINT fpFlags, "Use_Hook"
  IF Use_Hscroll OR Use_Vscroll THEN FPRINT fpFlags, "Use_Hscroll"
  IF Use_Icon THEN FPRINT fpFlags, "Use_Icon"
  IF Use_Idxqsort THEN FPRINT fpFlags, "Use_Idxqsort"
  IF Use_IdxqsortSt THEN FPRINT fpFlags, "Use_IdxqsortSt"
  IF Use_Iif THEN FPRINT fpFlags, "Use_Iif"
  IF Use_Inchr THEN FPRINT fpFlags, "Use_Inchr"
  IF Use_Infobox THEN FPRINT fpFlags, "Use_Infobox"
  IF Use_Inkey THEN FPRINT fpFlags, "Use_Inkey"
  IF Use_InkeyD THEN FPRINT fpFlags, "Use_InkeyD"
  IF Use_Infobox THEN FPRINT fpFlags, "Use_Infobox"
  IF Use_Inputbox THEN FPRINT fpFlags, "Use_Inputbox"
  IF Use_Ins THEN FPRINT fpFlags, "Use_Ins"
  IF Use_Instr THEN FPRINT fpFlags, "Use_Instr"
  IF Use_Instrrev THEN FPRINT fpFlags, "Use_Instrrev"
  IF Use_IRemove THEN FPRINT fpFlags, "Use_IRemove"
  IF Use_iReplace THEN FPRINT fpFlags, "Use_iReplace"
  IF Use_Join THEN FPRINT fpFlags, "Use_Join"
  IF Use_Keypress THEN FPRINT fpFlags, "Use_Keypress"
  IF Use_Label THEN FPRINT fpFlags, "Use_Label"
  IF UseFlag THEN FPRINT fpFlags, "UseFlag"
  IF UseLCaseTbl THEN FPRINT fpFlags, "UseLCaseTbl"
  IF Use_Lcase THEN FPRINT fpFlags, "Use_Lcase"
  IF Use_LccPath THEN FPRINT fpFlags, "Use_LccPath"
  IF Use_Left THEN FPRINT fpFlags, "Use_Left"
  IF Use_Like THEN FPRINT fpFlags, "Use_Like"
  IF Use_Listbox THEN FPRINT fpFlags, "Use_Listbox"
  IF Use_ListBoxLoadFile THEN FPRINT fpFlags, "Use_ListBoxLoadFile"
  IF Use_Listview THEN FPRINT fpFlags, "Use_Listview"
  IF Use_LoadFile THEN FPRINT fpFlags, "Use_LoadFile"
  IF Use_Loc THEN FPRINT fpFlags, "Use_Loc"
  IF Use_Locate THEN FPRINT fpFlags, "Use_Locate"
  IF Use_Lof THEN FPRINT fpFlags, "Use_Lof"
  IF Use_Lpad THEN FPRINT fpFlags, "Use_Lpad"
  IF Use_Ltrim THEN FPRINT fpFlags, "Use_Ltrim"
  IF Use_Max THEN FPRINT fpFlags, "Use_Max"
  IF Use_Mcase THEN FPRINT fpFlags, "Use_Mcase"
  IF Use_Mid THEN FPRINT fpFlags, "Use_Mid"
  IF Use_Midstr THEN FPRINT fpFlags, "Use_Midstr"
  IF Use_Min THEN FPRINT fpFlags, "Use_Min"
  IF Use_Mkd THEN FPRINT fpFlags, "Use_Mkd"
  IF Use_Mki THEN FPRINT fpFlags, "Use_Mki"
  IF Use_Mkl THEN FPRINT fpFlags, "Use_Mkl"
  IF Use_Mkld THEN FPRINT fpFlags, "Use_Mkld"
  IF Use_Mks THEN FPRINT fpFlags, "Use_Mks"
  IF Use_Modstyle THEN FPRINT fpFlags, "Use_Modstyle"
  IF Use_Msgbox THEN FPRINT fpFlags, "Use_Msgbox"
  IF Use_Now THEN FPRINT fpFlags, "Use_Now"
  IF Use_Numqsortadouble THEN FPRINT fpFlags, "Use_Numqsortadouble"
  IF Use_Numqsortafloat THEN FPRINT fpFlags, "Use_Numqsortafloat"
  IF Use_Numqsortaint THEN FPRINT fpFlags, "Use_Numqsortaint"
  IF Use_Numqsortddouble THEN FPRINT fpFlags, "Use_Numqsortddouble"
  IF Use_Numqsortdfloat THEN FPRINT fpFlags, "Use_Numqsortdfloat"
  IF Use_Numqsortdint THEN FPRINT fpFlags, "Use_Numqsortdint"
  IF Use_Oct THEN FPRINT fpFlags, "Use_Oct"
  IF Use_OSVersion THEN FPRINT fpFlags, "Use_OSVersion"
  IF Use_Panel THEN FPRINT fpFlags, "Use_Panel"
  IF Use_Pause THEN FPRINT fpFlags, "Use_Pause"
  IF Use_PeekStr THEN FPRINT fpFlags, "Use_PeekStr"
  IF Use_PellesPath THEN FPRINT fpFlags, "Use_PellesPath"
  IF Use_PlayWav THEN FPRINT fpFlags, "Use_PlayWav"
  IF Use_Pos THEN FPRINT fpFlags, "Use_Pos"
  IF UseCpp THEN FPRINT fpFlags, "UseCpp"
  IF Use_Printer THEN FPRINT fpFlags, "Use_Printer"
  IF Use_ProgressBar THEN FPRINT fpFlags, "Use_ProgressBar"
  IF Use_PtrqsortSt THEN FPRINT fpFlags, "Use_PtrqsortSt"
  IF Use_QBColor THEN FPRINT fpFlags, "Use_QBColor"
  IF Use_Radio THEN FPRINT fpFlags, "Use_Radio"
  IF Use_Randomize THEN FPRINT fpFlags, "Use_Randomize"
  IF Use_Rec THEN FPRINT fpFlags, "Use_Rec"
  IF Use_RecCount THEN FPRINT fpFlags, "Use_RecCount"
  IF Use_RegInt THEN FPRINT fpFlags, "Use_RegInt"
  IF Use_RegString THEN FPRINT fpFlags, "Use_RegString"
  IF Use_Remain THEN FPRINT fpFlags, "Use_Remain"
  IF Use_Remove THEN FPRINT fpFlags, "Use_Remove"
  IF Use_Repeat THEN FPRINT fpFlags, "Use_Repeat"
  IF Use_Replace THEN FPRINT fpFlags, "Use_Replace"
  IF Use_Retain THEN FPRINT fpFlags, "Use_Retain"
  IF Use_Reverse THEN FPRINT fpFlags, "Use_Reverse"
  IF Use_Richedit THEN FPRINT fpFlags, "Use_Richedit"
  IF Use_Right THEN FPRINT fpFlags, "Use_Right"
  IF Use_Rnd THEN FPRINT fpFlags, "Use_Rnd"
  IF Use_Round THEN FPRINT fpFlags, "Use_Round"
  IF Use_Rpad THEN FPRINT fpFlags, "Use_Rpad"
  IF Use_Rtrim THEN FPRINT fpFlags, "Use_Rtrim"
  IF Use_Run THEN FPRINT fpFlags, "Use_Run"
  IF Use_SaveBmp THEN FPRINT fpFlags, "Use_SaveBmp"
  IF Use_Scan THEN FPRINT fpFlags, "Use_Scan"
  IF Use_Screen THEN FPRINT fpFlags, "Use_Screen"
  IF Use_SearchPath THEN FPRINT fpFlags, "Use_SearchPath"
  IF Use_SetColor THEN FPRINT fpFlags, "Use_SetColor"
  IF Use_SetDimension THEN FPRINT fpFlags,"Use_SetDimension"
  IF Use_SetFont THEN FPRINT fpFlags, "Use_SetFont"
  IF Use_SetFormColor THEN FPRINT fpFlags, "Use_SetFormColor"
  IF Use_SetText THEN FPRINT fpFlags, "Use_SetText"
  IF Use_Set_BCX_Bitmap THEN FPRINT fpFlags, "Use_Set_BCX_Bitmap"
  IF Use_Set_BCX_Bitmap2 THEN FPRINT fpFlags, "Use_Set_BCX_Bitmap2"
  IF Use_Set_BCX_BmpButton THEN FPRINT fpFlags, "Use_Set_BCX_BmpButton"
  IF Use_Set_BCX_Icon THEN FPRINT fpFlags, "Use_Set_BCX_Icon"
  IF Use_Sgn THEN FPRINT fpFlags, "Use_Sgn"
  IF Use_Sound THEN FPRINT fpFlags, "Use_Sound"
  IF Use_Space THEN FPRINT fpFlags, "Use_Space"
  IF Use_Split THEN FPRINT fpFlags, "Use_Split"
  IF Use_Status THEN FPRINT fpFlags, "Use_Status"
  IF Use_Str THEN FPRINT fpFlags, "Use_Str"
  IF Use_Strim THEN FPRINT fpFlags, "Use_Strim"
  IF Use_String THEN FPRINT fpFlags, "Use_String"
  IF Use_Stristr THEN FPRINT fpFlags, "Use_Stristr"
  IF Use_StrStr THEN FPRINT fpFlags, "Use_StrStr"
  IF Use_Strl THEN FPRINT fpFlags, "Use_Strl"
  IF Use_Strqsorta THEN FPRINT fpFlags, "Use_Strqsorta"
  IF Use_Strqsortd THEN FPRINT fpFlags, "Use_Strqsortd"
  IF Use_Strtoken THEN FPRINT fpFlags, "Use_Strtoken"
  IF Use_Str_Cmp THEN FPRINT fpFlags, "Use_Str_Cmp"
  IF Use_Swap THEN FPRINT fpFlags, "Use_Swap"
  IF Use_Sysdir THEN FPRINT fpFlags, "Use_Sysdir"
  IF Use_SysStr THEN FPRINT fpFlags, "Use_SysStr"
  IF Use_sziif THEN FPRINT fpFlags, "Use_sziif"
  IF Use_Tally THEN FPRINT fpFlags, "Use_Tally"
  IF Use_Tempdir THEN FPRINT fpFlags, "Use_Tempdir"
  IF Use_TempFileName THEN FPRINT fpFlags, "Use_TempFileName"
  IF Use_Textmode THEN FPRINT fpFlags, "Use_Textmode"
  IF Use_Time THEN FPRINT fpFlags, "Use_Time"
  IF Use_Timer THEN FPRINT fpFlags, "Use_Timer"
  IF Use_Treeview THEN FPRINT fpFlags, "Use_Treeview"
  IF Use_Trim THEN FPRINT fpFlags, "Use_Trim"
  IF Use_Ucase THEN FPRINT fpFlags, "Use_Ucase"
  IF Use_Using THEN FPRINT fpFlags, "Use_Using"
  IF Use_VBS THEN FPRINT fpFlags, "Use_VBS"
  IF Use_VChr THEN FPRINT fpFlags, "Use_VChr"
  IF Use_Verify THEN FPRINT fpFlags, "Use_Verify"
  IF Use_Whiterect THEN FPRINT fpFlags, "Use_Whiterect"
  IF Use_WideToAnsi THEN FPRINT fpFlags, "Use_WideToAnsi"
  IF Use_Windir THEN FPRINT fpFlags, "Use_Windir"
  CLOSE fpFlags
END SUB ' SetFlags


$COMMENT
' ************************************************************************************************************
' for debugging
' ************************************************************************************************************
SUB DumpLocalStorage()
  DIM j
  DIM dump_path$
  dump_path$ = APPEXEPATH$ & "comlocals.txt"
  OPEN dump_path$ FOR OUTPUT AS FP68
  FPRINT FP68, "******************************************************************************************"
  FPRINT FP68, "Dump of local COM storage. Size = ", lc_COM_names_index
  FPRINT FP68, "******************************************************************************************"
  FOR j = 0 TO MAX_Local_COM_Objects
    FPRINT FP68, "name =",lc_COM_names_storage[j].name$, " | initialized = ", lc_COM_names_storage[j].initialized
  NEXT
  FPRINT FP68, "******************************************************************************************"
  CLOSE FP68
END SUB ' DumpLocalStorage
' ************************************************************************************************************
$COMMENT


' ************************************************************************************************************
' Functions for late binding COM support.
' ************************************************************************************************************
' ************************************************************************************************************
' Routine common to various methods of COM output
SUB CommonCOMOutput(fpOUT AS FILE)
  FPRINT fpOUT,"// *************************************************"
  FPRINT fpOUT,"// Late binding COM support section                 "
  FPRINT fpOUT,"// (c) Ljubisa Knezevic 2004-2009, ljube@blic.net        "
  FPRINT fpOUT,"// *************************************************"
  FPRINT fpOUT,"#include <unknwn.h>"
  FPRINT fpOUT,"#include <tchar.h>"
  FPRINT fpOUT,"// types used by Late binding COM support"
  FPRINT fpOUT,"#define COM_STACK_SIZE ", COM_STACK_SIZE
  FPRINT fpOUT,"#ifndef CON_VARBOOL2BOOL"
  FPRINT fpOUT,"#define CON_VARBOOL2BOOL(b) ((BOOL)(b ? TRUE : FALSE))"
  FPRINT fpOUT,"#endif"
  FPRINT fpOUT,""
  FPRINT fpOUT,"typedef struct _OBJECT"
  FPRINT fpOUT,"{"
  FPRINT fpOUT,"  IUnknown*  p_unknown;"
  FPRINT fpOUT,"  VARIANT    pObjects[COM_STACK_SIZE];"
  FPRINT fpOUT,"  BOOL       pStatus;"
  FPRINT fpOUT,"  int        ipointer;"
  FPRINT fpOUT,"}OBJECT, *LPOBJECT;"
  FPRINT fpOUT,""
  FPRINT fpOUT,"typedef struct _PARAM_VARARRAY"
  FPRINT fpOUT,"{"
  FPRINT fpOUT,"  VARIANT  pParams[COM_STACK_SIZE];"
  FPRINT fpOUT,"}PARAM_VARARRAY, *LPPARAM_VARARRAY;"
  FPRINT fpOUT,""
END SUB



' Reformatted replacement for bcx20090212Trial.bas lines 25344 to 26275
' Reformatted February 26 2009 by Robert Wishlaw
' ************************************************************************************************************
' Sub: EmitCOMSupportTypes (part of BCX COM parser)
' This sub emmits standard typedefs and global variables used by BCX late binding COM interface.
'
' Last revised 09.Dec.2004
' ************************************************************************************************************
SUB EmitCOMSupportTypes(FP_WRITE AS FILE)
  DIM RAW prefix$
  IF NOT Use_Library THEN FPRINT FP_WRITE,"/* <--UNICODE AWARE-->  */"
  IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTHEADER: COM SUPPORT DATA"
  'CALL CommonCOMOutput(FP_WRITE)
  FPRINT FP_WRITE,"// global vars used by late binding COM support"
  prefix$ = "static "
  IF Use_Library THEN prefix$ = ""
  IF Use_Project THEN prefix$ = ""
  IF Use_Dll THEN prefix$ = "C_EXPORT "

  FPRINT FP_WRITE,prefix$+"PARAM_VARARRAY bcx_static_param_list;"
  FPRINT FP_WRITE,prefix$+"_TCHAR bcx_last_com_error_holder[4096];"
  FPRINT FP_WRITE,prefix$+"_TCHAR bcx_last_com_error_indicator[64];"
  FPRINT FP_WRITE,prefix$+"int bcx_param_list_index_p=0;"
  FPRINT FP_WRITE,prefix$+"VARIANT bcx_temp_result_variant;"
  FPRINT FP_WRITE,prefix$+"HRESULT bcx_last_com_HRESULT;"
  FPRINT FP_WRITE,prefix$+"BOOL bcx_ole_initialized = FALSE;"
  FPRINT FP_WRITE,prefix$+"int  bcx_ole_objects_count = 0;"
  FPRINT FP_WRITE,prefix$+"int  bcx_force_reset_chain = 0;"
  FPRINT FP_WRITE,prefix$+"BOOL BCX_COM_ERROR = FALSE;"
  FPRINT FP_WRITE,prefix$+"BOOL bSHOW_BCX_COM_ERROR = FALSE;"
  FPRINT FP_WRITE,prefix$+"SAFEARRAY * bcx_safe_array_pointer_psa = NULL;"
  FPRINT FP_WRITE,prefix$+"LPOLESTR bcx_temp_wide_string_pointer = NULL;"
  FPRINT FP_WRITE,prefix$+"char* bcx_temp_ans_string_pointer = NULL;"
  FPRINT FP_WRITE,prefix$+"ULONG bcx_temp_wide_string_buffer_size = 0;"
  FPRINT FP_WRITE,prefix$+"ULONG bcx_temp_ans_string_buffer_size = 0;"
  FPRINT FP_WRITE,prefix$+"BOOL bcx_com_get_enumerator_intf = FALSE;"

  ' <WITH - END WITH>
  FPRINT FP_WRITE,prefix$+"int bcx_preserve_dispatch_storage[", MAX_BCX_COM_NESTED_WITHS , "];"
  FPRINT FP_WRITE,prefix$+"int bcx_preserve_dispatch_storage_index = 0;"
  FPRINT FP_WRITE,prefix$+"int bcx_preserve_dispatch_at_offset = 0;" ' for nested (with - end with) constructions
  ' </WITH - END WITH>

  IF Use_COM_Collections THEN
    FPRINT FP_WRITE,prefix$+"VARIANT bcx_sys_temp_ack_var;"
    FPRINT FP_WRITE,prefix$+"IEnumVARIANT* bcx_sys_temp_enum_var = NULL;"
    FPRINT FP_WRITE,prefix$+"ULONG bcx_sys_temp_long_coll = 0;"
  END IF

  FPRINT FP_WRITE,"\n"
  IF NOT Use_Library THEN FPRINT FP_WRITE,"/* >--UNICODE AWARE--<  */"
  IF Use_Library THEN FPRINT FP_WRITE,"// END BCXRTHEADER\n\n"
END SUB 'EmitCOMSupportTypes
' ************************************************************************************************************



' ************************************************************************************************************
' Code emmission for BCX late binding COM interface.
'
' Last revised 09.Dec.2004
' ************************************************************************************************************
SUB Emit_For_BCX_COM_StandardSet(FP_WRITE AS FILE)
  IF NOT Use_Library THEN FPRINT FP_WRITE,"/* <--UNICODE AWARE-->  */"
  IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_GET_COM_ERROR_CODE"
  FPRINT FP_WRITE,"HRESULT  BCX_GET_COM_ERROR_CODE(void)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  return bcx_last_com_HRESULT;"
  FPRINT FP_WRITE,"}\n\n"
  FPRINT FP_WRITE,"_TCHAR*    BCX_GET_COM_ERROR_DESC(void)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  return bcx_last_com_error_holder;"
  FPRINT FP_WRITE,"}\n\n"
  FPRINT FP_WRITE,"BOOL     BCX_GET_COM_SUCCESS(void)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  return (!BCX_COM_ERROR);"
  FPRINT FP_WRITE,"}\n\n"
  FPRINT FP_WRITE,"void     BCX_SHOW_COM_ERRORS(BOOL Show_err)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  bSHOW_BCX_COM_ERROR = Show_err;"
  FPRINT FP_WRITE,"}\n\n"
  FPRINT FP_WRITE,"void bcx_ole_initialize(void)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  if (bcx_ole_initialized) return;"
  IF build_com_trace_code  THEN
    FPRINT FP_WRITE,"  DeleteFile(", ENC$("c:\\\\com_trace.txt"),");"
  END IF
  FPRINT FP_WRITE,"#ifdef __BCX_MULTITHREADED__"
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = CoInitializeEx(NULL,COINIT_MULTITHREADED);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#else"
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = CoInitializeEx(NULL,COINIT_APARTMENTTHREADED);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#endif"
  FPRINT FP_WRITE,"  if (SUCCEEDED(bcx_last_com_HRESULT))"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    bcx_ole_initialized = TRUE;"
  FPRINT FP_WRITE,"    VariantInit(&bcx_temp_result_variant);"

  ' Next line atexit ANSI C function causes bcx_ole_uninitialize to call when program exits

  FPRINT FP_WRITE,"    atexit(bcx_ole_uninitialize);"
  FPRINT FP_WRITE,"    bcx_preserve_dispatch_storage[0] = 0;"
  FPRINT FP_WRITE,"    bcx_preserve_dispatch_storage_index = 0;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    if (bcx_temp_wide_string_pointer) CoTaskMemFree((void*)bcx_temp_wide_string_pointer);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    bcx_temp_wide_string_pointer = (LPOLESTR)CoTaskMemAlloc(";cDefaultStringSize;");"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    if (NULL == bcx_temp_wide_string_pointer)"
  FPRINT FP_WRITE,"    {"
  FPRINT FP_WRITE,"      bcx_temp_wide_string_buffer_size = 0;"
  FPRINT FP_WRITE,"      bcx_last_com_HRESULT =  E_OUTOFMEMORY;"
  FPRINT FP_WRITE,"      bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("Mem Allocation of temp_wide_variable Failed in CoInitializeEx!"), "));"
  FPRINT FP_WRITE,"      return;"
  FPRINT FP_WRITE,"    }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    bcx_temp_wide_string_buffer_size = ";cDefaultStringSize;";"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    if (bcx_temp_ans_string_pointer) free(bcx_temp_ans_string_pointer);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    bcx_temp_ans_string_pointer = (char*)calloc(";cDefaultStringSize;",sizeof(char));"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    if (NULL == bcx_temp_ans_string_pointer)"
  FPRINT FP_WRITE,"    {"
  FPRINT FP_WRITE,"      bcx_last_com_HRESULT =  E_OUTOFMEMORY;"
  FPRINT FP_WRITE,"      bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("Mem Allocation of temp_char_variable Failed in CoInitializeEx!"), "));"
  FPRINT FP_WRITE,"    return;"
  FPRINT FP_WRITE,"    }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    bcx_temp_ans_string_buffer_size = ";cDefaultStringSize;";"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    return;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,"  else"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("CoInitializeEx Failed!"), "));"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,"}\n\n"
  FPRINT FP_WRITE,"void  bcx_ole_uninitialize(void)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  if (bcx_ole_objects_count)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    _TCHAR ermm";cSizeOfADefaultString$;";"
  FPRINT FP_WRITE,"    wsprintf(ermm,_T(", ENC$("Check BCX Set Nothing Statement!\\nNumber of objects not released: %d"), "), bcx_ole_objects_count);"
  FPRINT FP_WRITE,"    MessageBox(GetActiveWindow(), ermm,  _T(", ENC$("Memory leaks detected!"), "),MB_OK|MB_ICONWARNING|MB_TASKMODAL);"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  BCX_COM_FREE_TEMP_WIDE_STRING();"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  BCX_COM_FREE_TEMP_ANSI_STRING();"
  FPRINT FP_WRITE,"  CoUninitialize();"
  FPRINT FP_WRITE,sENDBCXRTLIB$

  IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_GET_COM_STATUS"
  FPRINT FP_WRITE,"BOOL BCX_GET_COM_STATUS(OBJECT* object)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  if(object)"
  FPRINT FP_WRITE,"    return object->pStatus;"
  FPRINT FP_WRITE,"  return 0;"
  FPRINT FP_WRITE,sENDBCXRTLIB$

  FPRINT FP_WRITE,"void BCX_SetNothing(OBJECT* object)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  if (!object->pStatus) return;"
  FPRINT FP_WRITE,""

  IF build_com_trace_code THEN ' used if com trace variable is set
    FPRINT FP_WRITE,"  bcx_com_trace_add_line(", ENC$("Called BCX_SetNothing") , ");"
    FPRINT FP_WRITE,""
  END IF
  FPRINT FP_WRITE,"  bcx_ole_objects_count--;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#ifdef __cplusplus"
  FPRINT FP_WRITE,"  if (object->p_unknown) object->p_unknown->Release();"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#else"
  FPRINT FP_WRITE,"  if (object->p_unknown) object->p_unknown->lpVtbl->Release(object->p_unknown);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#endif"
  FPRINT FP_WRITE,"  if (object->ipointer)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    bcx_reset_dispatch_chain(object);"
  FPRINT FP_WRITE,"    object->ipointer = 0;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = VariantClear(&object->pObjects[0]);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (FAILED(bcx_last_com_HRESULT))"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    lstrcpy(bcx_last_com_error_indicator, _T(", ENC$("BCX_SetNothing Failed!"),"));"
  FPRINT FP_WRITE,"    bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("Release of objects IDispatch interface failed!" ),"));"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  object->pStatus = FALSE;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  Sleep(100);"
  FPRINT FP_WRITE,"}\n\n"
  FPRINT FP_WRITE,"void bcx_catch_hr_error_desc(HRESULT hr, const _TCHAR* extra_info)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  BCX_COM_ERROR = TRUE;"
  FPRINT FP_WRITE,"  void* pMsgBuf;"
  FPRINT FP_WRITE,"  FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,NULL,hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR) &pMsgBuf, 0, NULL);"
  FPRINT FP_WRITE,"  wsprintf(bcx_last_com_error_holder, _T(", ENC$("COM error code %d (0x%X)\\n%s\\n%s\\nmember: %s"),"), hr,hr,extra_info, pMsgBuf, bcx_last_com_error_indicator);"

  IF build_com_trace_code  THEN
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"  bcx_com_trace_add_line(", ENC$(">>> COM ERROR DUMP >>> COM ERROR DUM >>> COM ERROR DUMP >>>"),");"
    FPRINT FP_WRITE,"  bcx_com_trace_add_line(bcx_last_com_error_holder);"
    FPRINT FP_WRITE,"  bcx_com_trace_add_line(", ENC$("<<< COM ERROR DUMP <<< COM ERROR DUM <<< COM ERROR DUMP <<<"),");"
    FPRINT FP_WRITE,""

  END IF
  FPRINT FP_WRITE,"  memset(&bcx_last_com_error_indicator,0,sizeof(bcx_last_com_error_indicator));"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (bSHOW_BCX_COM_ERROR)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    MessageBox(GetActiveWindow(),bcx_last_com_error_holder, _T(", ENC$("BCX COM parser, error report:"), "), MB_OK|MB_ICONERROR|MB_SYSTEMMODAL);"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  LocalFree(pMsgBuf);"
  FPRINT FP_WRITE,"}\n\n"
  FPRINT FP_WRITE,"void  bcx_build_exception_info(HRESULT hr,  EXCEPINFO* pexcep, UINT uiArgErr)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  SCODE oleSCODE;"
  FPRINT FP_WRITE,"  static _TCHAR lv_message";cSizeOfADefaultString$;";"
  'FPRINT FP_WRITE,"  memset(&lv_message,0,sizeof(lv_message));"
  FPRINT FP_WRITE,"  oleSCODE = GetScode(hr);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  for (;;)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    if (oleSCODE==DISP_E_PARAMNOTFOUND)"
  FPRINT FP_WRITE,"    {"
  FPRINT FP_WRITE,"      wsprintf(lv_message, _T(", ENC$("\\nArgument not found, argument %d."),"), uiArgErr);"
  FPRINT FP_WRITE,"      _tcscat(bcx_last_com_error_holder, lv_message);"
  FPRINT FP_WRITE,"      break;"
  FPRINT FP_WRITE,"    }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    if (oleSCODE==DISP_E_TYPEMISMATCH)"
  FPRINT FP_WRITE,"    {"
  FPRINT FP_WRITE,"      wsprintf(lv_message, _T(", ENC$("\\nType mismatch, argument %d."),"), uiArgErr);"
  FPRINT FP_WRITE,"      _tcscat(bcx_last_com_error_holder, lv_message);"
  FPRINT FP_WRITE,"      break;"
  FPRINT FP_WRITE,"    }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    if (oleSCODE==DISP_E_BADVARTYPE)"
  FPRINT FP_WRITE,"    {"
  FPRINT FP_WRITE,"      _tcscat(bcx_last_com_error_holder, _T(", ENC$("\\nOne or more of the arguments passed in isn't a valid VARIANT type."), "));"
  FPRINT FP_WRITE,"      break;"
  FPRINT FP_WRITE,"    }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    if (oleSCODE==E_INVALIDARG)"
  FPRINT FP_WRITE,"    {"
  FPRINT FP_WRITE,"      _tcscat(bcx_last_com_error_holder, _T(", ENC$("\\nOne of the arguments is invalid."),"));"
  FPRINT FP_WRITE,"      break;"
  FPRINT FP_WRITE,"    }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    break;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (pexcep)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    wsprintf(lv_message, _T(", ENC$("\\nCOM Error %X:"),"), pexcep->wCode);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    if (pexcep->bstrDescription)"
  FPRINT FP_WRITE,"    {"
  FPRINT FP_WRITE,"      _TCHAR err_desc[512];"
  FPRINT FP_WRITE,"#ifndef UNICODE"
  FPRINT FP_WRITE,"      bcx_last_com_HRESULT = BCX_COM_WS2AS(pexcep->bstrDescription,CP_ACP);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"      if (FAILED(bcx_last_com_HRESULT))"
  FPRINT FP_WRITE,"      {"
  FPRINT FP_WRITE,"        bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("Get Error Description Failed! Wide to ANSI conversion failure!"),"));"
  FPRINT FP_WRITE,"      }"
  FPRINT FP_WRITE,"      else"
  FPRINT FP_WRITE,"      {"
  FPRINT FP_WRITE,"        wsprintf(err_desc, _T(", ENC$("\\nException desc: %s"), "), bcx_temp_ans_string_pointer);"
  FPRINT FP_WRITE,"      }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#else"
  FPRINT FP_WRITE,"      wsprintf(err_desc, _T(", ENC$("\\nException desc: %s"), "), pexcep->bstrDescription);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#endif"
  FPRINT FP_WRITE,"      _tcscat(lv_message, err_desc);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"      SysFreeString(pexcep->bstrDescription);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"      pexcep->bstrDescription = NULL;"
  FPRINT FP_WRITE,"    }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    if (pexcep->bstrSource)"
  FPRINT FP_WRITE,"    {"
  FPRINT FP_WRITE,"      _TCHAR err_desc[512];"
  FPRINT FP_WRITE,"#ifndef UNICODE"
  FPRINT FP_WRITE,"      bcx_last_com_HRESULT = BCX_COM_WS2AS(pexcep->bstrSource,CP_ACP);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"      if (FAILED(bcx_last_com_HRESULT))"
  FPRINT FP_WRITE,"      {"
  FPRINT FP_WRITE,"        bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("Get Error Source Failed! Wide to ANSI conversion failure!"),"));"
  FPRINT FP_WRITE,"      }"
  FPRINT FP_WRITE,"      else"
  FPRINT FP_WRITE,"      {"
  FPRINT FP_WRITE,"        wsprintf(err_desc, _T(", ENC$("\\nException source: %s"), "), bcx_temp_ans_string_pointer);"
  FPRINT FP_WRITE,"      }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#else"
  FPRINT FP_WRITE,"      wsprintf(err_desc, _T(", ENC$("\\nException source: %s"), "), pexcep->bstrSource);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#endif"
  FPRINT FP_WRITE,"      _tcscat(lv_message, err_desc);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"      SysFreeString(pexcep->bstrSource);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"      pexcep->bstrSource = NULL;"
  FPRINT FP_WRITE,"    }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    if (pexcep->bstrHelpFile)"
  FPRINT FP_WRITE,"    {"
  FPRINT FP_WRITE,"      _TCHAR err_desc[512];"
  FPRINT FP_WRITE,"#ifndef UNICODE"
  FPRINT FP_WRITE,"      bcx_last_com_HRESULT = BCX_COM_WS2AS(pexcep->bstrHelpFile,CP_ACP);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"      if (FAILED(bcx_last_com_HRESULT))"
  FPRINT FP_WRITE,"      {"
  FPRINT FP_WRITE,"      bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("Get Help File Info Failed! Wide to ANSI conversion failure!"),"));"
  FPRINT FP_WRITE,"      }"
  FPRINT FP_WRITE,"      else"
  FPRINT FP_WRITE,"      {"
  FPRINT FP_WRITE,"      wsprintf(err_desc, _T(", ENC$("\\nHelp file: %s | topic: %lu"), "), bcx_temp_ans_string_pointer, pexcep->dwHelpContext);"
  FPRINT FP_WRITE,"      }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#else"
  FPRINT FP_WRITE,"      wsprintf(err_desc, _T(", ENC$("\\nHelp file: %s | topic: %lu"), "), pexcep->bstrHelpFile, pexcep->dwHelpContext);"
  FPRINT FP_WRITE,"#endif"
  FPRINT FP_WRITE,"      _tcscat(lv_message, err_desc);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"      SysFreeString(pexcep->bstrHelpFile);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"      pexcep->bstrHelpFile = NULL;"
  FPRINT FP_WRITE,"    }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    _tcscat(bcx_last_com_error_holder ,lv_message);"
  FPRINT FP_WRITE,"  }"
  IF build_com_trace_code  THEN
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"  bcx_com_trace_add_line(", ENC$(">>> COM EXCEPTION DUMP >>> COM EXCEPTION DUM >>> COM EXCEPTION DUMP >>>"),");"
    FPRINT FP_WRITE,"  bcx_com_trace_add_line(bcx_last_com_error_holder);"
    FPRINT FP_WRITE,"  bcx_com_trace_add_line(", ENC$("<<< COM EXCEPTION DUMP <<< COM EXCEPTION DUM <<< COM EXCEPTION DUMP <<<"),");"
  END IF
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (bSHOW_BCX_COM_ERROR)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    MessageBox(NULL,bcx_last_com_error_holder, _T(", ENC$("BCX COM pareser, Exception Info:"), "), MB_OK|MB_ICONERROR|MB_SYSTEMMODAL);"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,"}\n\n"
  FPRINT FP_WRITE,"DISPID bcx_get_DISPID_of_dispatch(IDispatch* lpDispatch, LPOLESTR comsegment)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  static DISPID D_ID;"
  FPRINT FP_WRITE,"  D_ID = 0;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (!lpDispatch) return -1;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#ifdef __cplusplus"
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = lpDispatch->GetIDsOfNames(IID_NULL, &comsegment, 1, LOCALE_SYSTEM_DEFAULT, &D_ID);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#else"
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = lpDispatch->lpVtbl->GetIDsOfNames(lpDispatch, &IID_NULL, &comsegment, 1, LOCALE_SYSTEM_DEFAULT, &D_ID);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#endif"
  FPRINT FP_WRITE,"  if (FAILED(bcx_last_com_HRESULT))"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("Unrecognized member name" ),"));"
  FPRINT FP_WRITE,"    return -1;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  return D_ID;"
  FPRINT FP_WRITE,"}\n\n"
  FPRINT FP_WRITE,"void  bcx_get_next_dispatch(OBJECT* object, LPOLESTR comsegment)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  if (!object->pStatus) return;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (0 == object->ipointer) BCX_COM_ERROR = FALSE;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (BCX_COM_ERROR) return;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  bcx_force_reset_chain++;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  bcx_invoke_helper(object, comsegment,DISPATCH_PROPERTYGET|DISPATCH_METHOD,&object->pObjects[object->ipointer+1]);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  bcx_force_reset_chain--;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (!BCX_COM_ERROR)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    object->ipointer++;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,"}\n\n"
  FPRINT FP_WRITE,"void bcx_invoke_helper(OBJECT* object, const LPOLESTR comsegment,WORD wFlags, VARIANT *pvResult)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  if (!object->pStatus) return;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (BCX_COM_ERROR) return;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  DISPID lv_DID;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  EXCEPINFO exception;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  UINT argerr = 0;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  DISPPARAMS dp = {NULL, NULL, 0, 0 };"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  WORD invoke_flags=0;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  DISPID setdispid = DISPID_PROPERTYPUT;"
  FPRINT FP_WRITE,""

  IF build_com_trace_code THEN
    FPRINT FP_WRITE,"  char extra_error_info";cSizeOfADefaultString$;";"
    FPRINT FP_WRITE,""

  END IF
  FPRINT FP_WRITE,"  if (bcx_com_get_enumerator_intf)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    lv_DID = DISPID_NEWENUM;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,"  else"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    lv_DID = bcx_get_DISPID_of_dispatch(object->pObjects[object->ipointer].pdispVal, comsegment);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    if (-1 == lv_DID) goto cleanInProp;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  memset(&exception,0,sizeof(EXCEPINFO));"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (bcx_param_list_index_p>0)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    setdispid = DISPID_PROPERTYPUT;"
  FPRINT FP_WRITE,"    dp.rgvarg = (VARIANTARG*)bcx_static_param_list.pParams;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (wFlags & DISPATCH_PROPERTYPUT)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    dp.rgdispidNamedArgs = &setdispid;"
  FPRINT FP_WRITE,"    dp.cNamedArgs = 1;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  dp.cArgs = bcx_param_list_index_p;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  invoke_flags = wFlags;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (wFlags & DISPATCH_PROPERTYGET)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    if (pvResult) VariantInit(pvResult);"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  IF build_com_trace_code  THEN
    FPRINT FP_WRITE,"  bcx_com_trace_dump_DISPPARAMS(&dp);"
    FPRINT FP_WRITE,"  bcx_com_trace_dump_flags(wFlags);"
    FPRINT FP_WRITE,"  bcx_com_trace_dump_indicators(object);"
    FPRINT FP_WRITE,""

  END IF
  FPRINT FP_WRITE,"  if (VT_DISPATCH != object->pObjects[object->ipointer].vt||NULL==object->pObjects[object->ipointer].pdispVal)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    bcx_last_com_HRESULT = E_NOINTERFACE;"
  FPRINT FP_WRITE,"    bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("bcx_invoke_helper::Invalid IDispatch interface."), "));"
  FPRINT FP_WRITE,"    goto cleanInProp;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#ifdef __cplusplus"
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = object->pObjects[object->ipointer].pdispVal->Invoke(lv_DID, IID_NULL, LOCALE_SYSTEM_DEFAULT, invoke_flags , &dp, pvResult, &exception, &argerr);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#else"
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = object->pObjects[object->ipointer].pdispVal->lpVtbl->Invoke(object->pObjects[object->ipointer].pdispVal, lv_DID, &IID_NULL, LOCALE_SYSTEM_DEFAULT, invoke_flags , &dp, pvResult, &exception, &argerr);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#endif"
  FPRINT FP_WRITE,"  if (FAILED(bcx_last_com_HRESULT))"
  FPRINT FP_WRITE,"  {"
  IF build_com_trace_code  THEN
    FPRINT FP_WRITE,""
    FPRINT FP_WRITE,"  bcx_com_trace_add_line(", ENC$("Invoke FAILED!"),");"
    FPRINT FP_WRITE,""

  END IF
  FPRINT FP_WRITE,"    bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("bcx_invoke_helper::Invoke failed." ),"));"
  FPRINT FP_WRITE,"    bcx_build_exception_info(bcx_last_com_HRESULT,&exception,argerr);"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  IF build_com_trace_code  THEN
    FPRINT FP_WRITE,"  else "
    FPRINT FP_WRITE,"  {"
    FPRINT FP_WRITE,"    bcx_com_trace_add_line(", ENC$("Invoke SUCEEDED!"),");"
    FPRINT FP_WRITE,"    if(wFlags & DISPATCH_PROPERTYGET)"
    FPRINT FP_WRITE,"    {"
    FPRINT FP_WRITE,"      sprintf(extra_error_info,", ENC$("result Variant type = %d"),",pvResult->vt);"
    FPRINT FP_WRITE,"      bcx_com_trace_add_line(extra_error_info);"
    FPRINT FP_WRITE,"    }"
    FPRINT FP_WRITE,"  }"
  END IF
  FPRINT FP_WRITE,"cleanInProp:"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (V_ISARRAY(&bcx_static_param_list.pParams[0]))"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    if ((VT_ARRAY|VT_VARIANT)==bcx_static_param_list.pParams[0].vt)"
  FPRINT FP_WRITE,"    {"
  FPRINT FP_WRITE,"      bcx_last_com_HRESULT = SafeArrayDestroy(V_ARRAY(&bcx_static_param_list.pParams[0]));"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"      if (FAILED(bcx_last_com_HRESULT))"
  FPRINT FP_WRITE,"      {"
  FPRINT FP_WRITE,"        lstrcpy(bcx_last_com_error_indicator, _T(", ENC$("SafeArrayDestroy failed"),"));"
  FPRINT FP_WRITE,"        bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("Error while cleaning parameter list." ),"));"
  FPRINT FP_WRITE,"      }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"      ZeroMemory((PVOID)&bcx_static_param_list.pParams[0],sizeof(VARIANT));"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"      bcx_safe_array_pointer_psa = NULL;"
  FPRINT FP_WRITE,"      bcx_param_list_index_p = 0;"
  FPRINT FP_WRITE,"    }"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (bcx_param_list_index_p)  bcx_clean_parameter_list();"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (0 == bcx_force_reset_chain) bcx_reset_dispatch_chain(object);"
  FPRINT FP_WRITE,"}\n\n"
  FPRINT FP_WRITE,"void  bcx_clean_parameter_list(void)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  int total_parms = bcx_param_list_index_p;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (bcx_param_list_index_p > 0)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    do"
  FPRINT FP_WRITE,"    {"
  IF build_com_trace_code THEN ' used if com trace variable is set
    FPRINT FP_WRITE,"  sprintf(bcx_com_trace_line, ", ENC$("+++ clear parameter list. Clear variant at index %d. Variant type = %d"), ",bcx_param_list_index_p-1,bcx_static_param_list.pParams[bcx_param_list_index_p-1].vt);"
    FPRINT FP_WRITE,"  bcx_com_trace_add_line(bcx_com_trace_line);"
    FPRINT FP_WRITE,""

  END IF
  FPRINT FP_WRITE,"      bcx_last_com_HRESULT = VariantClear(&bcx_static_param_list.pParams[bcx_param_list_index_p-1]);"
  ' it appears that VariantClear cant clear variant that has a vt = VT_ARRAY | VT_VARIANT
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"      if (FAILED(bcx_last_com_HRESULT))"
  FPRINT FP_WRITE,"      {"
  FPRINT FP_WRITE,"        wsprintf(bcx_last_com_error_indicator, _T(", ENC$("\\nVariant type = %d, at index %d, total params = %d.") ,"),bcx_static_param_list.pParams[bcx_param_list_index_p-1].vt, bcx_param_list_index_p-1, total_parms);"
  FPRINT FP_WRITE,"        bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("Error while cleaning parameter list." ),"));"
  FPRINT FP_WRITE,"      }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"      bcx_param_list_index_p--;"
  FPRINT FP_WRITE,"    }"
  FPRINT FP_WRITE,"    while (bcx_param_list_index_p > 0);"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,"}\n\n"
  FPRINT FP_WRITE,"void  bcx_reset_dispatch_chain(OBJECT* object)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  if (object->ipointer>bcx_preserve_dispatch_at_offset)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    do"
  FPRINT FP_WRITE,"    {"
  IF build_com_trace_code THEN ' used if com trace variable is set
    FPRINT FP_WRITE,"  sprintf(bcx_com_trace_line, ", ENC$("+++ Dispath release at index %d. VAriant Type = %d"), ",object->ipointer,object->pObjects[object->ipointer].vt);"
    FPRINT FP_WRITE,"  bcx_com_trace_add_line(bcx_com_trace_line);"
    FPRINT FP_WRITE,""

  END IF
  FPRINT FP_WRITE,"      VariantClear(&object->pObjects[object->ipointer]);"
  FPRINT FP_WRITE,"      object->ipointer--;"
  FPRINT FP_WRITE,"    }"
  FPRINT FP_WRITE,"    while (object->ipointer > bcx_preserve_dispatch_at_offset);"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,sENDBCXRTLIB$
  IF NOT Use_Library THEN FPRINT FP_WRITE,"/* <--UNICODE AWARE-->  */"
END SUB ' Emit_For_BCX_COM_StandardSet



SUB Emit_For_BCX_COM_GetObject(FP_WRITE AS FILE)
  IF NOT Use_Library THEN FPRINT FP_WRITE,"/* <--UNICODE AWARE-->  */"
  IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_GetObject"
  ' TCHAR is used to support UNICODE versions of programs
  FPRINT FP_WRITE,"void     BCX_GetObject(_TCHAR* objname, OBJECT* obj)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  if (!bcx_ole_initialized) bcx_ole_initialize();"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  CLSID clsid;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#ifndef UNICODE"
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = BCX_COM_AS2WS(objname,CP_ACP);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (FAILED(bcx_last_com_HRESULT))"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("CreateObject Failed! ANSI to Wide conversion failure!"),"));"
  FPRINT FP_WRITE,"    return;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = BCX_COM_WS2AS(bcx_temp_wide_string_pointer,CP_ACP);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (FAILED(bcx_last_com_HRESULT))"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("CreateObject Failed! Wide to ANSI conversion failure!"),"));"
  FPRINT FP_WRITE,"    return;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  sprintf(bcx_last_com_error_indicator,", ENC$("%s, WideName(%s)"), ",objname, bcx_temp_ans_string_pointer);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = CLSIDFromProgID((LPCOLESTR)bcx_temp_wide_string_pointer, (LPCLSID)&clsid);"
  FPRINT FP_WRITE,"#else"
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = BCX_COM_WS2AS((LPCWSTR)objname,CP_ACP);"
  FPRINT FP_WRITE,"  lstrcpy(bcx_last_com_error_indicator, bcx_temp_ans_string_pointer);"
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = CLSIDFromProgID((LPCOLESTR)objname, (LPCLSID)&clsid);"
  FPRINT FP_WRITE,"#endif"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (FAILED(bcx_last_com_HRESULT))"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"#ifndef UNICODE"
  FPRINT FP_WRITE,"    BCX_GetObjectMon((LPCOLESTR)bcx_temp_wide_string_pointer, obj);"
  FPRINT FP_WRITE,"#else"
  FPRINT FP_WRITE,"    BCX_GetObjectMon((LPCOLESTR)objname, obj);"
  FPRINT FP_WRITE,"#endif"
  FPRINT FP_WRITE,"    return;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#ifdef __cplusplus"
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = GetActiveObject((REFCLSID)clsid, NULL, (IUnknown **)&obj->p_unknown);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#else"
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = GetActiveObject((REFCLSID)&clsid, NULL, (IUnknown **)&obj->p_unknown);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#endif"
  FPRINT FP_WRITE,"  if (FAILED(bcx_last_com_HRESULT))"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("GetActiveObject failed!"),"));"
  FPRINT FP_WRITE,"    return;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,"  else"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    VariantInit(&obj->pObjects[0]);"
  FPRINT FP_WRITE,"#ifdef __cplusplus"
  FPRINT FP_WRITE,"    bcx_last_com_HRESULT = obj->p_unknown->QueryInterface(IID_IDispatch, (void **)&obj->pObjects[0].pdispVal);"
  FPRINT FP_WRITE,"#else"
  FPRINT FP_WRITE,"    bcx_last_com_HRESULT = obj->p_unknown->lpVtbl->QueryInterface(obj->p_unknown, &IID_IDispatch, (void **)&obj->pObjects[0].pdispVal);"
  FPRINT FP_WRITE,"#endif"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (FAILED(bcx_last_com_HRESULT))"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("QueryInterface::IID_IDispatch  failed!"),"));"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    if (obj->p_unknown)"
  FPRINT FP_WRITE,"    {"
  FPRINT FP_WRITE,"#ifdef __cplusplus"
  FPRINT FP_WRITE,"      obj->p_unknown->Release();"
  FPRINT FP_WRITE,"#else"
  FPRINT FP_WRITE,"      obj->p_unknown->lpVtbl->Release(obj->p_unknown);"
  FPRINT FP_WRITE,"#endif"
  FPRINT FP_WRITE,"    }"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,"  else"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    obj->pObjects[0].vt = VT_DISPATCH;"
  FPRINT FP_WRITE,"    obj->pStatus = TRUE;"
  FPRINT FP_WRITE,"    obj->ipointer = 0;"
  FPRINT FP_WRITE,"    bcx_ole_objects_count++;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,sENDBCXRTLIB$

  IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_GetObjectMon"
  FPRINT FP_WRITE,"void BCX_GetObjectMon(LPCOLESTR objname, OBJECT* obj)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  IBindCtx* vBindCtx = NULL;"    ' Bind context to be used
  FPRINT FP_WRITE,"  IMoniker* vMoniker = NULL;"    ' Receives moniker built from display name
  FPRINT FP_WRITE,"  ULONG vChEaten = 0;"           ' Receives number of characters consumed
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = CreateBindCtx(0, &vBindCtx);"  ' Receives the pointer to the bind context
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (bcx_last_com_HRESULT != S_OK)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("GetObject: CreateBindCtx failed!"),"));"
  FPRINT FP_WRITE,"    return;" ' no interfaces, so it may return.
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = MkParseDisplayName(vBindCtx, objname, &vChEaten, &vMoniker);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (bcx_last_com_HRESULT != S_OK)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("GetObject: Receive Moniker failed!"),"));"
  FPRINT FP_WRITE,"    goto CleanGetObjectMon;" ' clean all and then exit.
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  VariantInit(&obj->pObjects[0]);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#ifdef __cplusplus"
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = vMoniker->BindToObject(vBindCtx, NULL, IID_IDispatch, (void **)&obj->pObjects[0].pdispVal);"
  FPRINT FP_WRITE,"#else"
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = vMoniker->lpVtbl->BindToObject(vMoniker, vBindCtx, NULL, &IID_IDispatch, (void **)&obj->pObjects[0].pdispVal);"
  FPRINT FP_WRITE,"#endif"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (bcx_last_com_HRESULT != S_OK)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("GetObject: Moniker BindToObject failed!"),"));"
  FPRINT FP_WRITE,"    goto CleanGetObjectMon;" ' clean all and then exit.
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  // ok, we got IDispatch now, set the flags, and object is ready to use ..."
  FPRINT FP_WRITE,"  obj->p_unknown = NULL;" 'doesn't get IUnknown this way
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  obj->pObjects[0].vt = VT_DISPATCH;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  obj->pStatus = TRUE;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  obj->ipointer = 0;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  bcx_ole_objects_count++;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"CleanGetObjectMon:"
  FPRINT FP_WRITE,"#ifdef __cplusplus"
  FPRINT FP_WRITE,"  if (vMoniker) vMoniker->Release();"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (vBindCtx) vBindCtx->Release();"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#else"
  FPRINT FP_WRITE,"  if (vMoniker) vMoniker->lpVtbl->Release(vMoniker);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (vBindCtx) vBindCtx->lpVtbl->Release(vBindCtx);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#endif"
  FPRINT FP_WRITE,sENDBCXRTLIB$
  IF NOT Use_Library THEN FPRINT FP_WRITE,"/* >--UNICODE AWARE--<  */"
END SUB ' Emit_For_BCX_COM_GetObject



SUB Emit_For_BCX_COM_DispatchObject(FP_WRITE AS FILE)
  IF NOT Use_Library THEN FPRINT FP_WRITE,"/* <--UNICODE AWARE-->  */"
  IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_DispatchObject"
  FPRINT FP_WRITE,"void BCX_DispatchObject(IUnknown* iobj, OBJECT* obj, BOOL b_release)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  if (!obj) return;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  static ULONG inc_inf_ussage=0;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (!bcx_ole_initialized) bcx_ole_initialize();"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  obj->p_unknown = iobj;"
  FPRINT FP_WRITE,""

  ' Now, we are going to increment IUnknown usage so that parameter iobj can be released.
  FPRINT FP_WRITE,"#ifdef __cplusplus"
  FPRINT FP_WRITE,"  inc_inf_ussage = obj->p_unknown->AddRef();"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#else"
  FPRINT FP_WRITE,"  inc_inf_ussage = obj->p_unknown->lpVtbl->AddRef(obj->p_unknown);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#endif"
  FPRINT FP_WRITE,"  VariantInit(&obj->pObjects[0]);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#ifdef __cplusplus"
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = obj->p_unknown->QueryInterface(IID_IDispatch, (void **)&obj->pObjects[0].pdispVal);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#else"
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = obj->p_unknown->lpVtbl->QueryInterface(obj->p_unknown, &IID_IDispatch, (void **)&obj->pObjects[0].pdispVal);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#endif"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (FAILED(bcx_last_com_HRESULT))"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("QueryInterface::IID_IDispatch  failed!"),"));"
  FPRINT FP_WRITE,"#ifdef __cplusplus"
  FPRINT FP_WRITE,"    obj->p_unknown->Release();"
  FPRINT FP_WRITE,"#else"
  FPRINT FP_WRITE,"    obj->p_unknown->lpVtbl->Release(obj->p_unknown);"
  FPRINT FP_WRITE,"#endif"
  FPRINT FP_WRITE,"    return;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (b_release)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"#ifdef __cplusplus"
  FPRINT FP_WRITE,"    iobj->Release();"
  FPRINT FP_WRITE,"#else"
  FPRINT FP_WRITE,"    iobj->lpVtbl->Release(obj->p_unknown);"
  FPRINT FP_WRITE,"#endif"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  obj->pObjects[0].vt = VT_DISPATCH;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  obj->pStatus = TRUE;"
  FPRINT FP_WRITE,"  obj->ipointer = 0;"
  FPRINT FP_WRITE,"  bcx_ole_objects_count++;"
  FPRINT FP_WRITE,sENDBCXRTLIB$
  IF NOT Use_Library THEN FPRINT FP_WRITE,"/* >--UNICODE AWARE--<  */"
END SUB ' Emit_For_BCX_COM_DispatchObject



SUB Emit_For_BCX_COM_GetProperty(FP_WRITE AS FILE)
END SUB ' Emit_For_BCX_COM_GetProperty



SUB Emit_For_BCX_COM_SetProperty(FP_WRITE AS FILE)
END SUB ' Emit_For_BCX_COM_SetProperty



SUB Emit_For_BCX_COM_InvokeMethod(FP_WRITE AS FILE)
END SUB ' Emit_For_BCX_COM_InvokeMethod



SUB Emit_For_BCX_COM_SafeArray(FP_WRITE AS FILE)
  IF NOT Use_Library THEN FPRINT FP_WRITE,"/* <--UNICODE AWARE-->  */"
  IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: bcx_create_safe_array"
  FPRINT FP_WRITE,"void bcx_create_safe_array(void)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  long lv_param_incr=0;"
  FPRINT FP_WRITE,"  long lv_param_incr_rev=0;"
  FPRINT FP_WRITE,"  HRESULT hr = NO_ERROR;"
  FPRINT FP_WRITE,"  bcx_safe_array_pointer_psa = SafeArrayCreateVector(VT_VARIANT,0,bcx_param_list_index_p);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (bcx_safe_array_pointer_psa == NULL)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    bcx_clean_parameter_list();"
  FPRINT FP_WRITE,"    bcx_last_com_HRESULT = E_OUTOFMEMORY;"
  FPRINT FP_WRITE,"    bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("SafeArrayCreate failed."), "));"
  FPRINT FP_WRITE,"    return;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  for (lv_param_incr = bcx_param_list_index_p-1; lv_param_incr>=0; lv_param_incr-=1)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    hr = SafeArrayPutElement(bcx_safe_array_pointer_psa, &lv_param_incr, &bcx_static_param_list.pParams[lv_param_incr_rev]);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    if (FAILED(hr))"
  FPRINT FP_WRITE,"    {"
  FPRINT FP_WRITE,"      wsprintf(bcx_last_com_error_indicator, _T(", ENC$("Param Index = %d."), "),lv_param_incr);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"      if (bcx_safe_array_pointer_psa) SafeArrayDestroy(bcx_safe_array_pointer_psa);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"      bcx_safe_array_pointer_psa = NULL;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"      bcx_clean_parameter_list();"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"      bcx_last_com_HRESULT = hr;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"      bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("SafeArrayPutElement failed!"),"));"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"      return;"
  FPRINT FP_WRITE,"    }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    lv_param_incr_rev++;"
  FPRINT FP_WRITE,"  }"
  IF build_com_trace_code THEN ' used if com trace variable is set
    FPRINT FP_WRITE,"  bcx_com_trace_add_line(", ENC$("Saffearay created. cleaning temp variants...") , ");"
    FPRINT FP_WRITE,""

  END IF
  FPRINT FP_WRITE,"  bcx_clean_parameter_list();"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if(bcx_safe_array_pointer_psa)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    VariantInit(&bcx_static_param_list.pParams[0]);"
  FPRINT FP_WRITE,"    bcx_static_param_list.pParams[0].vt = VT_ARRAY|VT_VARIANT;"
  FPRINT FP_WRITE,"    V_ARRAY(&bcx_static_param_list.pParams[0]) = bcx_safe_array_pointer_psa;"
  FPRINT FP_WRITE,"    bcx_param_list_index_p = 1;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,sENDBCXRTLIB$
  IF NOT Use_Library THEN FPRINT FP_WRITE,"/* >--UNICODE AWARE--<  */"
END SUB ' Emit_For_BCX_COM_SafeArray



SUB Emit_For_BCX_COM_UsesConversion(FP_WRITE AS FILE)
  IF NOT Use_Library THEN FPRINT FP_WRITE,"/* <--UNICODE AWARE-->  */"
  IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_COM_WS2AS"
  FPRINT FP_WRITE,"HRESULT BCX_COM_WS2AS(LPCWSTR wide_string, UINT code_page)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  if (wide_string==NULL) return (HRESULT) NO_ERROR;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  ULONG temp_bytes_copied_len=0;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  ULONG temp_ansi_len = (ULONG)WideCharToMultiByte(code_page,0,wide_string,-1,bcx_temp_ans_string_pointer,0,NULL,NULL)+256;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (temp_ansi_len==0) return (HRESULT) NO_ERROR;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (bcx_temp_ans_string_buffer_size < temp_ansi_len)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    if (bcx_temp_ans_string_pointer) free(bcx_temp_ans_string_pointer);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    bcx_temp_ans_string_pointer = (char*)calloc(temp_ansi_len,sizeof(char));"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    if (NULL == bcx_temp_ans_string_pointer)"
  FPRINT FP_WRITE,"    {"
  FPRINT FP_WRITE,"      bcx_temp_ans_string_buffer_size = 0;"
  FPRINT FP_WRITE,"      return E_OUTOFMEMORY;"
  FPRINT FP_WRITE,"    } // if"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    bcx_temp_ans_string_buffer_size = temp_ansi_len;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if ((temp_bytes_copied_len = WideCharToMultiByte(code_page,0,wide_string,-1,bcx_temp_ans_string_pointer,temp_ansi_len,NULL,NULL))==0)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    return HRESULT_FROM_WIN32(GetLastError());"
  FPRINT FP_WRITE,"  } // if"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  bcx_temp_ans_string_pointer[temp_bytes_copied_len] = '\\0';"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  return (HRESULT)NO_ERROR;"
  FPRINT FP_WRITE,sENDBCXRTLIB$

  IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_COM_AS2WS"
  FPRINT FP_WRITE,"HRESULT BCX_COM_AS2WS(LPCSTR ansi_string, UINT code_page)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  if (!*ansi_string) return (HRESULT)NO_ERROR;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  ULONG ansi_str_len = strlen(ansi_string);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (!ansi_str_len) return (HRESULT)NO_ERROR;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  ULONG wide_str_len = (ansi_str_len * 2) + 256;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (bcx_temp_wide_string_buffer_size < wide_str_len)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    if (bcx_temp_wide_string_pointer) CoTaskMemFree((void*)bcx_temp_wide_string_pointer);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    bcx_temp_wide_string_pointer = (LPOLESTR)CoTaskMemAlloc(wide_str_len);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    if (NULL == bcx_temp_wide_string_pointer)"
  FPRINT FP_WRITE,"    {"
  FPRINT FP_WRITE,"      bcx_temp_wide_string_buffer_size = 0;"
  FPRINT FP_WRITE,"      return E_OUTOFMEMORY;"
  FPRINT FP_WRITE,"    } // if"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"    bcx_temp_wide_string_buffer_size = wide_str_len;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (MultiByteToWideChar(code_page, MB_PRECOMPOSED, ansi_string, ansi_str_len, bcx_temp_wide_string_pointer, wide_str_len)==0)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    return HRESULT_FROM_WIN32(GetLastError());"
  FPRINT FP_WRITE,"  } // if"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  bcx_temp_wide_string_pointer[ansi_str_len] = L'\\0';"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  return (HRESULT)NO_ERROR;"
  FPRINT FP_WRITE,sENDBCXRTLIB$

  IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_COM_FREE_TEMP_WIDE_STRING"
  FPRINT FP_WRITE,"void BCX_COM_FREE_TEMP_WIDE_STRING(void)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  if (bcx_temp_wide_string_pointer)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    CoTaskMemFree((void*)bcx_temp_wide_string_pointer);"
  FPRINT FP_WRITE,"    bcx_temp_wide_string_pointer = NULL;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,sENDBCXRTLIB$

  IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_COM_FREE_TEMP_ANSI_STRING"
  FPRINT FP_WRITE,"void BCX_COM_FREE_TEMP_ANSI_STRING(void)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  if (bcx_temp_ans_string_pointer)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    free(bcx_temp_ans_string_pointer);"
  FPRINT FP_WRITE,"    bcx_temp_ans_string_pointer = NULL;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,sENDBCXRTLIB$
  IF NOT Use_Library THEN FPRINT FP_WRITE,"/* >--UNICODE AWARE--<  */"
END SUB ' Emit_For_BCX_COM_UsesConversion



SUB Emit_For_BCX_COM_TraceCalls(FP_WRITE AS FILE)
  IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: bcx_com_trace_dump_DISPPARAMS"
  FPRINT FP_WRITE,"void bcx_com_trace_dump_DISPPARAMS(DISPPARAMS* dp)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  bcx_com_trace_add_line(", ENC$("   --- BEGIN DUMP OF DISPPARAMS  ---"), ");"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (!dp)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    bcx_com_trace_add_line(", ENC$("*** bcx_com_trace_dump_DISPPARAMS failed!"), ");"
  FPRINT FP_WRITE,"    bcx_com_trace_add_line(", ENC$("*** NULL argument received for DISPPARAMS* dp"), ");"
  FPRINT FP_WRITE,"    bcx_com_trace_add_line(", ENC$("   --- END DUMP OF DISPPARAMS ---"), ");"
  FPRINT FP_WRITE,"    return;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  wsprintf(bcx_com_trace_line, ", ENC$("     DISPPARAMS.rgvarg = %lu  // pointer to array of arguments."), ", dp->rgvarg);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  bcx_com_trace_add_line(bcx_com_trace_line);"
  FPRINT FP_WRITE,"  wsprintf(bcx_com_trace_line, ", ENC$("     DISPPARAMS.rgdispidNamedArgs = %lu // pointer to array of Dispatch IDs of named arguments."), ", dp->rgdispidNamedArgs);"
  FPRINT FP_WRITE,"  bcx_com_trace_add_line(bcx_com_trace_line);"
  FPRINT FP_WRITE,"  wsprintf(bcx_com_trace_line, ", ENC$("     DISPPARAMS.cArgs = %d // Number of arguments."), ", dp->cArgs);"
  FPRINT FP_WRITE,"  bcx_com_trace_add_line(bcx_com_trace_line);"
  FPRINT FP_WRITE,"  wsprintf(bcx_com_trace_line, ", ENC$("     DISPPARAMS.cNamedArgs = %d  // Number of named arguments"), ", dp->cNamedArgs);"
  FPRINT FP_WRITE,"  bcx_com_trace_add_line(bcx_com_trace_line);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  bcx_com_trace_add_line(", ENC$("   --- END DUMP OF DISPPARAMS ---"), ");"
  FPRINT FP_WRITE,sENDBCXRTLIB$

  IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: bcx_com_trace_dump_indicators"
  FPRINT FP_WRITE,"void bcx_com_trace_dump_indicators(OBJECT* object)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  bcx_com_trace_add_line(", ENC$("*** start dump of global vars ***"),");"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (object->pStatus)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"  strcpy(bcx_com_trace_line, ", ENC$("   Object status - Initialized"), ");"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,"  else"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"  strcpy(bcx_com_trace_line, ", ENC$("   Object status - UnInitialized"), ");"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  bcx_com_trace_add_line(bcx_com_trace_line);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  wsprintf(bcx_com_trace_line, ", ENC$("   dispatch chain index = %d"), ", object->ipointer);"
  FPRINT FP_WRITE,"  bcx_com_trace_add_line(bcx_com_trace_line);"
  FPRINT FP_WRITE,"  wsprintf(bcx_com_trace_line, ", ENC$("   Count of params = %d"), ", bcx_param_list_index_p);"
  FPRINT FP_WRITE,"  bcx_com_trace_add_line(bcx_com_trace_line);"
  FPRINT FP_WRITE,"  wsprintf(bcx_com_trace_line, ", ENC$("   bcx_ole_initialized = %d"), ", bcx_ole_initialized);"
  FPRINT FP_WRITE,"  bcx_com_trace_add_line(bcx_com_trace_line);"
  FPRINT FP_WRITE,"  wsprintf(bcx_com_trace_line, ", ENC$("   bcx_ole_objects_count = %d"), ", bcx_ole_objects_count);"
  FPRINT FP_WRITE,"  bcx_com_trace_add_line(bcx_com_trace_line);"
  FPRINT FP_WRITE,"  wsprintf(bcx_com_trace_line, ", ENC$("   don't reset dispatch chain afer invoke = %d"), ", bcx_force_reset_chain);"
  FPRINT FP_WRITE,"  bcx_com_trace_add_line(bcx_com_trace_line);"
  FPRINT FP_WRITE,"  bcx_com_trace_add_line(", ENC$("*** end dump of global vars ***"),");"
  FPRINT FP_WRITE,sENDBCXRTLIB$

  IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: bcx_com_trace_dump_flags"
  FPRINT FP_WRITE,"void bcx_com_trace_dump_flags(WORD wFlags)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  wsprintf(bcx_com_trace_line, ", ENC$("calling invoke with flags: "), ");"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if(wFlags & DISPATCH_PROPERTYPUT) strcat(bcx_com_trace_line,", ENC$("| DISPATCH_PROPERTYPUT "), ");"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if(wFlags & DISPATCH_PROPERTYGET) strcat(bcx_com_trace_line,", ENC$("| DISPATCH_PROPERTYGET "), ");"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if(wFlags & DISPATCH_PROPERTYPUTREF) strcat(bcx_com_trace_line,", ENC$("| DISPATCH_PROPERTYPUTREF "), ");"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if(wFlags & DISPATCH_METHOD) strcat(bcx_com_trace_line,", ENC$("| DISPATCH_METHOD "), ");"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  bcx_com_trace_add_line(bcx_com_trace_line);"
  FPRINT FP_WRITE,sENDBCXRTLIB$

  IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: bcx_com_trace_add_line"
  FPRINT FP_WRITE,"void bcx_com_trace_add_line(char* trcline)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  static FILE*  com_trc_file;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if((com_trc_file=fopen(", ENC$("c:\\\\com_trace.txt"),",",ENC$("a"),"))==0)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    fprintf(stderr,", ENC$("Can't open file c:\\\\com_trace.txt\\n"),");"
  FPRINT FP_WRITE,"    exit(1);"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  fprintf(com_trc_file,", ENC$("%s\\n"),", trcline);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (com_trc_file)"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    fflush(com_trc_file);"
  FPRINT FP_WRITE,"    fclose(com_trc_file);"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,sENDBCXRTLIB$
END SUB ' Emit_For_BCX_COM_TraceCalls



SUB Emit_For_BCX_SAFEARRAY(FP_WRITE AS FILE)
  IF NOT Use_Library THEN FPRINT Outfile,"/* <--UNICODE AWARE-->  */"
  IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: InitSafeArray"
  FPRINT FP_WRITE,"HRESULT InitSafeArray (SAFEARRAY** ppsa, VARTYPE vtype, UINT ndim, ...)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  int iCNT;"
  FPRINT FP_WRITE,"  int iDIM;"
  FPRINT FP_WRITE,"  va_list  marker;"
  FPRINT FP_WRITE,"  SAFEARRAYBOUND  tArraySize[10];"
  FPRINT FP_WRITE,"  va_start(marker,ndim);"
  FPRINT FP_WRITE,"  iCNT=0;"
  FPRINT FP_WRITE,"  iDIM=ndim;"
  FPRINT FP_WRITE,"  while(iDIM--)"
  FPRINT FP_WRITE,"    {"
  FPRINT FP_WRITE,"      tArraySize[iCNT].lLbound=va_arg(marker,long);"
  FPRINT FP_WRITE,"      tArraySize[iCNT].cElements=va_arg(marker,long);"
  FPRINT FP_WRITE,"      iCNT++;"
  FPRINT FP_WRITE,"    }"
  FPRINT FP_WRITE,"  *ppsa=SafeArrayCreate(vtype,ndim,tArraySize);"
  FPRINT FP_WRITE,"  if(*ppsa==NULL)"
  FPRINT FP_WRITE,"    {"
  FPRINT FP_WRITE,"      return E_OUTOFMEMORY;"
  FPRINT FP_WRITE,"    }"
  FPRINT FP_WRITE,"  return S_OK;"
  FPRINT FP_WRITE,sENDBCXRTLIB$
  IF NOT Use_Library THEN FPRINT FP_WRITE,"/* <--UNICODE AWARE-->  */"

  IF NOT Use_Library THEN FPRINT FP_WRITE,"/* <--UNICODE AWARE-->  */"
  IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: DestroySafeArray"
  FPRINT FP_WRITE,"HRESULT DestroySafeArray(SAFEARRAY* psA)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  return SafeArrayDestroy(psA);"
  FPRINT FP_WRITE,sENDBCXRTLIB$
  IF NOT Use_Library THEN FPRINT FP_WRITE,"/* <--UNICODE AWARE-->  */"
END SUB ' Emit_For_BCX_SAFEARRAY



SUB Emit_For_BCX_COM_CreateObject(FP_WRITE AS FILE)
  IF NOT Use_Library THEN FPRINT FP_WRITE,"/* <--UNICODE AWARE-->  */"
  IF Use_Library THEN FPRINT FP_WRITE,"// BCXRTLIB: BCX_CreateObject"
  FPRINT FP_WRITE,"void BCX_CreateObject(_TCHAR* objname, OBJECT* obj)"
  FPRINT FP_WRITE,"{"
  FPRINT FP_WRITE,"  if (!bcx_ole_initialized) bcx_ole_initialize();"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  CLSID clsid;"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#ifndef UNICODE"
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = BCX_COM_AS2WS(objname,CP_ACP);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (FAILED(bcx_last_com_HRESULT))"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("CreateObject Failed! ANSI to Wide conversion failure!"),"));"
  FPRINT FP_WRITE,"    return;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = BCX_COM_WS2AS(bcx_temp_wide_string_pointer,CP_ACP);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (FAILED(bcx_last_com_HRESULT))"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("CreateObject Failed! Wide to ANSI conversion failure!"),"));"
  FPRINT FP_WRITE,"    return;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  sprintf(bcx_last_com_error_indicator,", ENC$("%s, WideName(%s)"), ",objname, bcx_temp_ans_string_pointer);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = CLSIDFromProgID((LPCOLESTR)bcx_temp_wide_string_pointer, (LPCLSID)&clsid);"
  FPRINT FP_WRITE,"#else"
  FPRINT FP_WRITE,"  lstrcpy(bcx_last_com_error_indicator, objname);"
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = CLSIDFromProgID((LPCOLESTR)objname, (LPCLSID)&clsid);"
  FPRINT FP_WRITE,"#endif"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (FAILED(bcx_last_com_HRESULT))"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("CLSIDFromProgID failed!"),"));"
  FPRINT FP_WRITE,"    return;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#ifdef __cplusplus"
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = CoCreateInstance((REFCLSID)clsid, NULL,  CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER , IID_IUnknown, (void **)&obj->p_unknown);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#else"
  FPRINT FP_WRITE,"  bcx_last_com_HRESULT = CoCreateInstance((REFCLSID)&clsid, NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,&IID_IUnknown, (void **)&obj->p_unknown);"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"#endif"
  FPRINT FP_WRITE,"  if (FAILED(bcx_last_com_HRESULT))"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"  bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("CoCreateInstance failed!"),"));"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,"  else"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    VariantInit(&obj->pObjects[0]);"
  FPRINT FP_WRITE,"    obj->pObjects[0].vt = VT_DISPATCH;"
  FPRINT FP_WRITE,"#ifdef __cplusplus"
  FPRINT FP_WRITE,"    bcx_last_com_HRESULT = obj->p_unknown->QueryInterface(IID_IDispatch, (void **)&obj->pObjects[0].pdispVal);"
  FPRINT FP_WRITE,"#else"
  FPRINT FP_WRITE,"    bcx_last_com_HRESULT = obj->p_unknown->lpVtbl->QueryInterface(obj->p_unknown, &IID_IDispatch, (void **)&obj->pObjects[0].pdispVal);"
  FPRINT FP_WRITE,"#endif"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,""
  FPRINT FP_WRITE,"  if (FAILED(bcx_last_com_HRESULT))"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("QueryInterface::IID_IDispatch  failed!"),"));"
  FPRINT FP_WRITE,"    obj->pObjects[0].vt = VT_NULL;"
  FPRINT FP_WRITE,"    VariantClear(&obj->pObjects[0]);"
  FPRINT FP_WRITE,"#ifdef __cplusplus"
  FPRINT FP_WRITE,"    obj->p_unknown->Release();"
  FPRINT FP_WRITE,"#else"
  FPRINT FP_WRITE,"    obj->p_unknown->lpVtbl->Release(obj->p_unknown);"
  FPRINT FP_WRITE,"#endif"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,"  else"
  FPRINT FP_WRITE,"  {"
  FPRINT FP_WRITE,"    obj->pStatus = TRUE;"
  FPRINT FP_WRITE,"    obj->ipointer = 0;"
  FPRINT FP_WRITE,"    bcx_ole_objects_count++;"
  FPRINT FP_WRITE,"  }"
  FPRINT FP_WRITE,sENDBCXRTLIB$
  IF NOT Use_Library THEN FPRINT FP_WRITE,"/* >--UNICODE AWARE--<  */"
END SUB ' Emit_For_BCX_COM_CreateObject



' ************************************************************************************************************
' Sub: Add_COM_Global_Variable (part of BCX COM parser)
' This sub adds OBJECT variable to global space, which is cleaned on program end.
' If the Global nnn an Object or Dim nnn as Object is called otside Functions ans Subs,
' than nnn will be added to global COM names space. This is used so that object variables could be identifed.
'
' Last revised 17.Oct.2004
' ************************************************************************************************************
SUB Add_COM_Global_Variable(p_name$)
  IF LEN(p_name$) > 64 THEN Abort("Length of object variable " & p_name$ & " is:" & STR$(LEN(p_name$)) & ". Maximum allowed is 64 characters.")

  IF gl_COM_names_index = MAX_Global_COM_Objects THEN
    Abort("Max number of Global COM object variables reached:" & STR$(MAX_Global_COM_Objects) & CRLF$ & "Failed to reserve space for Object variable: " & p_name$)
    EXIT SUB
  END IF
  strcpy(gl_COM_names_storage[gl_COM_names_free_index].name, p_name)
  gl_COM_names_storage[gl_COM_names_free_index].initialized = TRUE
  gl_COM_names_index++
  gl_COM_names_free_index = gl_COM_names_index
END SUB ' Add_COM_Global_Variable



' ************************************************************************************************************
' Sub: Add_COM_Local_Variable (part of BCX COM parser)
' This sub adds OBJECT variable to local space, which is cleaned on exit or return from function/sub
' If the Dim nnn as Object is called inside Functions ans Subs, than nnn will be added to local
' COM object space. This is used so that object variables could be identifed.
'
' Last revised 17.Oct.2004
' ************************************************************************************************************
SUB Add_COM_Local_Variable(p_name$)
  IF LEN(p_name$) > 64 THEN Abort("Length of object variable " & p_name$ & " is:" & STR$(LEN(p_name$)) & ". Maximum allowed is 64 characters.")

  IF lc_COM_names_index = MAX_Local_COM_Objects THEN
    Abort("Max number of Local COM object variables reached:" & STR$(MAX_Local_COM_Objects) & CRLF$ & "Failed to reserve space for Object variable: " & p_name$)
    EXIT SUB
  END IF
  strcpy(lc_COM_names_storage[lc_COM_names_free_index].name, p_name)
  lc_COM_names_storage[lc_COM_names_free_index].initialized = TRUE
  lc_COM_names_index++
  lc_COM_names_free_index = lc_COM_names_index
END SUB ' Add_COM_Local_Variable



' ************************************************************************************************************
' Function: IsVariableComObject (part of BCX COM parser)
' Checks wether variable is COM initialized as COM object or not.
'
' Return Values:
' Function returns index (base 1) of COM object in storage.
' If the name is found in local storage, it will return positive index.
' If the name is found in global storage, it will return index with negative preffix.
' Zero (0) indicates that the name is not found in COM names storage.
'
' Last revised 18.Oct.2004
' ************************************************************************************************************
FUNCTION IsVariableComObject%(p_varname$)
  DIM RAW sz_var_name$
  DIM RAW l_index%

  sz_var_name$ = TRIM$(p_varname$)

  ' first try to find it in local COM object space
  IF lc_COM_names_index > 0 THEN

    FOR l_index = 0 TO lc_COM_names_index-1
      IF lc_COM_names_storage[l_index].initialized THEN
        IF sz_var_name$ = lc_COM_names_storage[l_index].name$ THEN FUNCTION = l_index+1 ' if it is found, then return index of it
      END IF
    NEXT

  END IF

  ' then, try to find it in global COM object space
  IF gl_COM_names_index > 0 THEN

    FOR l_index = 0 TO gl_COM_names_index-1
      IF gl_COM_names_storage[l_index].initialized THEN
        ' if it is found, then return negative index of it, indicating that it is a global variable
        IF sz_var_name$ = gl_COM_names_storage[l_index].name$ THEN FUNCTION = (-1 * (l_index+1))
      END IF
    NEXT

  END IF
  ' not found, so return 0
  FUNCTION = 0
END FUNCTION   ' IsVariableComObject



' ************************************************************************************************************
' Sub: BCX_FreeLocalCOMObjects (part of BCX COM parser)
' This sub is called when user forgot to call "Set ... = Nothing" for each created COM object.
'
' Last revised 17.Oct.2004
' ************************************************************************************************************
SUB BCX_FreeLocalCOMObjects(p_remove AS BOOL)
  LOCAL j
  LOCAL eraseOffset
  DO
    IF lc_COM_names_storage[j].initialized THEN
      'FPRINT Outfile,Scoot$;"if (",lc_COM_names_storage[j].name$, ".pStatus) BCX_SetNothing(&",lc_COM_names_storage[j].name$,");"
    ELSE
      ' if it comes here, than it means that at this index, object is already relased.
      ' it will happen when user calls "Set ... = Nothing" for some COM objects but not for all.
      eraseOffset ++
    END IF
    j++
  LOOP WHILE j < (lc_COM_names_index + eraseOffset)
  IF p_remove THEN
    lc_COM_names_index = 0
    lc_COM_names_free_index = 0
  END IF
END SUB  'BCX_FreeLocalCOMObjects


$comment
' Not used ?
' ************************* BCX_FreeGlobalCOMObjects *********************************************************
' This sub is called on program end to release all com objects that user forgot to call "Set ... = Nothing"
' Last revised 18.Oct.2004
SUB BCX_FreeGlobalCOMObjects()
  LOCAL j
  LOCAL eraseOffset
  DO
    IF gl_COM_names_storage[j].initialized = TRUE THEN
      'FPRINT Outfile,Scoot$;"if (",gl_COM_names_storage[j].name$, ".pStatus) BCX_SetNothing(&",gl_COM_names_storage[j].name$,");"
    ELSE
      ' if it comes here, than it means that at this index, object is already relased.
      ' it will happen when user calls "... = Nothing" for some COM objects but not for all.
      eraseOffset ++
    END IF
    j++
  LOOP WHILE j < (gl_COM_names_index + eraseOffset)
  gl_COM_names_index = 0
  gl_COM_names_free_index = 0
END SUB ' BCX_FreeGlobalCOMObjects
$comment

$comment
' disabled for now
' ********************** BCX_Remove_COM_Object ***************************************************************
' This sub is called when user use "Set ... = Nothing" to release COM object.
' First it checks the name in local storage and if it's not found it continue search in global space.
' Last revised 18.Oct.2004
SUB BCX_Remove_COM_Object(com_obj_name$)
  LOCAL com_obj_inx%
  com_obj_inx = IsVariableComObject(com_obj_name$) ' index starts from 1 for this function, 0 indicates not found
  IF com_obj_inx = 0 THEN
    'DumpLocalStorage()
    Abort("Unknown COM Object " & com_obj_name$)
    EXIT SUB
  END IF
  IF com_obj_inx > 0 THEN ' found in local object space
    com_obj_inx--  ' convert to base 0
    lc_COM_names_storage[com_obj_inx].name$ = ""
    lc_COM_names_storage[com_obj_inx].initialized = FALSE
    lc_COM_names_free_index = com_obj_inx
    lc_COM_names_index--
  ELSE ' found in global object space
    ' function IsVariableComObject returns index with negative preffix if name is found in global space (base 1).
    com_obj_inx = IABS(com_obj_inx)
    com_obj_inx--  ' convert to base 0
    gl_COM_names_storage[com_obj_inx].name$ = ""
    gl_COM_names_storage[com_obj_inx].initialized = FALSE
    gl_COM_names_free_index = com_obj_inx ' set the pointer of free space to a deleted record
    gl_COM_names_index--
  END IF
END SUB ' BCX_Remove_COM_Object
$comment


' ************************************************************************************************************
' Function: Find_COM_statement (part of BCX COM parser)
' The one and only ... *** Main  COM parser *** !!!
'
' Return Values:
' Function returns TRUE indicating that COM statement is found in currently parsed BCX line,
' or FALSE if COM statement is NOT found in current BCX source line.
'
' Last revised 29.Nov.2004
' Modified 2009/01/26 - Wayne Halsdorf
' ************************************************************************************************************
FUNCTION Find_COM_statement(pp_Src$) AS BOOL
  DIM RAW p_Src$
  DIM FOUND_OBJECT
  DIM FOUND_DOT
  DIM FOUND_EQU
  DIM RAW word_left$
  DIM RAW prev_word_left$
  DIM RAW j AS Integer

  p_Src$ = pp_Src$
  IF p_Src$ = "endwith" THEN FUNCTION = FALSE
  IF p_Src$ = "" THEN FUNCTION = FALSE
  ProcessingCOM_Set = FALSE
  IF LCASE$(LEFT$(pp_Src$,4))= "set " THEN
    ProcessingCOM_Set = TRUE
    pp_Src$ = TRIM$(MID$(pp_Src$,5))
    p_Src$ = pp_Src$
  END IF
  IF iMatchLft(p_Src$,"for ") THEN FUNCTION = FALSE
  ' handles with - end with constructions used in COM statements
  IF iMatchLft(p_Src$,"with ") THEN
    word_left$ = TRIM$(MID$(p_Src$,6))
    IF bcx_com_open_with_statement THEN
      IF word_left[0] = 46 THEN ' Found "." this means that this is a nested (WITH - END WITH)
        INCR bcx_com_open_with_statement
        p_Src$ = com_with_temp_str_name$ + " = " + com_with_temp_str_name$ + word_left$
      ELSE
        Abort ("Nested <<WITH>> statements, in open WITH block, are allowed only for interfaces of same COM object. For more info, see rules for using COM in BCX.")
      END IF
    ELSE ' first with block
      prev_word_left$ = TRIM$(EXTRACT$(word_left$, "."))
      IF IsVariableComObject(prev_word_left$) THEN
        INCR bcx_com_open_with_statement
        com_with_temp_str_name$ = prev_word_left$
        p_Src$ = word_left$
        IF INCHR(p_Src$,".") = 0 THEN
          pp_Src$ = ""
          FUNCTION = TRUE
        END IF
        ' fake that this is a com get statment
        p_Src$ = prev_word_left$ + " = " + word_left$
      END IF
    END IF
  ELSE ' not found with
    IF bcx_com_open_with_statement THEN            ' but inside with block
      IF p_Src[0] = 46 THEN ' Found "."            ' found . as first character
        p_Src$ = com_with_temp_str_name$ + p_Src$  ' pre-append object name
      END IF
    END IF
  END IF
  CALL FastLexer(p_Src$,"","'")
  RAW i = 2
  p_Src$ = Stk$[1]

  WHILE i <= Ndx
    IF Stk$[i] = "'" THEN EXIT WHILE
    p_Src$ = p_Src$ + Stk$[i]
    i++
  WEND

  CALL FastLexer(p_Src$,"","= ",0)
  i = 1
  j = 0
  WHILE i < Ndx
    IF Stk[i][0] = 61 THEN
      j = i
    END IF
    i++
  WEND
  IF j THEN
    i = 2
    p_Src$ = TRIM$(Stk$[1])
    WHILE i < j
      p_Src$ = p_Src$ + TRIM$(Stk$[i])
      i++
    WEND
    p_Src$ = p_Src$ + Stk$[j]
    WHILE ++j <= Ndx
      p_Src$ = p_Src$ + TRIM$(Stk$[j])
    WEND
  END IF

  CALL FastLexer(p_Src$,"","[]()=. ",0)

  RAW szLeft$
  RAW szRight$
  RAW FOUND_SPACE
  FOUND_OBJECT = FALSE
  FOUND_EQU = FALSE
  FOUND_SPACE = FALSE
  szLeft$ = ""
  szRight$ = ""
  FOUND_DOT = FALSE
  RAW DO_COM = 0  ' Get = -1, Method = 0, Set = 1

  FOR i = 1 TO Ndx

    IF FOUND_OBJECT = FALSE THEN
      FOUND_OBJECT = IsVariableComObject(Stk$[i])
    END IF

    IF Stk[i][0] = 61 THEN
      FOUND_EQU = TRUE     ' check for =
      IF FOUND_OBJECT = FALSE THEN
        IF DO_COM = 0 THEN DO_COM = -1 ELSE DO_COM = 1
      ELSE
        IF FOUND_DOT = FALSE THEN DO_COM = -1 ELSE DO_COM = 1
      END IF
      ITERATE
    END IF

    IF Stk[i][0] = 46 AND FOUND_OBJECT <> FALSE THEN FOUND_DOT = TRUE
    IF FOUND_OBJECT AND Stk[i][0] = 32 THEN FOUND_SPACE = i : ITERATE
    IF FOUND_EQU OR FOUND_SPACE THEN
      szRight$ = szRight$ + Stk$[i]
      IF Stk$[i] = "(" THEN
        RAW iP AS Integer
        iP = 1
        WHILE iP
          i++
          IF Stk$[i] = "(" THEN iP++
          IF Stk$[i] = ")" THEN iP--
          szRight$ = szRight$ + TRIM$(Stk$[i])
        WEND
      END IF
    ELSE
      IF Stk$[i] = "(" THEN
        RAW iP AS Integer
        szLeft$ = szLeft$ + Stk$[i]
        iP = 1
        WHILE iP
          IF i = Ndx THEN Abort("Unbalance () in COM statement")
          i++
          IF Stk$[i] = "(" THEN iP++
          IF Stk$[i] = ")" THEN iP--
          szLeft$ = szLeft$ + TRIM$(Stk$[i])
        WEND
      ELSE
        szLeft$ = szLeft$ + Stk$[i]
      END IF
    END IF
  NEXT

  IF FOUND_OBJECT <> FALSE THEN
    IF FOUND_DOT THEN
      IF build_com_trace_code THEN
        FPRINT Outfile,"bcx_com_trace_add_line(", ENC$("  "),");"
        FPRINT Outfile,"bcx_com_trace_add_line(", ENC$("***********************************************************"),");"
        FPRINT Outfile,"bcx_com_trace_add_line(", ENC$("Source Line= "+BCX_PREPARE_COM_TRACE_LINE$(pp_Src$)),");"
      END IF

      SELECT CASE DO_COM
        CASE -1
        BCX_COM_Parse_GetProperty(szLeft$, szRight$)

        CASE 0
        BCX_COM_Parse_Method(szLeft$, szRight$)

        CASE 1
        BCX_COM_Parse_SetProperty(szLeft$, szRight$, FOUND_OBJECT)

      END SELECT
      pp_Src$ = ""
      FUNCTION = TRUE
    END IF
  END IF
'jcfuller added 08/06/2013 as a Wayne bcx 7.0.5 fix
  CALL XParse(pp_Src$)
  FUNCTION = FALSE
END FUNCTION ' Find_COM_statement





' ************************************************************************************************************
' Sub: BCX_COM_Parse_GetProperty (part of BCX COM parser)
' Called internaly by main com parser function, Find_COM_statement.
' If the statment is a COM Get Property type, this function will be called.
'
' Typical sample:
' b$ = excel.ActiveSheet.Cells(4,1).Value
'
' Last revised 29.Apr.2008  - fix for floating point parameters -- Ljubisa
' 2009-01-26 - Added ParseCom() so that all COM parsing is identicall - Wayne
' ************************************************************************************************************
'SUB BCX_COM_Parse_GetProperty(varname$, com_property$)
SUB BCX_COM_Parse_GetProperty(vn As const char Ptr, cp As const char Ptr)
  Use_BCX_COM_GetProperty = Use_BCX_COM_UsesConversion = Use_COM = TRUE

  LOCAL com_method$
  DIM RAW j
  LOCAL ObjName$
  LOCAL ComTok$
  LOCAL ComTokPrev$
  LOCAL temp_param$
  LOCAL force_cast$
  DIM varname$,com_property$
  varname$ = vn
  com_property$ = cp

  DIM RAW force_casting = 0
  com_method$ = TRIM$(com_property$)

  IF com_method[0] = c_LPar THEN ' type casting
    force_cast$ = TRIM$(UCASE$(EXTRACT$(com_method+1,")")))
    com_method$ = TRIM$(REMAIN$(com_method,")"))
    force_casting = 1
  END IF

  CALL ParseCom(com_method$)
  j = 1
  ObjName$ = ComStk$[j++]
  ComTok$ = ComStk$[j++]

  DO
    ComTokPrev$ = ComTok$
    ComTok$ = ComStk$[j++]
    FPRINT Outfile, ""
    FPRINT Outfile, Scoot$;"lstrcpy(bcx_last_com_error_indicator, _T(", ENC$(BCX_PREPARE_COM_TRACE_LINE$(ComTokPrev$)),"));"

    IF INCHR(ComTokPrev$, "(") > 0 THEN
      temp_param$ = TRIM$(REMAIN$(ComTokPrev$,"("))
      FPRINT Outfile, Scoot$;"bcx_param_list_index_p = ", BCX_COM_BUILD_PARAMETER_LIST(MID$(temp_param$,1,LEN(temp_param$)-1),1),";"
      ComTokPrev$ = EXTRACT$(ComTokPrev$,"(")
    END IF

    IF ComTok$ > "" THEN
      IF build_com_trace_code  THEN ' used if com trace variable is set
        FPRINT Outfile,"    bcx_com_trace_add_line(", ENC$(">>> Get next dispatch for:: "+ComTokPrev$), ");"
      END IF
      FPRINT Outfile, Scoot$;"bcx_get_next_dispatch(&",ObjName$,", L",ENC$(REMOVE$(ComTokPrev$," ")),");"

    ELSE
      IF bcx_com_open_with_statement THEN
        IF build_com_trace_code  THEN ' used if com trace variable is set
          FPRINT Outfile,"    bcx_com_trace_add_line(", ENC$("WITH construction >>> Get next dispatch for:: "+ComTokPrev$), ");"
        END IF
        FPRINT Outfile, Scoot$;"bcx_get_next_dispatch(&",ObjName$,", L",ENC$(REMOVE$(ComTokPrev$," ")),");"
        FPRINT Outfile, Scoot$;"bcx_preserve_dispatch_at_offset = ";com_with_temp_str_name$;".ipointer;"
        FPRINT Outfile, Scoot$;"bcx_preserve_dispatch_storage_index++;"
        FPRINT Outfile, Scoot$;"bcx_preserve_dispatch_storage[bcx_preserve_dispatch_storage_index] = bcx_preserve_dispatch_at_offset;"
        EXIT SUB
      END IF

      IF build_com_trace_code  THEN ' used if com trace variable is set
        FPRINT Outfile,"    bcx_com_trace_add_line(", ENC$(">>> bcx_invoke_helper for:: "+ComTokPrev$), ");"
      END IF

      IF bcx_get_com_enumerator THEN
        FPRINT Outfile, Scoot$;"bcx_get_next_dispatch(&",ObjName$,", L",ENC$(REMOVE$(ComTokPrev$," ")),");"
        EXIT SUB
      ELSE
        FPRINT Outfile, Scoot$;"bcx_invoke_helper(&",ObjName$,", L",ENC$(REMOVE$(ComTokPrev$," ")),",DISPATCH_PROPERTYGET|DISPATCH_METHOD, &bcx_temp_result_variant);"
      END IF

      IF force_casting = 1 THEN
        FPRINT Outfile, Scoot$;"VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0,", force_cast$ ,");"
      END IF

      IF NOT *varname THEN EXIT DO ' varname is not passed and variant will be cleared elsewhere. Used Internaly by COM parser.

      RAW Cleanvarname$
      Cleanvarname$ = TRIM$(Clean$(varname$))

      IF force_casting = 1 THEN
        IF force_cast$ = "VT_BSTR" THEN
          FPRINT Outfile,Scoot$;Cleanvarname$," = SysAllocString(bcx_temp_result_variant.bstrVal);"
        ELSE
          force_cast$ = REPLACE$(force_cast$,"VT_","V_")
          FPRINT Outfile,Scoot$;Cleanvarname$," = ", force_cast$,"(&bcx_temp_result_variant);"
        END IF
      ELSE
        RAW VI AS VarInfo PTR
        RAW vt, id
        RAW tVI AS VarInfo

        IF INSTR(Cleanvarname$, ".") THEN
          RAW sTAG$
          sTAG$ = LEFT$(Cleanvarname$,INSTR(Cleanvarname$,".")-1)
          vt = CheckLocal(sTAG$, &id)
          IF vt = vt_UNKNOWN THEN
            vt = CheckGlobal(sTAG$, &id)
            IF vt = vt_UNKNOWN THEN
              Abort("Unknown structure " + sTAG$ + " not previously dimensioned")
            END IF
          END IF
          tVI.VarPntr = 0
          tVI.VarType = 0
          'FPRINT Outfile,"// Structure ";sTAG$;vt  'DEBUG
          IF vt = vt_VARIANT THEN
            raw i
            sTAG$ = mid$(Cleanvarname$,instr(Cleanvarname$,".")+1)
            i = 0
            while atVARIANTVALUENAMES[i].sNAME
              if atVARIANTVALUENAMES[i].sNAME$ = sTAG$ then
                tVI.VarType = atVARIANTVALUENAMES[i].iTYPE
                tVI.VarPntr = atVARIANTVALUENAMES[i].iPTRS
                vt = tVI.VarType
                exit while
              end if
              i++
            wend
          END IF
          VI = &tVI
        ELSE
          vt = CheckLocal(Cleanvarname$, &id)
          IF vt = vt_UNKNOWN THEN
            vt = CheckGlobal(Cleanvarname$, &id)
            IF vt = vt_UNKNOWN THEN
              Abort("Unknown variable " + varname$ + " not previously dimensioned")
            END IF
            VI = &GlobalVars[id]
          ELSE
            VI = &LocalVars[id]
          END IF
        END IF
        ' Debugger line
        'FPRINT Outfile,Scoot$;"// ";vt;VI->VarPntr
        SELECT CASE vt    'RIGHT$(TRIM$(varname$),1)
          CASE vt_VARIANT

          IF VI->VarPntr THEN
            'FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != (VT_VARIANT | VT_BYREF))"
            'FPRINT Outfile,Scoot$;" VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0,VT_VARIANT | VT_BYREF);"
            FPRINT Outfile,Scoot$;"VariantCopy((VARIANT *)(&";Cleanvarname$;"),&bcx_temp_result_variant);"
          ELSE
            FPRINT Outfile,Scoot$;"VariantCopy(&";Cleanvarname$;",&bcx_temp_result_variant);"
          END IF

          CASE vt_DOUBLE ' double precision float variable
          IF VI->VarPntr THEN
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != (VT_R8 | VT_BYREF))"
            FPRINT Outfile,Scoot$;"  {"
            FPRINT Outfile,Scoot$;"  VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0,VT_R8 | VT_BYREF);"
            IF build_com_trace_code THEN ' used if com trace variable is set
              FPRINT Outfile,Scoot$;"  bcx_com_trace_add_line(";ENC$("Return variable for "+Cleanvarname$+" was coerced");");"
            END IF
            FPRINT Outfile,Scoot$;"  }"
            FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.pdblVal;"
          ELSE
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != VT_R8)"
            FPRINT Outfile,Scoot$;"  {"
            FPRINT Outfile,Scoot$;"  VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0,VT_R8);"
            IF build_com_trace_code THEN ' used if com trace variable is set
              FPRINT Outfile,Scoot$;"  bcx_com_trace_add_line(";ENC$("Return variable for "+Cleanvarname$+" was coerced");");"
            END IF
            FPRINT Outfile,Scoot$;"  }"
            FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.dblVal;"
          END IF

          CASE vt_SINGLE ' single precision float variable
          IF VI->VarPntr THEN
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != (VT_R4 | VT_BYREF))"
            FPRINT Outfile,Scoot$;"  {"
            FPRINT Outfile,Scoot$;"  VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0, VT_R4 | VT_BYREF);"
            IF build_com_trace_code THEN ' used if com trace variable is set
              FPRINT Outfile,Scoot$;"  bcx_com_trace_add_line(";ENC$("Return variable for "+Cleanvarname$+" was coerced");");"
            END IF
            FPRINT Outfile,Scoot$;"  }"
            FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.pfltVal;"
          ELSE
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != VT_R4)"
            FPRINT Outfile,Scoot$;"  {"
            FPRINT Outfile,Scoot$;"  VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0, VT_R4);"
            IF build_com_trace_code THEN ' used if com trace variable is set
              FPRINT Outfile,Scoot$;"  bcx_com_trace_add_line(";ENC$("Return variable for "+Cleanvarname$+" was coerced");");"
            END IF
            FPRINT Outfile,Scoot$;"  }"
            FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.fltVal;"
          END IF

          CASE vt_INTEGER ' integer variable
          IF VI->VarPntr THEN
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != (VT_INT | VT_BYREF))"
            FPRINT Outfile,Scoot$;"  {"
            FPRINT Outfile,Scoot$;"  VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0, VT_INT | VT_BYREF);"
            IF build_com_trace_code THEN ' used if com trace variable is set
              FPRINT Outfile,Scoot$;"  bcx_com_trace_add_line(";ENC$("Return variable for "+Cleanvarname$+" was coerced");");"
            END IF
            FPRINT Outfile,Scoot$;"  }"
            FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.pintVal;"
          ELSE
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != VT_INT)"
            FPRINT Outfile,Scoot$;"  {"
            FPRINT Outfile,Scoot$;"  VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0, VT_INT);"
            IF build_com_trace_code THEN ' used if com trace variable is set
              FPRINT Outfile,Scoot$;"  bcx_com_trace_add_line(";ENC$("Return variable for "+Cleanvarname$+" was coerced");");"
            END IF
            FPRINT Outfile,Scoot$;"  }"
            FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.intVal;"
          END IF

          CASE vt_UINT
          IF VI->VarPntr THEN
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != (VT_UI4 | VT_BYREF))"
            FPRINT Outfile,Scoot$;"  {"
            FPRINT Outfile,Scoot$;"  VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0, VT_UI4 | VT_BYREF);"
            IF build_com_trace_code THEN ' used if com trace variable is set
              FPRINT Outfile,Scoot$;"  bcx_com_trace_add_line(";ENC$("Return variable for "+Cleanvarname$+" was coerced");");"
            END IF
            FPRINT Outfile,Scoot$;"  }"
            FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.uintVal;"
          ELSE
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != VT_INT)"
            FPRINT Outfile,Scoot$;"  {"
            FPRINT Outfile,Scoot$;"  VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0, VT_INT);"
            IF build_com_trace_code THEN ' used if com trace variable is set
              FPRINT Outfile,Scoot$;"  bcx_com_trace_add_line(";ENC$("Return variable for "+Cleanvarname$+" was coerced");");"
            END IF
            FPRINT Outfile,Scoot$;"  }"
            FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.uintVal;"
          END IF

          CASE vt_LONG ' integer variable
          IF VI->VarPntr THEN
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != (VT_I4 | VT_BYREF))"
            FPRINT Outfile,Scoot$;"  {"
            FPRINT Outfile,Scoot$;"  VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0, VT_I4 | VT_BYREF);"
            IF build_com_trace_code THEN ' used if com trace variable is set
              FPRINT Outfile,Scoot$;"  bcx_com_trace_add_line(";ENC$("Return variable for "+Cleanvarname$+" was coerced");");"
            END IF
            FPRINT Outfile,Scoot$;"  }"
            FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.plVal;"
          ELSE
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != VT_I4)"
            FPRINT Outfile,Scoot$;"  {"
            FPRINT Outfile,Scoot$;"  VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0, VT_I4);"
            IF build_com_trace_code THEN ' used if com trace variable is set
              FPRINT Outfile,Scoot$;"  bcx_com_trace_add_line(";ENC$("Return variable for "+Cleanvarname$+" was coerced");");"
            END IF
            FPRINT Outfile,Scoot$;"  }"
            FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.lVal;"
          END IF

          CASE vt_ULONG
          IF VI->VarPntr THEN
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != (VT_UI4 | VT_BYREF))"
            FPRINT Outfile,Scoot$;"  {"
            FPRINT Outfile,Scoot$;"  VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0, VT_UI4 | VT_BYREF);"
            IF build_com_trace_code THEN ' used if com trace variable is set
              FPRINT Outfile,Scoot$;"  bcx_com_trace_add_line(";ENC$("Return variable for "+Cleanvarname$+" was coerced");");"
            END IF
            FPRINT Outfile,Scoot$;"  }"
            FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.pulVal;"
          ELSE
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != VT_UI4)"
            FPRINT Outfile,Scoot$;"  {"
            FPRINT Outfile,Scoot$;"  VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0, VT_UI4);"
            IF build_com_trace_code THEN ' used if com trace variable is set
              FPRINT Outfile,Scoot$;"  bcx_com_trace_add_line(";ENC$("Return variable for "+Cleanvarname$+" was coerced");");"
            END IF
            FPRINT Outfile,Scoot$;"  }"
            FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.ulVal;"
          END IF

          CASE vt_LLONG
          IF VI->VarPntr THEN
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != (VT_I8 | VT_BYREF))"
            FPRINT Outfile,Scoot$;"  {"
            FPRINT Outfile,Scoot$;"  VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0, VT_I8 | VT_BYREF);"
            IF build_com_trace_code THEN ' used if com trace variable is set
              FPRINT Outfile,Scoot$;"  bcx_com_trace_add_line(";ENC$("Return variable for "+Cleanvarname$+" was coerced");");"
            END IF
            FPRINT Outfile,Scoot$;"  }"
            FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.pllVal;"
          ELSE
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != VT_I8)"
            FPRINT Outfile,Scoot$;"  {"
            FPRINT Outfile,Scoot$;"  VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0, VT_I8);"
            IF build_com_trace_code THEN ' used if com trace variable is set
              FPRINT Outfile,Scoot$;"  bcx_com_trace_add_line(";ENC$("Return variable for "+Cleanvarname$+" was coerced");");"
            END IF
            FPRINT Outfile,Scoot$;"  }"
            FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.llVal;"
          END IF

          CASE vt_ULLONG
          IF VI->VarPntr THEN
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != (VT_UI8 | VT_BYREF))"
            FPRINT Outfile,Scoot$;"  {"
            FPRINT Outfile,Scoot$;"  VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0, VT_UI8 | VT_BYREF);"
            IF build_com_trace_code THEN ' used if com trace variable is set
              FPRINT Outfile,Scoot$;"  bcx_com_trace_add_line(";ENC$("Return variable for "+Cleanvarname$+" was coerced");");"
            END IF
            FPRINT Outfile,Scoot$;"  }"
            FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.pullVal;"
          ELSE
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != VT_UI8)"
            FPRINT Outfile,Scoot$;"  {"
            FPRINT Outfile,Scoot$;"  VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0, VT_UI8);"
            IF build_com_trace_code THEN ' used if com trace variable is set
              FPRINT Outfile,Scoot$;"  bcx_com_trace_add_line(";ENC$("Return variable for "+Cleanvarname$+" was coerced");");"
            END IF
            FPRINT Outfile,Scoot$;"  }"
            FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.ullVal;"
          END IF

          CASE vt_SHORT
          IF VI->VarPntr THEN
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != (VT_I2 | VT_BYREF))"
            FPRINT Outfile,Scoot$;"  {"
            FPRINT Outfile,Scoot$;"  VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0, VT_I2 | VT_BYREF);"
            IF build_com_trace_code THEN ' used if com trace variable is set
              FPRINT Outfile,Scoot$;"  bcx_com_trace_add_line(";ENC$("Return variable for "+Cleanvarname$+" was coerced");");"
            END IF
            FPRINT Outfile,Scoot$;"  }"
            FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.piVal;"
          ELSE
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != VT_I2)"
            FPRINT Outfile,Scoot$;"  {"
            FPRINT Outfile,Scoot$;"  VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0, VT_I2);"
            IF build_com_trace_code THEN ' used if com trace variable is set
              FPRINT Outfile,Scoot$;"  bcx_com_trace_add_line(";ENC$("Return variable for "+Cleanvarname$+" was coerced");");"
            END IF
            FPRINT Outfile,Scoot$;"  }"
            FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.iVal;"
          END IF

          CASE vt_USHORT
          IF VI->VarPntr THEN
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != (VT_UI2 | VT_BYREF))"
            FPRINT Outfile,Scoot$;"  {"
            FPRINT Outfile,Scoot$;"  VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0, VT_UI2 | VT_BYREF);"
            IF build_com_trace_code THEN ' used if com trace variable is set
              FPRINT Outfile,Scoot$;"  bcx_com_trace_add_line(";ENC$("Return variable for "+Cleanvarname$+" was coerced");");"
            END IF
            FPRINT Outfile,Scoot$;"  }"
            FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.puiVal;"
          ELSE
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != VT_UI2)"
            FPRINT Outfile,Scoot$;"  {"
            FPRINT Outfile,Scoot$;"  VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0, VT_UI2);"
            IF build_com_trace_code THEN ' used if com trace variable is set
              FPRINT Outfile,Scoot$;"  bcx_com_trace_add_line(";ENC$("Return variable for "+Cleanvarname$+" was coerced");");"
            END IF
            FPRINT Outfile,Scoot$;"  }"
            FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.uiVal;"
          END IF

          'CASE vt_CHAR
          '    IF VI->VarPntr THEN
          '      FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != (VT_UI2 | VT_BYREF))"
          '      FPRINT Outfile,Scoot$;"VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0, VT_UI2 | VT_BYREF);"
          '      FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.puiVal;"
          '    ELSE
          '      FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != VT_UI2)"
          '      FPRINT Outfile,Scoot$;"  VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0, VT_UI2);"
          '      FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.uiVal;"
          '    END IF

          CASE vt_BYTE
          IF VI->VarPntr THEN
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != (VT_UI1 | VT_BYREF))"
            FPRINT Outfile,Scoot$;"  {"
            FPRINT Outfile,Scoot$;"  VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0, VT_UI1 | VT_BYREF);"
            IF build_com_trace_code THEN ' used if com trace variable is set
              FPRINT Outfile,Scoot$;"  bcx_com_trace_add_line(";ENC$("Return variable for "+Cleanvarname$+" was coerced");");"
            END IF
            FPRINT Outfile,Scoot$;"  }"
            FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.pbVal;"
          ELSE
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != VT_UI1)"
            FPRINT Outfile,Scoot$;"  {"
            FPRINT Outfile,Scoot$;"  VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0, VT_UI1);"
            IF build_com_trace_code THEN ' used if com trace variable is set
              FPRINT Outfile,Scoot$;"  bcx_com_trace_add_line(";ENC$("Return variable for "+Cleanvarname$+" was coerced");");"
            END IF
            FPRINT Outfile,Scoot$;"  }"
            FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.bVal;"
          END IF

          CASE vt_BOOL
          IF VI->VarPntr THEN
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != (VT_BOOL | VT_BYREF))"
            FPRINT Outfile,Scoot$;"  {"
            FPRINT Outfile,Scoot$;"VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0, VT_BOOL | VT_BYREF);"
            IF build_com_trace_code THEN ' used if com trace variable is set
              FPRINT Outfile,Scoot$;"  bcx_com_trace_add_line(";ENC$("Return variable for "+Cleanvarname$+" was coerced");");"
            END IF
            FPRINT Outfile,Scoot$;"  }"
            FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.pboolVal;"
          ELSE
            FPRINT Outfile,Scoot$;Cleanvarname$," = CON_VARBOOL2BOOL(bcx_temp_result_variant.boolVal);"
          END IF


          CASE vt_STRVAR, vt_CHAR     ' string variable
          '<Temporary fix for null BSTR. GOK 2004-12-04
          FPRINT Outfile,Scoot$;"if(bcx_temp_result_variant.vt == VT_NULL){"
          FPRINT Outfile,Scoot$;"  *",Cleanvarname$,"=0;"
          FPRINT Outfile,Scoot$;"} else {"
          FPRINT Outfile,Scoot$;"bcx_last_com_HRESULT = VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0, VT_BSTR);"
          FPRINT Outfile,Scoot$;"if (FAILED(bcx_last_com_HRESULT)) {"
          FPRINT Outfile,Scoot$;"  bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("VariantChangeType (BSTR) Failed!"),"));"
          FPRINT Outfile,Scoot$;"} else {"
          FPRINT Outfile,Scoot$;"  #ifndef UNICODE"
          FPRINT Outfile,Scoot$;"  bcx_last_com_HRESULT = BCX_COM_WS2AS(bcx_temp_result_variant.bstrVal,CP_ACP);"
          FPRINT Outfile,Scoot$;"  if (FAILED(bcx_last_com_HRESULT)) {"
          FPRINT Outfile,Scoot$;"    bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("COM Get Property Failed! Wide to ANSI conversion failure!"),"));"
          FPRINT Outfile,Scoot$;"  } else {"
          FPRINT Outfile,Scoot$;"   strcpy(", Cleanvarname$,", bcx_temp_ans_string_pointer);"
          FPRINT Outfile,Scoot$;"  }"
          FPRINT Outfile,Scoot$;"  #else"
          FPRINT Outfile,Scoot$;"  lstrcpy(", Cleanvarname$,",bcx_temp_result_variant.bstrVal);"
          FPRINT Outfile,Scoot$;"  #endif"
          FPRINT Outfile,Scoot$;"}"
          FPRINT Outfile,Scoot$;"}"

          CASE vt_UDT
          'FPRINT Outfile,Scoot$;"// CASE vt_UDT GENERATED CODE" 'DEBUG

          IF ProcessingCOM_Set AND IsVariableComObject(Cleanvarname$) THEN
            ProcessingCOM_Set = FALSE
            'FPRINT Outfile,Scoot$;"printf(", ENC$("VT_TYPE %d\\n"), ",bcx_temp_result_variant.vt);"
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != VT_DISPATCH) {"
            FPRINT Outfile,Scoot$;"bcx_last_com_HRESULT = VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0,VT_DISPATCH);"
            FPRINT Outfile,Scoot$;"}"
            FPRINT Outfile,Scoot$;"if (FAILED(bcx_last_com_HRESULT)) {"
            FPRINT Outfile,Scoot$;"  strcpy(bcx_last_com_error_indicator ,",ENC$(Cleanvarname$), ");"
            FPRINT Outfile,Scoot$;"  bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("VariantChangeType failed. Expected IDIspatch*"), "));"
            FPRINT Outfile,Scoot$;"} else {"
            FPRINT Outfile,Scoot$;"  VariantInit(&", Cleanvarname$,".pObjects[0]);"
            FPRINT Outfile,Scoot$;"  bcx_last_com_HRESULT = VariantCopy(&",Cleanvarname$,".pObjects[0],&bcx_temp_result_variant);"
            FPRINT Outfile,Scoot$;"  if (FAILED(bcx_last_com_HRESULT)) {"
            FPRINT Outfile,Scoot$;"    strcpy(bcx_last_com_error_indicator ,",ENC$(Cleanvarname$), ");"
            FPRINT Outfile,Scoot$;"    bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("VariantCopy failed."), "));"
            FPRINT Outfile,Scoot$;"  } else {"
            FPRINT Outfile,Scoot$;"    bcx_ole_objects_count++;"
            FPRINT Outfile,Scoot$;"    ", Cleanvarname$,".pStatus = TRUE;"
            FPRINT Outfile,Scoot$;"    ", Cleanvarname$,".ipointer = 0;"
            FPRINT Outfile,Scoot$;"  }  // if"
            FPRINT Outfile,Scoot$;"} // if"
          ELSE
            '<GOK 23-12-04 Bug fix changed = VT_BOOL to == VT_BOOL>
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt == VT_BOOL) {" ' performs conversion from VARIANT_BOOL to BOOL
            FPRINT Outfile,Scoot$;Cleanvarname$," = CON_VARBOOL2BOOL(bcx_temp_result_variant.boolVal);"
            FPRINT Outfile,Scoot$;"} else {"
            FPRINT Outfile,Scoot$;"switch (bcx_temp_result_variant.vt)"
            FPRINT Outfile,Scoot$;"  {"
            FPRINT Outfile,Scoot$;"  case VT_R8:"
            FPRINT Outfile,Scoot$;"      ";Cleanvarname$," = bcx_temp_result_variant.dblVal;"
            FPRINT Outfile,Scoot$;"    break;"
            FPRINT Outfile,Scoot$;"  case VT_R4:"
            FPRINT Outfile,Scoot$;"      ";Cleanvarname$," = bcx_temp_result_variant.fltVal;"
            FPRINT Outfile,Scoot$;"    break;"
            FPRINT Outfile,Scoot$;"  default:"
            FPRINT Outfile,Scoot$;"      ";Cleanvarname$," = (int)bcx_temp_result_variant.lVal;"
            FPRINT Outfile,Scoot$;"    break;"
            FPRINT Outfile,Scoot$;"  }"
            FPRINT Outfile,Scoot$;"}"
          END IF

          CASE vt_BSTR
          IF VI->VarPntr THEN
            FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.pbstrVal;"
          ELSE
            FPRINT Outfile,Scoot$;Cleanvarname$," = bcx_temp_result_variant.bstrVal;"
          END IF

          CASE ELSE
          IF ProcessingCOM_Set AND IsVariableComObject(Cleanvarname$) THEN
            ProcessingCOM_Set = FALSE
            'FPRINT Outfile,Scoot$;"printf(", ENC$("VT_TYPE %d\\n"), ",bcx_temp_result_variant.vt);"
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt != VT_DISPATCH) {"
            FPRINT Outfile,Scoot$;"bcx_last_com_HRESULT = VariantChangeType(&bcx_temp_result_variant,&bcx_temp_result_variant,0,VT_DISPATCH);"
            FPRINT Outfile,Scoot$;"}"
            FPRINT Outfile,Scoot$;"if (FAILED(bcx_last_com_HRESULT)) {"
            FPRINT Outfile,Scoot$;"  strcpy(bcx_last_com_error_indicator ,",ENC$(Cleanvarname$), ");"
            FPRINT Outfile,Scoot$;"  bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("VariantChangeType failed. Expected IDIspatch*"), "));"
            FPRINT Outfile,Scoot$;"} else {"
            FPRINT Outfile,Scoot$;"  VariantInit(&", Cleanvarname$,".pObjects[0]);"
            FPRINT Outfile,Scoot$;"  bcx_last_com_HRESULT = VariantCopy(&",Cleanvarname$,".pObjects[0],&bcx_temp_result_variant);"
            FPRINT Outfile,Scoot$;"  if (FAILED(bcx_last_com_HRESULT)) {"
            FPRINT Outfile,Scoot$;"    strcpy(bcx_last_com_error_indicator ,",ENC$(Cleanvarname$), ");"
            FPRINT Outfile,Scoot$;"    bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("VariantCopy failed."), "));"
            FPRINT Outfile,Scoot$;"  } else {"
            FPRINT Outfile,Scoot$;"    bcx_ole_objects_count++;"
            FPRINT Outfile,Scoot$;"    ", Cleanvarname$,".pStatus = TRUE;"
            FPRINT Outfile,Scoot$;"    ", Cleanvarname$,".ipointer = 0;"
            FPRINT Outfile,Scoot$;"  }  // if"
            FPRINT Outfile,Scoot$;"} // if"
          ELSE
            '<GOK 23-12-04 Bug fix changed = VT_BOOL to == VT_BOOL>
            FPRINT Outfile,Scoot$;"if (bcx_temp_result_variant.vt == VT_BOOL) {" ' performs conversion from VARIANT_BOOL to BOOL
            FPRINT Outfile,Scoot$;Cleanvarname$," = CON_VARBOOL2BOOL(bcx_temp_result_variant.boolVal);"
            FPRINT Outfile,Scoot$;"} else {"
            FPRINT Outfile,Scoot$;"switch (bcx_temp_result_variant.vt)"
            FPRINT Outfile,Scoot$;"  {"
            FPRINT Outfile,Scoot$;"  case VT_R8:"
            FPRINT Outfile,Scoot$;"      ";Cleanvarname$," = bcx_temp_result_variant.dblVal;"
            FPRINT Outfile,Scoot$;"    break;"
            FPRINT Outfile,Scoot$;"  case VT_R4:"
            FPRINT Outfile,Scoot$;"      ";Cleanvarname$," = bcx_temp_result_variant.fltVal;"
            FPRINT Outfile,Scoot$;"    break;"
            FPRINT Outfile,Scoot$;"  default:"
            FPRINT Outfile,Scoot$;"      ";Cleanvarname$," = (int)bcx_temp_result_variant.lVal;"
            FPRINT Outfile,Scoot$;"    break;"
            FPRINT Outfile,Scoot$;"  }"
            FPRINT Outfile,Scoot$;"}"
          END IF
        END SELECT
      END IF
      FPRINT Outfile,Scoot$;"VariantClear(&bcx_temp_result_variant);"
      EXIT DO
    END IF
  LOOP
  FPRINT Outfile,Scoot$;"if (0 == bcx_force_reset_chain) bcx_reset_dispatch_chain(&",ObjName$,");"
END SUB ' BCX_COM_Parse_GetProperty



' ************************************************************************************************************
' Sub: BCX_COM_Parse_SetProperty (part of BCX COM parser)
' Called internaly by main com parser function, Find_COM_statement.
' If the statment is a COM Set Property type, this function will be called.
'
' Typical sample:
' (Property set)      -- app.language = "VBScript"
' (Property set)      -- app.visible = true
'
' Last revised 29.Apr.2008  - fix for floating point parameters -- Ljubisa
' 2009-01-26 - Added ParseCom() so that all COM parsing is identicall - Wayne Halsdorf
' ************************************************************************************************************
SUB BCX_COM_Parse_SetProperty(com_method$, pparms$, Obj_At_Index%)
  Use_BCX_COM_SetProperty = Use_BCX_COM_UsesConversion = Use_COM = TRUE
  DIM RAW j
  LOCAL ObjName$
  LOCAL ComTok$
  LOCAL ComTokPrev$
  LOCAL temp_param$
  LOCAL parms$
  DIM RAW BuildSafeArray = 0
  IF build_com_trace_code  THEN ' used if com trace variable is set
    FPRINT Outfile,"    bcx_com_trace_add_line(", ENC$("BCX_COM_Parse_SetProperty("+BCX_PREPARE_COM_TRACE_LINE$(com_method$)+" , "+BCX_PREPARE_COM_TRACE_LINE$(pparms$)+" , "+STR$(Obj_At_Index%)+")"), ");"
  END IF

  parms$ = TRIM$(pparms$)
  IF parms$ <> "" THEN
    IF MID$(UCASE$(parms$),1,6) = "ARRAY(" OR MID$(UCASE$(parms$),1,6) = "ARRAY " THEN
      parms$ = REMAIN$(parms$,"(")
      j = LEN(parms$) -1
      parms[j] = 0 ' strip closing brace )
      BuildSafeArray = 1
      Use_BCX_COM_SafeArray = TRUE
    END IF
  END IF

  CALL ParseCom(com_method$)
  j = 1
  ObjName$ = ComStk$[j++]
  ComTok$ = ComStk$[j++]

  DO
    ComTokPrev$ = ComTok$
    ComTok$ = ComStk$[j++]
    FPRINT Outfile,""
    FPRINT Outfile,Scoot$;"lstrcpy(bcx_last_com_error_indicator, _T(", ENC$(BCX_PREPARE_COM_TRACE_LINE$(ComTokPrev$)),"));"
    IF ComTok$ > "" THEN
      IF INCHR(ComTokPrev$, "(") > 0 THEN
        temp_param$ = TRIM$(REMAIN$(ComTokPrev$,"("))
        FPRINT Outfile,Scoot$;"bcx_param_list_index_p = ", BCX_COM_BUILD_PARAMETER_LIST(MID$(temp_param$,1,LEN(temp_param$)-1),1),";"
        ComTokPrev$ = TRIM$(EXTRACT$(ComTokPrev$,"("))
      END IF

      IF build_com_trace_code  THEN ' used if com trace variable is set
        FPRINT Outfile,"    bcx_com_trace_add_line(", ENC$(">>> Get next dispatch for:: "+ComTokPrev$), ");"
      END IF
      FPRINT Outfile,Scoot$;"bcx_get_next_dispatch(&",ObjName$,", L",ENC$(REMOVE$(ComTokPrev$," ")),");"
    ELSE
      IF build_com_trace_code  THEN
        FPRINT Outfile,"bcx_com_trace_add_line(", ENC$("Invoke helper for:: "+ComTokPrev$), ");"
      END IF
      FPRINT Outfile,Scoot$;"bcx_param_list_index_p =", BCX_COM_BUILD_PARAMETER_LIST(parms$,0),";"
      IF BuildSafeArray THEN
        FPRINT Outfile,Scoot$;"bcx_create_safe_array();"
      END IF

      RAW sXX$
      sXX$ = "\"+CHR$(c_DblQt)
      REPLACE CHR$(c_DblQt) WITH sXX$ IN ComTokPrev$
      FPRINT Outfile,""
      FPRINT Outfile,Scoot$;"if (!BCX_COM_ERROR) bcx_invoke_helper(&",ObjName$,", L",ENC$(REMOVE$(ComTokPrev$," ")),", DISPATCH_PROPERTYPUT, NULL);"
      EXIT DO
    END IF
  LOOP
END SUB ' BCX_COM_Parse_SetProperty



'*******************************************************************
' Function to break up parameter string into parameter token blocks
' Note: Limited support for functions and array values as parameters
' 2009-01-26 - Wayne Halsdorf
'*******************************************************************
FUNCTION GetParameterTokens(sP$)
  RAW iWorkingOn AS Integer
  RAW iLastTokenPlus1 AS Integer
  RAW ParamTok$

  CALL FastLexer(sP$,"",",()[]")
  iLastTokenPlus1 = Ndx
  IF TALLY(sP$,"(") OR TALLY(sP$,"[") THEN
    FOR iWorkingOn = 1 TO Ndx
      Stk$[iWorkingOn] = TRIM$(Stk$[iWorkingOn])
    NEXT
    CALL RemEmptyTokens
    iWorkingOn = 1
    iLastTokenPlus1 = 0
    WHILE Stk[iWorkingOn][0]
      ParamTok$ = Stk$[iWorkingOn]
      IF ParamTok[0] <> c_Komma AND Stk[iWorkingOn+1][0] <> c_Komma THEN
          DO
            iWorkingOn++
            IF iWorkingOn > Ndx THEN EXIT DO
            ParamTok$ = ParamTok$ + Stk$[iWorkingOn]
            WHILE (TALLY(ParamTok$,"[")-TALLY(ParamTok$,"]"))<>0 OR (TALLY(ParamTok$,"(")-TALLY(ParamTok$,")"))<>0
              iWorkingOn++
              ParamTok$ = ParamTok$ + Stk$[iWorkingOn]
            WEND
            IF Stk[iWorkingOn][0] = c_Komma THEN EXIT DO
          LOOP WHILE Stk[iWorkingOn][0]
      END IF
      iWorkingOn++
      Stk$[++iLastTokenPlus1] = ParamTok$
      IF iWorkingOn > Ndx THEN EXIT WHILE
    WEND
    Ndx = iLastTokenPlus1
  END IF
  iLastTokenPlus1++
  Stk$[iLastTokenPlus1] = ""
  IF cMaxParamToken <= iLastTokenPlus1 THEN CALL Abort("Maximum nunber of com tokens exceeded.")
  FOR iWorkingOn = 1 TO iLastTokenPlus1
    ParamToken$[iWorkingOn] = Stk$[iWorkingOn]
  NEXT
  FUNCTION = Ndx
END FUNCTION  ' GetParameterTokens



' ************************************************************************************************************
' Function: BCX_COM_BUILD_PARAMETER_LIST (part of BCX COM parser)
' Function calls BCX_COM_PREBUILD_PARAMETER_LIST which emmits code for COM methods invocation.
' Parameters are placed in reverse order, as requiered by COM standard.
'
' Return Values:
' returns number of created parameters for next COM call.
'
' Last revised 17.Nov.2004
' ************************************************************************************************************
FUNCTION BCX_COM_BUILD_PARAMETER_LIST(parms$, i AS Integer)
  DIM RAW RetValue%
  RetValue = BCX_COM_PREBUILD_PARAMETER_LIST(parms$, i)
  FUNCTION = RetValue
END FUNCTION ' BCX_COM_BUILD_PARAMETER



'*******************************************************
' Function to return the parameter type used in COM
' Note: Limited support for functions as parameters
' 2008-01-26 --- Wayne Halsdorf
'*******************************************************
FUNCTION ComParamType(sParam$, iRebuild AS Integer PTR)
  RAW varidx AS Integer
  RAW k AS Integer
  RAW ptVI AS VarInfo PTR
  RAW iBYREF_Flag AS Integer

  *iRebuild = 0
  IF sParam[0] = c_LPar THEN
    FUNCTION = comvt_CAST
  END IF
  IF iMatchWrd(sParam$,"true") THEN
    FUNCTION = comvt_TRUE
  END IF
  IF iMatchWrd(sParam$,"false") THEN
    FUNCTION = comvt_FALSE
  END IF
  IF sParam[0] = c_DblQt THEN
    FUNCTION = comvt_BSTR
  END IF
  IF IsNumberEx(sParam$) THEN
    IF INSTR(sParam$,".") THEN
      FUNCTION = comvt_R8_LITERAL
    ELSE
      FUNCTION = comvt_I4_LITERAL
    END IF
  END IF
  IF INSTR(sParam$, ":=") > 0 THEN ' this is named argument
    FUNCTION = comvt_NAMED_ARGUMENT
  END IF
  IF IsVariableComObject(TRIM$(Clean$(sParam$))) THEN
    FUNCTION = comvt_OBJECT
  END IF
  IF RIGHT$(sParam$,1) = "#" THEN
    FUNCTION = comvt_R8
  END IF
  IF RIGHT$(sParam$,1) = "!" THEN
    FUNCTION = comvt_R4
  END IF
  IF RIGHT$(sParam$,1) = "$" THEN
    FUNCTION = comvt_STRVAR
  END IF
  IF RIGHT$(sParam$,1) = "%" THEN
    FUNCTION = comvt_INT
  END IF
  ptVI = NULL
  k = CheckLocal(sParam$, &varidx)
  IF k <> vt_UNKNOWN THEN
    ptVI = &LocalVars[varidx]
  ELSE
    k = CheckGlobal(sParam$, &varidx)
    IF k <> vt_UNKNOWN THEN
      ptVI = &GlobalVars[varidx]
    END IF
  END IF

  IF ptVI <> NULL THEN

    iBYREF_Flag = 0
    'comvt_VECTOR    = 0x1000
    'comvt_ARRAY     = 0x2000

    IF ptVI->VarPntr = 1 THEN iBYREF_Flag = comvt_BYREF
    IF ptVI->VarPntr < 2 THEN

      SELECT CASE k
        CASE vt_VOID
          FUNCTION = comvt_VOID BOR iBYREF_Flag
        CASE vt_STRVAR
          FUNCTION = comvt_STRVAR BOR iBYREF_Flag
        CASE vt_DOUBLE
          FUNCTION = comvt_R8 BOR iBYREF_Flag
        CASE vt_SINGLE
          FUNCTION = comvt_R4 BOR iBYREF_Flag
        CASE vt_INTEGER
          FUNCTION = comvt_INT BOR iBYREF_Flag
        CASE vt_LLONG
          FUNCTION = comvt_I8 BOR iBYREF_Flag
        CASE vt_ULLONG
          FUNCTION = comvt_UI8 BOR iBYREF_Flag
        CASE vt_LONG
          FUNCTION = comvt_I4 BOR iBYREF_Flag
        CASE vt_ULONG
          FUNCTION = comvt_UI4 BOR iBYREF_Flag
        CASE vt_SHORT
          FUNCTION = comvt_I2 BOR iBYREF_Flag
        CASE vt_USHORT
          FUNCTION = comvt_UI2 BOR iBYREF_Flag
        CASE vt_CHAR
          FUNCTION = comvt_I1 BOR iBYREF_Flag
        CASE vt_BYTE
          FUNCTION = comvt_UI1 BOR iBYREF_Flag
        CASE vt_BOOL
          FUNCTION = comvt_BOOL BOR iBYREF_Flag
        CASE vt_UINT
          FUNCTION = comvt_UINT BOR iBYREF_Flag
        CASE vt_VARIANT
          FUNCTION = comvt_VARIANT BOR iBYREF_Flag
        CASE vt_UDT
          IF TypeDefs[ptVI->VarDef].VarName$ = "SAFEARRAY" THEN
            FUNCTION = comvt_SAFEARRAY BOR iBYREF_Flag
          END IF
      END SELECT
    END IF
  END IF
  IF INSTR(sParam$,"(") THEN
    RAW Keyword$
    RAW tpBCX AS tagTokenSubFunctions PTR
    *iRebuild = 1
    CALL XParse(sParam$)
    CALL TokenSubstitutions(1)
    Keyword$ = LCASE$(Stk$[1])
    tpBCX = GetWordInfo(Keyword$)
    IF tpBCX THEN
      IF tpBCX->iCOM <> comvt_BAD THEN
        FUNCTION = tpBCX->iCOM
      END IF
    END IF
  END IF
  *iRebuild = 0
  FUNCTION = comvt_DEFAULT
END FUNCTION ' ComParamType




'szParam$ (VT_ARRAY|VT_BYREF|VT_XXXX)(C_CAST)
SUB ConvertCast(szParam$, szVT$, szVAL$)
  RAW i AS Integer
  RAW szWork$

  szVT$ = ""
  szVAL$ = ""
  szWork$ = EXTRACT$(szParam$,")")
  szWork$ = MID$(szWork$,2)
  IF LEFT$(szWork$,3) = "VT_" THEN
    IF LEFT$(szWork$,8) = "VT_ARRAY" THEN
      szVAL$ = "parray"
      szVT$ = "VT_ARRAY"
      REPLACE "VT_ARRAY" WITH "" IN szWork$
    END IF
    IF INSTR(szWork$,"VT_BYREF") THEN
      szVAL$ = "p"+szVAL$
      IF szVT$ <> "" THEN szVT$ = szVT$ + "|"
      szVT$ = szVT$ + "VT_BYREF"
      REPLACE "VT_BYREF" WITH "" IN szWork$
    END IF
    WHILE szWork[0] = 124
      szWork$ = MID$(szWork$,2)
    WEND
    i = 0
    WHILE ptVCasts[i].pszCAST <> NULL
      IF LEFT$(szWork$,LEN(ptVCasts[i].pszCAST$)) = ptVCasts[i].pszCAST$ THEN
        szWork$ = REMAIN$(szParam$,")")
        IF *szWork$ = ASC("(") THEN szWork$ = REMAIN$(szWork$,")")
        szVAL$ = szVAL$ + "=" + szWork$ ' ASSUME VALID C CAST OR NO CAST
        IF szVT$ <> "" THEN szVT$ = szVT$ + "|"
        szVT$ = szVT$ + ptVCasts[i].pszCAST$
        EXIT SUB
      END IF
      i++
    WEND
    IF INSTR(szVAL$,"array") THEN
      IF szVT$ <> "" THEN szVT$ = szVT$ + "|"
      szVT$ = szVT$ + szWork$
      szWork$ = REMAIN$(szParam$,")")
      IF *szWork$ = ASC("(") THEN szWork$ = REMAIN$(szWork$,")")
      szVAL$ = szVAL$ + "=" + szWork$ ' ASSUME VALID C CAST OR NO CAST
      EXIT SUB
    END IF
    CALL Abort("Unknown cast. "+szWork$+" See help file")
  END IF
  ' DEALING WITH C CAST
  IF INSTR(szWork$,"*") THEN szVAL$ = "p"
  REPLACE "*" WITH "" IN szWork$
  i = 0
  WHILE ptCCasts[i].pszCAST <> NULL
    IF szWork$ = ptCCasts[i].pszCAST$ THEN
      szWork$ = REMAIN$(szParam$,")")
      IF *szWork$ = ASC(")") THEN szWork$ = REMAIN$(szWork$,")")
      szVAL$ = szVAL$+ptCCasts[i].pszVAL$ + "=" + szWork$ ' ASSUME VALID C CAST OR NO CAST
      IF szVT$ <> "" THEN szVT$ = szVT$ + "|"
      szVT$ = szVT$ + ptCCasts[i].pszCAST$
      EXIT SUB
    END IF
    i++
  WEND
  CALL Abort("Unknown C cast. szParam$="+szParam$+" szVT$="+szVT$+" szVAL$="+ szVAL$+" See help file")
END SUB  ' ConvertCast



' ************************************************************************************************************
' Function: BCX_COM_PREBUILD_PARAMETER_LIST (part of BCX COM parser)
' Function emmits appropriate parameters for COM calls (invoke).
'
' Return Values:
' returns number of created parameters for next COM call.
' Last revised 17.Nov.2004

'typedef struct tagSAFEARRAY {
'   USHORT cDims;
'   USHORT fFeatures;
'   ULONG cbElements;
'   ULONG cLocks;
'   PVOID pvData;
'   SAFEARRAYBOUND rgsabound[1];
'} SAFEARRAY;


'struct tagVARIANT {
'   union {
'       struct __tagVARIANT {
'           VARTYPE vt;
'           WORD wReserved1;
'           WORD wReserved2;
'           WORD wReserved3;
'           union {
'               ULONGLONG ullVal;
'               LONGLONG llVal;
'               LONG lVal;
'               BYTE bVal;
'               SHORT iVal;
'               FLOAT fltVal;
'               DOUBLE dblVal;
'               VARIANT_BOOL boolVal;
'               _VARIANT_BOOL bool;
'               SCODE scode;
'               CY cyVal;
'               DATE date;
'               BSTR bstrVal;
'               IUnknown *punkVal;
'               IDispatch *pdispVal;
'               SAFEARRAY *parray;
'               BYTE *pbVal;
'               SHORT *piVal;
'               LONG *plVal;
'               LONGLONG *pllVal;
'               FLOAT *pfltVal;
'               DOUBLE *pdblVal;
'               VARIANT_BOOL *pboolVal;
'               _VARIANT_BOOL *pbool;
'               SCODE *pscode;
'               CY *pcyVal;
'               DATE *pdate;
'               BSTR *pbstrVal;
'               IUnknown **ppunkVal;
'               IDispatch **ppdispVal;
'               SAFEARRAY **pparray;
'               VARIANT *pvarVal;
'               PVOID byref;
'               CHAR cVal;
'               USHORT uiVal;
'               ULONG ulVal;
'               INT intVal;
'               UINT uintVal;
'               DECIMAL *pdecVal;
'               CHAR *pcVal;
'               USHORT *puiVal;
'               ULONG *pulVal;
'               ULONGLONG *pullVal;
'               INT *pintVal;
'               UINT *puintVal;
'               struct __tagBRECORD {
'                   PVOID pvRecord;
'                   IRecordInfo *pRecInfo;
'               } __VARIANT_NAME_4;
'           } __VARIANT_NAME_3;
'       } __VARIANT_NAME_2;
'       DECIMAL decVal;
'   } __VARIANT_NAME_1;
'};
' 2008-01-26  --- Wayne Halsdorf
'   Recoded to allow for more diffent variable type support
'   Note: While there is some code for all types NOT all types are supported.
' ************************************************************************************************************
FUNCTION BCX_COM_PREBUILD_PARAMETER_LIST (parms$, IsIndex AS Integer)
  RAW sTMP$
  RAW sCleanTemp$
  RAW iTokens AS Integer
  RAW i AS Integer
  RAW j AS Integer
  RAW k AS Integer
  RAW iArrayFlag AS Integer
  RAW iByrefFlag AS Integer
  RAW P$
  RAW P2$
  RAW szVCast$
  RAW szCCast$
  RAW local_parm_copy$

  RAW local_temp_str$
  RAW ComParameterCnt AS Integer
  RAW iReturn AS Integer
  IF NOT *parms THEN FUNCTION = 0  ' Handle null arguments
  ComParameterCnt = 0
  local_parm_copy$ = TRIM$(parms$)
  iTokens = GetParameterTokens(local_parm_copy$)
  i = 1
  WHILE i <= iTokens
    IF ParamToken[i][0] = c_Komma THEN
      i++
    ELSE
      i += 2
    END IF
    ComParameterCnt++
  WEND
  iReturn = ComParameterCnt
  i = 1
  WHILE i <= iTokens
    szVCast$ = ""
    szCCast$ = ""
    P$ = ""
    P2$ = ";"
    iByrefFlag = 0
    iArrayFlag = 0
    IF ParamToken[i][0] = c_Komma THEN
      j = comvt_ERROR
      sCleanTemp$ = "DISP_E_PARAMNOTFOUND"
      i++
    ELSE
      j = ComParamType(ParamToken$[i], &k)
      IF k THEN
        sCleanTemp$ = ""
        FOR k = 1 TO Ndx
          sCleanTemp$ = sCleanTemp$ + Stk$[k]
        NEXT
        sCleanTemp$ = Clean$(sCleanTemp$)
      ELSE
        IF j = comvt_CAST THEN  ' Determine if C or VT cast
          CALL ConvertCast(ParamToken$[i], local_temp_str$, sCleanTemp$)
        ELSE
          sCleanTemp$ = Clean$(ParamToken$[i])
        END IF
      END IF
      iByrefFlag = j BAND comvt_BYREF
      IF iByrefFlag THEN P$ = "p" : P2$ = "|VT_BYREF;"
      iArrayFlag = j BAND comvt_ARRAY
      IF iArrayFlag THEN P$ = P$+"p" : P2$ = "|VT_ARRAY"+P2$
      j = j BAND comvt_TYPEMASK
      i += 2
    END IF

    ComParameterCnt--
    sTMP$ = TRIM$(STR$(ComParameterCnt))

    SELECT CASE j
      CASE comvt_EMPTY
      IF iArrayFlag THEN Abort("Invalid: Array of empty")
      IF iByrefFlag THEN Abort("Invalid: Pointer to empty")
      'No value was specified. If an optional argument to an Automation method is left blank,
      'do not pass a VARIANT of type VT_EMPTY. Instead, pass a VARIANT of type VT_ERROR with a
      'value of DISP_E_PARAMNOTFOUND.
      ' BY_REF INVLAID
      ' VT_ARRAY INVALID

      CASE comvt_UI1
      'An unsigned 1-byte character is stored in bVal.
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_UI1";P2$
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].";P$;"bVal = ",sCleanTemp$,";"

      CASE comvt_UI2
      'An unsigned 2-byte integer value is stored in uiVal.
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_UI2";P2$
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].";P$;"uiVal = ",sCleanTemp$,";"

      CASE comvt_UI4
      'An unsigned 4-byte integer value is stored in ulVal.
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_UI4";P2$
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].";P$;"ulVal = ",sCleanTemp$,";"

      CASE comvt_UI8
      'An unsigned 8-byte integer value is stored in ullVal.
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_UI8";P2$
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].";P$;"ullVal = ",sCleanTemp$,";"

      CASE comvt_UINT
      'An unsigned integer value is stored in uintVal.
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_UINT";P2$
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].";P$;"uintVal = ",sCleanTemp$,";"

      CASE comvt_INT
      'An integer value is stored in intVal.
      IF IsIndex = 1 THEN
        ' if warning levels add to bcx issue warning "variable type int casted to long"
        FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_I4";P2$
        FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].lVal = ",sCleanTemp$,";"
      ELSE
        FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_INT";P2$
        FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].";P$;"intVal = ",sCleanTemp$,";"
      END IF

      CASE comvt_I1
      'A 1-byte character value is stored in cVal.
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_I1";P2$
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].";P$;"cVal = ",sCleanTemp$,";"

      CASE comvt_I2
      'A 2-byte integer value is stored in iVal.
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_I2";P2$
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].";P$;"iVal = ",sCleanTemp$,";"


      CASE comvt_I4
      'A 4-byte integer value is stored in lVal.
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_I4";P2$
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].";P$;"lVal = ",sCleanTemp$,";"

      CASE comvt_I8
      'A 8-byte integer value is stored in llVal.
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_I8";P2$
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].";P$;"llval = ",sCleanTemp$,";"

      CASE comvt_R4
      'An IEEE 4-byte real value is stored in fltVal.
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_R4";P2$
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].";P$;"fltVal = ",sCleanTemp$,";"

      CASE comvt_R8
      'An 8-byte IEEE real value is stored in dblVal.
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_R8";P2$
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].";P$;"dblVal = ",sCleanTemp$,";"

      CASE comvt_CY
      'A currency value was specified. A currency number is stored as 64-bit (8-byte),
      'two's complement integer, scaled by 10,000 to give a fixed-point number
      'with 15 digits to the left of the decimal point and 4 digits to the right.
      'The value is in cyVal.
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_CY";P2$
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].";P$;"cyVal = ",sCleanTemp$,";"

      CASE comvt_BSTR
      'A string was passed; it is stored in bstrVal. This pointer must be obtained and
      'freed by the BSTR functions, which are described in Conversion and Manipulation Functions.
      'jcfuller change for new chr$ use vchr instead
      REPLACE CHR$(92)       WITH VCHR$(2,92,92) IN sCleanTemp$
      REPLACE VCHR$(3,92,92,92) WITH VCHR$(2,92,92) IN sCleanTemp$

'      REPLACE CHR$(92)       WITH CHR$(92,92) IN sCleanTemp$
'      REPLACE CHR$(92,92,92) WITH CHR$(92,92) IN sCleanTemp$
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_BSTR";P2$
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].";P$;"bstrVal = SysAllocString(L",sCleanTemp$,");"

      CASE comvt_DECIMAL
      'Decimal variables are stored as 96-bit (12-byte) unsigned integers scaled by a
      'variable power of 10. VT_DECIMAL uses the entire 16 bytes of the Variant.
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_BYREF|VT_DECIMAL;"
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].";P$;"decVal = ",sCleanTemp$,";"

      CASE comvt_NULL
      IF iArrayFlag THEN Abort("Invalid: Array of NULLs")
      IF iByrefFlag THEN Abort("Invalid: Pointer to NULL")
      'A propagating null value was specified. (This should not be confused with the null pointer.)
      'The null value is used for tri-state logic, as with SQL.
      ' BY_REF INVALID
      ' VT_ARRAY INVALID

      CASE comvt_ERROR
      'An SCODE was specified. The type of the error is specified in scodee. Generally,
      'operations on error values should raise an exception or propagate the error to
      'the return value, as appropriate.
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_ERROR";P2$
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].";P$;"scode = ",sCleanTemp$,";"

      CASE comvt_BOOL
      'A 16 bit Boolean (True/False) value was specified.
      'A value of 0xFFFF (all bits 1) indicates True;
      'a value of 0 (all bits 0) indicates False. No other values are valid.
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_BOOL";P2$
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].";P$;"boolVal = ",sCleanTemp$,";"

      CASE comvt_TRUE
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_BOOL";P2$
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].";P$;"boolVal = VARIANT_TRUE;"

      CASE comvt_FALSE
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_BOOL";P2$
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].";P$;"boolVal = VARIANT_FALSE;"

      CASE comvt_DATE
      'A value denoting a date and time was specified. Dates are represented as
      'double-precision numbers, where midnight, January 1, 1900 is 2.0, January 2, 1900 is 3.0,
      'and so on. The value is passed in date.
      'This is the same numbering system used by most spreadsheet programs,
      'although some specify incorrectly that February 29, 1900 existed, and thus
      'set January 1, 1900 to 1.0. The date can be converted to and from an MS-DOS
      'representation using VariantTimeToDosDateTime, which is discussed in
      'Conversion and Manipulation Functions.
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_DATE";P2$
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].";P$;"date = ",sCleanTemp$,";"

      CASE comvt_DISPATCH
      'A pointer to an object was specified. The pointer is in pdispVal.
      'This object is known only to implement IDispatch. The object can be queried as to
      'whether it supports any other desired interface by calling QueryInterface on the object.
      'Objects that do not implement IDispatch should be passed using VT_UNKNOWN.
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_DISPATCH";P2$
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].";P$;"pdispVal = ",sCleanTemp$,";"

      CASE comvt_VARIANT
      'IF NOT iByrefFlag AND NOT iArrayFlag THEN Abort("Invalid: VARIANTARGs must be passed by reference.")
      'A pointer to another VARIANTARG is passed in pvarVal. This referenced VARIANTARG,
      'pvarVal, cannot be another VT_VARIANT|VT_BYREF. This value can be used to support
      'languages that allow functions to change the types of variables passed by reference.
      IF NOT iByrefFlag AND NOT iArrayFlag THEN   ' assumes variant holds a safearray of variants
        FPRINT Outfile,Scoot$;"  bcx_static_param_list.pParams[",sTMP$,"].vt = VT_VARIANT | VT_ARRAY;"
        FPRINT Outfile,Scoot$;"  bcx_static_param_list.pParams[",sTMP$,"].pvarVal = ";sCleanTemp$;".pvarVal;"
      ELSE
        FPRINT Outfile,Scoot$;"  bcx_static_param_list.pParams[",sTMP$,"].vt = VT_VARIANT";P2$
        FPRINT Outfile,Scoot$;"  bcx_static_param_list.pParams[",sTMP$,"].";P$;"pvarVal = ",sCleanTemp$,";"
      END IF

      CASE comvt_UNKNOWN
      'A pointer to an object that implements the IUnknown interface is passed in punkVal.
      'BY_REF: A pointer to the IUnknown interface is passed in ppunkVal. The pointer to
      'the interface is stored in the location referred to by ppunkVal.
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_UNKNOWN";P2$
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].";P$;"punkVal = ",sCleanTemp$,";"



      'CASE comvt__VARIANT_BOOL
      '  FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT__VARIANT_BOOL";P2$
      '  FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].";P$;"bool = ",sCleanTemp$,";"

      CASE comvt_PVOID
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_PVOID";P2$
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].";P$;"byref = ",sCleanTemp$,";"

      CASE comvt_STRVAR
      FPRINT Outfile,Scoot$;"bcx_last_com_HRESULT = BCX_COM_AS2WS(",sCleanTemp$, ",CP_ACP);"
      FPRINT Outfile,Scoot$;"if (FAILED(bcx_last_com_HRESULT)) {"
      FPRINT Outfile,Scoot$;"  bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("Build ParamList Failed! ANSI to Wide conversion failure!"),"));"
      FPRINT Outfile,Scoot$;"} else {"
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_BSTR";P2$
      FPRINT Outfile,Scoot$;"  bcx_static_param_list.pParams[",sTMP$,"].bstrVal = SysAllocString(bcx_temp_wide_string_pointer);"
      FPRINT Outfile,Scoot$;"}"

      CASE comvt_R8_LITERAL
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_R8";P2$
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].dblVal = ",sCleanTemp$,";"

      CASE comvt_OBJECT
      FPRINT Outfile,Scoot$;"VariantCopy(&bcx_static_param_list.pParams[",sTMP$,"], &",sCleanTemp$,".pObjects[0]);"

      CASE comvt_I4_LITERAL
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_I4";P2$
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].lVal = ",sCleanTemp$,";"

      CASE comvt_VOID
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_VOID;"
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].lVal = (void)",sCleanTemp$,";"


      CASE comvt_HRESULT

      CASE comvt_PTR

      CASE comvt_SAFEARRAY
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_SAFEARRAY";P2$
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].";P$;"parray = &",sCleanTemp$,";"

      CASE comvt_CARRAY

      CASE comvt_USERDEFINED

      CASE comvt_LPSTR

      CASE comvt_LPWSTR

      CASE comvt_RECORD

      CASE comvt_INT_PTR

      CASE comvt_UINT_PTR

      CASE comvt_FILETIME

      CASE comvt_BLOB

      CASE comvt_STREAM

      CASE comvt_STORAGE

      CASE comvt_STREAMED_OBJECT

      CASE comvt_STORED_OBJECT

      CASE comvt_BLOB_OBJECT

      CASE comvt_CF

      CASE comvt_CLSID

      CASE comvt_VERSIONED_STREAM

      CASE comvt_BSTR_BLOB

      CASE comvt_NAMED_ARGUMENT
      Abort ("Named arguments are NOT supported in this version! (" + ParamToken$[i] + ")")

      CASE comvt_CAST
      'local_temp_str$ = TRIM$(UCASE$(EXTRACT$(sCleanTemp+1, ")")))
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = ",local_temp_str$,";"
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].",sCleanTemp$,";"

      CASE comvt_DEFAULT
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].vt = VT_I4;"
      FPRINT Outfile,Scoot$;"bcx_static_param_list.pParams[",sTMP$,"].lVal = (long)",sCleanTemp$,";"

    END SELECT
  WEND
  FUNCTION = iReturn
END FUNCTION ' BCX_COM_BUILD_PARAMETER_LIST
' ************************************************************************************************************



' ************************************************************************************************************
' Sub: BCX_COM_Parse_Method (part of BCX COM parser)
' Called internally by main com parser function, Find_COM_statement.
' If the statment is a COM method (with or without parameters) this function will be called.
'
' Typical samples of COM methods:
' (method with parms) -- app.activeworkbook.saveas "c:\temp.xls"
' (invoke method)     -- app.quit
'
' Last revised 29.Apr.2008  - fix for floating point parameters -- Ljubisa
' 2008-01-26 - Added ParseCom() so that all COM parsing is identicall - Wayne Halsforf
' ************************************************************************************************************
SUB BCX_COM_Parse_Method(com_method$, pparms$)
  Use_BCX_COM_InvokeMethod = Use_BCX_COM_UsesConversion = Use_COM = TRUE
  DIM RAW j
  LOCAL ObjName$
  LOCAL ComTok$
  LOCAL ComToken$
  LOCAL temp_param$
  DIM RAW BuildSafeArray = 0
  DIM parms$

  IF build_com_trace_code  THEN ' used if com trace variable is set
    FPRINT Outfile,"    bcx_com_trace_add_line(", ENC$("BCX_COM_Parse_Method("+BCX_PREPARE_COM_TRACE_LINE$(com_method$)+" , "+BCX_PREPARE_COM_TRACE_LINE$(parms$)+")"), ");"
  END IF

  parms$ = TRIM$(pparms$)
  IF parms$ > "" THEN
    IF MID$(UCASE$(parms$),1,6) = "ARRAY(" OR MID$(UCASE$(parms$),1,6) = "ARRAY " THEN
      parms$ = REMAIN$(parms$,"(")
      j = LEN(parms$) -1
      parms[j] = 0 ' strip closing brace )
      BuildSafeArray = 1
      Use_BCX_COM_SafeArray = TRUE
    END IF
  END IF
  CALL ParseCom(com_method$)

  j = 1
  ObjName$ = ComStk$[j++]

  DO
    ComTok$ = ComStk$[j++]
    ComToken$ = ComTok$
    FPRINT Outfile,""
    FPRINT Outfile,Scoot$;"lstrcpy(bcx_last_com_error_indicator, _T(", ENC$(BCX_PREPARE_COM_TRACE_LINE$(ComTok$)),"));"
    IF INCHR(ComTok$, "(") > 0 THEN
      temp_param$ = TRIM$(REMAIN$(ComTok$,"("))
      FPRINT Outfile,Scoot$;"bcx_param_list_index_p = ", BCX_COM_BUILD_PARAMETER_LIST(MID$(temp_param$,1,LEN(temp_param$)-1),0),";"
      ComToken$ = EXTRACT$(ComTok$,"(")
    END IF
    IF build_com_trace_code  THEN ' used if com trace variable is set
      IF ComStk$[j] <> "" THEN
        FPRINT Outfile,"    bcx_com_trace_add_line(", ENC$("Get next dispatch for "+BCX_PREPARE_COM_TRACE_LINE$(ComTok$)), ");"
      ELSE
        FPRINT Outfile,"bcx_com_trace_add_line(", ENC$("Invoke helper for:: "+ComTok$), ");"
      END IF
    END IF
    IF ComStk$[j] = "" THEN
      IF LEN(TRIM$(parms$))>0 THEN
        FPRINT Outfile,Scoot$;"bcx_param_list_index_p =", BCX_COM_BUILD_PARAMETER_LIST(parms$,0),";"
        IF BuildSafeArray THEN
          FPRINT Outfile,Scoot$;"bcx_create_safe_array();"
        END IF
      END IF
      FPRINT Outfile,Scoot$;"bcx_invoke_helper(&",ObjName$,", L",ENC$(REMOVE$(ComToken$," ")),", DISPATCH_METHOD, NULL);"
      EXIT DO
    END IF
    FPRINT Outfile,Scoot$;"bcx_get_next_dispatch(&",ObjName$,", L",ENC$(REMOVE$(ComToken$," ")),");"
  LOOP
END SUB ' BCX_COM_Parse_Method
' ************************************************************************************************************


'**************************************************************
' Common parser for COM SUBs
'   BCX_COM_Parse_GetProperty
'   BCX_COM_Parse_SetProperty
'   BCX_COM_Parse_Method
'**************************************************************
SUB ParseCom(sCom$)
  RAW i AS Integer
  RAW j AS Integer
  RAW k AS Integer
  RAW ComTok$
  ComNdx = 0
  CALL FastLexer(sCom$," ","()")
  IF Ndx THEN
    i = 1
    ComStk$[++ComNdx] = STRTOKEN$(Stk$[i],"." , 1)' get the name of object
    j = 1
    DO
      j++
      ComTok$ = STRTOKEN$ (Stk$[i], "." , j)
      IF ComTok$ = RIGHT$(Stk$[i],LEN(ComTok$)) THEN
        IF i < Ndx THEN
          IF Stk$[i+1] = "(" THEN                     ' Parameter token
            k = 0
            DO
              i++
              ComTok$ = ComTok$ + Stk$[i]
              IF Stk$[i] = "(" THEN k++
              IF Stk$[i] = ")" THEN k--
            LOOP WHILE k
          END IF
          i++
          j = 1
        END IF
      END IF
      IF ComTok$ = "" THEN
        EXIT DO
      END IF
      CALL Add2ComStk(ComTok$)
    LOOP
    CALL Add2ComStk("")
    ComNdx--
  END IF
END SUB


'SUB Add2ComStk(ComTok$)
SUB Add2ComStk(ComTok As const char Ptr)
  IF cMaxComStk = ++ComNdx THEN CALL Abort("To many COM tokens.")
  ComStk$[ComNdx] = ComTok$
END SUB

' ************************************************************************************************************
' Function: BCX_PREPARE_COM_TRACE_LINE (part of BCX COM parser)
' This function is used only if $COM_TRACE option is used.
' Function prepares escape characters in string literals for emitting to resulting C/C++ files.
'
' Return Values:
' Function returns altered string.
'
' Last revised 10.Nov.2004
' ************************************************************************************************************
FUNCTION BCX_PREPARE_COM_TRACE_LINE$(p_Src$)
  DIM pp_Src$
  pp_Src$ = TRIM$(p_Src$)
  pp_Src$ = REPLACE$(pp_Src$, "\\", "\\\\")
  pp_Src$ = REPLACE$(pp_Src$, CHR$(c_DblQt), "\" & CHR$(c_DblQt))
  pp_Src$ = REPLACE$(pp_Src$, "%", "%%")
  pp_Src$ = REPLACE$(pp_Src$, "'", "\'")
  FUNCTION = pp_Src$
END FUNCTION ' BCX_PREPARE_COM_TRACE_LINE


' TODO:
' add code to check are all com objects released on exit from sub/functions
' and on a return;

'*************************************************************************
' END OF: FUNCTIONS FOR LATE BINDING COM SUPPORT
'*************************************************************************

FUNCTION JoinLines(Arg$)

  IF iMatchRgt(Arg$, " _") THEN
    Arg[LEN(Arg)-1] = 0
    CurLine$ = CurLine$ & Arg$
    FUNCTION = TRUE
  END IF

  IF *CurLine <> 0 THEN
    Arg$ = CurLine$ & Arg$
    CurLine$ = ""
  END IF
  UmQt = FALSE
  FUNCTION = FALSE
END FUNCTION



SUB StripCode( Arg$ )
  RAW p AS PCHAR
  RAW p2 = Arg AS PCHAR
  RAW asmFlag = 0
  RAW eStr = 0
  RAW sub_$

  WHILE (*p2 >8 AND *p2 < 13) OR *p2 = 32      'Trim leading space
    INCR p2
  WEND

  IF *p2 = ASC("!") THEN asmFlag = NOT UmQt    'Handle "!" Asm lines
  p = p2
  WHILE *p
    IF *p = 9 THEN *p = 32
    IF *p = c_DblQt THEN ' ignore anything in string literal
      IF *(p-1) = 69 THEN ' we're in an extended string: E"\qABCD\n"
        *(p-1) = 1 ' chr$(1) will be deleted
        eStr = TRUE
      END IF
      WHILE *(++p) <> c_DblQt
        IF *p = 92 AND eStr THEN ' look for a \0, \t, \n, \r, \q, \\
          *p = 2
          SELECT CASE *(p+1)
            CASE 48  ' 0
            *(p+1) = 3
            CASE 116 ' t
            *(p+1) = 4
            CASE 110 ' n
            *(p+1) = 5
            CASE 114 ' r
            *(p+1) = 6
            CASE 113 ' q
            *(p+1) = 7
            CASE 92 ' \
            *(p+1) = 8
' ADDED
'            CASE c_DblQt
'            *(p+1) = 14
          END SELECT
          p++
        END IF
        IF *p = 0 THEN UmQt = NOT UmQt : EXIT WHILE
      WEND
    END IF
    ' If we're in a quoted continuation line then ignore comments
    IF NOT UmQt AND NOT asmFlag THEN
      'Remove REM's
      IF (*p BOR 32) = ASC("r") THEN
        IF _
          (*(p+1) BOR 32) = ASC("e") AND _
          (*(p+2) BOR 32) = ASC("m") AND _
          (*(p+3) = 32 OR *(p+3) = 0) THEN
          IF p = p2 OR *(p-1) = ASC(":") OR *(p-1) = 32 THEN
            *p = 0 : EXIT WHILE
          END IF
        END IF
      END IF
      ' check for single quote comment marker and // C++ style comments
      IF *p = ASC("'") OR (*p = ASC("/") AND *(p+1) = ASC("/")) THEN
        *p = 0 : EXIT WHILE
      END IF
    END IF
    p++
  WEND

  WHILE p2 < p
    'Trim trailing space
    WHILE (*(p-1) >8 AND *(p-1) < 13) OR *(p-1) = 32
      *(--p) = 0
    WEND

    IF UmQt OR asmFlag THEN EXIT WHILE

    'Strip dangling colons
    IF *(p-1) = ASC(":") AND *(p-2) = 32 THEN
      DECR p
    ELSE
      EXIT WHILE
    END IF
  WEND
  IF eStr THEN
    REPLACE CHR$(1) WITH "" IN p2$  ' E
    REPLACE CHR$(2) WITH "" IN p2$ ' \ first backslash
    '---
    sub_$ = DQ$+"+CHR$(0)+"+DQ$
    REPLACE CHR$(3) WITH sub_$ IN p2$  ' 0
    sub_$ = DQ$+"+CHR$(9)+"+DQ$
    REPLACE CHR$(4) WITH sub_$ IN p2$  ' t
    sub_$ = DQ$+"+CHR$(10)+"+DQ$
    REPLACE CHR$(5) WITH sub_$ IN p2$ ' n
    sub_$ = DQ$+"+CHR$(13)+"+DQ$
    REPLACE CHR$(6) WITH sub_$ IN p2$ ' r
    sub_$ = DQ$+"+CHR$(34)+"+DQ$
    REPLACE CHR$(7) WITH sub_$ IN p2$ ' q
    sub_$ = DQ$+"+CHR$(92)+"+DQ$
    REPLACE CHR$(8) WITH sub_$ IN p2$ ' \
' ADDED
    'sub_$ = "\"+DQ$
    'REPLACE CHR$(14) WITH sub_$ IN p2$ ' DQ$
    '---
    REPLACE (CHR$(c_DblQt)+CHR$(c_DblQt)+CHR$(43)) WITH "" IN p2$
    REPLACE (CHR$(43)+CHR$(c_DblQt)+CHR$(c_DblQt)) WITH "" IN p2$
    '---
  END IF
  Arg$ = p2$
END SUB



'----------------------------------------------
'Case insensitive comparison - MatchStr$ to Arg$
' mt = 0, 1 or 2 Match left, whole word, right
'----------------------------------------------
CONST iMatchLft(A,B) = iMatch(A,B,0)
CONST iMatchWrd(A,B) = iMatch(A,B,1)
CONST iMatchRgt(A,B) = iMatch(A,B,2)

'FUNCTION iMatch(Arg$, MatchStr$, mt)
FUNCTION iMatch(Arg As const char Ptr, MatchStr As const char Ptr, mt)

  IF mt = 2 THEN
    DIM RAW L1, L2
    L1 = LEN(Arg$) : L2 = LEN(MatchStr$)
    IF L1 < L2 THEN FUNCTION = FALSE
    Arg = (Arg + L1) - L2
  END IF

  WHILE *MatchStr
    'If we run out string to match against then return no match
    IF *Arg = 0 THEN FUNCTION = FALSE
    'bit ORing a character with 0x20 produces the lower case of it
    IF (*Arg BOR 32) <> (*MatchStr BOR 32) THEN FUNCTION = FALSE
    INCR Arg
    INCR MatchStr
  WEND
  IF mt AND *Arg <> 0 THEN FUNCTION = FALSE
  FUNCTION = TRUE
END FUNCTION



'----------------------------------------------
'Returns the position of the first occurrence
'of MatchStr$ in Arg$ that isn't in quotes.
'----------------------------------------------
'FUNCTION iMatchNQ(Arg$, MatchStr$)
'FUNCTION iMatchNQ(Arg$, MatchStr As const char Ptr)
FUNCTION iMatchNQ(Arg As const char Ptr, MatchStr As const char Ptr)
  DIM RAW mi=0
  DIM RAW a = (char*)Arg AS PCHAR


  WHILE MatchStr[mi]
    IF *a = c_DblQt THEN
      mi=0
      WHILE *(++a) <> c_DblQt
        IF *a = 0 THEN FUNCTION = 0
      WEND
    END IF

    IF a[mi] = 0 THEN FUNCTION = 0
    'If we run out string to match against then return no match
    'bit ORing a character with 0x20 produces the lower case of it
    IF (a[mi] BOR 32) <> (MatchStr[mi] BOR 32) THEN
      INCR a : mi= -1
    END IF
    INCR mi
  WEND
  FUNCTION = (a-Arg) + 1  ' We have a match
END FUNCTION



SUB ProcSingleLineIf(BYREF ifFlag)
  DIM RAW Tmp$, ifp, NdIfs
  DIM STATIC EFlag
  IF ifFlag = 0 THEN EFlag = 0

REDO:
  IF SplitCnt = cMaxSplitLines THEN CALL Abort("Stack Overflow - Too many statements on one line")
  Tmp$ = SplitStk$[SplitCnt] & SPC$

  IF iMatchLft(Tmp$, "if ") THEN
    ifp = iMatchNQ(Tmp$, " then ")
    IF ifp THEN
      IF SplitCnt = cMaxSplitLines-1 THEN CALL Abort("Stack Overflow - Too many statements on one line")
      SplitStk$[SplitCnt++] = LEFT$(Tmp$,ifp+4)
      SplitStk$[SplitCnt] = LTRIM$(Tmp+ifp+4)
      'EFlag = MAX(0,EFlag-1) : INCR (ifFlag)
      'jcf
      EFlag = max(0,EFlag-1) : INCR (ifFlag)
      GOTO REDO
    END IF

  ELSE
    IF (ifFlag) THEN
      IF iMatchLft(Tmp$, "else ") THEN   '"else xxx"
LftLse:
        IF ++EFlag > 1 THEN
           'jcf 11/02/2013
          'NdIfs = MAX(1,(ifFlag)-1) : (ifFlag) = 1 : EFlag = 0
          NdIfs = max(1,(ifFlag)-1) : (ifFlag) = 1 : EFlag = 0
          IF iMatchWrd(SplitStk$[SplitCnt-1],"else") THEN DECR SplitCnt
          IF SplitCnt = cMaxSplitLines-1 THEN CALL Abort("Stack Overflow - Too many statements on one line")
          REPEAT NdIfs : SplitStk$[SplitCnt++] = "END IF" : END REPEAT
        END IF
        IF SplitCnt = cMaxSplitLines-1 THEN CALL Abort("Stack Overflow - Too many statements on one line")
        SplitStk$[SplitCnt++] = "ELSE"
        SplitStk$[SplitCnt] = TRIM$(Tmp+4)
        GOTO REDO
      ELSE
        ifp = iMatchNQ(Tmp$, " else ")
        IF ifp THEN                      '"xxx else xxx"
          IF SplitCnt = cMaxSplitLines-1 THEN CALL Abort("Stack Overflow - Too many statements on one line")
          SplitStk$[SplitCnt++] = RTRIM$(LEFT$(Tmp$, ifp-1))
          Tmp$ = MID$(Tmp$, ifp+1)
          GOTO LftLse
        END IF
      END IF
    END IF
  END IF         'process "if/then/else"
END SUB



FUNCTION SplitLines(Arg$)
  DIM RAW p  = Arg AS PCHAR
  DIM RAW st = Arg AS PCHAR
  DIM RAW i = 0, IfFlag = 0, SpcolonFlag = 0
  DIM RAW ParaCnt = 0

  IF *p = ASC("!") OR *p = ASC("$") THEN FUNCTION = 0

  WHILE *p
    IF *p = 32 THEN SpcolonFlag = 1
    IF *p = c_DblQt THEN ' ignore anything in string literal
      WHILE *(++p) <> c_DblQt
        IF *p = 0 THEN FUNCTION = SplitCnt
      WEND
    END IF

    IF *p = c_LPar THEN ParaCnt++
    IF *p = c_RPar THEN ParaCnt--

    IF *p = ASC(":") THEN
      IF *(p+1) = ASC(":") THEN
        *p = 15
        *(p+1) = 15
      ELSE
        IF *(p+1) <> 0 OR SpcolonFlag THEN

          WHILE *st = 32
            st++
          WEND         'Forward past leading spaces

          SplitCnt++
          IF SplitCnt = cMaxSplitLines THEN CALL Abort("Stack Overflow - Too many statements on one line")
          WHILE st < p                         'Copy new string
            SplitStk[SplitCnt][i++] = *(st++)
          WEND

          WHILE SplitStk[SplitCnt][i-1] = 32   'Trim trailing spaces
            i--
          WEND
          SplitStk[SplitCnt][i] = 0            'Add a string terminator
          IF ParaCnt = 0 THEN
            i=0
            st++   'advance to next start position
            ProcSingleLineIf(&IfFlag)
          ELSE
            SplitCnt--
          END IF
        END IF         'if NOT End of line
      END IF
    END IF           'if :
    p++
  WEND

  'Add the last string
  IF SplitCnt > 0 THEN
    WHILE *st = 32
      st++
    WEND  'Forward past leading spaces
    SplitCnt++
    IF SplitCnt = cMaxSplitLines THEN CALL Abort("Stack Overflow - Too many statements on one line")
    WHILE *st
      SplitStk[SplitCnt][i++] = *(st++)
    WEND
    SplitStk[SplitCnt][i] = 0
    ProcSingleLineIf(&IfFlag)
    'Process single line if/thens that don't contain colon separated statements
  ELSE
    IF iMatchLft(Arg$,"if ") AND NOT iMatchRgt(Arg$," then") THEN
      CALL Add2SplitLines(Arg$)
      ProcSingleLineIf(&IfFlag)
    END IF
  END IF

  'If we processed single line "if/then" then close it up
  IF IfFlag THEN
    WHILE IfFlag
      CALL Add2SplitLines("END IF")
      IfFlag--
    WEND
  END IF

  FUNCTION = SplitCnt
END FUNCTION ' SplitLines
'==============================================================================
'From Waynes bcx 7.0.6
'==============================================================================
'FUNCTION SpecialCaseHandler(Arg$)
  'DIM RAW i,j,k
  'DIM RAW lsz$
  'RAW iSrcStkIndex AS INT

  'IF iMatchNQ(Arg$," sub ") OR iMatchNQ(Arg$," function ") THEN FUNCTION = FALSE

  ''**************************************************
  '' Handle Multiple Dim's, Locals, Globals, Shared etc.
  '' Example: DIM a, b!, c$, d$*1000, q[100] AS DWORD
  '' Forward propagation of a type
  ''          DIM as INT a, b[10], c, d[20]
  ''**************************************************
  'lsz$ =  SPC$ & EXTRACT$(Arg$," ") & SPC$
  'IF iMatchNQ(" dim , local , global , raw , static , shared , dynamic , auto , register , extern ", lsz$) THEN
    'CALL FastLexer(Arg$," ",",&(){}=")
    'IF iMatchWrd("as",Stk$[3]) THEN
      'lsz$ =  SPC$ & LCASE$(Stk$[2]) & SPC$
      'IF iMatchNQ(" local , raw , static , shared , dynamic , auto , register ", lsz$) THEN
        'Stk$[1] = Stk$[2]
        'CALL DeleteTokens(2, 1)
      'END IF
    'END IF

    '' Begin forward propagation of a type
    'IF iMatchWrd("as",Stk$[2]) THEN
      'RAW szWrk$
      'RAW FirstComma, Ignore, b, EqualAt
      'RAW Tmp$[8]
      'RAW iFUNC = 0
      'CALL BuildDelimStr(1, Ndx, szWrk$)
      'CALL FastLexer(szWrk$," ",",&(){}=")

      'XFOR i = 3, Ignore = 0, FirstComma = 0, EqualAt = 0 WHILE i <= Ndx AND FirstComma = 0 BY i++
        'IF Stk$[i] = "=" AND Ignore = 0 THEN EqualAt = i
        'IF Stk$[i] = "{" THEN Ignore++
        'IF Stk$[i] = "(" THEN Ignore++ : IF iFUNC = 0 THEN iFUNC = i
        'IF Stk$[i] = ")" THEN Ignore--
        'IF Stk$[i] = "}" THEN Ignore--
        'IF Stk$[i] = "," AND Ignore = 0 THEN FirstComma = i
      'XNEXT

      'IF FirstComma = 0 THEN FirstComma = Ndx+1
      'IF iFUNC THEN i = iFUNC
      'IF i > EqualAt AND EqualAt THEN i = EqualAt
      'b = 0
      'DO
        'i--
        ''IF Stk$[i] = "=" THEN EqualAt = 0
        'IF Stk$[i] = "}" THEN b++
        'IF Stk$[i] = ")" THEN b++
        'IF Stk$[i] = "(" THEN b--
        'IF Stk$[i] = "{" THEN b--
      'LOOP WHILE b 'OR EqualAt
      'IF Stk$[i] = "=" THEN i--
      'IF Stk$[i] = "(" THEN i--
      'IF Stk$[i] = "{" THEN i--
      'IF Stk$[i] = "," THEN i--
      'XFOR j = 0, k = 2 WHILE k < i BY j++,k++
        'Tmp$[j] = Stk$[k] : Stk$[k] = ""
      'XNEXT

      'k = Ndx
      'InsertTokens(Ndx, j ,Tmp$[0] ,Tmp$[1] ,Tmp$[2] ,Tmp$[3] ,Tmp$[4] ,Tmp$[5] ,Tmp$[6] ,Tmp$[7])
      'Ignore = 0
      'WHILE k >= FirstComma
        'IF Stk$[k] = "}" THEN Ignore++
        'IF Stk$[k] = ")" THEN Ignore++
        'IF Stk$[k] = "(" THEN Ignore--
        'IF Stk$[k] = "{" THEN Ignore--
        'IF Stk$[k] = "," AND NOT Ignore THEN
          'InsertTokens(k-1, j ,Tmp$[0] ,Tmp$[1] ,Tmp$[2] ,Tmp$[3] ,Tmp$[4] ,Tmp$[5] ,Tmp$[6] ,Tmp$[7])
        'END IF
        'k--
      'WEND

      'CALL RemEmptyTokens()
      'CALL BuildDelimStr(1, Ndx, Arg$)
      'CALL FastLexer(Arg$," ",",(){}=")
    'END IF
    '' End forward propagation of a type

    '' tolerate nonsense like DIM A% as double
    'XFOR i = 1, INT j = 1 WHILE i < Ndx AND j BY i++
      'j = GetAsPosF(i, Ndx)
      'IF j THEN
        'i = j
        'Stk$[i-1] = Clean$(Stk$[i-1])
      'END IF
    'XNEXT

    'Stk$[2] = SPC$ & Stk$[2] & SPC$
    'IF iMatchNQ(" raw , local , dynamic , register , static , shared , auto ",Stk$[2]) THEN
      'Stk$[1] = Stk$[1] & Stk$[2]
      'Stk$[2] = ""
    'END IF
    'INCR SrcCnt
    'j=0
    'FOR i = 1 TO Ndx
      'IF Stk[i][0] = ASC("(") THEN INCR j
      'IF Stk[i][0] = ASC("{") THEN INCR j
      'IF Stk[i][0] = ASC(")") THEN DECR j
      'IF Stk[i][0] = ASC("}") THEN DECR j
      'IF Stk[i][0] = ASC(",") AND NOT j THEN
        'Stk$[i]  = Stk$[1]
        'INCR SrcCnt
      'END IF
      'IF SrcCnt = cMaxSingleLineIFLines THEN CALL Abort("Single line conversion to multi-line exceeds limit.")
      'SrcStk$[SrcCnt] = SrcStk$[SrcCnt] + Stk$[i] + " "
    'NEXT
    'GOTO ProcessNew
  'END IF

  'IF InDialogEvt OR ModDialogEvt THEN
    'IF iMatchNQ(Arg$,"WM_INITDIALOG") THEN
      'CALL AddExpressionToStack(Arg$)
      'CALL AddExpressionToStack("SetDialogScale(hWnd,0)")
      'GOTO ProcessNew
    'END IF
  'END IF

  'SELECT CASE TRUE

    ''******************************
    'CASE iMatchLft(Arg$,"on ")     ' on expression gosub | goto | call  label1,label2,Sub...
    ''******************************
    'DIM RAW Target = 0
    'j = 0
    'CALL FastLexer(Arg$," ",",")

    'FOR i = 1 TO Ndx
      'IF iMatchLft(Stk$[i],"gosub") OR _
        'iMatchLft(Stk$[i],"goto")  OR _
        'iMatchLft(Stk$[i],"call")  THEN
        'Target = i+1
        'EXIT FOR
      'END IF
    'NEXT

    'IF Target = 0 THEN CALL Abort("Malformed ON/GOSUB,GOTO,CALL.")
    'CALL AddExpressionToStack("select case ")        'Assemble our expression
    'FOR i = 2 TO Target - 2
      'SrcStk$[SrcCnt] = SrcStk$[SrcCnt]+" "+ Stk$[i]
    'NEXT

    'FOR i = Target TO Ndx
      'IF Stk$[i] = "," THEN ITERATE
      'INCR j
      'CALL AddExpressionToStack("case" + STR$(j))
      'CALL AddExpressionToStack(Stk$[Target-1] + SPC$ + Stk$[i])
    'NEXT
    'CALL AddExpressionToStack("end select")

    'GOTO ProcessNew

    ''******************************
    'CASE iMatchLft(Arg$,"loop ")
    ''******************************
    'CALL FastLexer(Arg$," ",",()")

    'IF iMatchLft(Stk$[2],"until") THEN
    'CALL AddExpressionToStack("if ")
      'FOR i = 3 TO Ndx
        'SrcStk$[SrcCnt] = SrcStk$[SrcCnt] + Stk$[i] + " "
      'NEXT
      'SrcStk$[SrcCnt] = SrcStk$[SrcCnt] + " then"
      'CALL AddExpressionToStack("exit do")
      'CALL AddExpressionToStack("end if")
      'CALL AddExpressionToStack("loop")
      'iLoopCond = 1
      'GOTO ProcessNew

    'ELSEIF iMatchLft(Stk$[2],"while") THEN
      'CALL AddExpressionToStack("if NOT (")
      'FOR i = 3 TO Ndx
        'SrcStk$[SrcCnt] = SrcStk$[SrcCnt] + Stk$[i] + " "
      'NEXT
      'SrcStk$[SrcCnt] = SrcStk$[SrcCnt] + ") then"
      'CALL AddExpressionToStack("exit do")
      'CALL AddExpressionToStack("end if")
      'CALL AddExpressionToStack("loop")
      'iLoopCond = 1
      'GOTO ProcessNew
    'ELSE
      'IF Ndx > 1 THEN
        'Abort("UNKNOWN Word " + Stk$[2] + " After LOOP")
      'END IF
    'END IF

    ''******************************
    'CASE iMatchLft(Arg$,"do ")
    ''******************************
    'CALL FastLexer(Arg$," ",",()")

    'IF iMatchLft(Stk$[2],"until") THEN
      'CALL AddExpressionToStack("do")
      'CALL AddExpressionToStack("if ")
      'FOR i = 3 TO Ndx
        'SrcStk$[SrcCnt] = SrcStk$[SrcCnt] + Stk$[i] + " "
      'NEXT
      'SrcStk$[SrcCnt] = SrcStk$[SrcCnt] + "then"
      'CALL AddExpressionToStack("exit do")
      'CALL AddExpressionToStack("end if")
      'iDoWhile = lt_DOUNTILLOOP
      'GOTO ProcessNew
    'ELSEIF iMatchLft(Stk$[2],"while") THEN
      'CALL AddExpressionToStack("while ")
      'iDoWhile = lt_DOWHILELOOP
      'FOR i = 3 TO Ndx
        'SrcStk$[SrcCnt] = SrcStk$[SrcCnt] + Stk$[i] + " "
      'NEXT
      'GOTO ProcessNew

    'ELSE
      'IF Ndx > 1 THEN
        'Abort("UNKNOWN Word " + Stk$[2] + " After DO")
      'END IF
    'END IF
  'END SELECT

  'FUNCTION = FALSE

  'ProcessNew:

  'Ndx = iSrcStkIndex = 0
  'WHILE SrcCnt
    'Arg$ = SrcStk$[++iSrcStkIndex]
    'SrcStk$[iSrcStkIndex] = ""
    'DECR SrcCnt
    'PassOne = TRUE
    'CALL XParse(Arg$)
    'PassOne = FALSE
    'CALL FixUps()
    'IF Ndx THEN CALL EmitMain()
  'WEND
  'FUNCTION = TRUE
'END FUNCTION ' SpecialCaseHandler
'==============================================================================


'jcfuller added 9/14/2013 from BCX 7.0.9
FUNCTION SpecialCaseHandler(Arg$)
  DIM RAW i,j,k
  DIM RAW lsz$
  RAW iSrcStkIndex AS INT

  IF iMatchNQ(Arg$," sub ") OR iMatchNQ(Arg$," function ") THEN FUNCTION = FALSE

  '**************************************************
  ' Handle Multiple Dim's, Locals, Globals, Shared etc.
  ' Example: DIM a, b!, c$, d$*1000, q[100] AS DWORD
  ' Forward propagation of a type
  '          DIM as INT a, b[10], c, d[20]
  '**************************************************
  lsz$ =  SPC$ & EXTRACT$(Arg$," ") & SPC$
  'IF iMatchNQ(" dim , local , global , raw , static , shared , dynamic , auto , register , extern ", lsz$) THEN
  'IF iMatchNQ(" dim , local , global , raw , static , shared , dynamic , register , extern ", lsz$) THEN
  IF iMatchNQ(" dim , local , global , raw , static , shared , dynamic , extern ", lsz$) THEN
    CALL FastLexer(Arg$," ",",&(){}=")
    IF iMatchWrd("as",Stk$[3]) THEN
      lsz$ =  SPC$ & LCASE$(Stk$[2]) & SPC$
      'IF iMatchNQ(" local , raw , static , shared , dynamic , auto , register ", lsz$) THEN
      'IF iMatchNQ(" local , raw , static , shared , dynamic , register ", lsz$) THEN
      IF iMatchNQ(" local , raw , static , shared , dynamic ", lsz$) THEN
        Stk$[1] = Stk$[2]
        CALL DeleteTokens(2, 1)
      END IF
    END IF

    ' Begin forward propagation of a type
    IF iMatchWrd("as",Stk$[2]) THEN
      RAW szWrk$
      RAW FirstComma, Ignore, b, EqualAt
      RAW Tmp$[8]
      RAW iFUNC = 0
      CALL BuildDelimStr(1, Ndx, szWrk$)
      CALL FastLexer(szWrk$," ",",&(){}=")

      XFOR i = 3, Ignore = 0, FirstComma = 0, EqualAt = 0 WHILE i <= Ndx AND FirstComma = 0 BY i++
        IF Stk$[i] = "=" AND Ignore = 0 THEN EqualAt = i
        IF Stk$[i] = "{" THEN Ignore++
        IF Stk$[i] = "(" THEN Ignore++ : IF iFUNC = 0 THEN iFUNC = i
        IF Stk$[i] = ")" THEN Ignore--
        IF Stk$[i] = "}" THEN Ignore--
        IF Stk$[i] = "," AND Ignore = 0 THEN FirstComma = i
      XNEXT

      IF FirstComma = 0 THEN FirstComma = Ndx+1
      IF iFUNC THEN i = iFUNC
      IF i > EqualAt AND EqualAt THEN i = EqualAt
      b = 0
      DO
        i--
        'IF Stk$[i] = "=" THEN EqualAt = 0
        IF Stk$[i] = "}" THEN b++
        IF Stk$[i] = ")" THEN b++
        IF Stk$[i] = "(" THEN b--
        IF Stk$[i] = "{" THEN b--
      LOOP WHILE b 'OR EqualAt
      IF Stk$[i] = "=" THEN i--
      IF Stk$[i] = "(" THEN i--
      IF Stk$[i] = "{" THEN i--
      IF Stk$[i] = "," THEN i--
      RAW iVecCheck
      XFOR j = 0, k = 2, iVecCheck = 0 WHILE k < i BY j++,k++
        IF INSTR(Stk$[k], CHR$(15)) THEN iVecCheck = 1
        IF iVecCheck THEN REPLACE "<" WITH CHR$(16) IN Stk$[k]
        IF iVecCheck THEN REPLACE "," WITH CHR$(18) IN Stk$[k]
        IF iVecCheck THEN REPLACE ">" WITH CHR$(17) IN Stk$[k]
        Tmp$[j] = Stk$[k] : Stk$[k] = ""
      XNEXT

      k = Ndx
      Tmp$[0] = " "+Tmp$[0]

      InsertTokens(Ndx, j ,Tmp$[0] ,Tmp$[1] ,Tmp$[2] ,Tmp$[3] ,Tmp$[4] ,Tmp$[5] ,Tmp$[6] ,Tmp$[7])
      Ignore = 0
      WHILE k >= FirstComma
        IF Stk$[k] = "}" THEN Ignore++
        IF Stk$[k] = ")" THEN Ignore++
        IF Stk$[k] = "(" THEN Ignore--
        IF Stk$[k] = "{" THEN Ignore--
        IF Stk$[k] = "," AND NOT Ignore THEN
          InsertTokens(k-1, j ,Tmp$[0] ,Tmp$[1] ,Tmp$[2] ,Tmp$[3] ,Tmp$[4] ,Tmp$[5] ,Tmp$[6] ,Tmp$[7])
        END IF
        k--
      WEND

      CALL RemEmptyTokens()
      CALL BuildDelimStr(1, Ndx, Arg$)
      CALL FastLexer(Arg$," ",",(){}=")
    ELSE
      XFOR i = 1, INT j = 1, INT iVecCheck = 0 WHILE i < Ndx AND j BY i++
        j = GetAsPosF(i, Ndx)
        IF j THEN
          j++
          XFOR iVecCheck = 0 WHILE j <= Ndx BY j++
            IF Stk$[j] = "," AND iVecCheck = 0 THEN EXIT XFOR
            IF INSTR(Stk$[j], CHR$(15)) THEN iVecCheck = 1
            IF iVecCheck THEN REPLACE "<" WITH CHR$(16) IN Stk$[j]
            IF iVecCheck THEN REPLACE "," WITH CHR$(18) IN Stk$[j]
            IF iVecCheck THEN REPLACE ">" WITH CHR$(17) IN Stk$[j]
           XNEXT
        END IF
      XNEXT
    END IF
    ' End forward propagation of a type

    ' tolerate nonsense like DIM A% as double
    XFOR i = 1, INT j = 1 WHILE i < Ndx AND j BY i++
      j = GetAsPosF(i, Ndx)
      IF j THEN
        i = j
        Stk$[i-1] = Clean$(Stk$[i-1])
      END IF
    XNEXT

    Stk$[2] = SPC$ & Stk$[2] & SPC$
    'IF iMatchNQ(" raw , local , dynamic , register , static , shared , auto ",Stk$[2]) THEN
    'IF iMatchNQ(" raw , local , dynamic , register , static , shared ",Stk$[2]) THEN
    IF iMatchNQ(" raw , local , dynamic , static , shared ",Stk$[2]) THEN
      Stk$[1] = Stk$[1] & Stk$[2]
      Stk$[2] = ""
    END IF
    INCR SrcCnt
    j=0
    FOR i = 1 TO Ndx
      IF Stk[i][0] = ASC("(") THEN INCR j
      IF Stk[i][0] = ASC("{") THEN INCR j
      IF Stk[i][0] = ASC(")") THEN DECR j
      IF Stk[i][0] = ASC("}") THEN DECR j
      IF Stk[i][0] = ASC(",") AND NOT j THEN
        Stk$[i]  = Stk$[1]
        INCR SrcCnt
      END IF
      IF SrcCnt = cMaxSingleLineIFLines THEN CALL Abort("Single line conversion to multi-line exceeds limit.")
      SrcStk$[SrcCnt] = SrcStk$[SrcCnt] + Stk$[i] + " "
    NEXT
    GOTO ProcessNew
  END IF

  IF InDialogEvt OR ModDialogEvt THEN
    IF iMatchNQ(Arg$,"WM_INITDIALOG") THEN
      CALL AddExpressionToStack(Arg$)
'jcfuller 01/24/2015
      If Use_BCXDialogCommon Then
		CALL AddExpressionToStack("SetDialogScale(hWnd,0)")
	  End If

      GOTO ProcessNew
    END IF
  END IF
'jcfuller changed 10/27/2013
'this is BAD coding!!! Should never use if xx = TRUE THEN . Use If xx THEN
'TDM-GCC cannot translate fix
	'Raw As Int ImTrue= TRUE
  SELECT CASE TRUE
  'SELECT CASE ImTrue

    '******************************
    CASE iMatchLft(Arg$,"on ")     ' on expression gosub | goto | call  label1,label2,Sub...
    '******************************
    DIM RAW Target = 0
    j = 0
    CALL FastLexer(Arg$," ",",")

    FOR i = 1 TO Ndx
      IF iMatchLft(Stk$[i],"gosub") OR _
        iMatchLft(Stk$[i],"goto")  OR _
        iMatchLft(Stk$[i],"call")  THEN
        Target = i+1
        EXIT FOR
      END IF
    NEXT

    IF Target = 0 THEN CALL Abort("Malformed ON/GOSUB,GOTO,CALL.")
    CALL AddExpressionToStack("select case ")        'Assemble our expression
    FOR i = 2 TO Target - 2
      SrcStk$[SrcCnt] = SrcStk$[SrcCnt]+" "+ Stk$[i]
    NEXT

    FOR i = Target TO Ndx
      IF Stk$[i] = "," THEN ITERATE
      INCR j
      CALL AddExpressionToStack("case" + STR$(j))
      CALL AddExpressionToStack(Stk$[Target-1] + SPC$ + Stk$[i])
    NEXT
    CALL AddExpressionToStack("end select")

    GOTO ProcessNew

    '******************************
    CASE iMatchLft(Arg$,"loop ")
    '******************************
    CALL FastLexer(Arg$," ",",()")

    IF iMatchLft(Stk$[2],"until") THEN
    CALL AddExpressionToStack("if ")
      FOR i = 3 TO Ndx
        SrcStk$[SrcCnt] = SrcStk$[SrcCnt] + Stk$[i] + " "
      NEXT
      SrcStk$[SrcCnt] = SrcStk$[SrcCnt] + " then"
      CALL AddExpressionToStack("exit do")
      CALL AddExpressionToStack("end if")
      CALL AddExpressionToStack("loop")
      iLoopCond = 1
      GOTO ProcessNew

    ELSEIF iMatchLft(Stk$[2],"while") THEN
      CALL AddExpressionToStack("if NOT (")
      FOR i = 3 TO Ndx
        SrcStk$[SrcCnt] = SrcStk$[SrcCnt] + Stk$[i] + " "
      NEXT
      SrcStk$[SrcCnt] = SrcStk$[SrcCnt] + ") then"
      CALL AddExpressionToStack("exit do")
      CALL AddExpressionToStack("end if")
      CALL AddExpressionToStack("loop")
      iLoopCond = 1
      GOTO ProcessNew
    ELSE
      IF Ndx > 1 THEN
        Abort("UNKNOWN Word " + Stk$[2] + " After LOOP")
      END IF
    END IF

    '******************************
    CASE iMatchLft(Arg$,"do ")
    '******************************
    CALL FastLexer(Arg$," ",",()")

    IF iMatchLft(Stk$[2],"until") THEN
      CALL AddExpressionToStack("do")
      CALL AddExpressionToStack("if ")
      FOR i = 3 TO Ndx
        SrcStk$[SrcCnt] = SrcStk$[SrcCnt] + Stk$[i] + " "
      NEXT
      SrcStk$[SrcCnt] = SrcStk$[SrcCnt] + "then"
      CALL AddExpressionToStack("exit do")
      CALL AddExpressionToStack("end if")
      iDoWhile = lt_DOUNTILLOOP
      GOTO ProcessNew
    ELSEIF iMatchLft(Stk$[2],"while") THEN
      CALL AddExpressionToStack("while ")
      iDoWhile = lt_DOWHILELOOP
      FOR i = 3 TO Ndx
        SrcStk$[SrcCnt] = SrcStk$[SrcCnt] + Stk$[i] + " "
      NEXT
      GOTO ProcessNew

    ELSE
      IF Ndx > 1 THEN
        Abort("UNKNOWN Word " + Stk$[2] + " After DO")
      END IF
    END IF
  END SELECT

  FUNCTION = FALSE

  ProcessNew:

  Ndx = iSrcStkIndex = 0
  WHILE SrcCnt
    Arg$ = SrcStk$[++iSrcStkIndex]
    SrcStk$[iSrcStkIndex] = ""
    DECR SrcCnt
    PassOne = TRUE
    CALL XParse(Arg$)
    PassOne = FALSE
    CALL FixUps()
    IF Ndx THEN CALL EmitMain()
  WEND
  FUNCTION = TRUE
END FUNCTION ' SpecialCaseHandler






'*************************************************************
'delim1$ = delimiters to be removed
'delim2$ = delimiters to keep
'Stk$ and Ndx are Global
'As long as Ndx is honored Stk does not need to be initialized
'*************************************************************
'SUB FastLexer OPTIONAL(Arg$, delim1$, delim2$, TokQuote = 1)
SUB FastLexer OPTIONAL(A As const char Ptr, d1 As const char Ptr, d2 As const char Ptr, TokQuote = 1)
  Dim Arg$,delim1$,delim2$
  DIM RAW cnt1=0, cnt2=0
  DIM RAW pd1 AS PCHAR, pd2 AS PCHAR
  Arg$ = A
  delim1$ = d1
  delim2$ = d2
  'RAW iExtStr = FALSE
  Ndx=1

  WHILE Arg[cnt1]

    IF Arg[cnt1] = c_DblQt THEN      'quotes - string literals
      'IF Arg[cnt1-1] = 69 THEN
      '  iExtStr = TRUE
      'ELSE
      '  iExtStr = FALSE
        IF cnt2 AND TokQuote THEN Stk[Ndx++][cnt2]=0 : cnt2=0
      'END IF
      Stk[Ndx][cnt2] = c_DblQt
      WHILE Arg[++cnt1] <> c_DblQt
        Stk[Ndx][++cnt2] = Arg[cnt1]
        'IF Arg[cnt1] = 92 AND Arg[cnt1+1] = c_DblQt THEN
        '  Stk[Ndx][++cnt2] = Arg[++cnt1]
        'END IF
        IF Arg[cnt1] = 0 THEN EXIT SUB
        'IF iExtStr THEN
        '  IF Arg[cnt1] = 92 AND Arg[cnt1+1] = 34 THEN
        '    Stk[Ndx][++cnt2] = Arg[++cnt1]
        '  END IF
        'END IF
      WEND
      Stk[Ndx][++cnt2] = Arg[cnt1]
      IF TokQuote THEN
        Stk[Ndx++][++cnt2]=0
        cnt2=0
        GOTO again
      END IF
    END IF

    pd1 = delim1
    WHILE *pd1
      IF *(pd1++) = Arg[cnt1] THEN
        IF cnt2 THEN Stk[Ndx++][cnt2]=0 : cnt2=0
        GOTO again
      END IF
    WEND

    pd2 = delim2
    WHILE *pd2
      IF *(pd2++) = Arg[cnt1] THEN
        IF cnt2 THEN Stk[Ndx++][cnt2]=0
        Stk[Ndx][0] = Arg[cnt1]
        Stk[Ndx++][1]=0 : cnt2 = 0
        GOTO again
      END IF
    WEND

    Stk[Ndx][cnt2++]=Arg[cnt1]
again:
    INCR cnt1
  WEND
  Stk[Ndx][cnt2]=0
  IF cnt2 = 0 THEN DECR Ndx
END SUB ' FastLexer



SUB DeleteTokens(PosStart, NumTokens)
  Stk$[Ndx+1] = ""
  FOR INT i = PosStart TO Ndx-NumTokens+1
    Stk$[i] = Stk$[i+NumTokens]
  NEXT
  Ndx -= NumTokens
END SUB ' DeleteTokens



SUB InsertTokens(PosAfter, NumTokens, ...)
  DIM RAW ap AS va_list, i

  FOR i = Ndx TO PosAfter+1 STEP -1
    Stk$[i+NumTokens] = Stk$[i]
  NEXT

  va_start(ap,NumTokens)
  FOR i = PosAfter+1 TO PosAfter+NumTokens
    Stk$[i] = va_arg(ap, char*)
  NEXT
  va_end(ap)
  INCR Ndx,NumTokens
  Stk$[Ndx+1] = ""
END SUB ' InsertTokens



SUB AppendTokens(NumTokens, ...)
  DIM RAW ap AS va_list

  va_start(ap,NumTokens)
  FOR INT i = Ndx+1 TO Ndx+NumTokens
    Stk$[i] = va_arg(ap, char*)
  NEXT
  va_end(ap)
  INCR Ndx,NumTokens
  Stk$[Ndx+1] = ""
END SUB ' AppendTokens



SUB EmitExportDef(fs$)
  STATIC beenhere
  DIM RAW fname$, funcname$
  DIM RAW i, st=1, sz=0
'jcfuller 1/29/2013
  'fname$ = EXTRACT$(FileIn$,".") + ".def"
  fname$ = RemoveExtension$(FileIn$) + ".def"

  IF NOT beenhere THEN
    OPEN fname$ FOR OUTPUT AS fpdef
    _splitpath(FileIn$, NULL, NULL, fname$, NULL)
    FPRINT fpdef,"LIBRARY ", ENC$(fname$)
    FPRINT fpdef, "EXPORTS"
    beenhere = TRUE
  END IF

  FastLexer(fs$, "", "(,)")
  WHILE *Stk$[st] <> ASC("(")
    INCR st
  WEND

  FOR i = st+1 TO Ndx
    IF *Stk$[i] = ASC(")") THEN EXIT FOR
    IF *Stk$[i] <> ASC(",") THEN
      IF INCHR(Stk$[i],"*") THEN INCR sz,4 : ITERATE

      IF INSTR(Stk$[i],"longlong",1,1) OR _
        INSTR(Stk$[i],"double",1,1)    OR _
        INSTR(Stk$[i],"long long") THEN
        INCR sz,8
        ITERATE
      END IF
      IF NOT INCHR(Stk$[i],"void") THEN INCR sz,4
    END IF
  NEXT
  Stk$[1] = TRIM$(Stk$[1])
  funcname$ = MID$(Stk$[1],INSTRREV(Stk$[1],SPC$) + 1)
  FPRINT fpdef,funcname$," = _",funcname$,"@",LTRIM$(STR$(sz))
END SUB ' EmitExportDef



FUNCTION GetArg$(ArgNum, fp AS functionParse PTR)

  DIM RAW RetArg$
  DIM RAW ArgEnd   = fp->CommaPos[ArgNum] - 1
  DIM RAW ArgStart = fp->CommaPos[ArgNum - 1] + 1
  RetArg$ = ""

  IF ArgNum >= fp->NumArgs THEN ArgEnd = Ndx

  FOR ArgStart = ArgStart TO ArgEnd
    CONCAT(RetArg$, Stk$[ArgStart])
  NEXT

  FUNCTION = RetArg$
END FUNCTION ' GetArg



FUNCTION SepFuncArgs(Strt, fp AS functionParse PTR, functionflag AS INTEGER)
  DIM RAW CountR = 0 '()[] counter
  DIM RAW i = Strt 'loop counter

  IF functionflag THEN
    WHILE i <= Ndx
      IF Stk[i][0] = ASC("(") THEN EXIT WHILE
      INCR i
    WEND
    Strt = i + 1

    fp->NumArgs = 0 'comma counter
    fp->CommaPos[0] = i 'Strt-1
    IF Strt > Ndx THEN
      FUNCTION = 0
    END IF
  ELSE
    Strt = 2
    fp->CommaPos[0] = 1
  END IF

  IF *Stk$[Strt] = ASC(")") THEN
    fp->CommaPos[1] = Strt
    FUNCTION = 0
  END IF
  fp->NumArgs = 1

  FOR i = Strt TO Ndx
    IF *Stk$[i] = ASC("(") OR *Stk$[i] = ASC("[") THEN
      CountR++
    ELSEIF *Stk$[i] = ASC(")") OR *Stk$[i] = ASC("]") THEN
      IF CountR = 0 THEN
        fp->CommaPos[fp->NumArgs] = i
        EXIT FOR
      END IF
      CountR--
    ELSEIF *Stk$[i] = ASC(",") AND CountR = 0 THEN
      fp->CommaPos[fp->NumArgs] = i
      INCR fp->NumArgs
      IF fp->NumArgs = cCommaPos THEN CALL Abort("Number of arguements exceeds 127")
    END IF
  NEXT
  IF functionflag = 0 THEN fp->CommaPos[fp->NumArgs] = Ndx

  FUNCTION = fp->NumArgs 'Number of commas + 1 = Number of arguments
END FUNCTION ' SepFuncArgs



FUNCTION MakeDecProto OPTIONAL(fp AS functionParse PTR, iStart=2 AS INT, iEnd=Ndx AS INT, iNoTypeDef = FALSE AS INT) AS LPSTR
  DIM RAW fpp AS functionParse
  DIM RAW AsType$
  DIM RAW AsArrys$
  DIM RAW FoundAs
  DIM RAW pointer   = 0
  DIM RAW i,ii
  DIM RAW OptValue$
  DIM RAW OptFlag   = 0
  STATIC Proto$
  STATIC SubFunPtr
  STATIC FunType$

  IF SubFunPtr THEN GOTO argparse

  Proto$   = ""
  FunType$ = ""

  'Determine function type
  '-----------------------------------------------------
  ' constructor/destructor
  IF ConstructDestructTest(1) THEN
    FunType$ = ""
  ELSE
    IF iMatchWrd(Stk$[iStart], "sub") THEN
      FunType$ = "void"
    ELSEIF *Stk$[iEnd] = ASC(")") THEN
      'check for type identifier suffix
      'if unknown, then integer will default
      FunType$ = VarTypeLookup$[ INCHR(VarTypes$, RIGHT$(Stk$[iStart+1],1)) ]
    ELSE
      FOR i = iEnd TO fp->CommaPos[fp->NumArgs]+1 STEP -1
        IF iMatchWrd(Stk$[i], "ptr") OR *Stk$[i] = ASC("*") THEN
          INCR pointer
        ELSEIF iMatchWrd(Stk$[i], "as") THEN
          EXIT FOR
        ELSE
          IF Stk$[i] <> "" THEN FunType$ = Stk$[i] + SPC$ + FunType$
        END IF
      NEXT
      FunType$ = TRIM$(FunType$)
    END IF
  END IF

  'INCR pointer, TALLY(FunType$, "*")
  'RemoveAll(FunType$, "*", 1)
  IF FunType$ = "" THEN
    Proto$ = Stk$[iStart]+"("
  ELSE
    IF InTypeDef THEN
      Proto$ = FunType$ + "  " + STRING$(pointer, ASC("*")) + " (" + CallType$ + "*" + Clean$(Stk$[iStart+1]) + ")("
      DIM RAW Var$, w, id, vt
      Var$ = FunType$ + STRING$(pointer, ASC("*"))
      GetTypeInfo(Var$, &w, &id, &vt)
      AddTypedefElement(BaseTypeDefsCnt[InTypeDef],vt, Clean$(Stk$[iStart+1]), FunType$, 0)
    ELSEIF SFPOINTER THEN
      IF iNoTypeDef THEN
        Proto$ = FunType$ + " (" + CallType$ + "*" + Clean$(Stk$[iStart+1]) + ")("
      ELSE
        Proto$ = "typedef " + FunType$ + " (" + CallType$ + "*" + Clean$(Stk$[iStart+1]) + "_TYPE)("
      END IF
    ELSEIF NOT NoTypeDeclare AND NOT InClassModule AND NOT InPPTypeModule THEN
      Proto$ = "typedef " + FunType$ + " (" + CallType$ + "*BCXFPROT" + LTRIM$(STR$(DllCnt)) + ")("
    ELSE
    'jcfuller added (UseWinApi = FALSE)
      IF UseCProto OR InClassModule OR InPPTypeModule OR (UseWinApi = FALSE) THEN
        UseCProto = FALSE
        Proto$ = FunType$ + "  " + STRING$(pointer, ASC("*")) + SPC$ + CallType$ + Clean$(Stk$[iStart+1]) + "("
      ELSE
        Proto$ = "C_IMPORT " + FunType$ + "  " + STRING$(pointer, ASC("*")) + SPC$ + CallType$ + Clean$(Stk$[iStart+1]) + "("
      END IF
    END IF
  END IF
  '-----------------------------------------------------
  argparse:
  '-----------------------------------------------------
  'Determine argument types
  '-----------------------------------------------------
  IF fp->NumArgs = 0 THEN
    IF FunType$ <> ""  THEN
      Proto$ = Proto$ + "void)"
    ELSE
      Proto$ = Proto$ + ")"
    END IF
  ELSE
    FOR ii = 0 TO fp->NumArgs - 1

      OptValue$ = ""
      AsType$   = ""
      AsArrys$  = ""
      pointer   = 0
      FoundAs   = 0

      DIM RAW FirstToken  = fp->CommaPos[ii] + 1
      DIM RAW LastToken   = fp->CommaPos[ii+1] - 1
      DIM RAW NumOfTokens = (LastToken - FirstToken) + 1

      i = INCHR(Stk$[FirstToken], "[")
      IF i THEN
        AsArrys$ = MID$(Stk$[FirstToken], i)
        Stk[FirstToken][i-1] = 0
      END IF

      IF NumOfTokens = 1 THEN
        '--------------------------------------------------------
        ' The bracket handling should be handled better.
        ' currently using the preprocessing of FunSubDecs1
        ' which converts A![] to *A! and A$[] to *A$[][2048]
        ' and A[] as xxx to A as xxx*
        '--------------------------------------------------------
        AsType$ = VarTypeLookup$[ INCHR(VarTypes$, RIGHT$(Stk$[FirstToken],1)) ]
        IF *AsArrys$ THEN
          REMOVE "*" FROM AsType$
        ELSE
          pointer = TALLY(Stk$[FirstToken], "*")
        END IF
        '--------------------------------------------------------
        FoundAs = TRUE
      ELSE

        FOR i = LastToken TO FirstToken STEP -1
          IF iMatchWrd(Stk$[i], "ptr") OR *Stk$[i] = ASC("*") THEN
            INCR pointer
            'Stk$[i] = ""

          ELSEIF iMatchWrd(Stk$[i], "sub") THEN
            SepFuncArgs(fp->CommaPos[ii]+2, &fpp, TRUE)
            Proto$ = Proto$ + "void (*)("
            SubFunPtr = FoundAs = TRUE
            MakeDecProto(&fpp)
            SubFunPtr = FALSE
            EXIT FOR

          ELSEIF iMatchWrd(Stk$[i], "function") THEN
            SepFuncArgs(fp->CommaPos[ii]+2, &fpp, TRUE)
            IF AsType$ = "" THEN
              AsType$ = VarTypeLookup$[ INCHR( VarTypes$, RIGHT$(Stk$[FirstToken],1)) ]
            END IF
            Proto$ = Proto$ + RTRIM$(AsType$) + STRING$(pointer,ASC("*")) + " (*)("
            pointer = 0
            AsType$ = ""
            SubFunPtr = FoundAs = TRUE
            MakeDecProto(&fpp)
            SubFunPtr = FALSE
            EXIT FOR

          ELSEIF iMatchWrd(Stk$[i], "as") THEN
            IF AsType$ = "" THEN Abort("No type specified for argument" + STR$(ii+1))
            'CONCAT(AsType$,STRING$(pointer,ASC("*")))
            FoundAs = TRUE
            EXIT FOR

          ELSEIF *Stk$[i] = ASC("=") THEN
            OptFlag = FoundAs = TRUE
            OptValue$ = " =" + AsType$
            AsType$ = ""
            IF i = FirstToken + 1 THEN
              AsType$ = VarTypeLookup$[ INCHR( VarTypes$, RIGHT$(Stk$[FirstToken],1)) ]
              IF *AsArrys$ THEN
                REMOVE "*" FROM AsType$
              ELSE
                pointer = TALLY(Stk$[FirstToken], "*")
              END IF
              EXIT FOR
            END IF

          ELSE
            IF *Stk$[i] <> ASC(".") THEN
              AsType$ = Stk$[i] + SPC$ + AsType$
            ELSE
              IF *Stk$[i-1] = ASC(".") THEN
                IF OptFlag THEN Abort("Default value not allowed when using variable arguments")
                IF ii <> (fp->NumArgs-1) THEN Abort("Variable argument must be the last parameter")
                IF fp->NumArgs = 1 THEN Abort("Variable argument must be preceded by at least one other parameter")
                FoundAs = TRUE
              END IF
              AsType$ = Stk$[i] + AsType$
            END IF
          END IF
        NEXT i
      END IF
      IF NOT FoundAs THEN Abort("Malformed argument type in parameter" + STR$(ii + 1))
      IF ii <> fp->NumArgs AND OptFlag AND OptValue$ = "" THEN Warning("No default value specified for parameter" + STR$(ii + 1), 1)
      Proto$ = Proto$ + RTRIM$(AsType$) + AsArrys$ + STRING$(pointer,ASC("*")) + OptValue$ + Stk$[fp->CommaPos[ii+1]]
    NEXT ii
    '-----------------------------------------------------
  END IF

  FUNCTION = Proto
END SUB ' MakeDecProto



SUB AsmUnknownStructs(CompArrays)

  DIM RAW InBrace  = 0
  DIM RAW InStruct = 0, i
  DIM RAW sztemp$

  FOR i = 2 TO Ndx

    ' --------------------------------
    ' Complete arrays
    ' --------------------------------

    IF CompArrays THEN
      IF Stk$[i] = "[" THEN
        sztemp$ = Stk$[i-1] : Stk$[i-1] = ""
        DO
          sztemp$ = sztemp$ + Stk$[i]
          IF Stk$[i] = "]" THEN DECR InBrace
          IF Stk$[i] = "[" THEN INCR InBrace
          Stk$[i] = ""
          INCR i
        LOOP WHILE InBrace AND i <= Ndx
        Stk$[--i] = sztemp$
      END IF
    END IF

    ' --------------------------------
    ' Complete unknown struct members
    ' --------------------------------
    IF LEN(Stk$[i]) > 1 AND NOT IsNumber(Stk$[i]+1) THEN
      IF *Stk$[i] = ASC(".") OR iMatchLft(Stk$[i], "->") THEN
        IF InStruct = 0 THEN
          Stk$[i] = Stk$[i-1] + Stk$[i]
          Stk$[i-1] = ""
          InStruct = i
        ELSE
          CONCAT(Stk$[InStruct], Stk$[i])
          Stk$[i] = ""
        END IF
        ITERATE
      END IF
    END IF

    IF *Stk$[i] AND InStruct > 0 THEN
      '? STR$(ModuleLineNos[ModuleNdx]), Stk$[InStruct] , STR$(CompArrays)
      InStruct = 0
    END IF
  NEXT i

  CALL RemEmptyTokens
END SUB ' AsmUnknownStructs



SUB CheckForASC()
  RAW Tmp, i, j
  RAW iEmp
  iEmp = 0
  FOR Tmp = 1 TO Ndx
    IF iMatchWrd(Stk$[Tmp], "asc") THEN
      i=0
      iEmp = 1
      j=GetNumArgs(Tmp+2,&i)
      IF *Stk[Tmp+2] = *DQ$ THEN
        IF j > 0 OR *Stk[Tmp+3] <> ASC(")") THEN
          Stk$[Tmp] = "asc"
          Use_Asc = Use_Proto = TRUE
        ELSE
          IF Stk$[Tmp+2] = DDQ$ THEN
            Stk$[Tmp] = "0"
          ELSE
            Stk$[Tmp] = LTRIM$(STR$(ASC(Stk$[Tmp+2],1)))
          END IF
          Stk$[Tmp+1] = "" : Stk$[Tmp+2] = "" : Stk$[Tmp+3] = ""
        END IF
      ELSE
        IF j > 0 THEN Stk$[i] = "+"
        Stk$[Tmp] = "(UCHAR)*"
      END IF
    END IF
  NEXT
  IF iEmp THEN CALL RemEmptyTokens
END SUB ' CheckForASC


SUB EmitIfCond OPTIONAL(CondType$, iOutputMethod AS INT, szOut$=0)
'SUB EmitIfCond OPTIONAL(CT As const char Ptr, iOutputMethod AS INT, szOut As const char*=0)
  '*********************************************************************
  ' Speedup/Optimize for statements like --->  if a$    = ""  THEN
  '               AND                    --->  if a$[1] = ""  THEN
  '               AND                    --->  while x = ASC("x")
  '*********************************************************************
  DIM RAW TestString, A, B, ParCnt, Tmp
  DIM RAW IsWhile = FALSE
  DIM RAW szTest$
  'DIM RAW CondType$
  'CondType$ = (char*)CT
  CALL CheckForASC()

  IF iOutputMethod = eStringPart OR iOutputMethod = eStringFull THEN szOut$ = ""

  TestString = DataType(Stk$[2])

  IF TestString = vt_STRVAR THEN
    IF Stk$[4] = DDQ$ THEN
      Stk$[2] = Clean$(Stk$[2]) + "[0]"
      Stk$[4] = "0"
    ELSE
      IF Stk$[3] = "[" AND Stk$[7] = DDQ$ THEN
        Stk$[2] = Clean$(Stk$[2])
        CONCAT (Stk$[5],"[0]")
        Stk$[7] = "0"
      END IF
    END IF
  END IF

  IF CondType$ = "while" THEN IsWhile = TRUE

  '********************   If, ElseIf, & While Handler   *********************
  IF iOutputMethod = eFull THEN
    FPRINT Outfile,Scoot$;CondType$, "(";
  END IF

  IF iOutputMethod = eStringFull THEN
   szOut$ = CondType$ + "("
  END IF

  Tmp = 2
  WHILE Stk$[Tmp] = "(" OR Stk$[Tmp] = "!"
    IF iOutputMethod = ePart OR iOutputMethod = eFull THEN
      FPRINT Outfile, Stk$[Tmp];
    ELSE
      CONCAT(szOut$, Stk$[Tmp])
    END IF
    Tmp++
  WEND

  TestString = FALSE

  A = DataType(Stk$[Tmp])
  IF A = vt_STRLIT OR A = vt_STRVAR THEN
    IF Stk$[Tmp + 1] <> ")" AND NOT iMatchWrd(Stk$[Tmp+1], "then") THEN
      TestString  = TRUE
      Use_Str_Cmp = TRUE
      IF iOutputMethod = ePart OR iOutputMethod = eFull THEN
        FPRINT Outfile,"str_cmp(";
      ELSE
        CONCAT(szOut$, Stk$[Tmp])
      END IF
    END IF
  END IF

  szTest$ = ""
  ParCnt  = 0

  DO
    IF TestString THEN
      SELECT CASE Stk$[Tmp]
        CASE "="
          Stk$[Tmp] = ","
          szTest$   = ")==0"
          ParCnt    =  0
        CASE "!="
          Stk$[Tmp] = ","
          szTest$   = ")!=0"
          ParCnt    = 0
        CASE ">"
          IF Stk$[Tmp + 1] = "=" THEN
            Stk$[Tmp] = ","
            szTest$   = ")>=0"
            Stk$[Tmp + 1] = ""
          ELSE
            Stk$[Tmp] = ","
            szTest$   = ")==1"
          END IF
          ParCnt = 0
        CASE "<"
          IF Stk$[Tmp + 1] = "=" THEN
            Stk$[Tmp] = ","
            szTest$   = ")<=0"
            Stk$[Tmp + 1] = ""
          ELSE
            Stk$[Tmp] = ","
            szTest$   = ")==-1"
          END IF
          ParCnt = 0
        CASE "("
          ParCnt++
        CASE ")"
          ParCnt--
      END SELECT

      IF Stk$[Tmp] = ")" AND szTest$ <> "" AND ParCnt < 0 THEN
        IF iOutputMethod = ePart OR iOutputMethod = eFull THEN
          FPRINT Outfile, szTest$, Stk$[Tmp];
        ELSE
          CONCAT(szOut$, szTest$)
          CONCAT(szOut$, Stk$[Tmp])
        END IF
        szTest$ = ""
      ELSE
        IF Stk$[Tmp] = "||" OR Stk$[Tmp] = "&&" THEN
          Stk$[Tmp] = szTest$ + " " + Stk$[Tmp] + " "
          szTest$ = ""
          B = 1
          WHILE Stk$[Tmp + B] = "("
            CONCAT (Stk$[Tmp],"(")
            Stk$[Tmp + B] = ""
            B++
          WEND
          A = DataType(Stk$[Tmp+B])      ' look ahead
          IF (A = vt_STRLIT OR A = vt_STRVAR) AND Stk$[Tmp+B+1] <> ")" THEN
            CONCAT (Stk$[Tmp]," str_cmp(")
            Use_Str_Cmp = TRUE
          ELSE
            IF iOutputMethod = ePart OR iOutputMethod = eFull THEN
              FPRINT Outfile,Clean$(Stk$[Tmp]);
            ELSE
              CONCAT(szOut$, Clean$(Stk$[Tmp]))
            END IF
            TestString = FALSE
            GOTO NxtToken
          END IF
        END IF
        IF iOutputMethod = ePart OR iOutputMethod = eFull THEN
          FPRINT Outfile, Clean$(Stk$[Tmp]);
        ELSE
          CONCAT(szOut$, Clean$(Stk$[Tmp]))
        END IF
      END IF
    ELSE  'Not TestString
      IF Stk$[Tmp] = "||" OR Stk$[Tmp] = "&&" THEN
        B = 1
        WHILE Stk$[Tmp + B] = "("
          CONCAT (Stk$[Tmp], "(")
          Stk$[Tmp + B] = ""
          B++
        WEND
        A = DataType(Stk$[Tmp+B])     ' look ahead
        IF (A = vt_STRLIT OR A = vt_STRVAR) AND Stk$[Tmp+B+1] <> ")" THEN
          CONCAT (Stk$[Tmp],"str_cmp(" )
          TestString  = TRUE
          Use_Str_Cmp = TRUE
          szTest$     = ""
          ParCnt      = 0
          IF iOutputMethod = ePart OR iOutputMethod = eFull THEN
            FPRINT Outfile, Clean$(Stk$[Tmp]);
          ELSE
            CONCAT(szOut$, Clean$(Stk$[Tmp]))
          END IF
          GOTO NxtToken
        END IF
      END IF

      IF Stk$[Tmp] = "!" THEN
        IF iOutputMethod = ePart OR iOutputMethod = eFull THEN
          FPRINT Outfile,Stk$[Tmp];
        ELSE
          CONCAT(szOut$, Stk$[Tmp])
        END IF
      ELSE
        IF iOutputMethod = ePart OR iOutputMethod = eFull THEN
          FPRINT Outfile,Clean$(Stk$[Tmp]);
        ELSE
          CONCAT(szOut$, Clean$(Stk$[Tmp]))
        END IF
        IF NOT ispunct(*Stk$[Tmp]) THEN
          IF Tmp < Ndx AND NOT ispunct(*Stk$[Tmp+1]) THEN
            IF iOutputMethod = ePart OR iOutputMethod = eFull THEN
              FPRINT Outfile,SPC$;
            ELSE
              CONCAT(szOut$, SPC$)
            END IF
          END IF
        END IF
      END IF

      IF Stk$[Tmp] = "=" THEN
        IF Stk$[Tmp-1] <> "<" AND Stk$[Tmp-1] <> ">" THEN
          IF Stk$[Tmp+1] <> ">" AND Stk$[Tmp+1] <> "<" THEN
            IF iOutputMethod = ePart OR iOutputMethod = eFull THEN
              FPRINT Outfile,"=";
            ELSE
              CONCAT(szOut$, "=")
            END IF
          END IF
        END IF
      END IF

    END IF

    NxtToken:

    INCR Tmp

    IF NOT IsWhile THEN
      IF iMatchWrd(Stk$[Tmp], "then") THEN
        EXIT DO
      ELSEIF Tmp > Ndx THEN
        Abort("If Without THEN")
      END IF
    END IF

  LOOP UNTIL Tmp > Ndx

  SELECT CASE iOutputMethod
    CASE   eFull
      FPRINT Outfile, szTest$, ")"
      CALL BumpUp
      FPRINT Outfile,Scoot$;"{"
      CALL BumpUp
    CASE ePart
      FPRINT Outfile, szTest$;
    CASE eStringPart
      CONCAT(szOut$, szTest$)
    CASE eStringFull
      CONCAT(szOut$, szTest$)
      CONCAT(szOut$, ")")
  END SELECT
END SUB ' EmitIfCond



SUB PrintGlobal(FP_WRITE AS FILE, A, idx, Storage$, P$, VarName$, VarDim$)
  DIM RAW VAR$

  SELECT CASE A
    ' handle exceptions
    CASE vt_FILEPTR
    REMOVE "@" FROM VarName$
    FPRINT FP_WRITE,Storage$;"FILE   *";P$;VarName$;VarDim$;";"

    CASE vt_UDT, vt_STRUCT, vt_UNION
    VAR$ = TypeDefs[GlobalVars[idx].VarDef].VarName$
    VAR$ = RPAD$(VAR$, 7)
    FPRINT FP_WRITE,Storage$;VAR$;" ";P$;VarName$;VarDim$;";"

    CASE vt_LPSTR
    FPRINT FP_WRITE,Storage$;"LPSTR  ";P$;VarName$;VarDim$;";"

    CASE vt_STRVAR
    IF VarDim$ = "" THEN VarDim$ = cSizeOfADefaultString
    FPRINT FP_WRITE,Storage$;"char    ";P$;VarName$;VarDim$;";"

	CASE vt_BC9CHAR
	FPRINT FP_WRITE,Storage$;"char    ";P$;VarName$;VarDim$;";"
    ' handle normal

    CASE vt_VarMin TO vt_VarMax
    VAR$ = GetVarTypeName$(GlobalVars[idx].VarType)
    VAR$ = RPAD$(VAR$, 7)
    FPRINT FP_WRITE,Storage$;VAR$;SPC$;P$;VarName$;VarDim$;";"

  END SELECT
END SUB ' PrintGlobal



'SUB ReDirectFPrint(TgtFile AS FILE, pat$, ...)  'Used primarily to bump gLinesWritten
SUB ReDirectFPrint(TgtFile AS FILE, p As const char Ptr, ...)  'Used primarily to bump gLinesWritten
  DIM RAW ap AS va_list
  DIM pat$
  pat$ = p
  IF DoCountLines AND TgtFile = FP_W THEN
    INCR gLinesWritten
  END IF

'$COMMENT
  'STATIC IWasHere = 0 AS INT
  'STATIC FPERRLOG AS FILE
  'Src$ = Src$ + CRLF$
  'IF NOT FirstTime(IWasHere) THEN

    'PUT$ FPERRLOG, AbortSrc$, LEN(AbortSrc$)
    'IF Ndx THEN
      'FOR INT I = 1 TO Ndx
        'CONCAT(Stk$[I],"|")
        'PUT$ FPERRLOG,Stk$[I],LEN(Stk$[I])
      'NEXT
      'PUT$ FPERRLOG, CRLF$, LEN(CRLF$)
    'END IF
  'ELSE

    'OPEN "ERROR.LOG.TXT" FOR OUTPUT AS FPERRLOG
    'PUT$ FPERRLOG, AbortSrc$, LEN(AbortSrc$)
    'IF Ndx THEN
      'FOR INT I = 1 TO Ndx
        'CONCAT(Stk$[I],"|")
        'PUT$ FPERRLOG,Stk$[I],LEN(Stk$[I])
      'NEXT
      'PUT$ FPERRLOG, CRLF$, LEN(CRLF$)
    'END IF
    'IWasHere = 1
  'END IF
'$COMMENT
'$COMMENT   ' -------- For debugging and testing -----------
'STATIC F2InIf$
'DIM RAW temp AS PCHAR

   'IF TgtFile = FP2 THEN
      'IF iMatchLft(pat$, "%s") THEN
         'va_start(ap, pat$)
         'temp = va_arg(ap, PCHAR)
         'va_end(ap)
         'IF iMatchLft(temp$, "#if") THEN
            'F2InIf$ = temp$
         'END IF
      'END IF
   'END IF
'$COMMENT '-------------------------------------------------

'  va_start(ap, pat$)
'  vfprintf(TgtFile, pat$, ap)
'  va_end(ap)

  va_start(ap, p)
  vfprintf(TgtFile, p, ap)
  va_end(ap)

END SUB ' ReDirectFPrint


'$COMMENT
'SET ReservedWord[] AS CHAR PTR
  '"IF",
  '"ELSEIF",
  '"THEN",
  '"ELSE",
  '"AND",
  '"OR",
  '"NOT",
  '"BOR",
  '"BAND",
  '"XOR",
  '"PRINT",
  '""
'END SET



'FUNCTION IsReservedWord(match$)
  'DIM mat$
  'mat$ = UCASE$(match$)
  'IF CONTAINEDIN(mat$,ReservedWord) = 0 THEN FUNCTION = 1
  'FUNCTION = 0
'END FUNCTION ' IsReservedWord
'$COMMENT


SUB InitReservedWordsLookup()
  RAW MaxReservedWords AS Integer
  RAW sL$
  RAW iC AS Integer
  RAW iD AS Integer

  MaxReservedWords = WordsInTable(BCXWords) ' How many reserved words

  sL$ = ""
  FOR iC = 0 TO 96
    iRIndex[iC][0] = MaxReservedWords-1
    iRIndex[iC][1] = 0
  NEXT
  FOR iC = 0 TO MaxReservedWords-1
    IF sL$ > BCXWords[iC].pszFunctionName$ THEN
      CALL Abort("Error in BCXWords[], Names out of order"+CRLF$+sL$+" comes after "+BCXWords[iC].pszFunctionName$+CRLF$+"Correct and recompile")
    END IF

    'IF BCXWords[iC].fpTranslate = NULL AND BCXWords[iC].pszFunctionXName[0] = 0  THEN
    '  CALL Abort("Error in BCXWords[], Missing either .pszFunctionXName OR .fpTranslate FOR "+BCXWords[iC].pszFunctionName$+CRLF$+STR$(iC)+" Lines from BCXWords[]")
    'END IF

    'IF BCXWords[iC].fpTranslate AND BCXWords[iC].pszFunctionXName[0]  THEN
    '  CALL Abort("Error in BCXWords[], Only direct substitution when both .pszFunctionXName AND .fpTranslate are not NULL/EMPTY FOR "+BCXWords[iC].pszFunctionName$+CRLF$+STR$(iC)+" Lines from BCXWords[]")
    'END IF

    sL$ = BCXWords[iC].pszFunctionName$
    iD = ASC(sL$)-32
    IF iD < 0 THEN iD = 0
    IF iD > 96 THEN iD = 96
    IF iRIndex[iD][0] > iC THEN iRIndex[iD][0] = iC
    IF iRIndex[iD][1] < iC THEN iRIndex[iD][1] = iC
  NEXT
  FOR iC = 0 TO 96
    IF iRIndex[iC][0] > iRIndex[iC][1] THEN iRIndex[iC][0] = iRIndex[iC][1]
    iRIndex[iC][1]++
  NEXT

'$COMMENT
  RAW iChk, iSize
  iSize = WordsInTable(tBcxWords)-2
  FOR iChk = 0 TO iSize
    IF tBcxWords[iChk].pszWord$ > tBcxWords[iChk+1].pszWord$ THEN
      CALL Abort("Error in SET tBcxWords: " + tBcxWords[iChk].pszWord$ + " comes after " + tBcxWords[iChk+1].pszWord$)
    END IF
  NEXT

  iSize = WordsInTable(tTypes)-2
  FOR iChk = 0 TO iSize
    IF tTypes[iChk].pszWord$ > tTypes[iChk+1].pszWord$ THEN
      CALL Abort("Error in SET tTypes: "+tTypes[iChk].pszWord$ + " comes after " + tTypes[iChk+1].pszWord$)
    END IF
  NEXT

  iSize = WordsInTable(atEmitWords)-2
  FOR iChk = 0 TO iSize
    IF atEmitWords[iChk].pszWord$ > atEmitWords[iChk+1].pszWord$ THEN
      CALL Abort("Error in SET atEmitWords: "+atEmitWords[iChk].pszWord$ + " comes after " + atEmitWords[iChk+1].pszWord$)
    END IF
  NEXT

  iSize = WordsInTable(tDirectives)-2
  FOR iChk = 0 TO iSize
    IF tDirectives[iChk].pszWord$ > tDirectives[iChk+1].pszWord$ THEN
      CALL Abort("Error in SET tDirectives: "+tDirectives[iChk].pszWord$ + " comes after " + tDirectives[iChk+1].pszWord$)
    END IF
  NEXT

  iSize = WordsInTable(atVARIANTVALUENAMES)-3
  FOR iChk = 0 TO iSize
    IF atVARIANTVALUENAMES[iChk].sNAME$ > atVARIANTVALUENAMES[iChk+1].sNAME$ THEN
      CALL Abort("Error in SET atVARIANTVALUENAMES: "+atVARIANTVALUENAMES[iChk].sNAME$ + " comes after " + atVARIANTVALUENAMES[iChk+1].sNAME$)
    END IF
  NEXT

  iSize = WordsInTable(ptVCasts)-3
  FOR iChk = 0 TO iSize
    IF ptVCasts[iChk].pszCAST$ > ptVCasts[iChk+1].pszCAST$ THEN
      CALL Abort("Error in SET ptVCasts: "+ptVCasts[iChk].pszCAST$ + " comes after " + ptVCasts[iChk+1].pszCAST$)
    END IF
  NEXT

  iSize = WordsInTable(ptCCasts)-3
  FOR iChk = 0 TO iSize
    IF ptCCasts[iChk].pszCAST$ > ptCCasts[iChk+1].pszCAST$ THEN
      CALL Abort("Error in SET ptCCasts: "+ptCCasts[iChk].pszCAST$ + " comes after " + ptCCasts[iChk+1].pszCAST$)
    END IF
  NEXT

'$COMMENT
END SUB ' InitReservedWordsLookup



FUNCTION GetWordInfo(sWord$) AS tagTokenSubFunctions PTR
  RAW iH AS Integer
  RAW iL AS Integer
  RAW iM AS Integer
  RAW iV AS Integer
  iM = ASC(sWord$)-32
  IF iM < 0 THEN iM = 0
  IF iM > 96 THEN iM = 96
  iL = iRIndex[iM][0]
  iH = iRIndex[iM][1]

  DO
    'middle = low + ((high - low) / 2)
    iM = (iH + iL)>>1
    iV = str_cmp(BCXWords[iM].pszFunctionName, sWord)
    SELECT CASE iV
      CASE -1
        IF iL <> iH THEN
          IF iL = iM THEN
            iL++
          ELSE
            iL = iM
          END IF
        END IF
      CASE 0
        FUNCTION = &BCXWords[iM]
      CASE 1
        IF iL <> iH THEN
          iH = iM
        END IF
    END SELECT
  LOOP UNTIL iL = iH
  FUNCTION = NULL
END FUNCTION ' GetWordInfo



FUNCTION FindWord(sWord$, tWordList AS tagWords PTR,iWordsInTable AS Integer) AS Integer
  RAW iH AS Integer
  RAW iL AS Integer
  RAW iM AS Integer
  RAW iV AS Integer
  iL = 0
  iH = iWordsInTable ' How many reserved words

  WHILE iL <> iH
    iM = (iH + iL)>>1
    iV = str_cmp(tWordList[iM].pszWord, sWord)
    SELECT CASE iV
      CASE -1
      IF iL = iM THEN FUNCTION = -1
      iL = iM
      CASE 0
      FUNCTION = iM
      CASE 1
      IF iL = iM THEN FUNCTION = -1
      iH = iM
    END SELECT
  WEND
  FUNCTION = -1
END FUNCTION ' FindWord
'==============================================================================
'From Wayne's bcx 7.0.6
'==============================================================================
'SUB FixAnyArrays(Arg$)
  'RAW iMakeNewArg AS INT
  'iMakeNewArg = 0
  'FOR INT i = 1 TO Ndx
    'IF iMatchWrd(Stk$[i], "as") THEN
      'i++
      ''removed per bcx 7.0.7
      ''IF INSTR(Stk$[i], CHR$(15)) THEN
        'FOR INT j = i+1 TO Ndx
          'IF Stk$[j] = "<" THEN
            'iMakeNewArg = 1
            'CONCAT(Stk$[i], CHR$(16))
            'Stk$[j] = ""
            'XFOR INT k = j+1, INT iV = 1 WHILE k<= Ndx BY k++
              'SELECT CASE Stk$[k]
                'CASE ">"
                  'iV--
                  'CONCAT(Stk$[i], CHR$(17))
                  'Stk$[k] = ""
                  'IF Stk$[k+1] <> "<" AND iV = 0 THEN EXIT SELECT, XFOR

                'CASE "<"
                  'iV++
                  'CONCAT(Stk$[i], CHR$(16))
                  'Stk$[k] = ""

                'CASE ","
                  'CONCAT(Stk$[i], CHR$(18))
                  'Stk$[k] = ""
                'CASE ELSE
                  'CONCAT(Stk$[i], Stk$[k])
                  'Stk$[k] = ""
              'END SELECT
            'XNEXT
          'END IF
        'NEXT
      ''END IF
    'END IF
  'NEXT
  'IF iMakeNewArg THEN
    'RAW szNewArg$
    'szNewArg$ = ""
    'CALL RemEmptyTokens()
    'FOR INT i = 1 TO Ndx
      'CONCAT(szNewArg$, Stk$[i])
      'CONCAT(szNewArg$, " ")
    'NEXT
    'Arg$ = szNewArg$
  'END IF

'END SUB ' FixAnyArrays
'Wayne fix for 7.0.7
'fix for
'SUB FixAnyArrays(Arg$)
	'RAW iMakeNewArg AS INT
	'RAW iAttach AS INT
	'iMakeNewArg = 0
	'FOR INT i = 1 TO Ndx
		'IF iMatchWrd(Stk$[i], "as") THEN
			'i++
			'iAttach = 0
			'IF iMatchWrd(Stk$[i], "vector") THEN
				'i++
				'IF Stk$[i] = "<" THEN
					''iAttach = i
					''WAyne update
					'iAttach = i-1
				'END IF
			'ELSE
				'IF iMatchWrd(Stk$[i+1], "vector") THEN
					'i += 2
					'IF Stk$[i] = "<" THEN
					''iAttach = i
					''Wayne update
						'iAttach = i-1
					'END IF
				'END IF
			'END IF
			'IF iAttach > 0 THEN
			''Wayne update
				''Stk$[iAttach] = CHR$(16)
				'iMakeNewArg = 1
				'FOR INT j = iAttach+1 TO Ndx
					'IF Stk$[j] = "<" THEN
						'CONCAT(Stk$[iAttach], CHR$(16))
						'Stk$[j] = ""
						'XFOR INT k = j+1, INT iV = 1 WHILE k<= Ndx AND iV > 0 BY k++
							'SELECT CASE Stk$[k]
								'CASE ">"
									'iV--
									'CONCAT(Stk$[iAttach], CHR$(17))
									'Stk$[k] = ""
								'CASE "<"
									'iV++
									'CONCAT(Stk$[iAttach], CHR$(16))
									'Stk$[k] = ""
								'CASE ","
									'CONCAT(Stk$[iAttach], CHR$(18))
									'Stk$[k] = ""
								'CASE ELSE
									'CONCAT(Stk$[iAttach], Stk$[k])
									'Stk$[k] = ""
							'END SELECT
						'XNEXT
					'END IF
				'NEXT
			'END IF
		'END IF
	'NEXT
	'IF iMakeNewArg THEN
		'RAW szNewArg$
		'szNewArg$ = ""
		'CALL RemEmptyTokens()
		'FOR INT i = 1 TO Ndx
			'CONCAT(szNewArg$, Stk$[i])
			'CONCAT(szNewArg$, " ")
		'NEXT
		'Arg$ = szNewArg$
	'END IF

'END SUB ' FixAnyArrays
'From bcx7.0.9
SUB FixAnyArrays(Arg$)
  RAW iMakeNewArg AS INT
  RAW iAttach AS INT
  iMakeNewArg = 0
  FOR INT i = 1 TO Ndx
    IF iMatchWrd(Stk$[i], "as") THEN
      i++
      iAttach = 0
      IF iMatchWrd(Stk$[i], "vector") THEN
        i++
        IF Stk$[i] = "<" THEN
          iAttach = i-1
        END IF
      ELSE
        IF iMatchWrd(Stk$[i+1], "vector") THEN
          i += 2
          IF Stk$[i] = "<" THEN
            iAttach = i-1
          END IF
        END IF
      END IF
      IF iAttach > 0 THEN
        iMakeNewArg = 1
        FOR INT j = iAttach+1 TO Ndx
          IF Stk$[j] = "<" THEN
            CONCAT(Stk$[iAttach], CHR$(16))
            Stk$[j] = ""
            XFOR INT k = j+1, INT iV = 1 WHILE k<= Ndx AND iV > 0 BY k++
              SELECT CASE Stk$[k]
                CASE ">"
                  iV--
                  CONCAT(Stk$[iAttach], CHR$(17))
                  Stk$[k] = ""
                CASE "<"
                  iV++
                  CONCAT(Stk$[iAttach], CHR$(16))
                  Stk$[k] = ""
                CASE ","
                  CONCAT(Stk$[iAttach], CHR$(18))
                  Stk$[k] = ""
                CASE ELSE
                  CONCAT(Stk$[iAttach], Stk$[k])
                  Stk$[k] = ""
              END SELECT
            XNEXT
          END IF
        NEXT
      END IF
    END IF
  NEXT
  IF iMakeNewArg THEN
    RAW szNewArg$
    szNewArg$ = ""
    CALL RemEmptyTokens()
    FOR INT i = 1 TO Ndx
      CONCAT(szNewArg$, Stk$[i])
      CONCAT(szNewArg$, " ")
    NEXT
    Arg$ = szNewArg$
  END IF

END SUB ' FixAnyArrays

SUB Translate(Arg$)
  RAW ptW AS tagTokenSubFunctions PTR
  RAW szWord$
  RAW iDoFixup
  RAW iEmitID

  ' Handle SET
  IF iMatchLft(Arg$,"set ") THEN
    IF ComSwitchON THEN  'IF ComSwitchON = TRUE THEN
      IF INCHR(Arg$, "=") THEN
        Use_COM = UseFlag = TRUE
      ELSE
        CALL ProcessSetCommand(0)
        EXIT SUB
      END IF
    ELSE
      CALL ProcessSetCommand(0)
      EXIT SUB
    END IF
  END IF

  IF iMatchLft(Arg$,"sharedset ") THEN
    CALL ProcessSetCommand(1)
    EXIT SUB
  END IF

  PassOne = TRUE
  CALL XParse(Arg$)
  PassOne = FALSE

  IF Ndx = 0 THEN EXIT SUB

'zero strip checked here still 0.30

'------------------------------------------------------------------------------
'jcfuller added
'From Wayne's 7.0.6
'------------------------------------------------------------------------------
IF UseCpp OR UseCpphdr THEN CALL FixAnyArrays(Arg$)
'------------------------------------------------------------------------------
  IF ComSwitchON THEN'IF ComSwitchON = TRUE THEN
    RAW i, j
    XFOR i = 1, j = bcx_com_open_with_statement WHILE i<= Ndx AND j = 0 BY i++
      IF IsVariableComObject(Stk$[i]) THEN j = 1
    XNEXT
    ' WITH
    IF j THEN
      IF Find_COM_statement(Src$) THEN EXIT SUB
    END IF
  END IF

  IF SpecialCaseHandler(Arg$) THEN EXIT SUB
  iDoFixup = TRUE
  szWord$ = LCASE$(Stk$[1])
  ptW = GetWordInfo(szWord$)
  IF ptW THEN
    IF (ptW->iWordInfo BAND eWI_Directive) THEN
      iEmitID = FindWord(szWord$, tDirectives,WordsInTable(tDirectives))
      IF iEmitID <> -1 THEN
        RAW FuncRetnFlag = 0
        IF tDirectives[iEmitID].Emitter(szWord$, &FuncRetnFlag) = 0 THEN EXIT SUB
      END IF
    END IF
    IF (ptW->iWordInfo BAND eWI_NoFixup) THEN
      iDoFixup = FALSE
    END IF
  END IF
'zero strip checked here still 0.30

  IF iDoFixup THEN
    CALL FixUps()
    PassOne = FALSE
  END IF
'zero strip checked here now .30
'If _ZTRACE_ Then
  'If iMatchLft(Src$,"CONST") Then
    'xFor int i = 1 While i <= Ndx By i++
		'ZPRINT(Stk$[i])
    'xNext
  'End If
'End If

  IF Ndx THEN

    CALL EmitMain()

    IF iEmitVariableGroup THEN CALL EmitBCXVariables()

  END IF
END SUB



SUB FixVector()
'jcfuller debug
'PRINT "FixVector"
    RAW Tmp, j, k
    FOR Tmp = 2 TO Ndx
      IF iMatchWrd(Stk$[Tmp],"as") THEN
        IF Stk$[Tmp+1] = "vector" THEN
          k = ++Tmp
          j = 0
          DO
            CONCAT(Stk$[k],Stk$[++Tmp])
            IF Stk$[Tmp] = ">" THEN j++
            Stk$[Tmp] = ""
          LOOP UNTIL j
        END IF
      END IF
    NEXT
    CALL RemEmptyTokens
END SUB



SUB EmitMain()
  RAW EmitAgain = TRUE
  RAW FuncRetnFlag = 0
  RAW iEmitID
  RAW Lookup$
  IF HasVector THEN CALL FixVector() : HasVector = FALSE
  Lookup$ = LCASE$(Stk$[1])
  IF SelectState[PusherSelectState].NoBreak2 AND NOT iMatchLft(Lookup$,"case") AND NOT iMatchWrd(Lookup$,"endselect") THEN
    SelectState[PusherSelectState].NoBreak2 = 0
  END IF

  FOR INT i = 1 TO Ndx
    REPLACE CHR$(15) WITH ":" IN Stk$[i]
'jcfuller added from Wayne's bcx 7.0.5
    REPLACE CHR$(16) WITH "<" IN Stk$[i]
    REPLACE CHR$(17) WITH ">" IN Stk$[i]
'jcfuller added from Wayne's bcx 7.0.6
    REPLACE CHR$(18) WITH "," IN Stk$[i]
  NEXT

  IF iMatchRgt(Stk$[1], ":") THEN    'This Must Be A Label
    FPRINT Outfile,""
    FPRINT Outfile,UCASE$(Stk$[1]),";"
    EXIT SUB
  END IF

  WHILE EmitAgain AND Ndx > 0
    Statements++
    'IF CurrentFuncType = vt_STRVAR AND InFunc AND OkayToSend THEN
    'per bcx 7.0.7
    IF CurrentFuncType = vt_STRVAR AND InFunc <> eNotInOne AND OkayToSend THEN
      FPRINT Outfile,Scoot$;"char *BCX_RetStr={0};"
      OkayToSend = 0
    END IF

    Lookup$ = LCASE$(Stk$[1])
    iEmitID = FindWord(Lookup$, atEmitWords,WordsInTable(atEmitWords))
    IF iEmitID = -1 THEN
      EmitOld(&FuncRetnFlag)
      EmitAgain = FALSE
    ELSE
      EmitAgain = atEmitWords[iEmitID].Emitter(Lookup$, &FuncRetnFlag)
    END IF

  WEND

  IF FuncRetnFlag = 1 THEN
    IF LocalDynaCnt <> 0 THEN
      FOR INT j = 1 TO LocalDynaCnt
        FPRINT Outfile,Scoot$;DynaStr$[j]
      NEXT
    END IF
    '******************************************************************
    FPRINT Outfile,Scoot$;"return BCX_RetStr;"  ' $ FUNCTION Return
    '******************************************************************
  END IF
  ExitSubFunc = FALSE
  IF iMatchWrd(Stk$[1], "exit") THEN
    IF iMatchWrd(Stk$[2], "sub") OR iMatchWrd(Stk$[2], "function") THEN
      ExitSubFunc = TRUE
    END IF
  END IF
END SUB ' EmitMain



FUNCTION Emit_FolderDriveProcs(Lookup$, FuncRetnFlag AS PINT)
  ' "chdir", "_chdir", "rmdir", "_rmdir", "mkdir", "_mkdir"
  If Lookup$ = "chdir" Then
  FPRINT Outfile,Scoot$;"NOT_USED(g_dum_int);"
  FPRINT Outfile,Scoot$;"g_dum_int = ";
  End If
  'cout << Lookup$ << endl
  
  FPRINT Outfile,Scoot$;Lookup$;" (";
  Stk$[++Ndx] = ");"
  CALL WriteCleanTokens(2,Ndx)
  FUNCTION = 0
END FUNCTION ' Emit_FolderDriveProcs



FUNCTION Emit_FunctionReturn(Lookup$, FuncRetnFlag AS PINT)
    RAW lszTmp$
    'cout << "Emit_FunctionReturn" << endl
    IF SelectState[PusherSelectState].CaseFlag THEN SelectState[PusherSelectState].NoBreak2 = TRUE
    lszTmp$ = ""

    FOR INT iA = 3 TO Ndx
      lszTmp$ = lszTmp$ + Stk$[iA] + " "
    NEXT

    IF CurrentFuncType = vt_STRVAR THEN
      lszTmp$ = "BCX_RetStr$ = " + lszTmp$
      *FuncRetnFlag = 1    '1 = return a string
      UseFlag = TRUE
    ELSE
      *FuncRetnFlag = 2    '2 = return a number
    END IF

    IF *FuncRetnFlag = 2 THEN
      '*********************************
      '    Clean up dynamic strings
      '*********************************
      IF LocalDynaCnt <> 0 THEN
        FOR INT j = 1 TO LocalDynaCnt
          FPRINT Outfile,Scoot$;DynaStr$[j]
        NEXT
      END IF
      '*********************************
      ' Clean up dynamic strings arrays
      '*********************************
      IF LocalDynArrCnt <> 0 THEN
        FOR INT i = 1 TO LocalDynArrCnt
          FPRINT Outfile,Scoot$;LocalDynArrName$[i]
          'cout << "33913" << endl
        NEXT
      END IF
      '*********************************
      FPRINT Outfile,Scoot$;"return ";
      LastCmd = 2
    END IF
    CALL XParse(lszTmp$)
    CALL FixUps()
    LastCmd = 0
    FUNCTION = 1
END FUNCTION ' Emit_FunctionReturn



FUNCTION Emit_GUIProcs(sWord$, FuncRetnFlag AS PINT)
  Raw i As integer
  Dim zt$
  SELECT CASE sWord$
    CASE "gui", "mdigui"
      IF Ndx < 2 THEN Abort( "Not Enough Parameters with " + UCASE$(sWord$) + " Statement!" )

	GUIIcon$ = " LoadIcon(NULL,IDI_WINLOGO);"

      IF LCASE$(Stk$[2]) = "nomain" THEN

        Use_Wingui    = TRUE
        NoMain        = TRUE
        Use_GUINoMain = TRUE
		FOR i = 1 TO Ndx
          IF LCASE$(Stk$[i]) = "pixels" THEN
            GUIMetric$ = "pixels"
            ITERATE
          END IF
          IF LCASE$(Stk$[i]) = "dpi" THEN
            GUIMetric$ = "dpi"
            ITERATE
          END IF

          IF LCASE$(Stk$[i]) = "icon" AND Stk$[i+2] <> "" THEN
            GUIIcon$ = " LoadIcon(BCX_hInstance,MAKEINTRESOURCE(" & Stk$[i+2] & "));"
            ITERATE
          END IF
'jcfuller added
'------------------------------------------------------------------------------
          IF LCASE$(Stk$[i])="menu" AND Stk$[i+2]<> "" THEN
        	  GUIMenu$ = DQ$ & "#" & Stk$[6] & DQ$
        	  'g_ResMenu$ = GUIMenu$
          End If

        Next i
'------------------------------------------------------------------------------
        IF sWord$ = "mdigui" THEN
          Use_Mdigui       = TRUE
          CALL EmitMDICode(Outfile)
          Use_MDIGUINoMain = TRUE
          Use_GUINoMain    = FALSE
        END IF

      ELSE '  Old GUI code before GUI NOMAIN

        Use_Wingui = TRUE

        LOCAL classname$
        LOCAL metric$

        classname$ = Stk$[2]
        If _ZTRACE_ Then
			ZPRINT(classname$)
		End If

        FOR i = 1 TO Ndx
	        IF LCASE$(Stk$[i]) = "pixels" THEN
	          metric$ = "pixels"
	          GUIMetric$ = "pixels"
	          ITERATE
	        END IF
	        IF LCASE$(Stk$[i]) = "dpi" THEN
	          metric$ = "dpi"
	          GUIMetric$ = "dpi"
	          ITERATE
	        END IF

        	IF LCASE$(Stk$[i]) = "icon" AND Stk$[i+2] <> "" THEN
          		GUIIcon$ = " LoadIcon(BCX_hInstance,MAKEINTRESOURCE(" & Stk$[i+2] & "));"
        	END IF

'jcfuller added
'------------------------------------------------------------------------------
        IF LCASE$(Stk$[i])="menu" AND Stk$[i+2]<> "" THEN
        	GUIMenu$ = DQ$ & "#" & Stk$[i+2] & DQ$
        	'g_ResMenu$ = GUIMenu$
        	ITERATE
        End If
'added 01/19/2015
        If LCASE$(Stk$[i])="dlg" AND Stk$[i+2]<> "" Then
        'If _ZTRACE_ Then
		'zt$= " DLG = " + Stk$[i+2]
		'	ZPRINT(zt$)
		'End If

			DlgWin = 1
			DlgWinProc$ = Stk$[i+2]

			Iterate
        End If
'------------------------------------------------------------------------------
        Next i
'------------------------------------------------------------------------------

        Use_BCX_SetMetric = Use_BCX_InitGUI = Use_BCX_RegWnd = TRUE
        EmitWinGUIMain( classname$, metric$, GUIIcon$ )

        IF sWord$ = "mdigui" THEN
          Use_Mdigui = TRUE
          CALL EmitMDI_MsgPump
          CALL EmitMDICode(Outfile)
        ELSE
          CALL EmitGUI_MsgPump
        END IF ' sWord$ = "mdigui"

      END IF

      CALL AddGUIGlobals()
      IF NOT Use_BCX_Class_Info THEN
        Use_BCX_Class_Info = TRUE
        iEmitVariableGroup = iEmitVariableGroup BOR (eFontGroup BOR eClassName)
      END IF

'        'PRINT "ndx = ";Ndx
'        'FOR i = 1 TO 10
'        '	PRINT "Stk[";STR$(i);"] = ";Stk$[i]
'        'Next
'      IF Ndx < 2 THEN Abort( "Not Enough Parameters with " + UCASE$(sWord$) + " Statement!" )
'
'      IF LCASE$(Stk$[2]) = "nomain" THEN
'
'        Use_Wingui    = TRUE
'        NoMain        = TRUE
'        Use_GUINoMain = TRUE
'
'        IF LCASE$(Stk$[4]) = "pixels" THEN
'          GUIMetric$ = "pixels"
'        END IF
'
'        IF LCASE$(Stk$[4]) = "icon" AND Stk$[6] <> "" THEN
'          GUIIcon$ = " LoadIcon(BCX_hInstance,MAKEINTRESOURCE(" & Stk$[6] & "));"
'        ELSEIF LCASE$(Stk$[6]) = "icon" AND Stk$[8] <> "" THEN
'          GUIIcon$ = " LoadIcon(BCX_hInstance,MAKEINTRESOURCE(" & Stk$[8] & "));"
'        ELSE
'          GUIIcon$ = " LoadIcon(NULL,IDI_WINLOGO);"
'        END IF
''jcfuller added
''------------------------------------------------------------------------------
'        IF LCASE$(Stk$[4])="menu" AND Stk$[6]<> "" THEN
'        	GUIMenu$ = DQ$ & "#" & Stk$[6] & DQ$
'        End If
''------------------------------------------------------------------------------
'        IF sWord$ = "mdigui" THEN
'          Use_Mdigui       = TRUE
'          CALL EmitMDICode(Outfile)
'          Use_MDIGUINoMain = TRUE
'          Use_GUINoMain    = FALSE
'        END IF
'
'      ELSE '  Old GUI code before GUI NOMAIN
'
'        Use_Wingui = TRUE
'
'        LOCAL classname$
'        LOCAL metric$
'
'        classname$ = Stk$[2]
'
'        IF LCASE$(Stk$[4]) = "pixels" THEN
'          metric$ = "pixels"
'          GUIMetric$ = "pixels"
'        END IF
'
'        IF LCASE$(Stk$[4]) = "icon" AND Stk$[6] <> "" THEN
'          GUIIcon$ = " LoadIcon(BCX_hInstance,MAKEINTRESOURCE(" & Stk$[6] & "));"
'        ELSEIF LCASE$(Stk$[6]) = "icon" AND Stk$[8] <> "" THEN
'          GUIIcon$ = " LoadIcon(BCX_hInstance,MAKEINTRESOURCE(" & Stk$[8] & "));"
'        ELSE
'          GUIIcon$ = " LoadIcon(NULL,IDI_WINLOGO);"
'        END IF
'
''jcfuller added
''------------------------------------------------------------------------------
'        IF LCASE$(Stk$[4])="menu" AND Stk$[6]<> "" THEN
'        	GUIMenu$ = DQ$ & "#" & Stk$[6] & DQ$
'        End If
''------------------------------------------------------------------------------
'
'        Use_BCX_SetMetric = Use_BCX_InitGUI = Use_BCX_RegWnd = TRUE
'        EmitWinGUIMain( classname$, metric$, GUIIcon$ )
'
'        IF sWord$ = "mdigui" THEN
'          Use_Mdigui = TRUE
'          CALL EmitMDI_MsgPump
'          CALL EmitMDICode(Outfile)
'        ELSE
'          CALL EmitGUI_MsgPump
'        END IF ' sWord$ = "mdigui"
'
'      END IF
'
'      CALL AddGUIGlobals()
'      IF NOT Use_BCX_Class_Info THEN
'        Use_BCX_Class_Info = TRUE
'        iEmitVariableGroup = iEmitVariableGroup BOR (eFontGroup BOR eClassName)
'      END IF

    CASE "insertmenu"  'HELPER
      RAW Comma
      Comma = 0
      FPRINT Outfile,Scoot$;"InsertMenu";

      FOR INT A = 2 TO Ndx
        IF Stk$[A] = "," THEN Comma++
        IF Stk$[A] = "," THEN
          IF Comma = 3 THEN
            Stk$[A] = ",(UINT_PTR)"
          END IF
        END IF
        FPRINT Outfile,Clean$(Stk$[A]);
      NEXT

      FPRINT Outfile,";"

    CASE "bcx_set_edit_color"  'These statements must appear in the EVENTS LOOP
      Use_SetColor = Use_Proto = TRUE

      IF Stk$[2] = "(" THEN

        CALL DeleteTokens(2, 1)
        Ndx--
      END IF

      szTmp$ = ""
      RAW i
      FOR i = 2 TO Ndx
        IF Stk$[i] = "," THEN EXIT FOR
        CONCAT(szTmp$,Stk$[i])
      NEXT

      FPRINT Outfile,Scoot$;"if((HWND)lParam=="; szTmp$ ;" && Msg==WM_CTLCOLOREDIT)"
      FPRINT Outfile,Scoot$;"return Set_Color(" ;
      Stk$[++Ndx] = ",(HDC)wParam,(HWND)lParam);"
      CALL WriteCleanTokens(i+1,Ndx)

    CASE "bcx_set_font"

      Use_SetFont = TRUE
      Use_Proto = TRUE

      IF Stk$[2] = "(" THEN
        CALL DeleteTokens(2, 1)
        Ndx--
      END IF

      FPRINT Outfile,Scoot$;"SendMessage(";
      RAW i
      i = 2

      DO
        FPRINT Outfile,Clean$(Stk$[i]);
        i++
        IF Stk$[i] = "," THEN EXIT DO
        IF i > Ndx THEN Abort ("Malformed BCX_SET_FONT")
      LOOP

      i++
      FPRINT Outfile,",(UINT)WM_SETFONT," ;
      FPRINT Outfile,"(WPARAM)BCX_Set_Font(" ;
      Stk$[++Ndx] = "),1);"
      CALL WriteCleanTokens(i,Ndx)

    CASE "bcx_set_label_color" ' These statements must appear in the EVENTS LOOP

      Use_SetColor = Use_Proto = TRUE

      IF Stk$[2] = "(" THEN
        CALL DeleteTokens(2, 1)
        Ndx--
      END IF

      szTmp$ = ""
      RAW i
      FOR i = 2 TO Ndx
        IF Stk$[i] = "," THEN EXIT FOR
        CONCAT(szTmp$,Stk$[i])
      NEXT

      FPRINT Outfile,Scoot$;"if((HWND)lParam=="; szTmp$ ;" && Msg==WM_CTLCOLORSTATIC)"
      FPRINT Outfile,Scoot$;"return Set_Color(" ;
      Stk$[++Ndx] = ",(HDC)wParam,(HWND)lParam);"
      CALL WriteCleanTokens(i+1,Ndx)

    CASE "msgbox"          ' MsgBox Msg$,Title$,button
      RAW i, j, k
      j = 0
      k = 0

      FOR i = 2 TO Ndx
        IF Stk$[i] = "[" THEN
          j++
        ELSEIF Stk$[i] = "]" THEN
          j--
        ELSEIF Stk$[i] = "(" THEN
          j++
        ELSEIF Stk$[i] = ")" THEN
          j--
        END IF
        IF j = 0 AND Stk$[i] = "," THEN k++
      NEXT

      IF k = 0 THEN
        Ndx++
        Stk$[Ndx]= ","
        Ndx++
        Stk$[Ndx]= DDQ$
        k = 1
      END IF

      IF k = 1 THEN
        Ndx++
        Stk$[Ndx]= ","
        Ndx++
        Stk$[Ndx]= "0"
      END IF

      FPRINT Outfile,Scoot$;"MessageBox (GetActiveWindow(),";
      Stk$[++Ndx] = ");"
      CALL WriteCleanTokens(2,Ndx)

    CASE "~vscroll"
      Use_Vscroll = VAL(Stk$[2])
      IF Use_Vscroll = 0 THEN Use_Vscroll = TRUE

    CASE "~hscroll"
      Use_Hscroll = VAL(Stk$[2])
      IF Use_Hscroll = 0 THEN Use_Hscroll = TRUE

  END SELECT

  FUNCTION = 0
END FUNCTION ' Emit_GUIProcs


FUNCTION Emit_FileIO(sWord$, FuncRetnFlag AS PINT)
  SELECT CASE sWord$
    CASE "close"               'CLOSE handle
    IF Ndx = 1 THEN
      FPRINT Outfile,Scoot$;"_fcloseall();"
      EXIT SELECT
    END IF

    IF DataType(Stk$[2]) = vt_NUMBER THEN
      Stk$[2]= "FP"  +  Stk$[Ndx]
    END IF

    RAW i
    IF CheckLocal(Stk$[2], &i) = vt_UNKNOWN THEN
      IF CheckGlobal(Stk$[2], &i) = vt_UNKNOWN THEN
        CALL AddGlobal(Stk$[2], vt_FILEPTR, 0,"",0,0,0,0,0)
      END IF
    END IF

    Handle$ = ""
    FOR INT j = 2 TO Ndx
      Handle$ = Handle$ + Stk$[j]
    NEXT j

    IF UseFileTest THEN
      FPRINT Outfile,Scoot$;"if(",Handle$,")"
      FPRINT Outfile,Scoot$;" {"
      FPRINT Outfile,Scoot$;"   fclose(";Handle$;");"
      FPRINT Outfile,Scoot$;"   ";Handle$;"=NULL;"
      FPRINT Outfile,Scoot$;" }"
    ELSE
      FPRINT Outfile,Scoot$;"fclose(";Handle$;");"
    END IF

    '*************************************************************************
    CASE "open"    'OPEN filename$ FOR INPUT | OUTPUT | APPEND AS handle
    '*************************************************************************
    RAW Keyword$, lszTmp$, Op$, HaveFOR, HaveAS
    HaveFOR = FALSE
    HaveAS = FALSE
    Op$ = ""
    FOR INT iA = 1 TO Ndx
      Keyword$ = LCASE$(Stk$[iA])

      SELECT CASE Keyword$
        CASE "open"
        Stk$[iA] = ""

        CASE "for"
        Stk$[iA] = ""
        CALL BuildCleanStr(2, iA-1, Filnam$)
        HaveFOR = TRUE

        CASE "as"
        Stk$[iA] = ""
        IF DataType(Stk$[iA + 1]) = vt_NUMBER THEN
          Stk$[iA + 1] = "FP" + Stk$[iA + 1]
        END IF
        HaveAS = TRUE

        RAW i
        IF CheckLocal(Stk$[iA + 1], &i) = vt_UNKNOWN THEN
          IF CheckGlobal(Stk$[iA + 1], &i) = vt_UNKNOWN THEN
            CALL AddGlobal(Stk$[iA + 1], vt_FILEPTR, 0,"",0,0,0,0,0)
          END IF
        END IF

        Var$ = ""
        FOR INT j = iA+1 TO Ndx
          IF iMatchWrd(Stk$[j], "reclen") THEN EXIT FOR
          CONCAT (Var$,Stk$[j])
          Stk$[j] = ""
        NEXT
        Handle$ = Var$ + "@"

        CASE "input"
        Op$ = ENC$("r")
        Stk$[iA] = ""

        CASE "output"
        Op$ = ENC$("w")
        Stk$[iA] = ""

        CASE "append"
        Op$ = ENC$("a")
        Stk$[iA] = ""

        CASE "binary"
        Op$ = ENC$("rb+")
        Stk$[iA] = ""

        CASE "binaryappend"
        Op$ = ENC$("ab+")
        Stk$[iA] = ""

        CASE "binarynew"
        Op$ = ENC$("wb+")
        Stk$[iA] = ""

        CASE "binaryinput"
        Op$ = ENC$("rb")
        Stk$[iA] = ""

        CASE "binaryoutput"
        Op$ = ENC$("rb+")
        Stk$[iA] = ""

        CASE "reclen"
        IF Stk$[iA+1] = "=" THEN
          FOR INT j = iA+2 TO Ndx
            Stk$[j-1] = Stk$[j]
          NEXT
          Ndx--
        END IF

        Var$ = EXTRACT$(Clean$(Handle$), "[") + "len"
        RAW i, j
        RAW ZZ$

        IF CheckLocal(Var$, &i) = vt_UNKNOWN THEN
          CALL AddGlobal(Var$, vt_INTEGER , 0,"",0,0,0,0,0)
        ELSE
          IF CheckLocal(Var$, &i) = vt_UNKNOWN THEN
            CALL AddLocal(Var$, vt_INTEGER , 0,"",0,0,0,0)
            Var$ = "int " + Var$
          END IF
        END IF

        i = CheckType(Stk$[iA+1])
        ZZ$ = LCASE$(Stk$[iA+1])
        j = FindWord(ZZ$, tTypes, WordsInTable(tTypes))
        IF i = vt_STRUCT OR i = vt_UNION OR j = vt_BOOL OR j = vt_BYTE OR _
          j = vt_CHAR OR j = vt_COLORREF OR j = vt_DOUBLE OR j = vt_DWORD OR _
          j = vt_SINGLE OR j = vt_INTEGER OR j = vt_LDOUBLE OR j = vt_LLONG OR _
          j = vt_LONG OR j = vt_SHORT OR j = vt_UINT OR j = vt_ULONG OR _
          j = vt_ULONGLONG OR j = vt_USHORT OR j = vt_VARIANT OR j = vt_WINBOOL THEN
          FPRINT Outfile,Scoot$;Var$;" = sizeof(";Stk$[iA+1];");"
        ELSE
          FPRINT Outfile,Scoot$;Var$;" = ";Clean$(Stk$[iA+1]);";"
        END IF
        Stk$[iA] = ""
        Stk$[iA + 1] = ""
      END SELECT
    NEXT
    IF Op$ = "" THEN CALL Abort("Syntax Error: Missing FOR operation in open statement")
    IF IDont(HaveFOR) THEN CALL Abort("Syntax Error: Missing FOR in open statement")
    IF IDont(HaveAS) THEN CALL Abort("Syntax Error: Missing AS in open statement")

    IF UseFileTest THEN
      FPRINT Outfile,Scoot$;"if((";Clean$(Handle$);"=fopen(";Filnam$;",";Op$;"))==0)"
      FPRINT Outfile,Scoot$;" {"
      lszTmp$ = ENC$("Can't open file %s\\n")
      FPRINT Outfile,Scoot$;"fprintf(stderr,";"(char*)";lszTmp$;",";Filnam$;");exit(1);"
      FPRINT Outfile,Scoot$;" }"
    ELSE
      FPRINT Outfile,Scoot$;Clean$(Handle$);"=fopen(";Filnam$;",";Op$;");"
    END IF

    '*************************************************************************
    ' Statement  RECORD [#] filenumber,recordnumber [,location in record]
    ' Definition:          Position the file pointer anywhere in a file.
    ' filenumber           Filenumber from  1 to 99
    ' record number        RECORD number to point to. Default first record
    ' location in record   Optional location in RECORD. Default is Zero
    ' RECORD fp1, 6[, 10]
    '*************************************************************************
    CASE "record"
      Raw ffp AS functionParse
      RAW numargs = 0

    IF DataType(Stk$[2]) = vt_NUMBER THEN
      Stk$[2]= "FP"  +  Stk$[2]
    END IF

    IF Ndx > 1 THEN numargs = SepFuncArgs(1, &ffp, FALSE)
    IF numargs < 1 THEN Abort("Missing required arguments to RECORD")
    IF numargs > 4 THEN Abort("Too many arguments to RECORD")

    IF numargs = 3 THEN
      FPRINT Outfile,Scoot$;"fseek("; GetArg$(1, &ffp); _
      ", ("; GetArg$(2, &ffp); " - 1) * ";Stk$[2];"len;";GetArg$(3, &ffp);", SEEK_SET);"

    ELSEIF numargs = 2 THEN
      FPRINT Outfile,Scoot$;"fseek("; GetArg$(1, &ffp); _
      ", ("; GetArg$(2, &ffp); " - 1) * ";Stk$[2];"len, SEEK_SET);"
    ELSE
      FPRINT Outfile,Scoot$;"fseek("; GetArg$(1, &ffp); ", 0, SEEK_SET);"
    END IF
  END SELECT
  FUNCTION = 0
END FUNCTION ' Emit_FileIO



FUNCTION Emit_FileManagementProcs(sWord$, FuncRetnFlag AS PINT)
  SELECT CASE sWord$

    CASE "copyfile"
      FPRINT Outfile,Scoot$;"CopyFile (";
      RAW szUS$
      szUS$ = UCASE$(Stk$[Ndx])
      SELECT CASE Stk$[Ndx]

        CASE "1", "0"
          Stk$[++Ndx] = ");"
        CASE "TRUE", "FALSE"
          IF UseCpp THEN
            Stk$[Ndx] = LCASE$(Stk$[Ndx]) & ");"
          ELSE
            Stk$[Ndx] = szUS$ & ");"
          END IF

        CASE ELSE
          IF UseCpp THEN
            Stk$[++Ndx] = ",false);"
          ELSE
            Stk$[++Ndx] = ",FALSE);"
          END IF

      END SELECT

      CALL WriteCleanTokens(2,Ndx)


    '***********************
    CASE "kill"
    '***********************
    'IF UseWinApi Then
    IF UseWinApi OR Use_TCLib Then
      FPRINT Outfile,Scoot$;"DeleteFile (";
    ELSE
      FPRINT Outfile,Scoot$;"remove (";
    END IF
    Stk$[++Ndx] = ");"
    CALL WriteCleanTokens(2,Ndx)


    '***********************
    CASE "rename"
    '***********************
    FPRINT Outfile,Scoot$;"MoveFile (";
    Stk$[++Ndx] = ");"
    CALL WriteCleanTokens(2,Ndx)

  END SELECT
  FUNCTION = 0
END FUNCTION ' Emit_FileManagementProcs



FUNCTION Emit_FileIOProcs(sWord$, FuncRetnFlag AS PINT)
  SELECT CASE sWord$
      ' LINEINPUT fp1,A$
      ' LINEINPUT "prompt", A$  <<< Keyboard version 4.21
    CASE "lineinput"

      RAW i

      '     Test for new keyboard version of LINE INPUT
      i = DataType(Stk$[2])

      IF i = vt_STRLIT OR i = vt_STRVAR THEN
        IF i <> vt_STRLIT THEN Stk$[2] = Clean$(Stk$[2])
        RAW sC_Stk3$
        sC_Stk3$ = Clean$(Stk$[3])
        FPRINT Outfile,Scoot$;"printf(", ENC$("%s"), ",", Stk$[2], ");"
        FPRINT Outfile,Scoot$;"fgets(", sC_Stk3$, ",sizeof(", sC_Stk3$,"),stdin);"
        FPRINT Outfile,Scoot$; sC_Stk3$,"[strlen(", sC_Stk3$, ")-1]=0;"
        EXIT SELECT
      END IF

      ' ********************* Okay, we're dealing with a file ************************
      REMOVE "#" FROM Stk$[2]

      IF DataType(Stk$[2]) = vt_NUMBER THEN
        Stk$[2]= "FP" & Stk$[2]
      END IF

      RAW Handle$
      RAW Var$
      RAW Var1$
      RAW CVar$
      Handle$ = EXTRACT$(Stk$[2], "[")

      IF CheckLocal(Handle$, &i) = vt_UNKNOWN THEN
        IF CheckGlobal(Handle$, &i) = vt_UNKNOWN THEN
          CALL AddGlobal(Handle$, vt_FILEPTR, 0,"",0,0,0,0,0)
        END IF
      END IF

      Var$ = Clean$(Stk$[3])
      Var1$ = ""
      CVar$ = Var$

      IF INCHR( Var$, "[" ) AND INCHR( Var$, "]" ) THEN
        IF INSTR( Var$, "[++" ) THEN
          REPLACE "++" WITH "" IN CVar$
        END IF
        IF INSTR( Var$, "[--" ) THEN
          REPLACE "--" WITH "" IN CVar$
        END IF
        IF INSTR( Var$, "++]" ) THEN
          REPLACE "++" WITH "" IN CVar$
          Var1$ = MID$(Var$,INCHR(Var$,"[")+1)
          Var1$ = EXTRACT$(Var1$,"]")
          Var$ = CVar$
        END IF
        IF INSTR( Var$, "--]" ) THEN
          REPLACE "--" WITH "" IN CVar$
          Var1$ = MID$(Var$,INCHR(Var$,"[")+1)
          Var1$ = EXTRACT$(Var1$,"]")
          Var$ = CVar$
        END IF
      END IF

'IF _ZTRACE_ THEN
  'Raw AS Integer _i
  'ZPRINT("---------------")
  'For _i = 1 To Ndx
      'ZPRINT(Stk$[_i])
  'Next _i
  'ZPRINT("---------------")
'END IF
      Raw As Integer BufSize=cMaxSrcLen
      Dim sBuf$
'Another rework 09/04/2015
	If Ndx > 3 Then
		For int iNdx = 4 To Ndx
			sBuf$ = sBuf$ & Stk$[iNdx]
	    Next iNdx
	Else
		sBuf$ = Str$(BufSize)
	End If
      'sBuf$ = Str$(BufSize)

      'If Ndx = 4 Then
		'BufSize = VAL(Stk$[Ndx])
		'sBuf$ = Stk$[Ndx]

	  'ElseIf Ndx > 4 Then
	    'sBuf$ = ""
		'For int iNdx = 4 To Ndx
			''cout << Stk$[iNdx]  << endl;
			'sBuf$ = sBuf$ & Stk$[iNdx]
	    'Next iNdx
	   'Else
	     'sBuf$ = Str$(BufSize)
      'End If

      'If IsBc9 Then
		'sBuf$ = Str$(cMaxSrcLen)
	  'Else
		'sBuf$ = "(sizeof(" & CVar$ & ")-1)"
	  'End If
      FPRINT Outfile,Scoot$;Var$ ; "[0]=0;"
'jcfuller change
	  'FPRINT Outfile,Scoot$;"int BufferSize = (sizeof(";Var$;")==4) ? _msize(";Var$;") : sizeof(";Var$;");"
	  'FPRINT Outfile,Scoot$;"fgets(" ; Var$ ; ",BufferSize,"; Clean$(Stk$[2]) ; ");"
      'FPRINT Outfile,Scoot$;"fgets(" ; Var$ ; ",";cMaxSrcLen;","; Clean$(Stk$[2]) ; ");"
      'FPRINT Outfile,Scoot$;"fgets(" ; Var$ ; ",";cSizeOfDefaultString;","; Clean$(Stk$[2]) ; ");"

      'FPRINT Outfile,Scoot$;"fgets(" ; Var$ ; ",";BufSize;","; Clean$(Stk$[2]) ; ");"
      'FPRINT Outfile,Scoot$;"fgets(" ; Var$ ; ",";sBuf$;","; Clean$(Stk$[2]) ; ");"
	  FPRINT Outfile,Scoot$;"g_cptr_ = fgets(" ; Var$ ; ",";sBuf$;","; Clean$(Stk$[2]) ; ");"
      FPRINT Outfile,Scoot$;"if("    ; CVar$ ; "[strlen(" ;CVar$ ; ")-1]==10)";
      FPRINT Outfile,CVar$  ; "[strlen(" ; CVar$ ; ")-1]=0;"

      IF Var1$ <> "" THEN
        FPRINT Outfile,Var1$ ; ";"
      END IF

    CASE "finput"
      CALL EmitFileInputCode()

    CASE "~get"
      RAW i
      Use_Get = TRUE
      Use_SysMacros = TRUE

      IF DataType(Stk$[2])= vt_NUMBER THEN
        Stk$[2]= "FP" + Stk$[2]
      END IF
      IF CheckLocal(Stk$[2], &i) = vt_UNKNOWN THEN
        IF CheckGlobal(Stk$[2], &i) = vt_UNKNOWN THEN
          CALL AddGlobal(Stk$[2], vt_FILEPTR, 0,"",0,0,0,0,0)
        END IF
      END IF
      FPRINT Outfile,Scoot$;"GET(";
      Stk$[++Ndx] = ");"
      CALL WriteCleanTokens(2,Ndx)

    CASE "~put"
      RAW i
      Use_Put = TRUE
      Use_SysMacros = TRUE

      IF DataType(Stk$[2]) = vt_NUMBER THEN
        Stk$[2]= "FP" + Stk$[2]
      END IF
      IF CheckLocal(Stk$[2], &i) = vt_UNKNOWN THEN
        IF CheckGlobal(Stk$[2], &i) = vt_UNKNOWN THEN
          CALL AddGlobal(Stk$[2], vt_FILEPTR, 0,"",0,0,0,0,0)
        END IF
      END IF

      FPRINT Outfile,Scoot$;"PUT(";
      Stk$[++Ndx] = ");"
      CALL WriteCleanTokens(2,Ndx)

    CASE "seek"
      RAW i
      IF DataType(Stk$[2])= vt_NUMBER THEN
        Stk$[2]= "FP" + Stk$[2]
      END IF
      IF CheckLocal(Stk$[2], &i) = vt_UNKNOWN THEN
        CALL AddGlobal(Stk$[2], vt_FILEPTR, 0,"",0,0,0,0,0)
      END IF

      FPRINT Outfile,Scoot$;"fseek(";
      Stk$[++Ndx] = ",0);"
      CALL WriteCleanTokens(2,Ndx)

    CASE "fprint"
      RAW i
      RAW ZZ$
      IF IsNumber(Stk$[2]) THEN
        Stk$[2] = "FP" + Stk$[2]
      END IF

      IF LCASE$(Stk$[2]) = "stderr" THEN
        Handle$ = LCASE$(Stk$[2])
      ELSE
        IF CheckLocal(Stk$[2], &i) = vt_UNKNOWN THEN
          IF CheckGlobal(Stk$[2], &i) = vt_UNKNOWN THEN
            CALL AddGlobal(Stk$[2], vt_FILEPTR, 0,"",0,0,0,0,0)
          END IF
        END IF

        Handle$ = ""
        FOR INT j = 2 TO Ndx
          IF *Stk$[j] = ASC(",") OR *Stk$[j] = ASC(";") THEN
            Stk$[j] = ""
            EXIT FOR
          END IF
          Handle$ = Handle$ + Stk$[j]
          Stk$[j] = ""
        NEXT i

        Handle$ = Handle$ + "@"
      END IF

      Stk$[2] = ""  'get rid of handle
      Stk$[3] = ""  'get rid of the Comma

      ZZ$ = "f" + PrintWriteFormat$(0)
      ZZ$ = LEFT$(ZZ$,8) + REMOVE$(Handle$,"@") + "," + MID$(ZZ$,9)

      FPRINT Outfile,Scoot$;ZZ$

    CASE "fwrite"    'write handle,{list}
      RAW ZZ$
      RAW i
      IF DataType(Stk$[2]) = vt_NUMBER THEN
        Stk$[2] = "FP" + Stk$[2]
      END IF

      IF CheckLocal(Stk$[2], &i) = vt_UNKNOWN THEN
        CALL AddGlobal(Stk$[2], vt_FILEPTR, 0,"",0,0,0,0,0)
      END IF

      Handle$ = ""
      FOR INT j = 2 TO Ndx
        IF iMatchWrd(Stk$[j], ",") OR iMatchWrd(Stk$[j], ";") THEN
          Stk$[j] = ""              'get rid of the Comma
          EXIT FOR
        END IF
        Handle$ = Handle$ + Stk$[j]
        Stk$[j] = ""                 'get rid of handle
      NEXT j

      Handle$ = Handle$ + "@"

      ZZ$ = "f" + PrintWriteFormat$(1)
      ZZ$ = LEFT$(ZZ$,8)  +  Clean$(Handle$)  +  ","  +  MID$(ZZ$,9)
      FPRINT Outfile,Scoot$;ZZ$

    CASE ELSE
      CALL EmitOld(FuncRetnFlag)
  END SELECT
  FUNCTION = 0
END FUNCTION ' Emit_FileIOProcs


$comment
FUNCTION Emit_ConversionProcs(sWord$, FuncRetnFlag AS PINT)
  CALL EmitOld(FuncRetnFlag)
  FUNCTION = 0
END FUNCTION ' Emit_ConversionProcs
$comment


FUNCTION Emit_StringProcs(sWord$, FuncRetnFlag AS PINT)
  SELECT CASE sWord$

    CASE "midstr"            ' alias TO MID$ statement(NOT FUNCTION)
      Src$ = ""
      FOR INT A = 1 TO Ndx
        CONCAT(Src$,Clean$(Stk$[A]))
      NEXT

      FPRINT Outfile,Scoot$;TRIM$(Src$), ";"

    CASE ELSE
      CALL EmitOld(FuncRetnFlag)

  END SELECT
  FUNCTION = 0
END FUNCTION ' Emit_StringProcs



FUNCTION Emit_MathProcs(sWord$, FuncRetnFlag AS PINT)
  SELECT CASE sWord$

    CASE "incr"
      RAW j = FALSE
      FPRINT Outfile,Scoot$;
      FOR INT i = 2 TO Ndx
        IF Stk$[i] = "," THEN
          FPRINT Outfile,"+=(";
          j = TRUE
        ELSE
          FPRINT Outfile,Clean$(Stk$[i]);
        END IF
      NEXT
      FPRINT Outfile,IIF$(j,");","++;")

    CASE "decr"
      RAW j = FALSE
      FPRINT Outfile,Scoot$;
      FOR INT i = 2 TO Ndx
        IF Stk$[i] = "," THEN
          FPRINT Outfile,"-=(";
          j=TRUE
        ELSE
          FPRINT Outfile,Clean$(Stk$[i]);
        END IF
      NEXT
      FPRINT Outfile,IIF$(j,");","--;")

    CASE ELSE
      CALL EmitOld(FuncRetnFlag)
  END SELECT
  FUNCTION = 0
END FUNCTION ' Emit_MathProcs



FUNCTION Emit_ConsoleOnlyProcs(sWord$, FuncRetnFlag AS PINT)
  SELECT CASE sWord$

    CASE "print"
      FPRINT Outfile,Scoot$; PrintWriteFormat$(0)

    CASE "locate"
'      IF NoMain = TRUE OR MakeDLL = TRUE THEN
'jcfuller changed 07/01/2013
      IF NoMain OR MakeDLL THEN
        Use_Console = TRUE
        FPRINT Outfile,"  hConsole = GetStdHandle (STD_OUTPUT_HANDLE);"
      END IF

      FPRINT Outfile,Scoot$;"locate (";
      Stk$[++Ndx] = ");"
      CALL WriteCleanTokens(2,Ndx)

    CASE "panel"
      'IF NoMain = TRUE OR MakeDLL = TRUE THEN
      IF NoMain OR MakeDLL THEN
        Use_Console = TRUE
        FPRINT Outfile,"  hConsole = GetStdHandle (STD_OUTPUT_HANDLE);"
      END IF

      FPRINT Outfile,Scoot$;"panel (";
      Stk$[++Ndx] = ");"
      CALL WriteCleanTokens(2,Ndx)

    CASE "cls"
      'IF NoMain = TRUE OR MakeDLL = TRUE THEN
      IF NoMain OR MakeDLL THEN
        'If Use_Console = TRUE Then
        If Use_Console Then
        	FPRINT Outfile,"  hConsole = GetStdHandle (STD_OUTPUT_HANDLE);"
        End If
      END IF

      FPRINT Outfile,Scoot$;"cls();"

    CASE "color"

      'IF NoMain = TRUE OR MakeDLL = TRUE THEN
      IF NoMain OR MakeDLL THEN
        Use_Console = TRUE
        FPRINT Outfile,"  hConsole = GetStdHandle (STD_OUTPUT_HANDLE);"
      END IF

      FPRINT Outfile,Scoot$;"color (";
      Stk$[++Ndx] = ");"
      CALL WriteCleanTokens(2,Ndx)

    CASE "textmode"
      RAW lszTmp$
      CALL BuildCleanStr(2, Ndx, lszTmp$)                 'allow size to be an expression
      FPRINT Outfile,Scoot$;"TextMode(";lszTmp$;");"

    CASE "delay"
      RAW lszTmp$
      CALL BuildCleanStr(2, Ndx, lszTmp$)                 ' Allow size to be an expression
      FPRINT Outfile,Scoot$;"Sleep(1000*";lszTmp$;");"

    CASE "write"
      FPRINT Outfile,Scoot$;PrintWriteFormat$(1)

    CASE ELSE
      CALL EmitOld(FuncRetnFlag)
  END SELECT
  FUNCTION = 0
END FUNCTION ' Emit_ConsoleOnlyProcs


$comment
FUNCTION Emit_TimeProces(sWord$, FuncRetnFlag AS PINT)
  CALL EmitOld(FuncRetnFlag)
  FUNCTION = 0
END FUNCTION ' Emit_TimeProces
$comment


FUNCTION Emit_ControlFlow(sWord$, FuncRetnFlag AS PINT)
  STATIC iFallThrough AS INT
  SELECT CASE sWord$

    CASE "exit"

      IF SelectState[PusherSelectState].CaseFlag THEN SelectState[PusherSelectState].NoBreak2 = TRUE
      RAW szL_Stk2$
      RAW iLoops1
      RAW iLoops2 = 0

      FOR iLoops1 = 2 TO Ndx
        IF Stk$[iLoops1] = "," THEN ITERATE
        szL_Stk2$ = LCASE$(Stk$[iLoops1])
        SELECT CASE szL_Stk2$
          CASE "sub"
            IF lc_COM_names_index > 0 THEN
              ' cleaning local COM objects if user forgot to call xxx = Nothing for each declared object
              CALL BCX_FreeLocalCOMObjects(FALSE)
            END IF

            ' Clean up dynamic strings
            IF LocalDynaCnt <> 0 THEN

              FOR INT j = 1 TO LocalDynaCnt
                FPRINT Outfile,Scoot$;DynaStr$[j]
              NEXT

            END IF
            ' Clean up dynamic strings arrays
            IF LocalDynArrCnt <> 0 THEN

              FOR INT i = 1 TO LocalDynArrCnt
                FPRINT Outfile,Scoot$;LocalDynArrName$[i]
                'cout << "34925" << endl
              NEXT

            END IF
            FPRINT Outfile,Scoot$;"return;"

          CASE "function"
            ' Clean up dynamic strings

            IF LocalDynaCnt <> 0 THEN

              FOR INT j = 1 TO LocalDynaCnt
                FPRINT Outfile,Scoot$;DynaStr$[j]
              NEXT

            END IF
            ' Clean up dynamic strings arrays
            IF LocalDynArrCnt <> 0 THEN

              FOR INT i = 1 TO LocalDynArrCnt
                FPRINT Outfile,Scoot$;LocalDynArrName$[i]
                'cout << "34946" << endl
              NEXT

            END IF
            FPRINT Outfile,Scoot$;"return 0;"

          CASE "for"
            RAW szGL$
            RAW i
            XFOR i = LoopTypeCnt-iLoops2 UNTIL LoopType[i].iLoopType = lt_FORNEXT OR i = 0 BY i-- : XNEXT
            IF i THEN
              IF i <> LoopTypeCnt-iLoops2 THEN
                IF TestState THEN CALL WarningID(eExitingMoreThan1Loop, 1)
              END IF
              iLoops2 = LoopTypeCnt - i + 1
              'FPRINT Outfile,Scoot$;"break; // FOR"
              IF iLoops1 = Ndx THEN CALL DoGoto(i, 1)
            ELSE
              sprintf(szGL,"No FOR to exit from. Inner most loop is %s",LoopTypeName$(LoopType[LoopTypeCnt].iLoopType))
              CALL Abort(szGL$)
            END IF

          CASE "xfor"
            RAW szGL$
            RAW i
            XFOR i = LoopTypeCnt-iLoops2 UNTIL LoopType[i].iLoopType = lt_FORXNEXT  OR i = 0 BY i-- : XNEXT
            IF i THEN
              IF i <> LoopTypeCnt-iLoops2 THEN
                IF TestState THEN CALL WarningID(eExitingMoreThan1Loop, 1)
              END IF
              iLoops2 = LoopTypeCnt - i + 1
              IF iLoops1 = Ndx THEN CALL DoGoto(i, 1)
            ELSE
              sprintf(szGL,"No XFOR to exit from. Inner most loop is %s",LoopTypeName$(LoopType[LoopTypeCnt].iLoopType))
              CALL Abort(szGL$)
            END IF

          CASE "do"
            RAW szGL$
            RAW i
            XFOR i = LoopTypeCnt-iLoops2 UNTIL LoopType[i].iLoopType = lt_DOLOOP OR LoopType[i].iLoopType = lt_DOUNTILLOOP OR LoopType[i].iLoopType = lt_DOWHILELOOP OR i = 0 BY i-- : XNEXT
            IF i THEN
              IF i <> LoopTypeCnt-iLoops2 THEN
                IF TestState THEN CALL WarningID(eExitingMoreThan1Loop, 1)
              END IF
              iLoops2 = LoopTypeCnt - i + 1
              IF iLoops1 = Ndx THEN CALL DoGoto(i, 1)
              'FPRINT Outfile,Scoot$;"break; // DO"
            ELSE
              sprintf(szGL,"No DO to exit from. Inner most loop is %s",LoopTypeName$(LoopType[LoopTypeCnt].iLoopType))
              CALL Abort(szGL$)
            END IF

          CASE "while"
            RAW szGL$
            RAW i
            XFOR i = LoopTypeCnt-iLoops2 UNTIL LoopType[i].iLoopType = lt_WHILEWEND  OR i = 0 BY i-- : XNEXT
            IF i THEN
              IF i <> LoopTypeCnt-iLoops2 THEN
                IF TestState THEN CALL WarningID(eExitingMoreThan1Loop, 1)
              END IF
              iLoops2 = LoopTypeCnt - i + 1
              IF iLoops1 = Ndx THEN CALL DoGoto(i, 1)
              '  FPRINT Outfile,Scoot$;"break; // WHILE"
            ELSE
              sprintf(szGL,"No WHILE to exit from. Inner most loop is %s",LoopTypeName$(LoopType[LoopTypeCnt].iLoopType))
              CALL Abort(szGL$)
            END IF

          CASE "select"
            RAW szGL$
            RAW i
            XFOR i = LoopTypeCnt-iLoops2 UNTIL LoopType[i].iLoopType = lt_SELECT  OR i = 0 BY i-- : XNEXT
            IF i THEN
              IF i <> LoopTypeCnt-iLoops2 THEN
                IF TestState THEN CALL WarningID(eExitingMoreThan1Loop, 1)
              END IF
              iLoops2 = LoopTypeCnt - i + 1
              IF iLoops1 = Ndx THEN CALL DoGoto(i, 1) : SelectState[PusherSelectState].CaseFlag++
              '  FPRINT Outfile,Scoot$;"break; // WHILE"
            ELSE
              sprintf(szGL,"No SELECT to exit from. Inner most loop is %s",LoopTypeName$(LoopType[LoopTypeCnt].iLoopType))
              CALL Abort(szGL$)
            END IF

          CASE "nest"
            RAW szGL$
            RAW i
            IF LoopTypeCnt = 0 THEN
              CALL Abort("To many end loops")
            END IF
            XFOR i = LoopTypeCnt-iLoops2 UNTIL LoopType[i].iLoopType <> LoopType[LoopTypeCnt-iLoops2].iLoopType BY i-- : XNEXT
            sprintf(szGL,"Exiting from nested control loops. Outer to inner control loops are %s",LoopTypeName$(LoopType[LoopTypeCnt].iLoopType))
            IF TestState THEN CALL Warning(szGL$, 1)
            ++i
            iLoops2 = LoopTypeCnt - i + 1
            IF iLoops1 = Ndx THEN CALL DoGoto(i, 1)

          CASE ELSE
            RAW szGL$
            'RAW i
            'XFOR i = LoopTypeCnt UNTIL LoopType[i].iLoopType = lt_SELECT BY i-- : XNEXT
            sprintf(szGL,"Exiting from unnamed control loop. Inner most control loop is %s",LoopTypeName$(LoopType[LoopTypeCnt].iLoopType))
            IF TestState THEN CALL Warning(szGL, 1)
            'CALL DoGoto(LoopTypeCnt, 1)
            IF iLoops1 = Ndx THEN CALL DoGoto(LoopTypeCnt-iLoops2, 1)
            iLoops2++
        END SELECT
      NEXT

    CASE "repeat"
      RAW lszTmp$
      lszTmp$ = ""

      FOR INT i = 2 TO Ndx
        CONCAT(lszTmp$, Stk$[i])
      NEXT

      lszTmp$ = Clean$(lszTmp$)

      CALL BumpUp

      IF INCHR(Stk$[2],"-") THEN
        IF LEFT$(lszTmp$,1) = "-" THEN lszTmp$ = MID$(lszTmp$,2)
        'FPRINT Outfile,Scoot$;"{register int BCX_REPEAT;"
        FPRINT Outfile,Scoot$;"{int BCX_REPEAT;"
        FPRINT Outfile,Scoot$;"for(BCX_REPEAT=";lszTmp$;";BCX_REPEAT>=1;BCX_REPEAT--)"
        FPRINT Outfile,Scoot$;"{"
      ELSE
        'FPRINT Outfile,Scoot$;"{register int BCX_REPEAT;"
        FPRINT Outfile,Scoot$;"{int BCX_REPEAT;"
        FPRINT Outfile,Scoot$;"for(BCX_REPEAT=1;BCX_REPEAT<=";lszTmp$;";BCX_REPEAT++)"
        FPRINT Outfile,Scoot$;"{"
      END IF
      CALL BumpUp

    CASE "endrepeat"

      CALL BumpDown("To many un-indends in REPEAT/END REPEAT")
      FPRINT Outfile,Scoot$;"}"
      FPRINT Outfile,Scoot$;"}"
      CALL BumpDown("To many un-indends in REPEAT/END REPEAT")

    CASE "while"

      CALL EmitIfCond((char*)"while", eFull,NULL)
      IF iDoWhile THEN
        LoopType[++LoopTypeCnt].iLoopType = iDoWhile
      ELSE
        LoopType[++LoopTypeCnt].iLoopType = lt_WHILEWEND
      END IF
      LoopType[LoopTypeCnt].iJumpTo = LabelGenerator++
      LoopType[LoopTypeCnt].szUseNeedLabel$ = ""
      iDoWhile = 0
      LoopType[LoopTypeCnt].iLoopLine = ModuleLineNos[ModuleNdx]
      CALL InBlockSet()

    CASE "wend", "endwhile"
      CALL InBlockReSet()

      IF LoopTypeCnt = 0 THEN
        CALL Abort("To many end loops")
      END IF

      IF LoopType[LoopTypeCnt].iLoopType <> lt_WHILEWEND THEN
        RAW sErr$
        sErr$ = LoopTypeName$(LoopType[LoopTypeCnt].iLoopType) + " at" + STR$(LoopType[LoopTypeCnt].iLoopLine) + " closed with WEND"
        Abort(sErr$)
      END IF

      CALL BumpDown("Error in Emit_ControlFlow() CASE wend, endwhile")
      FPRINT Outfile,Scoot$;"}"
      FPRINT Outfile,LoopType[LoopTypeCnt].szUseNeedLabel$
      LoopTypeCnt--
      CALL BumpDown("Extra un-indent(s) and/or missing indents in loop")

    CASE "prepend"
      CONST cPrependVarSize = 8
      GLOBAL PrependVar$[cPrependVarSize]
      GLOBAL PrependCnt

      PrependCnt++
      IF PrependCnt = cPrependVarSize THEN Abort("Prepend depth exceeded")
      CALL BuildDelimStr(2, Ndx, PrependVar$[PrependCnt])

    CASE "endprepend"
      PrependCnt--
      IF PrependCnt < 0 THEN CALL Abort("To many END PREPENDs.")

    CASE "with"
      CONST cWithVarSize = 8
      GLOBAL WithVar$[cWithVarSize]
      GLOBAL WithCnt

      WithCnt++
      IF WithCnt = cWithVarSize THEN Abort("[With] depth exceeded")
      CALL BuildStr(2, Ndx, WithVar$[WithCnt])
      'WithVar$[WithCnt] = WithVar$[WithCnt-1] + WithVar$[WithCnt]

    CASE "endwith"
    IF bcx_com_open_with_statement THEN
      IF bcx_com_open_with_statement > 1 THEN
        FPRINT Outfile,Scoot$;"bcx_preserve_dispatch_storage_index--;"
        FPRINT Outfile,Scoot$;"bcx_preserve_dispatch_at_offset = bcx_preserve_dispatch_storage[bcx_preserve_dispatch_storage_index];"
      ELSE
        FPRINT Outfile,Scoot$;"bcx_preserve_dispatch_at_offset = 0;"
        FPRINT Outfile,Scoot$;"bcx_preserve_dispatch_storage_index = 0;"
      END IF
      FPRINT Outfile,Scoot$;"bcx_reset_dispatch_chain(&";com_with_temp_str_name$;");"
      DECR bcx_com_open_with_statement
    ELSE
      WithCnt--
    END IF

    CASE "goto"
      IF SelectState[PusherSelectState].CaseFlag THEN SelectState[PusherSelectState].NoBreak2 = TRUE
      FPRINT Outfile,Scoot$;"goto ";UCASE$(Stk$[2]);";"

    CASE "gosub"
      Use_GoSub = TRUE
      FPRINT Outfile,Scoot$;"if (setjmp(GosubStack[GosubNdx++])==0)";
      FPRINT Outfile," goto ";UCASE$(Stk$[2]);";"

    CASE "return"
      Use_GoSub = TRUE
      FPRINT Outfile,Scoot$;"longjmp (GosubStack [--GosubNdx],1 );"
      FPRINT Outfile,""

    CASE "fallthrough"
      iFallThrough = TRUE

    CASE "case"
      IF SelectState[PusherSelectState].iStartCase = 0 THEN
        CALL InBlockReSet()
      END IF

      SelectState[PusherSelectState].iStartCase = 0
      CALL InBlockSet()

      FOR INT i = 2 TO Ndx

        IF Stk$[i] = "%" THEN Stk$[i] = " % "    ' Added by MrBCX 3.36
        IF Stk$[i] = "=" AND Stk$[i+1]="<" THEN Stk$[i] = "<=" : Stk$[i+1] = ""
        IF Stk$[i] = "!=" THEN Stk$[i] = "<>"
        IF Stk$[i] = "!" AND Stk$[i+1] = "=" THEN
          Stk$[i] = "<>" : Stk$[i+1] = ""
        END IF

        IF isalpha(Stk[i][0]) THEN
          CONCAT(Stk$[i]," ")
        END IF
      NEXT

      szTmp$ = ""

      Test = FALSE

      IF DataType(CaseVar$) = vt_STRVAR THEN Test = TRUE
      RAW i = 0
      FOR INT A = 2 TO Ndx
        IF INCHR("([",Stk$[A]) THEN i++
        IF INCHR(")]",Stk$[A]) THEN i--
        IF i THEN
          CONCAT(szTmp$, Stk$[A])
          ITERATE
        END IF

        IF Stk$[A] = "," THEN   ' comma
          IF NOT INCHR("<>=",Stk$[A+1]) THEN
            szTmp$ = szTmp$ + " or " + CaseVar$ + "="
          ELSE
            szTmp$ = szTmp$ + " or " + CaseVar$
          END IF
          Stk$[A] = ""
          ITERATE
        END IF

        IF Stk$[A] = "&&" THEN
          szTmp$ = szTmp$ + " and " + CaseVar$
          Stk$[A]= ""
        ELSEIF Stk$[A] = "||" THEN
          szTmp$ = szTmp$ + " or "  + CaseVar$
          Stk$[A]= ""
        ELSE
          CONCAT(szTmp$, Stk$[A])
        END IF
      NEXT
      RAW szDrop$
      szDrop$ = ""
      IF SelectState[PusherSelectState].CaseFlag = 0 THEN SelectState[PusherSelectState].NoBreak = 0
      IF SelectState[PusherSelectState].CaseFlag THEN
        RAW szGL$
        IF iFallThrough = FALSE THEN
          'IF ExitSubFunc THEN SelectState[PusherSelectState].CaseFlag--
          SelectState[PusherSelectState].CaseFlag--
          IF SelectState[PusherSelectState].NoBreak = 0 THEN
            IF SelectState[PusherSelectState].NoBreak2 = 0 THEN
              SelectState[PusherSelectState].CaseFlag++
              sprintf(szGL, "goto L%i;",SelectState[PusherSelectState].iJumpTo)
              FPRINT Outfile,Scoot$;szGL$
            END IF
          END IF
        ELSE
          sprintf(szDrop,"L%i",LabelGenerator)
          sprintf(szGL, "goto L%i;",LabelGenerator++)
          CONCAT(szDrop$,":")
          FPRINT Outfile,Scoot$;szGL$
          SelectState[PusherSelectState].CaseFlag--
        END IF
        CALL BumpDown("Extra un-indent(s) and/or missing indents in SELECT")
        FPRINT Outfile,Scoot$;"}"
        CALL BumpDown("Extra un-indent(s) and/or missing indents in SELECT")
      END IF

      SelectState[PusherSelectState].CaseFlag++

      IF iMatchLft(CaseVar$," BAND ") THEN
        SelectState[PusherSelectState].NoBreak = 1
        Src$ = "IF " + szTmp$ + CaseVar$ + " Then "
      ELSE
        IF INCHR("<>=",szTmp$) AND NOT IsQuoted(szTmp$) THEN
          Src$ = "IF " + CaseVar$ + szTmp$ + " Then "
        ELSE
          Src$ = "IF " + CaseVar$ + " = " + szTmp$ + " Then "
        END IF
      END IF

      CALL XFE(Src$)
      IF iFallThrough THEN CALL XFE(szDrop$) :
      iFallThrough = FALSE

    CASE "select"
      LoopType[++LoopTypeCnt].iLoopType = lt_SELECT
      LoopType[LoopTypeCnt].iJumpTo = LabelGenerator++
      CALL DoGoto(LoopTypeCnt, 0)
      LoopType[LoopTypeCnt].iLoopLine = ModuleLineNos[ModuleNdx]
      CALL BuildStr(3, Ndx, CaseVar$)
      CALL PushSelectState(CaseVar$)
      SelectState[PusherSelectState].iStartCase = 1
      SelectState[PusherSelectState].CaseFlag = 0
      SelectState[PusherSelectState].iJumpTo = LoopType[LoopTypeCnt].iJumpTo
      iFallThrough = FALSE

    CASE "caseelse"
      IF SelectState[PusherSelectState].iStartCase = 0 THEN
        CALL InBlockReSet()
      END IF

      CALL InBlockSet()
      SelectState[PusherSelectState].iStartCase = 0
      SelectState[PusherSelectState].CaseElseFlag = TRUE
      IF SelectState[PusherSelectState].CaseFlag THEN
        CALL BumpDown("Extra un-indent(s) and/or missing indents in SELECT")
        FPRINT Outfile,Scoot$;"}"
        CALL BumpDown("Extra un-indent(s) and/or missing indents in SELECT")
        FPRINT Outfile,Scoot$;"else // case else"
        CALL BumpUp
        FPRINT Outfile,Scoot$;"{"
        CALL BumpUp
      END IF

    CASE "endselect"
      IF SelectState[PusherSelectState].iStartCase = 0 THEN
        CALL InBlockReSet()
      END IF

      IF LoopTypeCnt = 0 THEN
        Abort("To many end loops")
      END IF

      IF LoopType[LoopTypeCnt--].iLoopType <> lt_SELECT THEN
        RAW sErr$
        sErr$ = LoopTypeName$(LoopType[LoopTypeCnt+1].iLoopType) + " at" + STR$(LoopType[LoopTypeCnt+1].iLoopLine) + " closed with END SELECT"
        Abort(sErr$)
      END IF

      IF SelectState[PusherSelectState].CaseFlag = 0 THEN
        IF SelectState[PusherSelectState].CaseElseFlag = 0 THEN
          CALL Abort("Missing case statement before select end")
        ELSE
          CALL Abort("Missing case statement before case else")
        END IF
      END IF

      CALL BumpDown("Extra un-indent(s) and/or missing indents in SELECT")
      FPRINT Outfile,Scoot$;"}"
      CALL BumpDown("Extra un-indent(s) and/or missing indents in SELECT")
      IF SelectState[PusherSelectState].CaseFlag > 1 THEN
        RAW szGL$
        sprintf(szGL, "L%i:;",SelectState[PusherSelectState].iJumpTo)
'jcfuller I think this is one Wayne missed
        'FPRINT Outfile,szGL$;" // SelectState[PusherSelectState].CaseFlag";SelectState[PusherSelectState].CaseFlag
        FPRINT Outfile,szGL$
      END IF
      SelectState[PusherSelectState].NoBreak2 = SelectState[PusherSelectState].CaseElseFlag = 0
      CALL PopSelectState(CaseVar$)

    CASE "for"
      IF iMatchWrd(Stk$[2],"each") THEN ' "each" becomes reserved keyword

        ' beginning of for each - collections support
        RAW foreachlocal$
        RAW temp_parms$
        RAW ComVar$

        ComVar$ = Stk$[3]

        Use_COM_Collections = Use_COM = TRUE
        FPRINT Outfile, Scoot$;"VariantClear(&bcx_sys_temp_ack_var);"
        FPRINT Outfile, Scoot$;"bcx_sys_temp_enum_var = NULL;"
        FPRINT Outfile, Scoot$;"bcx_sys_temp_long_coll = 0;"
        IF NOT IsVariableComObject(ComVar$) THEN FPRINT Outfile, Scoot$;"OBJECT ", ComVar$, ";"
        FPRINT Outfile, Scoot$;"ZeroMemory((PVOID)&", ComVar$, ",sizeof(OBJECT));"
        LoopLocalVar[LoopLocalCnt++] = 0
        bcx_get_com_enumerator = TRUE
        foreachlocal$ = MID$(Src$,INSTR(Src$," in ",1,1) + 3)
        IF NOT IsVariableComObject(ComVar$) THEN Add_COM_Local_Variable(ComVar$)

        IF INCHR(foreachlocal$,".") THEN
          BCX_COM_Parse_GetProperty("bcx_sys_temp_ack_var", foreachlocal$)
          temp_parms$ = TRIM$(EXTRACT$(foreachlocal$, "."))
        ELSE
          temp_parms$ = TRIM$(foreachlocal$)
        END IF
        bcx_get_com_enumerator = FALSE

        FPRINT Outfile,Scoot$;"bcx_com_get_enumerator_intf = TRUE;"
        FPRINT Outfile,Scoot$;"bcx_invoke_helper(&", temp_parms$,", L", DDQ$ ,",DISPATCH_PROPERTYGET|DISPATCH_METHOD, &bcx_sys_temp_ack_var);"
        FPRINT Outfile,Scoot$;"bcx_reset_dispatch_chain(&", temp_parms$ , ");"
        FPRINT Outfile,Scoot$;"bcx_com_get_enumerator_intf = FALSE;"

        FPRINT Outfile,Scoot$;"for(;;) { // for each construction ..."
        CALL BumpUp()
        FPRINT Outfile,Scoot$;"if (FAILED(bcx_last_com_HRESULT)) {"
        FPRINT Outfile,Scoot$;"  bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("Get object enumerator failed! Collections unavailable!"),"));"
        FPRINT Outfile,Scoot$;"  break;"
        FPRINT Outfile,Scoot$;"} "

        FPRINT Outfile,Scoot$;"if (bcx_sys_temp_ack_var.vt != VT_DISPATCH && bcx_sys_temp_ack_var.vt != VT_UNKNOWN) {"
        FPRINT Outfile,Scoot$;"  bcx_last_com_HRESULT = E_NOINTERFACE;"
        FPRINT Outfile,Scoot$;"  bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("Enumerations interface not available! Collections unavailable!"),"));"
        FPRINT Outfile,Scoot$;"  VariantClear(&bcx_sys_temp_ack_var);"
        FPRINT Outfile,Scoot$;"  break;"
        FPRINT Outfile,Scoot$;"} "

        FPRINT Outfile,Scoot$;"if (bcx_sys_temp_ack_var.vt == VT_DISPATCH) {"
        CALL BumpUp()
        FPRINT Outfile,Scoot$;"#ifdef __cplusplus"
        FPRINT Outfile,Scoot$;"  bcx_last_com_HRESULT = bcx_sys_temp_ack_var.pdispVal->QueryInterface(IID_IEnumVARIANT, (void **)&bcx_sys_temp_enum_var);"
        FPRINT Outfile,Scoot$;"#else"
        FPRINT Outfile,Scoot$;"  bcx_last_com_HRESULT = bcx_sys_temp_ack_var.pdispVal->lpVtbl->QueryInterface(bcx_sys_temp_ack_var.pdispVal, &IID_IEnumVARIANT, (void **)&bcx_sys_temp_enum_var);"
        FPRINT Outfile,Scoot$;"#endif"
        FPRINT Outfile,Scoot$;"if (FAILED(bcx_last_com_HRESULT)) {"
        FPRINT Outfile,Scoot$;"  bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("QueryInterface: Get enum variant failed! Collections unavailable!"),"));"
        FPRINT Outfile,Scoot$;"  VariantClear(&bcx_sys_temp_ack_var);"
        FPRINT Outfile,Scoot$;"  break;"
        FPRINT Outfile,Scoot$;"} "
        CALL BumpDown("")
        FPRINT Outfile,Scoot$;"} else if (bcx_sys_temp_ack_var.vt == VT_UNKNOWN) {"
        CALL BumpUp()
        FPRINT Outfile,Scoot$;"#ifdef __cplusplus"
        FPRINT Outfile,Scoot$;"  bcx_last_com_HRESULT = bcx_sys_temp_ack_var.punkVal->QueryInterface(IID_IEnumVARIANT, (void **)&bcx_sys_temp_enum_var);"
        FPRINT Outfile,Scoot$;"#else"
        FPRINT Outfile,Scoot$;"  bcx_last_com_HRESULT = bcx_sys_temp_ack_var.punkVal->lpVtbl->QueryInterface(bcx_sys_temp_ack_var.punkVal, &IID_IEnumVARIANT, (void **)&bcx_sys_temp_enum_var);"
        FPRINT Outfile,Scoot$;"#endif"
        FPRINT Outfile,Scoot$;"if (FAILED(bcx_last_com_HRESULT)) {"
        FPRINT Outfile,Scoot$;"  bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("QueryInterface: Get enum variant failed! Collections unavailable!"),"));"
        FPRINT Outfile,Scoot$;"  VariantClear(&bcx_sys_temp_ack_var);"
        FPRINT Outfile,Scoot$;"  break;"
        FPRINT Outfile,Scoot$;"} "
        CALL BumpDown("")
        FPRINT Outfile,Scoot$;"} "
        FPRINT Outfile,Scoot$;"VariantClear(&bcx_sys_temp_ack_var);"
        FPRINT Outfile,Scoot$;"break;"
        FPRINT Outfile,Scoot$;"} // loop"

        FPRINT Outfile,Scoot$;"  while(bcx_sys_temp_enum_var) {"
        FPRINT Outfile,Scoot$;"    BCX_SetNothing(&";ComVar$;");"
        FPRINT Outfile,Scoot$;"  #ifdef __cplusplus"
        FPRINT Outfile,Scoot$;"    bcx_last_com_HRESULT = bcx_sys_temp_enum_var->Next(1, &";ComVar$;".pObjects[0], &bcx_sys_temp_long_coll);"
        FPRINT Outfile,Scoot$;"  #else"
        FPRINT Outfile,Scoot$;"    bcx_last_com_HRESULT = bcx_sys_temp_enum_var->lpVtbl->Next(bcx_sys_temp_enum_var, 1, &";ComVar$;".pObjects[0], &bcx_sys_temp_long_coll);"
        FPRINT Outfile,Scoot$;"  #endif"
        FPRINT Outfile,Scoot$;"  if (FAILED(bcx_last_com_HRESULT)) {"
        FPRINT Outfile,Scoot$;"    bcx_catch_hr_error_desc(bcx_last_com_HRESULT, _T(", ENC$("Enumeration failed! Collections unavailable!"),"));"
        FPRINT Outfile,Scoot$;"    #ifdef __cplusplus"
        FPRINT Outfile,Scoot$;"     if(bcx_sys_temp_enum_var) bcx_sys_temp_enum_var->Release();"
        FPRINT Outfile,Scoot$;"    #else"
        FPRINT Outfile,Scoot$;"     if(bcx_sys_temp_enum_var) bcx_sys_temp_enum_var->lpVtbl->Release(bcx_sys_temp_enum_var);"
        FPRINT Outfile,Scoot$;"    #endif"
        FPRINT Outfile,Scoot$;"    bcx_sys_temp_enum_var = NULL;"
        FPRINT Outfile,Scoot$;"    break;"
        FPRINT Outfile,Scoot$;"  } "

        FPRINT Outfile,Scoot$;"  if (";ComVar$;".pObjects[0].vt != VT_DISPATCH) {"
        FPRINT Outfile,Scoot$;"    VariantClear(&";ComVar$;".pObjects[0]);"
        FPRINT Outfile,Scoot$;"    bcx_sys_temp_long_coll = 0;"
        FPRINT Outfile,Scoot$;"  } else { "
        FPRINT Outfile,Scoot$;"  ", ComVar$, ".pStatus = TRUE;"
        FPRINT Outfile,Scoot$;"  ", ComVar$, ".ipointer = 0;"
        FPRINT Outfile,Scoot$;"  bcx_ole_objects_count++;"
        FPRINT Outfile,Scoot$;"  }"

        FPRINT Outfile,Scoot$;"  if (bcx_sys_temp_long_coll == 0) {"
        FPRINT Outfile,Scoot$;"  #ifdef __cplusplus"
        FPRINT Outfile,Scoot$;"   if(bcx_sys_temp_enum_var) bcx_sys_temp_enum_var->Release();"
        FPRINT Outfile,Scoot$;"  #else"
        FPRINT Outfile,Scoot$;"   if(bcx_sys_temp_enum_var) bcx_sys_temp_enum_var->lpVtbl->Release(bcx_sys_temp_enum_var);"
        FPRINT Outfile,Scoot$;"  #endif"
        FPRINT Outfile,Scoot$;"  BCX_SetNothing(&";ComVar$;");"
        FPRINT Outfile,Scoot$;"  bcx_sys_temp_enum_var = NULL;"
        FPRINT Outfile,Scoot$;"  break;"
        FPRINT Outfile,Scoot$;"  }"
        CALL BumpUp()

      ELSE ' this is "Normal" For - Next Loop
        DIM RAW FFlg = 0
        DIM RAW For1 = 0
        DIM RAW For2 = 0
        DIM RAW For3 = 0
        DIM RAW For4 = 0
        DIM RAW Reg$, xxx$, yyy$, zzz$, qqq$

        Reg$ = ""
        xxx$ = ""
        yyy$ = ""
        zzz$ = ""
        qqq$ = ""

        '******************************************************
        FOR INT i = Ndx TO 1 STEP -1
          IF iMatchWrd(Stk$[i],"step") THEN
            FFlg = TRUE
            EXIT FOR
          END IF
        NEXT

        IF NOT FFlg THEN
          Ndx++
          Stk$[Ndx] = "step"
          Ndx++
          Stk$[Ndx] = "1"
        END IF
        '******************************************************
        Test = FALSE

        FOR INT i = 1 TO Ndx
          IF Stk$[i]= "=" THEN Test = TRUE
        NEXT

        IF Test = FALSE THEN Abort("Missing =")
        '******************************************************
        Test = FALSE

        FOR INT i = 1 TO Ndx
          IF iMatchWrd(Stk$[i],"to") THEN Test = TRUE
        NEXT

        IF Test = FALSE THEN Abort("Missing TO")
        '******************************************************

        Reg$ = LCASE$(Stk$[2])

        SELECT CASE Reg$
          CASE "int","fint"
            Reg$ = SPC$
            LoopLocalVar[LoopLocalCnt++] = 1
            'FPRINT Outfile,Scoot$;"  {register int ";
            FPRINT Outfile,Scoot$;"  {int ";

          CASE "long"
            Reg$ = SPC$
            LoopLocalVar[LoopLocalCnt++] = 1
            'FPRINT Outfile,Scoot$;"  {register long ";
            FPRINT Outfile,Scoot$;"  {long ";

          CASE "single", "float"
            Reg$ = SPC$
            LoopLocalVar[LoopLocalCnt++] = 1
            FPRINT Outfile,Scoot$;"  {float ";

          CASE "double"
            Reg$ = SPC$
            LoopLocalVar[LoopLocalCnt++] = 1
            FPRINT Outfile,Scoot$;"  {double ";

          CASE "ldouble"
            Reg$ = SPC$
            LoopLocalVar[LoopLocalCnt++] = 1
            FPRINT Outfile,Scoot$;"  {LDOUBLE ";

          CASE ELSE
            Reg$ = ""
            LoopLocalVar[LoopLocalCnt++] = 0
        END SELECT

        IF LEN(Reg$) THEN
          FOR INT j = 3 TO Ndx
            Stk$[j-1] = Stk$[j]
          NEXT
          Ndx--
        END IF

        '******************************************************
        ' Every statement now conforms to the following:
        ' FOR xxx = yyy TO zzz STEP qqq
        '******************************************************

        FOR INT i = 2 TO Ndx
          IF Stk$[i] = "=" THEN
            For1 = i-1       'xxx spans from Stk$[2] to Stk$[For1]
            EXIT FOR
          END IF
        NEXT

        FOR INT i = For1+2 TO Ndx
          IF iMatchWrd(Stk$[i],"to") THEN
            For2 = i-1       'yyy spans from Stk$[For1+2] to Stk$[For2]
            EXIT FOR
          END IF
        NEXT

        FOR INT i = For2+2 TO Ndx
          IF iMatchWrd(Stk$[i],"step") THEN
            For3 = i-1       'zzz spans from Stk$[For2+2] to Stk$[For3]
            EXIT FOR
          END IF
        NEXT

        For4 = For3+2        'qqq spans from Stk$[For4] to Stk$[Ndx]

        CALL BuildCleanStr(2, For1, xxx$)
        CALL BuildCleanStr(For1+2, For2, yyy$)
        CALL BuildCleanStr(For2+2, For3, zzz$)
        CALL BuildCleanStr(For4, Ndx, qqq$)

        IF Reg$ = SPC$ THEN FPRINT Outfile, xxx$, ";"
        Reg$ = ""

        IF IsNumberEx (qqq$) THEN
          IF LEFT$(qqq$,1) = "-" THEN
            FPRINT Outfile,Scoot$;"for(", Reg$, xxx$, "=", yyy$, "; ", xxx$, ">=" , zzz$, "; " , xxx$, "+=" , qqq$, ")"
          ELSE
            FPRINT Outfile,Scoot$;"for(", Reg$, xxx$, "=", yyy$, "; ", xxx$, "<=" , zzz$, "; " , xxx$, "+=" , qqq$, ")"
          END IF
        ELSE
          FPRINT Outfile,Scoot$;"for(", Reg$, xxx$, "=", yyy$, "; ", qqq$, ">=0 ? ", xxx$, "<=" , zzz$, " : ", xxx$, ">=", zzz$, "; " , xxx$, "+=" , qqq$, ")"
        END IF

        CALL BumpUp
        FPRINT Outfile,Scoot$;"{"
        CALL BumpUp
      END IF
      LoopType[++LoopTypeCnt].iLoopType = lt_FORNEXT
      LoopType[LoopTypeCnt].iJumpTo = LabelGenerator++
      LoopType[LoopTypeCnt].szUseNeedLabel$ = ""
      LoopType[LoopTypeCnt].iLoopLine = ModuleLineNos[ModuleNdx]
      CALL InBlockSet()

    CASE "next"
      CALL InBlockReSet()

      IF LoopTypeCnt = 0 THEN
        Abort("To many end loops")
      END IF

      IF LoopType[LoopTypeCnt].iLoopType <> lt_FORNEXT THEN
        RAW sErr$
        sErr$ = LoopTypeName$(LoopType[LoopTypeCnt].iLoopType) + " at" + STR$(LoopType[LoopTypeCnt].iLoopLine) + " closed with NEXT"
        Abort(sErr$)
      END IF

      CALL BumpDown("Extra un-indent(s) and/or missing indents in FOR/NEXT")
      FPRINT Outfile,Scoot$;"}"
      IF LoopLocalVar[--LoopLocalCnt] THEN FPRINT Outfile,Scoot$;"}"
      FPRINT Outfile,LoopType[LoopTypeCnt].szUseNeedLabel$
      LoopTypeCnt--
      IF LoopLocalCnt < 0 THEN Abort ("Next without For")
      CALL BumpDown("Extra un-indent(s) and/or missing indents in FOR/NEXT")

    CASE "beginblock"
      CALL InBlockSet()
      FPRINT Outfile,Scoot$;"{"
      CALL BumpUp()

    CASE "endblock"
      CALL InBlockReSet()
      CALL BumpDown("Extra un-indent(s) and/or missing indents in BLOCK/END BLOCK")
      FPRINT Outfile,Scoot$;"}"

    CASE "call"
      RAW lszTmp$
      BuildCleanStr(2, Ndx, lszTmp$)
      IF NOT iMatchRgt(lszTmp$,")") THEN
        CONCAT(lszTmp$,  "()")
      END IF
      CONCAT(lszTmp$,  ";")
      FPRINT Outfile,Scoot$;lszTmp$

    CASE "continue"
      FPRINT Outfile,Scoot$;"continue;"

    CASE "end"
      IF Ndx = 1 THEN
        InsertTokens(1,2,"=","0")
      END IF

      IF Stk$[2] = "=" THEN
        IF Use_Wingui = FALSE THEN
          FPRINT Outfile,Scoot$;"fflush(stdout);"
        END IF
        'FPRINT Outfile,Scoot$;"ExitProcess(";
        FPRINT Outfile,Scoot$;"exit(";
        Stk$[++Ndx] = ");"
        CALL WriteCleanTokens(3,Ndx)
        EXIT SELECT
      END IF

      IF iMatchWrd(Stk$[2],"if") THEN
        CALL BumpDown("Extra un-indent(s) and/or missing indents in IF/END IF")
        FPRINT Outfile,Scoot$;"}"
        CALL BumpDown("Extra un-indent(s) and/or missing indents in IF/END IF")
        EXIT SELECT
      END IF

    CASE "endif"
      CALL BumpDown("Extra un-indents at ENDIF")
      FPRINT Outfile,Scoot$;"}"
      CALL BumpDown("Extra un-indents at ENDIF")

    CASE "endprogram"               'Force END of main- allow inclusions outside of main
      FPRINT Outfile,"return 0;         /* End of main program */"
      FPRINT Outfile,"}\n\n"
      EndOfProgram = 1

    CASE "if"
      CALL EmitIfCond((char*)"if", eFull,NULL)

    CASE "else"
      CALL BumpDown("Extra un-indent(s) and/or missing indents in IF/END IF")
      FPRINT Outfile,Scoot$;"}"
      CALL BumpDown("Extra un-indent(s) and/or missing indents in IF/END IF")
      FPRINT Outfile,Scoot$;"else"
      CALL BumpUp
      FPRINT Outfile,Scoot$;"{"
      CALL BumpUp

    CASE "elseif"
      CALL BumpDown("Extra un-indent(s) and/or missing indents in IF/END IF")
      FPRINT Outfile,Scoot$;"}"
      CALL BumpDown("Extra un-indent(s) and/or missing indents in IF/END IF")
      CALL EmitIfCond((char*)"else if", eFull,NULL)

    CASE "xfor"    ' XFOR ... WHILE/UNTILL ... BY ...
      RAW Ndx2
      RAW iPB
      RAW iBy    = 0
      RAW iLast
      RAW iUntil = 0
      RAW iWhile = 0
      RAW Stak$[128]
      RAW sClose$
      RAW szType$

      ' Basic syntax check
      FOR INT ii = 2 TO Ndx
        IF iMatchWrd(Stk$[ii],"while") THEN iWhile = ii
        IF iMatchWrd(Stk$[ii],"until") THEN iUntil = ii
        IF iMatchWrd(Stk$[ii],"by") THEN iBy = ii
      NEXT

      IF iWhile = 0 AND iUntil = 0 THEN CALL Abort("Missing WHILE or UNTIL in XFOR")
      IF iWhile AND iUntil THEN CALL Abort("Can't have both WHILE and UNTIL in XFOR")
      IF iBy = 0 THEN CALL Abort("Missing BY in XFOR")

      iLast = iWhile + iUntil
      szType$ = ""
      IF iLast > 2 THEN   ' Have initializers
        RAW i = 2
        RAW j = 3
        DO
          WHILE Stk$[j] <> "=" : j++ : WEND
          IF j - i > 1 THEN
            IF szType$ <> "" THEN CONCAT(szType$, ": RAW ")
            CONCAT(szType$, Stk$[j-1])
            CONCAT(szType$, " AS")
            WHILE i < j-1
              CONCAT(szType$, " ")
              CONCAT(szType$, Stk$[i])
              Stk$[i++] = ""
            WEND
          END IF
          i = j + 1

          iPB = 0
          WHILE i <= iLast
            IF Stk$[i] = "(" THEN iPB++
            IF Stk$[i] = ")" THEN iPB--
            IF Stk$[i] = "[" THEN iPB++
            IF Stk$[i] = "]" THEN iPB--
            IF iPB = 0 AND Stk$[i] = "," THEN EXIT WHILE
            i++
          WEND
          i++
          j = i + 1
        LOOP UNTIL i >= iLast
      END IF
      Stak$[1] = "for("
      sClose$ = ";"
      RAW j = 2
      RAW i = 2
      WHILE i <= Ndx
        IF Stk$[i] <> "" THEN
          IF iMatchWrd(Stk$[i],"while") THEN Stk$[i] = ";" : iLast = j
          IF iMatchWrd(Stk$[i],"until") THEN Stk$[i] = ";!(" : sClose$ = ");" : iLast = j
          IF iMatchWrd(Stk$[i],"by") THEN Stk$[i] = sClose$ : iBy = j
          Stak$[j] = Stk$[i]
          j++
        END IF
        i++
      WEND
      Ndx2 = j-1
      IF szType$ <> "" THEN
        CALL BumpUp
        FPRINT Outfile,Scoot$;"{"
        CALL InBlockSet()
        szType$ = "RAW " + szType$
        LoopLocalVar[LoopLocalCnt++] = 1
        i = INSTR(szType$, ": RAW ")
        WHILE i
          Src$ = LEFT$(szType$,i-1)
          szType$ = MID$(szType$,i+2)
          PassOne = TRUE
          CALL XFE(Src$)
          i = INSTR(szType$, ": RAW ")
        WEND
        Src$ = szType$
        PassOne = TRUE
        CALL XFE(Src$)
      ELSE
        LoopLocalVar[LoopLocalCnt++] = 0
      END IF

      Stk$[1] = "while"
      FOR INT k = iLast+1 TO iBy-1
        Stk$[k-iLast+1] = Stak$[k]
      NEXT

      Ndx = iBy-iLast
      Stk$[Ndx+1] = ""

      FPRINT Outfile,Scoot$;
      FOR INT k = 1 TO Ndx2
        IF k <= iLast OR k >= iBy THEN
          FPRINT Outfile,Stak$[k];
        END IF
        IF k = iLast THEN
          CALL EmitIfCond((char*)"while", ePart,NULL)
        END IF
      NEXT

      FPRINT Outfile,")"
      CALL BumpUp
      FPRINT Outfile,Scoot$;"{"
      CALL BumpUp
      LoopType[++LoopTypeCnt].iLoopType = lt_FORXNEXT
      LoopType[LoopTypeCnt].iJumpTo = LabelGenerator++
      LoopType[LoopTypeCnt].szUseNeedLabel$ = ""
      LoopType[LoopTypeCnt].iLoopLine = ModuleLineNos[ModuleNdx]
      CALL InBlockSet()

    CASE "xnext"
      CALL InBlockReSet()

      IF LoopTypeCnt = 0 THEN
        Abort("To many end loops")
      END IF

      IF LoopType[LoopTypeCnt].iLoopType <> lt_FORXNEXT THEN
        RAW sErr$
        sErr$ = LoopTypeName$(LoopType[LoopTypeCnt].iLoopType) + " at" + STR$(LoopType[LoopTypeCnt].iLoopLine) + " closed with NEXT"
        Abort(sErr$)
      END IF

      CALL BumpDown("Extra un-indent(s) and/or missing indents in XFOR/XNEXT")
      FPRINT Outfile,Scoot$;"}"
      IF LoopLocalVar[--LoopLocalCnt] THEN CALL InBlockReSet(): FPRINT Outfile,Scoot$;"}" : CALL BumpDown("Extra un-indent(s) and/or missing indents in XFOR/XNEXT")
      FPRINT Outfile,LoopType[LoopTypeCnt].szUseNeedLabel$
      LoopTypeCnt--
      IF LoopLocalCnt < 0 THEN Abort ("XNEXT without XFOR")
      CALL BumpDown("Extra un-indent(s) and/or missing indents in XFOR/XNEXT")

    CASE "do"
      CALL InBlockSet()

      IF iDoWhile THEN
        LoopType[++LoopTypeCnt].iLoopType = iDoWhile
      ELSE
        LoopType[++LoopTypeCnt].iLoopType = lt_DOLOOP
      END IF
      LoopType[LoopTypeCnt].iJumpTo = LabelGenerator++
      LoopType[LoopTypeCnt].szUseNeedLabel$ = ""
      iDoWhile = 0

      LoopType[LoopTypeCnt].iLoopLine = ModuleLineNos[ModuleNdx]
      FPRINT Outfile,Scoot$;"for(;;)"
      CALL BumpUp
      FPRINT Outfile,Scoot$;"{"
      CALL BumpUp

    CASE "loop"
      CALL InBlockReSet()

      IF LoopTypeCnt = 0 THEN
        Abort("To many end loops")
      END IF

      IF iLoopCond THEN
        IF LoopType[LoopTypeCnt].iLoopType <> lt_DOLOOP THEN
          RAW sErr$
          sErr$ = LoopTypeName$(LoopType[LoopTypeCnt].iLoopType) + " at" + STR$(LoopType[LoopTypeCnt].iLoopLine) + " closed with LOOP CONDITION"
          Abort(sErr$)
        END IF
      END IF

      iLoopCond = 0

      CALL BumpDown("Extra un-indent(s) and/or missing indents in DO/LOOP")
      FPRINT Outfile,Scoot$;"}"
      FPRINT Outfile,LoopType[LoopTypeCnt].szUseNeedLabel$
      LoopTypeCnt--
      CALL BumpDown("Extra un-indent(s) and/or missing indents in DO/LOOP")

    CASE ELSE
      CALL EmitOld(FuncRetnFlag)
  END SELECT
  FUNCTION = 0
END FUNCTION ' Emit_ControlFlow


$comment
FUNCTION Emit_ThreadProcs(sWord$, FuncRetnFlag AS PINT)
  CALL EmitOld(FuncRetnFlag)
  FUNCTION = 0
END FUNCTION ' Emit_ThreadProcs
$comment

$comment
FUNCTION Emit_HardwareProcs(sWord$, FuncRetnFlag AS PINT)
  CALL EmitOld(FuncRetnFlag)
  FUNCTION = 0
END FUNCTION ' Emit_HardwareProcs
$comment


FUNCTION Emit_KeyboardProcs(sWord$, FuncRetnFlag AS PINT)
  SELECT CASE sWord$

    CASE "input"
      CALL EmitInputCode()

    CASE ELSE
      CALL EmitOld(FuncRetnFlag)

  END SELECT
  FUNCTION = 0
END FUNCTION ' Emit_KeyboardProcs



FUNCTION Emit_ArrayProcs(sWord$, FuncRetnFlag AS PINT)
  SELECT CASE sWord$

    CASE "qsortidx"          'qsortidx idx, size_of_array, A$, key
      UseFlag = TRUE
      RAW lszTmp$
      Var$ = Clean$(Stk$[2])             'index array
      BuildCleanStr(4, Ndx-4, lszTmp$)   'allow size to be an expression

      FPRINT Outfile,Scoot$;"Key = ",Stk[Ndx],";"

      IF Var$ <> "0" THEN
        'FPRINT Outfile,Scoot$;"register int iDx;"
        FPRINT Outfile,Scoot$;"int iDx;"
        FPRINT Outfile,Scoot$;"for(iDx=0; iDx<",lszTmp$,"; iDx+=1) ";
        FPRINT Outfile, Var$,"[iDx]=iDx;"
      END IF

      IF NOT INCHR(Stk$[Ndx-2],".") THEN   'Check if this is a struct sort
        Use_Idxqsort = TRUE
        FPRINT Outfile,Scoot$;"pppStr = ",Clean$(Stk[Ndx-2]),";"
        FPRINT Outfile,Scoot$;"qsort(";Var$;",";lszTmp$;",sizeof(int),IdxCompare);"
      ELSE
        RAW Stptr$, StMem$, StName$
        RAW i

        StMem$ = REMAIN$(Clean$(Stk$[Ndx-2]),".")
        Stptr$ = EXTRACT$(Stk$[Ndx-2],".")

        IF CheckLocal(Stptr,&i) <> vt_UNKNOWN THEN
          StName$ = TypeDefs[LocalVars[i].VarDef].VarName$
        ELSE
          IF CheckGlobal(Stptr,&i) <> vt_UNKNOWN THEN
            StName$ = TypeDefs[GlobalVars[i].VarDef].VarName$
          END IF
        END IF

        IF Var$ <> "0" THEN
          Use_IdxqsortSt = TRUE
          FPRINT Outfile,Scoot$;"cmp1 =(char*)(",Stptr$ ,") + offsetof(",StName$,",",StMem$,");"
          FPRINT Outfile,Scoot$;"StructSize = sizeof(",StName$,");"
          FPRINT Outfile,Scoot$;"qsort(",Var$;",",lszTmp$,",sizeof(int),IdxCompareSt);"
        ELSE
          Use_PtrqsortSt = TRUE
          FPRINT Outfile,Scoot$;"OffSet = offsetof(",StName$,",",StMem$,");"
          FPRINT Outfile,Scoot$;"qsort(",Stptr$;",",lszTmp$,",sizeof(",StName$,"),PtrCompareSt);"
        END IF
      END IF


    CASE "qsort"    'qsort [dynamic] A$,size_of_array[,ascending|descending][,NATURAL]
      RAW QST=0
      RAW order=0
      RAW lszTmp$
      RAW vt
      RAW iAlphaNumeric = FALSE

      UseFlag = TRUE

      IF iMatchWrd(Stk$[2],"dynamic") THEN
        QST = TRUE
        CALL DeleteTokens(2, 1)
      END IF

      IF LCASE$(Stk$[Ndx])= "natural" THEN
        iAlphaNumeric = Use_AlphaNumeric = TRUE
        Ndx--
        Ndx--
      END IF

      IF LCASE$(Stk$[Ndx])= "ascending"  THEN
        order = 2
        Ndx--
        Ndx--
      END IF

      IF LCASE$(Stk$[Ndx])= "descending" THEN
        order = 1
        Ndx--
        Ndx--
      END IF

      IF order = 0 THEN order = 2      'default to ascending
      CALL BuildStr(4, Ndx, lszTmp$)                 'allow size to be an expression
      Var$ = Clean$(Stk$[2])
      vt = DataType(Stk$[2])

      IF vt <> vt_STRVAR AND vt <> vt_INTEGER AND vt <> vt_SINGLE AND vt <> vt_DOUBLE THEN
        vt = CheckType(Stk$[2])
      END IF

      FPRINT Outfile,Scoot$;"qsort(";Var$;",";Clean$(lszTmp$);

      SELECT CASE vt

        CASE vt_STRVAR
          IF NOT QST THEN
            IF order = 1 THEN
              IF iAlphaNumeric THEN
                FPRINT Outfile,",sizeof(";Var$;"[0]),AlphaNumericD);"
                Use_AlphaNumericD = TRUE
              ELSE
                FPRINT Outfile,",sizeof(";Var$;"[0]),StrCompareD);"
                Use_Strqsortd = TRUE
              END IF
            ELSE
              IF iAlphaNumeric THEN
                FPRINT Outfile,",sizeof(";Var$;"[0]),AlphaNumericA);"
                Use_AlphaNumericA = TRUE
              ELSE
                FPRINT Outfile,",sizeof(";Var$;"[0]),StrCompareA);"
                Use_Strqsorta = TRUE
              END IF
            END IF
          ELSE
            IF order = 1 THEN
              IF iAlphaNumeric THEN
                FPRINT Outfile,",sizeof(";Var$;"[0]),DynAlphaNumericD);"
                Use_DynAlphaNumericD = TRUE
              ELSE
                FPRINT Outfile,",sizeof(";Var$;"[0]),DynStrCompareD);"
                Use_DynStrqsortd = TRUE
              END IF
            ELSE
              IF iAlphaNumeric THEN
                FPRINT Outfile,",sizeof(";Var$;"[0]),DynAlphaNumericA);"
                Use_DynAlphaNumericA = TRUE
              ELSE
                FPRINT Outfile,",sizeof(";Var$;"[0]),DynStrCompareA);"
                Use_DynStrqsorta = TRUE
              END IF
            END IF
          END IF

        CASE vt_INTEGER
          IF order = 1 THEN
            FPRINT Outfile,",sizeof(int),NumCompareDint);"
            Use_Numqsortdint = TRUE
          ELSE
            FPRINT Outfile,",sizeof(int),NumCompareAint);"
            Use_Numqsortaint = TRUE
          END IF

        CASE vt_SINGLE
          IF order = 1 THEN
            FPRINT Outfile,",sizeof(float),NumCompareDfloat);"
            Use_Numqsortdfloat = TRUE
          ELSE
            FPRINT Outfile,",sizeof(float),NumCompareAfloat);"
            Use_Numqsortafloat = TRUE
          END IF

        CASE vt_DOUBLE
          IF order = 1 THEN
            FPRINT Outfile,",sizeof(double),NumCompareDdouble);"
            Use_Numqsortddouble = TRUE
          ELSE
            FPRINT Outfile,",sizeof(double),NumCompareAdouble);"
            Use_Numqsortadouble = TRUE
          END IF

        CASE ELSE
          IF order = 1 THEN
            FPRINT Outfile,",sizeof(int),NumCompareDint);"
            Use_Numqsortdint = TRUE
          ELSE
            FPRINT Outfile,",sizeof(int),NumCompareAint);"
            Use_Numqsortaint = TRUE
          END IF
      END SELECT

    CASE ELSE
      CALL EmitOld(FuncRetnFlag)

  END SELECT
  FUNCTION = 0
END FUNCTION ' Emit_ArrayProcs


$comment
FUNCTION Emit_PointerProcs(sWord$, FuncRetnFlag AS PINT)
  CALL EmitOld(FuncRetnFlag)
  FUNCTION = 0
END FUNCTION ' Emit_PointerProcs
$comment

$comment
FUNCTION Emit_RegistryProcs(sWord$, FuncRetnFlag AS PINT)
  CALL EmitOld(FuncRetnFlag)
  FUNCTION = 0
END FUNCTION ' Emit_RegistryProcs
$comment

$comment
FUNCTION Emit_ScriptProces(sWord$, FuncRetnFlag AS PINT)
  CALL EmitOld(FuncRetnFlag)
  FUNCTION = 0
END FUNCTION ' Emit_ScriptProces
$comment

$comment
FUNCTION Emit_UnicodeProcs(sWord$, FuncRetnFlag AS PINT)
  CALL EmitOld(FuncRetnFlag)
  FUNCTION = 0
END FUNCTION ' Emit_UnicodeProcs
$comment

'jcfuller changed 7/31/2013
FUNCTION Emit_template(sWord$, FuncRetnFlag AS PINT)
  SELECT CASE sWord$
    CASE "template"
      'template <typename Container, typename ValueType, int nPropType> class property
      RAW szTmp$
'jcfuller change from bcx7.0.7
      UsingTemplate = TRUE
      CALL BuildDelimStr(1, Ndx, szTmp$)
      FPRINT FP_UDT, szTmp$
      Outfile = FP_UDT

      'TemplateContainer$ = Stk$[4]
      'TemplateContainer$ = Stk$[Ndx]
      'Stk$[Ndx]=""
      'Ndx--
      'Stk$[Ndx]=""
      'Ndx--
      'UsingTemplate = TRUE
      'CALL BuildDelimStr(1, Ndx, szTmp$)
      'FPRINT FP_UDT, szTmp$
      'Outfile = FP_UDT
'IF _ZTRACE_ Then
'	xfor int i = Ndx WHILE i > 0 BY i--
'		ZPRINT(Stk$[i])
'	xnext

'END IF
      'CALL BumpUp()
      'FPRINT FP_UDT,Scoot$;"{"
'jcfuller 07/31/2013
    CASE "endtemplate"
'IF _ZTRACE_ Then
'	ZPRINT("here in Emit_template")
'END IF
		UsingTemplate = FALSE
    '  FPRINT FP_UDT,Scoot$;"}"
    '  CALL BumpDown("Extra un-indent(s) and/or missing indents in TEMPLATE/END TEMPLATE")
  END SELECT
  *FuncRetnFlag = 0
  FUNCTION = 0
END FUNCTION



SUB AddProto(szProto$)
  IF UsingTemplate = FALSE THEN
    ProtoCnt++
    IF ProtoCnt = cMAXProtoType THEN Abort("Maximum Prototypes Exceeded.")
    ProtoType[ProtoCnt].Prototype$ = szProto$
  END IF
END SUB ' AddProto



FUNCTION Emit_OtherProcs(sWord$, FuncRetnFlag AS PINT)
  'RAW iFirst
  'iFirst = INSTR("abcdefghijklmnopqrstuvwxyz", CHR$(sWord[0]))
  SELECT CASE sWord$

    CASE "extern"
      DIM RAW IsVolatile
      RAW IsSubOrFuncPtr
      RAW CVar$
      RAW IsPointer, id, vt
      RAW DimType$

      IsSubOrFuncPtr = SubFuncTest()
      CALL HandleNonsense
      IsVolatile = iMatchWrd(Stk$[2],"volatile")
      CVar$ = Clean$(Stk$[2+IsVolatile])
      CALL ValidVar(CVar$)

      IF Stk$[Ndx] = "*" THEN CALL PointerFix
      IF Stk$[Ndx] = "&" THEN Stk$[Ndx--] = "" : CONCAT(Stk$[Ndx], "&")

      IF Stk$[3+IsVolatile] = "*" THEN
        IF IsVolatile THEN Abort("volatile dynamic strings not supported")
        CALL DimDynaString(CVar$, 2, 0)
        EXIT SELECT
      END IF

      IF IsSubOrFuncPtr THEN
        IF IsVolatile THEN Abort("volatile SUB/FUNCTION pointers not supported")
        IF DimSubFunc(0) THEN EXIT SELECT
      END IF

      Var$ = Clean$(Stk$[2+IsVolatile])
      CALL ValidVar(Var$)

      IsPointer = 0
      DimType$  = ""

      IF iMatchWrd(Stk$[Ndx-1],"as") THEN
        GetTypeInfo(Stk$[Ndx], &IsPointer, &id, &vt)
        Stk$[Ndx] = REMOVE$(Stk$[Ndx],"*")
        CALL BuildStr(3+IsVolatile, Ndx-2, DimType$)
      ELSE
        CALL BuildStr(3+IsVolatile, Ndx, DimType$)
        vt = DataType(Stk$[2+IsVolatile])
        id = 0
      END IF

      IF vt = vt_STRVAR THEN '  AND DimType$ <> "" THEN
        CONCAT (DimType$, cSizeOfADefaultString)
      END IF
      'IF AS THEN USE ASCHECK TO SET vt
      IF IsVolatile THEN
        CALL AddGlobal(Var$, vt, id, DimType$, IsPointer,0,4,0,0)
      ELSE
        CALL AddGlobal(Var$, vt, id, DimType$, IsPointer,0,1,0,0)
      END IF

    CASE "run"

      FPRINT Outfile,Scoot$;"Run (";
      Stk$[++Ndx] = ");"
      CALL WriteCleanTokens(2,Ndx)

    CASE "shell"
      RAW ZZ$
      CALL BuildDelimStr(2, Ndx, ZZ$)
      IF ZZ$ = "" THEN ZZ$ = DDQ$
      FPRINT Outfile,Scoot$;"system(" ; Clean$(ZZ$) ; ");"

    CASE "redim"
      'REDIM b$ * 14
      'REDIM PRESERVE b$ * 20
      'REDIM a$[10]
      'REDIM PRESERVE a$[20]
      DIM RAW IsPreserve
      DIM RAW SOF$
      DIM RAW VI AS VarInfo PTR
      DIM RAW vt1 = 0
      DIM RAW IsSplat = 0
      DIM RAW BC = 0
      DIM RAW StartPoint
      RAW LastPoint
      RAW i
      RAW CVar$
      RAW ZZ$
      RAW vt, id, dms, A

      CALL HandleNonsense

      IsPreserve  = iMatchWrd(Stk$[2], "preserve")
      StartPoint  = 2 + IsPreserve

      vt1     = DataType(Stk$[StartPoint])
      CVar$   = Clean$(Stk$[StartPoint])
      IsSplat = iMatchWrd(Stk$[StartPoint + 1], "*")

      CALL ValidVar(CVar$)

      LastPoint = GetAsPosB(Ndx, 1) - 1
      IF LastPoint < 1 THEN LastPoint = Ndx
      RAW SP = 0

      WHILE LastPoint > StartPoint
        IF Stk$[LastPoint] = "[" THEN
          DECR BC
        ELSEIF Stk$[LastPoint] = "]" THEN
          INCR BC
          IF BC = 1 THEN DECR LastPoint : ITERATE
        END IF
        IF BC = 0 THEN
          INCR SP
          IF Stk$[LastPoint-1] <> "]" THEN EXIT WHILE
          ZZ$ = "," + ZZ$
        ELSE
          ZZ$ = Stk$[LastPoint] + ZZ$
        END IF
        DECR LastPoint
      WEND

      'get info
      vt = CheckLocal(CVar$, &id)
      IF vt = vt_UNKNOWN THEN
        vt = CheckGlobal(CVar$, &id)
        IF vt = vt_UNKNOWN THEN
          Abort("Can not REDIM " + CVar$ + " not previously dimensioned")
        END IF
        VI = &GlobalVars[id]
      ELSE
        VI = &LocalVars[id]
      END IF
      dms = VI->VarPntr

      IF vt = vt_STRUCT OR vt = vt_UDT OR vt = vt_UNION THEN  'added vt_UNION 4.40

        SOF$ = GetElement$( StartPoint, &vt, &dms, VI->VarDef)

        i = Ndx
        Ndx = LastPoint-1
        CALL AsmUnknownStructs(1)
        Ndx = i
        CALL RemEmptyTokens

        CVar$   = Clean$(Stk$[StartPoint])
        IsSplat = iMatchWrd(Stk$[StartPoint + 1], "*")

      ELSE
        SOF$ = GetVarTypeName$(vt)
      END IF

      IF iMatchWrd(Stk$[Ndx-1], "as") THEN
        IF SOF$ <> Stk$[Ndx] AND NOT iMatchWrd(Stk$[Ndx], "string") THEN
          Abort("Can not change types for variable " + CVar$ + " previously defined as " + SOF$ + " on line" + STR$(VI->VarLine))
        END IF
        IF iMatchWrd(Stk$[Ndx], "string") THEN
          Ndx--
          CALL AppendTokens(3, "[", csSizeOfDefaultString$, "]")
        ELSE
          Ndx -= 2
        END IF
      ELSE
        IF (vt = vt_CHAR AND vt1 = vt_STRVAR AND IsSplat = 0) OR vt = vt_CHARPTR THEN
          CALL AppendTokens(3, "[", csSizeOfDefaultString$, "]")
        END IF
      END IF

      IF Stk$[3 + IsPreserve] = "[" THEN
        IF IsPreserve THEN
          StartPoint = 4
        ELSE
          FPRINT Outfile,Scoot$;"if (";CVar$ + ") { DestroyArr((void **)";CVar$ + ",";STR$(dms) + ", 1); ";CVar$ + "=NULL; }"
          StartPoint = 3
        END IF

        Use_DynamicA =TRUE
        UseFlag      =TRUE
        A = 0
        ZZ$ = ""

        FOR i = StartPoint TO Ndx
          IF Stk$[i] = "[" THEN
            A++
            i++
            BC = 1

            WHILE BC > 0
              IF Stk$[i] = "[" THEN
                BC++
                CONCAT(ZZ$, Stk$[i])
              ELSE
                IF Stk$[i] = "]" THEN
                  BC--
                  IF BC = 0 AND i < Ndx THEN
                    CONCAT(ZZ$, ",")
                  END IF
                  IF BC THEN
                    CONCAT(ZZ$, Stk$[i])
                  END IF
                ELSE
                  CONCAT(ZZ$, Stk$[i])
                END IF
              END IF
              i++
            WEND

            i--
          END IF
        NEXT

        ZZ$ = Clean$(ZZ$)

        IF vt = vt_STRLIT OR vt = vt_DECFUNC OR vt = vt_NUMBER OR (vt = vt_VOID AND INCHR(Stk$[Ndx],"*") = 0) THEN
          Abort(Stk$[Ndx] + " is not a valid type")
        END IF
        IF vt = vt_STRVAR THEN
          SOF$ = "char"
          A++
          CONCAT(ZZ$,",")
          CONCAT(ZZ$,csSizeOfDefaultString$)
        END IF

        IF A <> dms THEN
          Abort("Mismatch in dimensions for " + CVar$ + ", orignally " + STR$(dms) + " found " + STR$(A))
        END IF
'cout << "36468 CreateArr" << endl
'jcfuller changed 02/20/2016		
		FPRINT Outfile,Scoot$;"{"
		FPRINT Outfile,Scoot$;"size_t dimensions[";TRIM$(STR$(dms));"] = {";ZZ$;"};" 
        FPRINT Outfile,Scoot$;CVar$ ; "= ("; SOF$ ;STRING$(dms,42);")CreateArr ("; CVar$ ; ",sizeof(";SOF$;"),";TRIM$(STR$(IsPreserve));",";TRIM$(STR$(dms));",dimensions);"
        FPRINT Outfile,Scoot$;"}"
		
        'FPRINT Outfile,Scoot$;CVar$ ; "= ("; SOF$ ;STRING$(dms,42);")CreateArr ("; CVar$ ; ",sizeof(";SOF$;"),";TRIM$(STR$(IsPreserve));",";dms;"," ; ZZ$ ; ");"

        EXIT SELECT
      END IF

      IF Stk$[3]= "*" OR (IsPreserve AND Stk$[4]= "*") THEN       ' DIM MySTRING$ * NumBytes
        IF IsPreserve THEN
          FPRINT Outfile,Scoot$; CVar$ ; "=(char*)realloc(";CVar$;",";
          i = 5
        ELSE
          FPRINT Outfile,Scoot$;"free(" ; CVar$ ; ");"
          FPRINT Outfile,Scoot$; CVar$ ; "=(char*)calloc(";
          i = 4
        END IF

        IF IsPreserve THEN
          Stk$[++Ndx] = ");"
        ELSE
          Stk$[++Ndx] = ",1);"
        END IF

        CALL WriteCleanTokens(i,Ndx)

        EXIT SELECT
      END IF

      Abort("Invalid REDIM statement")

    CASE "data"

      'IF Stk$[Ndx] <> "," THEN
      '  Stk$[++Ndx] = ","
      'END IF

      FOR INT A = 2 TO Ndx
        IF INCHR(Stk$[A],DQ$) = 0 AND Stk$[A] <> "," THEN
          Stk$[A] = ENC$(Stk$[A])  ' Allow unquoted text
        END IF
        FPRINT FP_DAT,Stk$[A];
      NEXT

      FPRINT FP_DAT,""

    CASE "declare"
    'ZPRINT("declare")
      RAW FP AS functionParse
      RAW TempProto$
      RAW Varcode AS VARCODE
      Varcode.IsExported = FALSE
      Varcode.UseInLine = UseInLine
      CALL FuncSubDecs1("sub", 1, Ndx, &Varcode) 'convert [] to pointer * and $[] to [][2048]

      CALL SepFuncArgs(3, &FP, TRUE)
      TempProto$ = MakeDecProto$(&FP)

      IF NOT NoTypeDeclare THEN
        FPRINT FP_UDT,TempProto$, ";"
      ELSE
        CALL AddProto(TempProto$ + ";")
      END IF

    CASE "clear"

      Use_Clear = TRUE
      Use_SysMacros = TRUE

      FPRINT Outfile,Scoot$;"Clear ";
      IF Stk$[2]<> "(" THEN FPRINT Outfile,"("; : Stk$[++Ndx] = ");"
      CALL WriteCleanTokens(2,Ndx)
      FPRINT Outfile,";"
'jcfuller added constexpr 5/16/2013
    CASE "const","constexpr"

      RAW i
      DIM RAW Buffer$
      DIM RAW Sep$

      Buffer$ = ""
      Sep$    = ""


      IF InClassModule THEN

        FOR i = 1 TO Ndx

          IF IsName(Stk$[i]) AND IsName(Stk$[i+1]) THEN CONCAT(Stk$[i],SPC$)
          CONCAT(Buffer$,Stk$[i])

        NEXT
        FPRINT FP_UDT,Scoot$;Buffer$;";"
      ELSE

        Stk$[1] = ""
        IF Stk$[3] = "(" THEN
          IF cMaxConstMacros = ConstMacroCnt THEN CALL Abort("Max Const Macros exceeded.")
          ConstMacro$[ConstMacroCnt++] = Stk$[2]
        END IF
        FOR i = 2 TO Ndx

          IF Stk$[i] = "=" THEN
            INCR i
            EXIT FOR
          ELSE
            IF IsNumber(Stk$[i]) THEN CONCAT(Stk$[1], SPC$)
            CONCAT(Stk$[1], Stk$[i])

          END IF
        NEXT
        Stk$[1] = "#define " + Clean$(Stk$[1]) + SPC$

        FOR i = i TO Ndx
        'IF _ZTRACE_ Then
	    '  zTrace(ANSITOWIDE((char*)Stk$[i]))
        'END IF

          IF NOT IsQuoted(Stk$[i]) THEN REMOVE "$" FROM Stk$[i]
          IF (IsName(Stk$[i]) AND IsName(Stk$[i+1])) OR IsNumber(Stk$[i+1]) THEN CONCAT(Stk$[i],SPC$)
          CONCAT(Buffer$,Stk$[i])
        NEXT

        Buffer$ = Stk$[1] + Buffer$

        IF InConditional THEN

          'IF InFunc THEN
          IF InFunc <> eNotInOne THEN
            FPRINT Outfile,Buffer$
          ELSE
            IF ConstLastDef$ <> "FP_CST" THEN
              FPRINT FP_CST,InIfDef$,"// FP_CST"
              ConstLastDef$ = "FP_CST"
            END IF
            FPRINT FP_CST,Buffer$
          END IF
        ELSE
          FPRINT FP_CST,Buffer$
        END IF
      END IF

    'CASE "auto"
    '  CALL DimVar(ImAuto)

    CASE "dim"
      CALL DimVar(ImDim)

    CASE "local"
      CALL DimVar(ImLocal)

    CASE "privatedim"
      CALL DimVar(ImCPPPrvDim)

    CASE "raw"
      CALL DimVar(ImRaw)

    'CASE "register"
    '  CALL DimVar(ImRegister)

    CASE "static"
      CALL DimVar(ImStatic)

    CASE "swap"
    RAW VI1 AS VarInfo PTR
    RAW VI2 AS VarInfo PTR
    RAW indx AS Integer
    RAW A, i, j

    UseFlag = TRUE
    FPRINT Outfile,Scoot$;"swap ((byte*)&";

    FOR i = 2 TO Ndx
      IF Stk$[i]= "," THEN EXIT FOR
      FPRINT Outfile,Clean$(Stk$[i]);
    NEXT

    A = CheckLocal(Stk$[2], &indx)
    IF A = vt_UNKNOWN THEN
      A = CheckGlobal(Stk$[2], &indx)
      IF A = vt_UNKNOWN THEN
        Abort("Variable '"+Stk$[2]+"' in swap statement unknown")
      END IF
      VI1 = &GlobalVars[indx]
    ELSE
      VI1 = &LocalVars[indx]
    END IF

    IF RIGHT$(Stk$[i-1],1) <> "]" THEN
      IF VI1->VarType = vt_CHAR AND VI1->VarPntr = 1 THEN FPRINT Outfile,"[0]";
      END IF

    FPRINT Outfile,",(byte*)&";

    i++

    FOR j = i TO Ndx
      FPRINT Outfile,Clean$(Stk$[j]);
    NEXT

    A = CheckLocal(Stk$[i], &indx)
    IF A = vt_UNKNOWN THEN
      A = CheckGlobal(Stk$[i], &indx)
      IF A = vt_UNKNOWN THEN
        Abort("Variable '"+Stk$[i]+"' in swap statement unknown")
      END IF
      VI2 = &GlobalVars[indx]
    ELSE
      VI2 = &LocalVars[indx]
    END IF

    IF RIGHT$(Stk$[j-1],1) <> "]" THEN
      IF VI2->VarType = vt_CHAR AND VI2->VarPntr = 1 THEN FPRINT Outfile,"[0]";
    END IF

    IF VI1->VarType <> VI2->VarType THEN
      Warning("Possible size error in swap statement")
    END IF

    IF VI2->VarType = vt_STRVAR OR VI2->VarType = vt_CHAR THEN
      FPRINT Outfile,",strlen(";
    ELSE
      FPRINT Outfile,",sizeof(";
    END IF

    Stk$[++Ndx] = "));"
    CALL WriteCleanTokens(i,Ndx)

  END SELECT
  FUNCTION = 0
END FUNCTION ' Emit_OtherProcs



FUNCTION Emit_PrinterProcs(sWord$, FuncRetnFlag AS PINT)
  SELECT CASE sWord$

    CASE "ejectpage"
      FPRINT Outfile,Scoot$;"EjectPage();"

    CASE "printerclose"
      FPRINT Outfile,Scoot$;"PrinterClose();"

    CASE "printeropen"
      IF Ndx = 1 THEN
        FPRINT Outfile,Scoot$;"PrinterOpen();"
      ELSE
        RAW szPrinterParameters$
        CALL BuildStr(2, Ndx, szPrinterParameters$)
        FPRINT Outfile,Scoot$;"PrinterOpen(";szPrinterParameters$;");"
      END IF

    CASE "lprint", "sprint"  'LPRINT & FPRINT  handle,{list}
      DIM RAW IsLprint = FALSE
      DIM RAW IsSprint = FALSE

      IF iMatchWrd(Stk$[1],"lprint") THEN
        Use_Proto = IsLprint = IsSprint = TRUE
        Stk$[1] = "sprint"
        InsertTokens(1, 2, "BcxPtr_Buffer",",")
      END IF

      IF iMatchWrd(Stk$[1],"sprint") THEN
        IsSprint = TRUE
      END IF

      IF IsNumber(Stk$[2]) THEN
        Stk$[2] = "FP" + Stk$[2]
      END IF

      IF IsSprint THEN
        Handle$ = Clean$(Stk$[2])
      ELSE
        IF LCASE$(Stk$[2]) = "stderr" THEN
          Handle$ = LCASE$(Stk$[2])
        ELSE
          RAW i
          IF CheckLocal(Stk$[2], &i) = vt_UNKNOWN THEN
            IF CheckGlobal(Stk$[2], &i) = vt_UNKNOWN THEN
              CALL AddGlobal(Stk$[2], vt_FILEPTR, 0,"",0,0,0,0,0)
            END IF
          END IF

          Handle$ = ""

          FOR INT i = 2 TO Ndx
            IF *Stk$[i] = ASC(",") OR *Stk$[i] = ASC(";") THEN
              Stk$[i] = ""
              EXIT FOR
            END IF
            Handle$ = Handle$ + Stk$[i]
            Stk$[i] = ""
          NEXT

          Handle$ = Handle$ + "@"
        END IF
      END IF

      Stk$[2] = ""  'get rid of handle
      Stk$[3] = ""  'get rid of the Comma
      RAW ZZ$
      IF IsSprint THEN
        ZZ$ = "s" + PrintWriteFormat$(0)
        REMOVE "\\n" FROM ZZ$
      ELSE
        ZZ$ = "f" + PrintWriteFormat$(0)
      END IF

      ZZ$ = LEFT$(ZZ$,8) + REMOVE$(Handle$,"@") + "," + MID$(ZZ$,9)

      IF IsLprint THEN
        FPRINT Outfile,Scoot$;ZZ$
        FPRINT Outfile,Scoot$;"PrinterWrite(BcxPtr_Buffer);"
        IF NOT Use_Printer THEN
          SrcTmp$ = "printer" : CALL XParse(SrcTmp$) : CALL FixUps() : CALL EmitMain()    ' Force printer globals declarations
        END IF
      ELSE
        FPRINT Outfile,Scoot$;ZZ$
      END IF

    CASE ELSE
      CALL EmitOld(FuncRetnFlag)
  END SELECT
  FUNCTION = 0
END FUNCTION ' Emit_PrinterProcs


$comment
FUNCTION Emit_GraphicsProcs(sWord$, FuncRetnFlag AS PINT)
  CALL EmitOld(FuncRetnFlag)
  FUNCTION = 0
END FUNCTION ' Emit_GraphicsProcs
$comment

$comment
FUNCTION Emit_RuntimeFunctionsCOM_ActiveX(sWord$, FuncRetnFlag AS PINT)
  CALL EmitOld(FuncRetnFlag)
  FUNCTION = 0
END FUNCTION ' Emit_RuntimeFunctionsCOM_ActiveX
$comment

$comment
FUNCTION Emit_FileInputProcs(sWord$, FuncRetnFlag AS PINT)
  CALL EmitOld(FuncRetnFlag)
  FUNCTION = 0
END FUNCTION ' Emit_FileInputProcs
$comment

$comment
FUNCTION Emit_DebugDirectives(sWord$, FuncRetnFlag AS PINT)
  CALL EmitOld(FuncRetnFlag)
  FUNCTION = 0
END FUNCTION ' Emit_DebugDirectives
$comment


' MEMSET/STATIC Truth Table
'
'  DIM         A        MEMSET  STATIC
'  LOCAL       B        MEMSET  STATIC
'  RAW         C
'  STATIC      D                STATIC
'  AUTO        E        MEMSET
'  REGISTER    F
'  ImCPPPrvDim

'ENUM
  'ImDim       = 0x0001
  'ImLocal     = 0x0002
  'ImRaw       = 0x0004
  'ImStatic    = 0x0008
  'ImAuto      = 0x0010
  'ImRegister  = 0x0020
  'ImCPPPrvDim = 0x0040
'END  ENUM

ENUM
  ImDim       = 0x0001
  ImLocal     = 0x0002
  ImRaw       = 0x0004
  ImStatic    = 0x0008
  ImRegister  = 0x0020
  ImCPPPrvDim = 0x0040
END  ENUM

FUNCTION Emit_Dynamic(sWord$, FuncRetnFlag AS PINT)
  SELECT CASE sWord$

    CASE "dynamic"
      DIM RAW w = 0
      DIM RAW SOF$
      RAW ZZ$
      RAW CVar$
      RAW vt, id, dms

      CALL HandleNonsense
      CVar$ = Clean$(Stk$[2])
      CALL ValidVar(CVar$)
      IF Stk$[Ndx] = "*" THEN CALL PointerFix
      IF Stk$[Ndx] = "&" THEN Stk$[Ndx--] = "" : CONCAT(Stk$[Ndx], "&")
      IF iMatchWrd(Stk$[Ndx-1], "as") THEN
        SOF$ = Stk$[Ndx]
        GetTypeInfo(SOF$, &w, &id, &vt)
        IF vt = vt_STRLIT OR vt = vt_DECFUNC OR vt = vt_NUMBER OR (vt = vt_VOID AND INCHR(Stk$[Ndx], "*") = 0) THEN
          Abort(SOF$ + " is not a valid type")
        END IF
        IF vt = vt_FILEPTR AND INCHR(SOF$, "*") = 0 THEN SOF$ = SOF$ + "*"
        Ndx -= 2
      ELSE
        vt = DataType(Stk$[2])
        id = 0
        SOF$ = GetVarTypeName$(vt)
      END IF

      Use_DynamicA = TRUE
      UseFlag      = TRUE

      CALL BuildStr(3, Ndx, ZZ$)
      dms = TALLY(ZZ$,"][") + 1
      IF dms > 1 THEN REPLACE "][" WITH "," IN ZZ$
      ZZ$ = Clean$(ZZ$)
      RemoveAll(ZZ$,"[]")
      IF vt = vt_STRVAR THEN
        vt = vt_CHAR
        SOF$ = "char"
        IF InTypeDef THEN
          IF Stk$[3] <> "[" THEN
            DECR dms
          ELSE
            vt = vt_CHARPTR
          END IF
        END IF

        dms++
        CONCAT(ZZ$,",")
        CONCAT(ZZ$,csSizeOfDefaultString$)
      END IF

      IF InTypeDef THEN
        IF vt = vt_STRUCT THEN
          FPRINT Outfile,Scoot$;"struct _", SOF$, "  ", STRING$(dms,42), CVar$, ";"
        ELSE
          FPRINT Outfile,Scoot$;SOF$, "  ", STRING$(dms,42), CVar$, ";"
        END IF
        CALL AddTypedefElement(BaseTypeDefsCnt[InTypeDef], vt, CVar$, SOF$, dms)
      'ELSEIF InFunc THEN
      ELSEIF InFunc <> eNotInOne THEN
        LocalDynArrCnt++
        IF cMaxLocalDynArr = LocalDynArrCnt THEN CALL Abort("Maximum number of Local Dynamic Arrays exceeded.")
        LocalDynArrName$ [LocalDynArrCnt] = "if (" + CVar$ + ") { DestroyArr((void **)" + CVar$ + "," + STR$(dms) + ", 1); " +  CVar$ + "=NULL; }"
        'cout << "36841" << endl
        FPRINT Outfile,Scoot$;SOF$;"  ";STRING$(dms,42);CVar$;"=0;"
        CALL AddLocal(CVar$, vt, id,"",dms,0,0,0)
      ELSE
        IF Use_GenFree THEN
          CALL AddDynamicGlobal("if (" + CVar$ + ") { DestroyArr((void **)" + CVar$ + "," + STR$(dms) + ", 1); " +  CVar$ + "=NULL; }")
        END IF
        CALL AddGlobal(CVar$, vt, id,"",dms,0,0,0,0)
      END IF

      IF NOT InTypeDef THEN
'cout << "36927 CreateArr" << endl  
'cout << "SOF$ -> " << SOF$ << endl  
'cout << "STRING$(dms,42) -> " << STRING$(dms,42) << endl
'cout << "TRIM$(STR$(dms)) -> " << TRIM$(STR$(dms)) << endl
'cout << "ZZ$ -> " << ZZ$ << endl 
		FPRINT Outfile,Scoot$;"{"
        FPRINT Outfile,Scoot$;"size_t dimensions[";TRIM$(STR$(dms));"] = {";ZZ$;"};" 
        'FPRINT Outfile,Scoot$;CVar$ ; "= ("; SOF$ ;STRING$(dms,42);")CreateArr ("; CVar$ ; ",sizeof(";SOF$;"),0,";TRIM$(STR$(dms));"," ; ZZ$ ; ");"
        FPRINT Outfile,Scoot$;CVar$ ; "= ("; SOF$ ;STRING$(dms,42);")CreateArr ("; CVar$ ; ",sizeof(";SOF$;"),0,";TRIM$(STR$(dms));",dimensions);"
        FPRINT Outfile,Scoot$;"}"
      END IF

    CASE "free"
      RAW VI AS VarInfo PTR
      RAW A, vt, id, dms
      RAW CVar$
      A = 2
      IF iMatchWrd(Stk$[2], "dynamic") THEN A = 3
      IF Stk$[A] = "(" THEN
        INCR A
        DECR Ndx
      END IF

      CVar$ = Clean$(Stk$[A])
      vt = CheckLocal(CVar$, &id)
      IF vt = vt_UNKNOWN THEN
        vt = CheckGlobal(CVar$, &id)
        IF vt = vt_UNKNOWN THEN
          Abort("Can not REDIM " + CVar$ + " not previously dimensioned")
        END IF
        VI = &GlobalVars[id]
      ELSE
        VI = &LocalVars[id]
        ' fix this
        Warning("Local dynamic variables are automatically freed.", 1)

      END IF

      CALL BuildStr(A, Ndx, CVar$)

      CVar$ = TRIM$(Clean$(CVar$))

      IF vt = vt_STRUCT OR vt = vt_UNION THEN
        GetElement$(2, &vt, &dms, VI->VarDef)
        IF vt <> vt_UNKNOWN AND dms > 0 THEN
          UseFlag = Use_DynamicA = TRUE
          FPRINT Outfile,Scoot$;"if (",  CVar$;
          FPRINT Outfile,") { DestroyArr((void **)", CVar$, ",", dms, ", 1); ";
          FPRINT Outfile,CVar$ ; "=NULL; }"
          EXIT SELECT
        END IF
      END IF

      IF VI->VarPntr > 1 THEN
        UseFlag = Use_DynamicA = TRUE
        FPRINT Outfile,Scoot$;"if ("  ; CVar$ ;
        FPRINT Outfile,") { DestroyArr((void **)";CVar$;",";STR$(VI->VarPntr);", 1); ";
        FPRINT Outfile,CVar$ ; "=NULL; }"
      ELSE
        FPRINT Outfile,Scoot$;"free(", CVar$, "), ";
        FPRINT Outfile, CVar$, "=NULL;"
      END IF

    CASE ELSE
      CALL EmitOld(FuncRetnFlag)

  END SELECT
  FUNCTION = 0
END FUNCTION ' Emit_Dynamic



'********************************************************
' DIM A$ * blah blah blah
' DIM a%[1000]  (integer)
' DIM a![1000]  (single)
' DIM a#[1000]  (double)
' DIM a[1000]  (long double)
' DIM A$[1000]  (string)
' DIM r             AS DATA_TYPE
' DIM r[1][2]...[n] AS DATA_TYPE
' DIM DYNAMIC A$[1000]
' DIM volatile a
' DIM a AS CONST CHAR PTR
'********************************************************
'$COMMENT
'SUB DimVar(iType)
  'RAW w = 0
  'RAW id = 0
  'RAW vt = 0
  'RAW UseStatic$
  'RAW IsVolatile
  'RAW sVolatile$
  'RAW IsALocalVar = FALSE
  'RAW Ok2UseMemset
  'RAW szVarName$
  'RAW VarType
  'RAW IsSubOrFuncPtr
  'RAW IsConsOrDestPtr
  'RAW IsPointer
  'RAW lszTmp$
  'RAW DimType$
  'RAW szVarTypeName$
  'RAW szMemsetName$
  'RAW szVarDecName$
  'DIM zt$
''Wayne 07/10/2013
'IF Stk[Ndx][0] = ASC(":") THEN
'CONCAT(Stk$[Ndx-1], Stk$[Ndx])
'Ndx--
'END IF

''bc9106 jcf


  'IsDim = IsLocal = IsRaw = IsRegister = IsStatic = FALSE
  'IF iType = ImDim      THEN IsDim      = TRUE
  'IF iType = ImLocal    THEN IsLocal    = TRUE
  'IF iType = ImRaw      THEN IsDim      = IsRaw
  'IF iType = ImRegister THEN IsRegister = TRUE
  'IF iType = ImStatic   THEN IsStatic   = TRUE

''jcfuller debug
  ''PRINT Stk$[Ndx]

  'IsVolatile = iMatchWrd(Stk$[2],"volatile")

  'IF IsVolatile THEN
    'IF ImRegister THEN Abort("Register volatile not supported")
    'sVolatile$ = "volatile "
  'ELSE
    'sVolatile$ = ""
  'END IF

  'IsSubOrFuncPtr = SubFuncTest()
  'IsConsOrDestPtr = ConstructDestructTest(2)

  'CALL HandleNonsense()
  'IF Stk$[Ndx] = "*" THEN CALL PointerFix()
  'IF Stk$[Ndx] = "&" THEN Stk$[Ndx--] = "" : CONCAT(Stk$[Ndx], "&")

  ''*************************************************************************
  'IF IsSubOrFuncPtr THEN
    'IF IsVolatile THEN Abort("volatile SUB/FUNCTION pointers not supported")
    'IF DimSubFunc(0) THEN EXIT SUB
  'END IF

  'IF IsConsOrDestPtr THEN
    'IF IsVolatile THEN Abort("volatile SUB/FUNCTION pointers not supported")
    'IF DimSubFunc(2) THEN EXIT SUB
  'END IF

  ''IF InFunc OR InTypeDef OR InBlock OR InNameSpace OR InClassModule THEN
  'IF InFunc <> eNotInOne OR InTypeDef OR InBlock OR InNameSpace OR InClassModule OR InPPTypeModule THEN
    'IsALocalVar = TRUE
  'END IF

  ''IF InTypeDef OR IsVolatile OR InNameSpace OR InClassModule THEN
  ''IF InTypeDef OR IsVolatile OR UseCpp THEN
  ''bc9105
  'IF InTypeDef OR IsVolatile THEN
    'Ok2UseMemset = FALSE
  'ELSE

    ''IF (iType BAND (ImDim BOR ImLocal BOR ImAuto)) <> 0 THEN
    'IF (iType BAND (ImDim BOR ImLocal )) <> 0 THEN
''jcfuller changed 6/19/2013
    ''IF iType = ImDim THEN
      'Ok2UseMemset = TRUE
    'ELSE
      'Ok2UseMemset = FALSE
    'END IF
  'END IF
  ''IF InTypeDef OR InNameSpace  OR InClassModule THEN
  'IF InTypeDef OR InNameSpace  THEN
    'UseStatic$ = ""
    ''IF IsStatic = TRUE THEN Warning
    'IsStatic = FALSE
  'ELSE
  ''bc9105 jcf
''I see no reason for static for local or dim

    ''IF (iType BAND (ImDim BOR ImLocal BOR ImStatic)) <> 0 THEN
    'IF (iType BAND (ImStatic)) <> 0 THEN
      'IsStatic = TRUE
      'UseStatic$ = "static "
    'ELSE
      'UseStatic$ = ""
      'IsStatic = FALSE
    'END IF
  'END IF
''IsStatic = FALSE
''UseStatic$ = ""

  'szVarName$ = Clean$(Stk$[2+IsVolatile])

  'CALL ValidVar(szVarName$)
  'VarType = DataType(Stk$[2+IsVolatile])

  'IF Stk$[3+IsVolatile] = "*" THEN       ' DIM MySTRING$ * NumBytes
    'IF IsVolatile THEN Abort("volatile dynamic strings not supported")
    'CALL DimDynaString(szVarName$, 0, 0)
    'EXIT SUB
  'END IF
  'RAW iASoffset = GetAsPosB(Ndx, 2) ' AS offset

  'IF iASoffset THEN
    'RAW sConst$
    'RAW iIsConst
    'iIsConst = 0
    'sConst$ = ""
    'IF iASoffset = Ndx-2 THEN
      'IF iMatchWrd(Stk$[Ndx-1],"const") THEN
        'sConst$ = "const "
        'iIsConst = 1
      'END IF
'''jcfuller 5-18-2013
      ''IF iMatchWrd(Stk$[Ndx-1],"constexpr") THEN
''IF _ZTRACE_ THEN
	''zTrace(ANSITOWIDE((char*)"Hello From line 32430"))
''END IF

        ''sConst$ = "constexpr "
        ''iIsConst = 1
      ''END IF

    'END IF
    'IsPointer = TALLY(Stk$[Ndx],"*")

    'CALL BuildStr(2+IsVolatile, iASoffset-1, lszTmp$)
    'CALL BuildStr(3+IsVolatile, iASoffset-1, DimType$)

    'szVarTypeName$ = REMOVE$(Stk$[Ndx],"*")
    'GetTypeInfo(szVarTypeName$, &w, &id, &vt)
    'IF vt = vt_WINBOOL THEN
      'IREPLACE "WINBOOL" WITH "BOOL" IN Stk$[Ndx]
    'END IF

    'IF vt = vt_STRVAR THEN
      'Stk$[Ndx] = "char"
      'szVarTypeName$ = Stk$[Ndx]
      'CONCAT(DimType$, cSizeOfADefaultString)
      'CONCAT(lszTmp$, cSizeOfADefaultString)
    'END IF

    'Stk$[Ndx] = RPAD$(Stk$[Ndx],7)

    'IF vt = vt_FILEPTR THEN
      'CONCAT(Stk$[Ndx], "*")
    'END IF

    'IF IsALocalVar THEN

      'SELECT CASE iType

        'CASE ImDim, ImLocal, ImRaw

          'IF vt = vt_STRUCT THEN
            'FPRINT Outfile,Scoot$;UseStatic$;sVolatile$;sConst$;"struct _" ; Stk$[Ndx]; "  ";
          'ELSE
            'FPRINT Outfile,Scoot$;UseStatic$;sVolatile$;sConst$;Stk$[Ndx];"  ";
''jcfuller debug
          ''PRINT UseStatic$;sVolatile$;sConst$;Stk$[Ndx]
          'END IF
          'IF InTypeDef AND NOT InBlock THEN
            'IF vt = vt_UDT THEN
              'IF ComSwitchON THEN
                'IF TypeDefs[id].VarName$ = "OBJECT" THEN
                  'Abort("Use of Object type in UDTs is Illegal!")
                'END IF
              'END IF
            'END IF
            'CALL AddTypedefElement(BaseTypeDefsCnt[InTypeDef], vt, szVarName$, szVarTypeName$, 0)
          'END IF

        'CASE ImStatic
          'FPRINT Outfile,Scoot$;UseStatic$;sVolatile$;sConst$;Stk$[Ndx];"  ";

        ''CASE ImAuto
        ''  FPRINT Outfile,Scoot$;"auto ";sVolatile$;sConst$;" ";Stk$[Ndx];"  ";

        'CASE ImRegister
          'FPRINT Outfile,Scoot$;"register  ";sConst$;Stk$[Ndx];"  ";

        'CASE ImCPPPrvDim
          'FPRINT Outfile,Scoot$;"private: ";Stk$[Ndx];"  ";

      'END SELECT

      'IF iType <> ImCPPPrvDim THEN
        'IF NOT InTypeDef THEN
          'IF vt = vt_UDT THEN
            'IF ComSwitchON THEN
              'IF TypeDefs[id].VarName$ = "OBJECT" THEN
                'Add_COM_Global_Variable(szVarName$)
                'Use_COM = UseFlag = TRUE
              'END IF
            'END IF
          'END IF
          'CALL AddLocal(szVarName$, vt, id, DimType$, IsPointer,0,0,iIsConst)
        'END IF
      'ELSE
        '' CALL AddClassVar()
      'END IF



      'IF Ok2UseMemset THEN
		''jcfuller changed 05/13/2014
        'szMemsetName$ = Clean$(EXTRACT$(lszTmp$,"["))
        'IF IsPointer THEN
			''IF _ZTRACE_ Then
			''	zt$ = "It's A Pointer -> " + szMemsetName$
			''	ZPRINT(zt$)
			''END IF
          ''FPRINT Outfile, Clean$(lszTmp$); ";"
          ''FPRINT Outfile, Scoot$;"memset(&";szMemsetName$;",0,sizeof(";Clean$(szVarTypeName$);" *";"));"

          'FPRINT Outfile,Clean$(lszTmp$); "={0};"
        'ELSE
          ''FPRINT Outfile, Scoot$;"memset(&";szMemsetName$;",0,sizeof(";szMemsetName$;"));"
          'SELECT CASE vt
            'CASE vt_BOOL, vt_BYTE, vt_DWORD, vt_INTEGER, vt_LONG, vt_SHORT, vt_UINT, vt_ULONG, vt_USHORT, vt_DWORD, vt_WORD
              'FPRINT Outfile,Clean$(lszTmp$); "={0};"
            'CASE vt_DOUBLE, vt_SINGLE, vt_LDOUBLE
              'FPRINT Outfile,Clean$(lszTmp$); "={0.0};"
            'CASE vt_PCHAR, vt_LPBYTE
              'FPRINT Outfile,Clean$(lszTmp$); "={NULL};"
            'CASE ELSE
              ''FPRINT Outfile, Clean$(lszTmp$); ";"
              ''FPRINT Outfile, Scoot$;"memset(&";szMemsetName$;",0,sizeof(";szMemsetName$;"));"
''jcfuller change 10/29/2013
              'FPRINT Outfile,Clean$(lszTmp$); "={0};"
          'END SELECT
        'END IF
      'ELSE
        'FPRINT Outfile, Clean$(lszTmp$); ";"
      'END IF
    'ELSE
      'IF IsVolatile THEN
        ''IF AS THEN USE ASCHECK TO SET vt
        'CALL AddGlobal(szVarName$, vt, id, DimType$,IsPointer,0,3,0,iIsConst)
      'ELSE
        'IF vt = vt_UDT THEN
          'IF ComSwitchON THEN
            'IF TypeDefs[id].VarName$ = "OBJECT" THEN
              'Add_COM_Global_Variable(szVarName$)
              'Use_COM = UseFlag = TRUE
            'END IF
          'END IF
        'END IF
        'IF iType = ImRaw THEN
          'CALL AddGlobal(szVarName$, vt, id, DimType$,IsPointer,0,2,0,iIsConst)
        'ELSE
          'CALL AddGlobal(szVarName$, vt, id, DimType$,IsPointer,0,0,0,iIsConst)
        'END IF
      'END IF
    'END IF
    'EXIT SUB
  'END IF

  '' Dimensioned without AS
  'CALL BuildStr(3+IsVolatile, Ndx, lszTmp$)

''jcfuller added 02/25/2016  
  ''IF INSTR(lszTmp$, "=") <> 0 THEN
  ''  Ok2UseMemset = FALSE
  ''END IF

  'IF IsALocalVar THEN lszTmp$ = LTRIM$(Clean$(lszTmp$))
  'IF VarType = vt_STRVAR THEN CONCAT (lszTmp$, cSizeOfADefaultString)

  'IF IsALocalVar THEN
    'IF VarType = vt_STRVAR THEN
      'szVarDecName$ = "char"
    'ELSE
      'szVarDecName$ = GetVarTypeName$(VarType)
    'END IF
    'szVarDecName$ = RPAD$(szVarDecName$, 7)

    'SELECT CASE iType

      'CASE ImDim, ImLocal, ImRaw, ImStatic
''bc9106 jcf
            '' FPRINT Outfile,Scoot$;UseStatic$;sVolatile$;szVarDecName$;" ";szVarName$;lszTmp$;";//test2"

         'IF (ImDim OR ImLocal) AND Ok2UseMemset THEN
         ''If Not IsBc9 Then
		''	cout << lszTmp$ << endl
		'' End if	
           'FPRINT Outfile,Scoot$;szVarDecName$;" ";szVarName$;lszTmp$;"={0};"
           'Ok2UseMemset=FALSE
         'ELSE
           'FPRINT Outfile,Scoot$;UseStatic$;sVolatile$;szVarDecName$;" ";szVarName$;lszTmp$;";"
         'END IF
      ''CASE ImAuto

''        FPRINT Outfile,Scoot$;"auto ";sVolatile$;szVarDecName$;" ";szVarName$;lszTmp$;";"
''jcfuller change 5-19-2013
		''FPRINT Outfile,Scoot$;"auto ";szVarName$;lszTmp$;";"
      'CASE ImRegister
        'IF IsVolatile THEN Abort("Regester volatile not supported")
        'FPRINT Outfile,Scoot$;"register ";szVarDecName$;" ";szVarName$;lszTmp$;";"

      'CASE ImCPPPrvDim
        'FPRINT Outfile,Scoot$;"private: ";szVarDecName$;" ";szVarName$;lszTmp$;";"

    'END SELECT

    'IF Ok2UseMemset THEN
      'szMemsetName$ = Clean$(EXTRACT$(szVarName$,"["))
      'FPRINT Outfile,Scoot$;"memset(&";szMemsetName$;",0,sizeof(";szMemsetName$;"));"
    'END IF

    'IF iType <> ImCPPPrvDim THEN
      'IF InTypeDef THEN
        'IF VarType = vt_UDT THEN
          'IF ComSwitchON THEN
            'IF TypeDefs[id].VarName$ = "OBJECT" THEN
              'Abort("Use of Object type in UDTs is Illegal!")
            'END IF
          'END IF
        'END IF
        'CALL AddTypedefElement(BaseTypeDefsCnt[InTypeDef], VarType, szVarName$, szVarTypeName$, 0)
      'ELSE
        'CALL AddLocal(szVarName$, VarType, 0, lszTmp$,0,0,0,0)
      'END IF
    'ELSE
      '' CALL AddClassVar()
    'END IF
    'EXIT SUB
  'END IF

  ''************************************************************************
  '' if we get here, we're creating with a GLOBAL variable
  ''************************************************************************
  'RAW iGlobalExtn

  'IF IsVolatile THEN
    'iGlobalExtn = 3
  'ELSE
    'IF VarType = vt_UDT THEN
      'IF ComSwitchON THEN
        'IF TypeDefs[id].VarName$ = "OBJECT" THEN
          'Add_COM_Global_Variable(szVarName$)
          'Use_COM = UseFlag = TRUE
        'END IF
      'END IF
    'END IF
    'iGlobalExtn = 0
  'END IF
  ''AddGlobal(GlobalName$, GlobalType, GlobalDef, GlobalDim$, GlobalPtr, GlobalFS, GlobalExtn, iEmitted, iConst)
  'CALL AddGlobal(szVarName$, VarType, 0,lszTmp$,0,0,iGlobalExtn,0,0)
'END SUB ' DimVar
'$COMMENT
$CPP
SUB DimVar(iType)
	RAW w = 0
	RAW id = 0
	RAW vt = 0
	RAW UseStatic$
	RAW IsVolatile
	RAW sVolatile$
	RAW IsALocalVar = FALSE
	RAW Ok2Initialize
	RAW NotInitialized = TRUE
	RAW szVarName$
	RAW VarType
	RAW IsSubOrFuncPtr
	RAW IsConsOrDestPtr
	RAW IsPointer
	RAW lszTmp$
	RAW DimType$
	RAW szVarTypeName$
	RAW szMemsetName$
	RAW szVarDecName$
	
	IF Stk[Ndx][0] = ASC(":") THEN
		CONCAT(Stk$[Ndx - 1], Stk$[Ndx])
		Ndx--
	END IF 
	
	IsDim = IsLocal = IsRaw =  IsStatic = FALSE
	IF iType = ImDim      THEN IsDim      = TRUE
	IF iType = ImLocal    THEN IsLocal    = TRUE
	IF iType = ImRaw      THEN IsDim      = IsRaw
	'IF iType = ImRegister THEN IsRegister = TRUE
	IF iType = ImStatic   THEN IsStatic   = TRUE
	
	IsVolatile = iMatchWrd(Stk$[2],"volatile")
	IF IsVolatile THEN
		'IF IsRegister THEN Abort("Register volatile not supported")
		sVolatile$ = "volatile "
	ELSE
		sVolatile$ = ""
	END IF
	
	IsSubOrFuncPtr = SubFuncTest()
	IsConsOrDestPtr = ConstructDestructTest(2)
	
	CALL HandleNonsense()
	IF Stk$[Ndx] = "*" THEN CALL PointerFix()
	IF Stk$[Ndx] = "&" THEN Stk$[Ndx--] = "" : CONCAT(Stk$[Ndx], "&")
	'*************************************************************************
	IF IsSubOrFuncPtr THEN
		IF IsVolatile THEN Abort("volatile SUB/FUNCTION pointers not supported")
		IF DimSubFunc(0) THEN EXIT SUB
	END IF
	
	IF IsConsOrDestPtr THEN
		IF IsVolatile THEN Abort("volatile SUB/FUNCTION pointers not supported")
		IF DimSubFunc(2) THEN EXIT SUB
	END IF
	
	'IF InFunc <> eNotInOne OR InTypeDef OR InBlock OR InNameSpace OR InClassModule THEN
	IF InFunc <> eNotInOne OR InTypeDef OR InBlock OR InNameSpace OR InClassModule OR InPPTypeModule THEN
		IsALocalVar = TRUE
	END IF
	
	'IF InTypeDef OR IsVolatile OR InNameSpace OR InClassModule THEN
	IF InTypeDef OR IsVolatile THEN
		Ok2Initialize = FALSE
	ELSE
		IF UseCpphdr THEN
			IF (iType BAND (ImDim BOR ImLocal)) <> 0 THEN
				Ok2Initialize = TRUE
			ELSE
				Ok2Initialize = FALSE
			END IF
		ELSE
			IF (iType BAND (ImDim BOR ImLocal )) <> 0 THEN
				Ok2Initialize = TRUE
			ELSE
				Ok2Initialize = FALSE
			END IF
		END IF
	END IF
	
	IF InTypeDef OR InNameSpace  THEN
		UseStatic$ = ""
		IsStatic = FALSE
	ELSE
		IF (iType BAND ImStatic) <> 0 THEN
			IsStatic = TRUE
			UseStatic$ = "static "
		ELSE
			UseStatic$ = ""
			IsStatic = FALSE
		END IF
	END IF
	
	szVarName$ = Clean$(Stk$[2+IsVolatile])
	
	CALL ValidVar(szVarName$)
	VarType = DataType(Stk$[2+IsVolatile])
	
	IF Stk$[3+IsVolatile] = "*" THEN       ' DIM MySTRING$ * NumBytes
		IF IsVolatile THEN Abort("volatile dynamic strings not supported")
		CALL DimDynaString(szVarName$, 0, 0)
		EXIT SUB
	END IF
	
	RAW iASoffset = GetAsPosB(Ndx, 2) ' AS offset
	
	IF iASoffset THEN
		RAW sConst$
		RAW iIsConst
		iIsConst = 0
		sConst$ = ""
		IF iASoffset = Ndx-2 THEN
			IF iMatchWrd(Stk$[Ndx-1],"const") THEN
				sConst$ = "const "
				iIsConst = 1
			END IF
		END IF
		IsPointer = TALLY(Stk$[Ndx],"*")
	
		CALL BuildStr(2+IsVolatile, iASoffset-1, lszTmp$)
		CALL BuildStr(3+IsVolatile, iASoffset-1, DimType$)
	
		IF INSTR(lszTmp$, "=") <> 0 THEN
			NotInitialized = FALSE
		END IF
	
		szVarTypeName$ = REMOVE$(Stk$[Ndx],"*")
		GetTypeInfo(szVarTypeName$, &w, &id, &vt)
		IF vt = vt_WINBOOL THEN
			IREPLACE "WINBOOL" WITH "BOOL" IN Stk$[Ndx]
		END IF
		'jcfuller 03/04/2016    
		'If Not IsBc9 Then
			'If vt = vt_BC9CHAR Then
				'cout << "vt_Bc9CHAR = " << vt_BC9CHAR << endl
				'cout << "vt in Dim Var = " << vt << endl
				'cout << "lszTmp$ = " << lszTmp$ << endl
				'cout << "DimType$ = " << DimType$ << endl
				'DimType$ = "bc9char"
			'End If	
		'End If
		IF vt = vt_STRVAR THEN
			Stk$[Ndx] = "char"
			szVarTypeName$ = Stk$[Ndx]
			CONCAT(DimType$, cSizeOfADefaultString)
			CONCAT(lszTmp$, cSizeOfADefaultString)
		END IF
	
		Stk$[Ndx] = RPAD$(Stk$[Ndx],7)
	
		IF vt = vt_FILEPTR THEN
			CONCAT(Stk$[Ndx], "*")
		END IF
	
		IF IsALocalVar THEN
			SELECT CASE iType
				CASE ImDim, ImLocal, ImRaw
					IF vt = vt_STRUCT THEN
						FPRINT Outfile, Scoot$;UseStatic$;sVolatile$;sConst$;"struct _" ; Stk$[Ndx]; "  ";
					ELSE
						FPRINT Outfile, Scoot$;UseStatic$;sVolatile$;sConst$;Stk$[Ndx];"  ";
					END IF
					IF InTypeDef AND NOT InBlock THEN
						IF vt = vt_UDT THEN
	  						IF ComSwitchON THEN
	    						IF TypeDefs[id].VarName$ = "OBJECT" THEN
	      							Abort("Use of Object type in UDTs is Illegal!")
	    						END IF
	  						END IF
						END IF
						CALL AddTypedefElement(BaseTypeDefsCnt[InTypeDef], vt, szVarName$, szVarTypeName$, 0)
					END IF
	
				CASE ImStatic
					FPRINT Outfile, Scoot$;UseStatic$;sVolatile$;sConst$;Stk$[Ndx];"  ";
				'CASE ImRegister
				'	FPRINT Outfile, Scoot$;"register  ";sConst$;Stk$[Ndx];"  ";
				CASE ImCPPPrvDim
					FPRINT Outfile, Scoot$;"private: ";Stk$[Ndx];"  ";
			END SELECT
	
			IF iType <> ImCPPPrvDim THEN
				IF NOT InTypeDef THEN
					IF vt = vt_UDT THEN
						IF ComSwitchON THEN
	  						IF TypeDefs[id].VarName$ = "OBJECT" THEN
	    						Add_COM_Global_Variable(szVarName$)
	    						Use_COM = UseFlag = TRUE
	  						END IF
						END IF
					END IF
					CALL AddLocal(szVarName$, vt, id, DimType$, IsPointer,0,0,iIsConst)
				END IF
			ELSE
				' CALL AddClassVar()
			END IF
	
			IF Ok2Initialize THEN
				szMemsetName$ = Clean$(EXTRACT$(lszTmp$,"["))
				IF IsPointer THEN
					IF NotInitialized THEN
						FPRINT Outfile,Clean$(lszTmp$); "={0};"
					ELSE
						FPRINT Outfile, Clean$(lszTmp$); ";"
					END IF
				ELSE
					'FPRINT Outfile, Scoot$;"memset(&";szMemsetName$;",0,sizeof(";szMemsetName$;"));"
					SELECT CASE vt
						CASE vt_BOOL, vt_BYTE, vt_DWORD, vt_INTEGER, vt_LONG, vt_SHORT, vt_UINT, vt_ULONG, vt_USHORT, vt_DWORD, vt_WORD, _
	     					vt_DOUBLE, vt_SINGLE, vt_LDOUBLE, vt_PCHAR, vt_LPBYTE

							IF NotInitialized THEN
	  							FPRINT Outfile,Clean$(lszTmp$); "={0};"
							ELSE
	  							FPRINT Outfile, Clean$(lszTmp$); ";"
							END IF
						CASE ELSE
							IF NotInitialized THEN
	  							FPRINT Outfile,Clean$(lszTmp$); "={0};"
							ELSE
	  							FPRINT Outfile, Clean$(lszTmp$); ";"
							END IF
					END SELECT
				END IF
			ELSE
				FPRINT Outfile, Clean$(lszTmp$); ";"
			END IF
		ELSE
			IF IsVolatile THEN
				'IF AS THEN USE ASCHECK TO SET vt
				CALL AddGlobal(szVarName$, vt, id, DimType$,IsPointer,0,3,0,iIsConst)
			ELSE
				IF vt = vt_UDT THEN
					IF ComSwitchON THEN
						IF TypeDefs[id].VarName$ = "OBJECT" THEN
	  						Add_COM_Global_Variable(szVarName$)
	  						Use_COM = UseFlag = TRUE
						END IF
					END IF
				END IF
				'If Not IsBc9 Then
					'cout << "szVarName -> " << szVarName$ << endl
					'cout << "vt        -> " << vt << endl
					'cout << "id        -> " << id << endl
					'cout << "DimType   -> " << DimType$ << endl   
				'End If	
				IF iType = ImRaw THEN
					CALL AddGlobal(szVarName$, vt, id, DimType$,IsPointer,0,2,0,iIsConst)
				ELSE
					CALL AddGlobal(szVarName$, vt, id, DimType$,IsPointer,0,0,0,iIsConst)
				END IF
			END IF
		END IF
		EXIT SUB
	END IF
	
	' Dimensioned without AS
	CALL BuildStr(3+IsVolatile, Ndx, lszTmp$)
	
	IF INSTR(lszTmp$, "=") <> 0 THEN
		NotInitialized = FALSE
	END IF
	
	IF IsALocalVar THEN lszTmp$ = LTRIM$(Clean$(lszTmp$))
	IF VarType = vt_STRVAR THEN CONCAT (lszTmp$, cSizeOfADefaultString)
	
	IF IsALocalVar THEN
		IF VarType = vt_STRVAR THEN
			szVarDecName$ = "char"
		ELSE
			szVarDecName$ = GetVarTypeName$(VarType)
		END IF
		szVarDecName$ = RPAD$(szVarDecName$, 7)
	
		IF UseCpphdr THEN
			DIM Ok2UseMemset
			Ok2UseMemset = Ok2Initialize
			SELECT CASE iType
				CASE ImDim, ImLocal, ImRaw, ImStatic
					IF (ImDim OR ImLocal) AND Ok2UseMemset THEN
						FPRINT Outfile,Scoot$;szVarDecName$;" ";szVarName$;lszTmp$;"={0};"
						Ok2UseMemset=FALSE
					ELSE
						FPRINT Outfile,Scoot$;UseStatic$;sVolatile$;szVarDecName$;" ";szVarName$;lszTmp$;";"
					END IF
				'CASE ImRegister
				'	IF IsVolatile THEN Abort("Register volatile not supported")
				'	FPRINT Outfile,Scoot$;"register ";szVarDecName$;" ";szVarName$;lszTmp$;";"
				CASE ImCPPPrvDim
					FPRINT Outfile,Scoot$;"private: ";szVarDecName$;" ";szVarName$;lszTmp$;";"
			END SELECT
			IF Ok2UseMemset THEN
				szMemsetName$ = Clean$(EXTRACT$(szVarName$,"["))
				FPRINT Outfile,Scoot$;"memset(&";szMemsetName$;",0,sizeof(";szMemsetName$;"));"
			END IF
		ELSE
			SELECT CASE iType
				CASE ImDim, ImLocal, ImStatic, ImRaw
					IF NotInitialized AND Ok2Initialize THEN
						FPRINT Outfile, Scoot$;UseStatic$;sVolatile$;szVarDecName$;" ";szVarName$;lszTmp$;"={0};"
					ELSE
						FPRINT Outfile, Scoot$;UseStatic$;sVolatile$;szVarDecName$;" ";szVarName$;lszTmp$;";"
					END IF
				'CASE ImRegister
				'	IF IsVolatile THEN Abort("Register volatile not supported")
				'	IF NotInitialized AND Ok2Initialize THEN
				'		FPRINT Outfile, Scoot$;"register ";szVarDecName$;" ";szVarName$;lszTmp$;"={0};"
				'	ELSE
				'		FPRINT Outfile, Scoot$;"register ";szVarDecName$;" ";szVarName$;lszTmp$;";"
				'	END IF	
				CASE ImCPPPrvDim
					IF NotInitialized AND Ok2Initialize THEN
						FPRINT Outfile, Scoot$;"private: ";szVarDecName$;" ";szVarName$;lszTmp$;"={0};"
					ELSE
						FPRINT Outfile, Scoot$;"private: ";szVarDecName$;" ";szVarName$;lszTmp$;";"
					END IF
				END SELECT
		END IF	
		IF iType <> ImCPPPrvDim THEN
			IF InTypeDef THEN
				IF VarType = vt_UDT THEN
					IF ComSwitchON THEN
						IF TypeDefs[id].VarName$ = "OBJECT" THEN
	  						Abort("Use of Object type in UDTs is Illegal!")
						END IF
					END IF
				END IF
				CALL AddTypedefElement(BaseTypeDefsCnt[InTypeDef], VarType, szVarName$, szVarTypeName$, 0)
			ELSE
				CALL AddLocal(szVarName$, VarType, 0, lszTmp$,0,0,0,0)
			END IF
		ELSE
		' CALL AddClassVar()
		END IF
		EXIT SUB
	END IF
	
	'************************************************************************
	' if we get here, we're creating with a GLOBAL variable
	'************************************************************************
	
	RAW iGlobalExtn
	IF IsVolatile THEN
		iGlobalExtn = 3
	ELSE
		IF VarType = vt_UDT THEN
			IF ComSwitchON THEN
				IF TypeDefs[id].VarName$ = "OBJECT" THEN
					Add_COM_Global_Variable(szVarName$)
					Use_COM = UseFlag = TRUE
				END IF
			END IF
		END IF
		iGlobalExtn = 0
	END IF
	'AddGlobal(GlobalName$, GlobalType, GlobalDef, GlobalDim$, GlobalPtr, GlobalFS, GlobalExtn, iEmitted, iConst)
	CALL AddGlobal(szVarName$, VarType, 0,lszTmp$,0,0,iGlobalExtn,0,0)
END SUB ' DimVar



FUNCTION Emit_CPP(sWord$, FuncRetnFlag AS PINT)
  *FuncRetnFlag = 0
  SELECT CASE sWord$
    CASE "asm"

    CASE "catch"
      RAW VarCode AS VARCODE
      VarCode.IsExported = FALSE
      VarCode.UseInLine = UseInLine
      CALL InBlockReSet()
      szTmp$ = ""
      IF Ndx > 1 THEN
        RAW A
        CALL FuncSubDecs1("sub", 1, Ndx, &VarCode)
        CALL FuncSubDecs2("sub", mt_Opts, &VarCode, 1, &Ndx)
        VarCode.Methd% = mt_FuncSubDecC_DecAParam
        A = 3
        WHILE A < Ndx
          ' GetParameter(piStart AS PINT,ptVar AS VARCODE PTR, iAParam AS INT, iNoParam AS INT, iOptOk AS INT)
          'IF *Stk$[A] THEN CALL GetParameter(&A,&VarCode, mt_OptsAParam, mt_OptsNoParam, 1)
          CALL GetParameter(&A,&VarCode, mt_OptsAParam, mt_OptsNoParam, 1)
          A++
        WEND

        VarCode.Methd% = mt_FuncSubDecC_DecAParam
        VarCode.Token$ = Stk$[1]
        FuncSubDecs3(&VarCode, Ndx, 0)
        szTmp$ = VarCode.Header$
      ELSE
        szTmp$ = "catch (const char *str)"
      END IF
      FPRINT Outfile,Scoot$;"}"
      CALL BumpDown("Extra un-indent(s) and/or missing indents before CATCH")
      CALL InBlockSet()
      FPRINT Outfile,Scoot$;szTmp$
      CALL BumpUp()
      FPRINT Outfile,Scoot$;"{"

    CASE "delete"
      RAW szTmp$
      CALL BuildCleanStr(2, Ndx, szTmp$)
      FPRINT Outfile,Scoot$;"delete ";szTmp$;";"

    CASE "class","struct","interface"
      IF InClassModule OR InTypeDef OR InFunc <> eNotInOne OR InPPTypeModule OR Stk$[2] = "" THEN CALL Abort("Syntax Error")
      InClassModuleName$ = Stk$[2]
      'FPRINT FP_UDT,""
		IF UsingTemplate = FALSE THEN FPRINT FP_UDT,""

      IF InIfDef$ <> "" AND InIfDef$ <> "FP3" THEN
        FPRINT FP_UDT, InIfDef$
      END IF

      'FPRINT FP_UDT,"class ";
      FPRINT FP_UDT,sWord$," ";
      Outfile = FP_UDT
      FOR INT i = 2 TO Ndx
        IF iMatchWrd(Stk$[i+1], "inherits") THEN
          CONCAT(Stk$[i],":")
          Stk$[i+1] = "public"
        END IF
        IF Stk$[i] = "using" THEN
          FPRINT FP_UDT," : ";
          ITERATE
        END IF
        IF Stk$[i] = "::" THEN
          FPRINT FP_UDT," : ";
        ELSE
          IF iMatchWrd(Stk$[i], "private") THEN Stk$[i] = "private"
          IF iMatchWrd(Stk$[i], "public") THEN Stk$[i] = "public"
          AddSpace(i)
          FPRINT FP_UDT, Stk$[i];
        END IF
      NEXT
      CALL BumpUp
      FPRINT FP_UDT,"\n";Scoot$;"{"
      INCR InClassModule
      InClassPP$ = ""

      'jcfuller added 08/11/2013 from bcx 7.0.7
      IF UsingTemplate THEN WasAClassModule = TRUE 'IF UsingTemplate = TRUE THEN WasAClassModule = TRUE
      ' Add loop control test

    CASE "endclass","endstruct","endinterface"
      IF InClassModule <> 1 THEN CALL Abort("Syntax Error")
      CALL BumpDown("Extra un-indent(s) and/or missing indents before END CLASS")
      FPRINT FP_UDT,Scoot$;"};"
      FPRINT FP_UDT, ""
      CALL BumpDown("Extra un-indent(s) and/or missing indents before END CLASS")
      DECR InClassModule
      Outfile = FP2
      InClassModuleName$ = ""
      InClassPP$ = ""
      ' Add loop control test

    CASE "namespace"
      Outfile = FP_UDT
      FPRINT Outfile,Scoot$;"namespace ";Stk$[2]
      CALL BumpUp
      FPRINT Outfile,Scoot$;"{"
      InNameSpace++

    CASE "endnamespace"
      FPRINT FP_UDT,Scoot$;"};\n"
      CALL BumpDown("Extra un-indent(s) and/or missing indents before END NAMESPACE")
      InNameSpace--

    'CASE "throw"
      'RAW szTmp$
      'IF Ndx = 2 THEN
        'szTmp$ = Stk$[2]
      'ELSE
        'szTmp$ = ENC$("An Exception has occured!")
      'END IF
      'FPRINT Outfile,Scoot$;"throw ";szTmp$;";"
'Wayne's fix of 07/09/2013
    CASE "throw"
      RAW szTmp$
      IF Ndx = 1 THEN
        szTmp$ = ENC$("An Exception has occured!")
      ELSE
        CALL BuildDelimStr(2, Ndx, szTmp$)
      END IF
      FPRINT Outfile, Scoot$;"throw ";szTmp$;";"

    CASE "try"
      FPRINT Outfile,Scoot$;"try"
      CALL BumpUp()
      FPRINT Outfile,Scoot$;"{"
      CALL InBlockSet()
      ' Add loop control test

    CASE "endtry"
      FPRINT Outfile,Scoot$;"}"
      CALL BumpDown("Extra un-indent(s) and/or missing indents in TRY/END TRY")
      CALL InBlockReSet()
      ' Add loop control test

    'CASE "const_cast"
    ' Handled as reserved word

    'CASE "dynamic_cast"
    '  Handled as normal reserve word
    'CASE "explicit"
    '  Handle as normal reserve word?
    CASE "friend"

    CASE "inline"

    CASE "mutable"

    CASE "private"
      IF Stk$[2] = ":" THEN
        IF InClassPP[0] THEN FPRINT FP_UDT, "" : CALL BumpDown("Error in Emit_CPP() CASE private")
        FPRINT FP_UDT,Scoot$;"private:"
        CALL BumpUp()
        InClassPP$ = "private"
        FUNCTION = 0
      END IF

    CASE "public"
      IF Stk$[2] = ":" THEN
        IF InClassPP[0] THEN FPRINT FP_UDT, "" : CALL BumpDown("Error in Emit_CPP() CASE public")
        FPRINT FP_UDT,Scoot$;"public:"
        CALL BumpUp()
        InClassPP$ = "public"
        FUNCTION = 0
      END IF

    CASE "property"
      RAW szTMP$
      CALL BuildDelimStr(1, Ndx-1, szTMP$)
      FPRINT FP_UDT,Scoot$;szTMP$;" ";Stk$[Ndx];";"
      FUNCTION = 0

    CASE "protected"
      IF Stk$[2] = ":" THEN
        IF InClassPP[0] THEN FPRINT FP_UDT, "" : CALL BumpDown("Error in Emit_CPP() CASE protected")
        FPRINT FP_UDT,Scoot$;"protected:"
        CALL BumpUp()
        InClassPP$ = "protected"
        FUNCTION = 0
      END IF

    'CASE "reinterpret_cast"
    ' Handled as reserve word

    'CASE "static_cast"
    ' Handled as reserve word

    CASE "typename"

    'CASE "virtual"
    '  Transformed into a DIM SUB/FUNCTION setting IsVirtual and szVirtual$

    CASE ELSE
      CALL EmitOld(FuncRetnFlag)

  END SELECT

  FUNCTION = 0
END FUNCTION ' Emit_CPP



FUNCTION Emit_DialogBox(sWord$, FuncRetnFlag AS PINT)

  SELECT CASE sWord$

    CASE "dialogbox" 'HELPER
      RAW Comma = 0
      FPRINT Outfile,Scoot$;"DialogBox";

      FOR INT A = 2 TO Ndx
        IF Stk$[A] = "," THEN Comma++

        IF Comma = 3 THEN
          IF Stk$[A] = "," THEN Stk$[A] = ",(DLGPROC)"
        END IF

        FPRINT Outfile,Clean$(Stk$[A]);
      NEXT

      FPRINT Outfile,";"

    CASE ELSE
      CALL EmitOld(FuncRetnFlag)

  END SELECT
  FUNCTION = 0
END FUNCTION ' Emit_DialogBox



FUNCTION Emit_ConditionalCompilation(sWord$, FuncRetnFlag AS PINT)
  SELECT CASE sWord$

    CASE "~ifndef"
      InIfDef$ = "#ifndef "
      FOR INT i = 2 TO Ndx
        InIfDef$ = InIfDef$ + Stk$[i] + " "
      NEXT
      InIfDef$ = TRIM$(InIfDef$)
      IF InFunc <> eNotInOne OR InMain THEN
        FPRINT Outfile,InIfDef$
      ELSE
        FPRINT FP_CST,InIfDef$
      END IF

    CASE "~if"
      InIfDef$ = "#if defined "
      FOR INT i = 2 TO Ndx
        InIfDef$ = InIfDef$ + Stk$[i] + " "
      NEXT
      InIfDef$ = TRIM$(InIfDef$)
      ConstLastDef$ = InIfDef$
      IF InFunc <> eNotInOne THEN
        'IF Outfile = FP3 THEN FPRINT Outfile,"// FP3"
        'IF Outfile = FP2 THEN FPRINT Outfile,"// FP2"

        'jcfuller changed 07/07/2013
        'FPRINT Outfile,InIfDef$,"// OUTFILE"
        FPRINT Outfile,InIfDef$
        InIfDef$ = "FP3"
      ELSE
        IF InMain THEN
          FPRINT Outfile, InIfDef$, "// --FP2--"
        END IF
      END IF

    CASE "~else"
      InIfDef$ = "#else"
      ConstLastDef$ = InIfDef$
      IF InFunc <> eNotInOne OR InMain THEN
        FPRINT Outfile,InIfDef$
      ELSE
        FPRINT FP_CST,InIfDef$
      END IF

    CASE "~elseif"
      InIfDef$ = "#elif defined "
      FOR INT i = 2 TO Ndx
        InIfDef$ = InIfDef$ + Stk$[i] + " "
      NEXT
      InIfDef$ = TRIM$(InIfDef$)
      ConstLastDef$ = InIfDef$
      IF InFunc <> eNotInOne OR InMain THEN
        FPRINT Outfile, InIfDef$
      ELSE
        FPRINT FP_CST,InIfDef$
      END IF

    CASE "~endif"
      IF InIfDef$ = "FP3" THEN
        FPRINT FP3,"#endif  // FP3"
      ELSE 'elseif InMain THEN
        'FPRINT Outfile,"#endif  // Main"
        FPRINT Outfile,"#endif"
      END IF

      IF ConstLastDef$ = "FP_CST" THEN
        FPRINT FP_CST,"#endif  // FP_CST"
      END IF
      InIfDef$ = "#endif  // other"


    IF InConditional = 0 THEN
      InIfDef$ = ""
      ConstLastDef$ = ""
      'DidConsts = 0
    END IF

    CASE "~pragmaoptimizeon"
      FPRINT Outfile,"#ifdef __POCC__"
      FPRINT Outfile,"#pragma optimize(time)"
      FPRINT Outfile,"#endif"

      FPRINT Outfile,"#ifdef __LCC__"
      FPRINT Outfile,"#pragma optimize(1)"
      FPRINT Outfile,"#endif"

    CASE "~pragmaoptimizeoff"
      FPRINT Outfile,"#ifdef __POCC__"
      FPRINT Outfile,"#pragma optimize(none)"
      FPRINT Outfile,"#endif"

      FPRINT Outfile,"#ifdef __LCC__"
      FPRINT Outfile,"#pragma optimize(0)"
      FPRINT Outfile,"#endif"

    CASE ELSE
      CALL EmitOld(FuncRetnFlag)

  END SELECT
  FUNCTION = 0
END FUNCTION ' Emit_ConditionalCompilation



FUNCTION Emit_Shared_Global(sWord$, FuncRetnFlag AS PINT)
  SELECT CASE sWord$

    CASE "shared", "global"
      RAW w = 0
      RAW SOF$
      RAW IsShared
      RAW IsVolatile
      RAW IsSubOrFuncPtr
      RAW CVar$
      RAW id, vt, dms, IsPointer
      RAW ZZ$

      IsSubOrFuncPtr = SubFuncTest()
      CALL HandleNonsense
      IsVolatile = iMatchWrd(Stk$[2],"volatile")
      CVar$ = Clean$(Stk$[2+IsVolatile])
      CALL ValidVar(CVar$)

      IsShared = iMatchWrd(Stk$[1],"shared")

      IF Stk$[Ndx] = "*" THEN CALL PointerFix
      IF Stk$[Ndx] = "&" THEN Stk$[Ndx--] = "" : CONCAT(Stk$[Ndx], "&")

      IF Stk$[3+IsVolatile] = "*" THEN
        IF IsVolatile THEN Abort("volatile dynamic strings not supported")
        CALL DimDynaString(CVar$, 1, IsShared)
        EXIT SELECT
      END IF

      IF IsSubOrFuncPtr THEN
        IF IsVolatile THEN Abort("volatile SUB/FUNCTION pointers not supported")
        CALL DimSubFunc(0)
        EXIT SELECT
      END IF

      IF iMatchWrd(Stk$[2],"dynamic") THEN
        CVar$ = Clean$(Stk$[3])

        CALL ValidVar(CVar$)
        IF iMatchWrd(Stk$[Ndx-1],"as") THEN
          SOF$ = Stk$[Ndx]
          GetTypeInfo(SOF$, &w, &id, &vt)
          IF vt = vt_STRLIT OR vt = vt_DECFUNC OR vt = vt_NUMBER OR (vt = vt_VOID AND INCHR(Stk$[Ndx],"*") = 0) THEN
            Abort(Stk$[Ndx] + " is not a valid type")
          END IF
          Ndx -= 2
        ELSE
          vt = DataType(Stk$[3])
          id = 0
          SOF$ = GetVarTypeName$(vt)
        END IF

        Use_DynamicA = TRUE
        UseFlag      = TRUE

        CALL BuildStr(4, Ndx, ZZ$)
        dms = TALLY(ZZ$,"][") + 1

        IF dms > 1 THEN REPLACE "][" WITH "," IN ZZ$

        ZZ$ = Clean$(ZZ$)
        RemoveAll(ZZ$,"[]")

        IF vt = vt_STRVAR THEN
          vt = vt_CHAR
          SOF$ = "char"
          dms++
          CONCAT(ZZ$,",")
          CONCAT(ZZ$,csSizeOfDefaultString$)
        END IF

        IF Use_GenFree THEN
          CALL AddDynamicGlobal("if (" + CVar$ + ") { DestroyArr((void **)" + CVar$ + "," + STR$(dms) + ", 1); " +  CVar$ + "=NULL; }")
        END IF

        CALL AddGlobal(CVar$, vt, id,"",dms,0,0,0,0)
'cout << "37783 CreateArr" << endl
 'jcfuller changed 02/20/2016
		FPRINT Outfile,Scoot$;"{"
		FPRINT Outfile,Scoot$;"size_t dimensions[";TRIM$(STR$(dms));"] = {";ZZ$;"};" 
		FPRINT Outfile,Scoot$;CVar$ ; "= ("; SOF$ ;STRING$(dms,42);")CreateArr ("; CVar$ ; ",sizeof(";SOF$;"),0,";TRIM$(STR$(dms));",dimensions);"
		FPRINT Outfile,Scoot$;"}"
        'FPRINT Outfile,Scoot$;CVar$ ; "= ("; SOF$ ;STRING$(dms,42);")CreateArr ("; CVar$ ; ",sizeof(";SOF$;"),0,";TRIM$(STR$(dms));"," ; ZZ$ ; ");"

        EXIT SELECT
      END IF

      IsPointer = 0

      Var$ = Clean$(Stk$[2+IsVolatile])
      CALL ValidVar(Var$)

      IF iMatchWrd(Stk$[Ndx-1],"as") THEN
        IF INCHR(Stk$[Ndx],"*") THEN
          IsPointer = TALLY(Stk$[Ndx],"*")
          Stk$[Ndx] = REMOVE$(Stk$[Ndx],"*")
        END IF
        CALL BuildStr(3+IsVolatile, Ndx-2, DimType$)
        GetTypeInfo(Stk$[Ndx], &w, &id, &vt)
      ELSE
        CALL BuildStr(3+IsVolatile, Ndx, DimType$)
        vt = DataType(Stk$[2+IsVolatile])
        id = 0
      END IF

      IF vt = vt_STRVAR THEN
        CONCAT (DimType$, cSizeOfADefaultString)
      END IF
      'global object in sub/func
      IF vt = vt_UDT THEN
        IF ComSwitchON THEN
          IF TypeDefs[id].VarName$ = "OBJECT" THEN
            Add_COM_Global_Variable(CVar$)
            Use_COM = UseFlag = TRUE
          END IF
        END IF
      END IF

      w =0
      IF IsShared THEN w = 2
      IF IsVolatile THEN w = w + 3
      CALL AddGlobal(Var$, vt, id, DimType$, IsPointer,0,w,0,0)

    CASE ELSE
      CALL EmitOld(FuncRetnFlag)

  END SELECT
  FUNCTION = 0
END FUNCTION ' Emit_Shared_Global



FUNCTION Emit_EndFuncSub(sWord$, FuncRetnFlag AS PINT)
  SELECT CASE sWord$

    CASE "endfunction", "endsub"
'		UsingTemplate = 0
      IF LoopTypeCnt THEN
        CALL LoopErrorMsg()
      END IF

      IF lc_COM_names_index > 0 THEN
        ' cleaning local COM objects if user forgot to
        ' call xxx = Nothing for each declared object
        CALL BCX_FreeLocalCOMObjects(TRUE)
      END IF

      IF iMatchWrd(Stk$[1],"endfunction") THEN
        InWinMain = FALSE
'03/28/2016
'revert back         
'Robert's fix for DYNAMIC deallocation in Function main()
'02/11/2016
'------------------------------------------------------------------------------
        LocalDynaCnt = 0
        LocalDynArrCnt = 0
        ' Clean up dynamic strings
        'IF LocalDynaCnt <> 0 THEN
          'FOR INT j = 1 TO LocalDynaCnt
            'FPRINT Outfile, Scoot$;DynaStr$[j]
          'NEXT
          'LocalDynaCnt = 0
        'END IF
        '' Clean up dynamic strings arrays
        'IF LocalDynArrCnt <> 0 THEN
          'FOR INT i = 1 TO LocalDynArrCnt
            'FPRINT Outfile, Scoot$;LocalDynArrName$[i]
          'NEXT
          'LocalDynArrCnt = 0
        'END IF
'------------------------------------------------------------------------------
        IF InDialogEvt THEN
          FPRINT Outfile,Scoot$;"if(Msg==WM_CLOSE) DestroyWindow(hWnd);"
          FPRINT Outfile,Scoot$;"return 0;"
          InDialogEvt = FALSE
        END IF

        IF ModDialogEvt THEN
          FPRINT Outfile,Scoot$;"if(Msg==WM_CLOSE) EndDialog(hWnd,0);"
          FPRINT Outfile,Scoot$;"return 0;"
          ModDialogEvt = FALSE
        END IF

        IF CallBackFlag THEN
          FPRINT Outfile,Scoot$;"return DefWindowProc(hWnd, Msg, wParam, lParam);"' // CallBackFlag"
          CallBackFlag = FALSE
        END IF
      END IF

      IF iMatchWrd(Stk$[1],"endsub") THEN
        ' Clean up dynamic strings
        IF LocalDynaCnt <> 0 THEN

          FOR INT j = 1 TO LocalDynaCnt
            FPRINT Outfile,Scoot$;DynaStr$[j]
          NEXT

          LocalDynaCnt = 0
        END IF
        ' Clean up dynamic strings arrays
        IF LocalDynArrCnt <> 0 THEN

          FOR INT i = 1 TO LocalDynArrCnt
            FPRINT Outfile,Scoot$;LocalDynArrName$[i]
            'cout << "37814" << endl
          NEXT

          LocalDynArrCnt = 0
        END IF
      END IF

      IF ForceMainToFunc THEN          'IF ForceMainToFunc = TRUE THEN
        ForceMainToFunc = FALSE
      END IF

      CALL BumpDown("Extra un-indent(s) and/or missing indents before END")

      IF InNameSpace OR InClassModule OR InPPTypeModule THEN
        FPRINT FP_UDT,Scoot$;"}\n"
        RAW iIndentsUsed AS INT, szErr$
        iIndentsUsed = 0
        szErr$ = ""
        IF InNameSpace THEN iIndentsUsed += (InNameSpace * cINDENT):szErr$ = " Namespace,"
        IF InClassModule THEN iIndentsUsed += ((InClassModule+1) * cINDENT):CONCAT(szErr$," Class Module,")
        IF InPPTypeModule THEN iIndentsUsed += (InPPTypeModule * cINDENT):CONCAT(szErr$," PPType,")
        IF Indent > iIndentsUsed THEN
          szErr$ = LEFT$(szErr$,LEN(szErr$)-1)
          szErr$ = "Possible missing ("+USING$("##",(Indent - iIndentsUsed)/2)+") END statements in"+szErr$+" SUB/FUNCTION"
          CALL Abort(szErr$)
        END IF
      ELSE
        FPRINT Outfile,Scoot$;"}\n\n"
        IF Indent > 0 THEN
          RAW szErr$
          szErr$ = "Possible missing ("+USING$("##",Indent/2)+") END statements in SUB/FUNCTION"
          CALL Abort(szErr$)
        END IF
      END IF

      'InFunc = FALSE
      InFunc = eNotInOne
      Use_Static = FALSE

      IF Outfile = FP3 THEN
        InIfDef$ = "FP3"
      END IF

      IF NOT (InNameSpace OR InClassModule) THEN
        Outfile = FP2
      END IF
      ByrefCnt = 0

    CASE ELSE
      CALL EmitOld(FuncRetnFlag)

  END SELECT
  FUNCTION = 0
END FUNCTION ' Emit_EndFuncSub



FUNCTION Emit_Type(sWord$, FuncRetnFlag AS PINT)
  SELECT CASE sWord$
    CASE "type"
      RAW i, j
      IF InTypeDef = 0 THEN
        SaveOutfileNum = Outfile
      END IF
      Outfile = FP_UDT
      IF Ndx > 2 THEN
        IF InTypeDef THEN
          CALL Abort("Single line TYPE within type/union not supported")
        END IF

        i = GetAsPosB(Ndx,1)

        IF i = 0 THEN
          CALL Abort("Missing AS TYPE")
        END IF
        FPRINT Outfile,Scoot$;"typedef ";
        j = i-1
        i++

        WHILE i <= Ndx
          FPRINT Outfile,Stk$[i];" ";
          i++
        WEND

        FOR i = 2 TO j
          FPRINT Outfile,Stk$[i];
        NEXT
        FPRINT Outfile,";"
        Outfile = SaveOutfileNum
      ELSE
        InTypeDef++
        IF cMaxBaseTypeDefs = InTypeDef THEN CALL Abort("Maximum number of nested TypeDefs exceeded.")
        TypeDefName$[InTypeDef] = Stk$[2]
        CALL AddTypeDefs(TypeDefName$[InTypeDef],vt_STRUCT)
        BaseTypeDefsCnt[InTypeDef] = TypeDefsCnt
        IF InClassModule OR InTypeDef > 1 THEN
          FPRINT Outfile,Scoot$;"struct"
          FPRINT Outfile,Scoot$;"{"
          CALL AddTypedefElement(BaseTypeDefsCnt[InTypeDef-1],vt_STRUCT,TypeDefName$[InTypeDef],TypeDefName$[InTypeDef], 0)
        ELSE
          FPRINT Outfile,""
          FPRINT Outfile,"typedef struct _";TypeDefName$[InTypeDef]
          FPRINT Outfile,"{"
        END IF
        CALL BumpUp
      END IF

    CASE "endtype"
      CALL BumpDown("Extra un-indent(s) and/or missing indents in TYPE/END TYPE")
      IF InClassModule THEN
        FPRINT Outfile,Scoot$;"} ";TypeDefName$[InTypeDef];";"
        FPRINT Outfile,""
      ELSE
        RAW szTDNames$
        szTDNames$ = ""
        IF Ndx > 1 THEN
          RAW i, j
          i = GetAsPosB(Ndx,1)
          IF i = 0 THEN CALL Abort("Missing AS after END TYPE")
          szTDNames$ = ", "
          FOR INT ii = i+1 TO Ndx
            j = INSTR(Stk$[ii],"*")
            IF j THEN Stk$[ii] = MID$(Stk$[ii],j)+LEFT$(Stk$[ii], j - 1)
            CONCAT(szTDNames$, Stk$[ii])
          NEXT
        END IF
        IF InTypeDef = 1 THEN
          FPRINT Outfile, "}";TypeDefName$[InTypeDef];", *";"LP";UCASE$(TypeDefName$[InTypeDef]); szTDNames$; ";"
          FPRINT Outfile, ""
          Outfile = SaveOutfileNum
          FPRINT FP_CST,Scoot$;"#define ",UCASE$(TypeDefName$[InTypeDef]),"_CLASS struct _",UCASE$(TypeDefName$[InTypeDef]),"*"
        
        'cout << "PROBLEM AREA" << endl
        
        ELSE
          FPRINT Outfile, Scoot$;"} ";TypeDefName$[InTypeDef];szTDNames$;";"
          FPRINT Outfile, ""
        END IF
      END IF
      InTypeDef--
  END SELECT
  FUNCTION = 0
END FUNCTION ' Emit_Type



FUNCTION Emit_Union(sWord$, FuncRetnFlag AS PINT)
  SELECT CASE sWord$
    CASE "union"

      IF InTypeDef = 0 THEN
        SaveOutfileNum = Outfile
      END IF
      Outfile = FP_UDT
      InTypeDef++
      IF cMaxBaseTypeDefs = InTypeDef THEN CALL Abort("Maximum number of nested TypeDefs exceeded.")
      TypeDefName$[InTypeDef] = Stk$[2]
      CALL AddTypeDefs(TypeDefName$[InTypeDef],vt_UNION)
      BaseTypeDefsCnt[InTypeDef] = TypeDefsCnt
      FPRINT Outfile,""
      IF InTypeDef = 1 THEN
        FPRINT Outfile,"typedef union "
        FPRINT Outfile,"{"
      ELSE
        FPRINT Outfile,Scoot$;"union"
        FPRINT Outfile,Scoot$;"{"
        CALL AddTypedefElement(BaseTypeDefsCnt[InTypeDef-1],vt_UNION,TypeDefName$[InTypeDef],TypeDefName$[InTypeDef], 0)
      END IF
      CALL BumpUp

    CASE "endunion"
      CALL BumpDown("Extra un-indent(s) and/or missing indents in UNION/END UNION")
      IF InTypeDef = 1 THEN
        FPRINT Outfile,"} ";TypeDefName$[InTypeDef];", *";"LP";UCASE$(TypeDefName$[InTypeDef]); ";"
        Outfile = SaveOutfileNum
      ELSE
        FPRINT Outfile,Scoot$;"} ";TypeDefName$[InTypeDef];";"
      END IF
      FPRINT Outfile,""
      InTypeDef--

    CASE ELSE
      CALL EmitOld(FuncRetnFlag)

  END SELECT
  FUNCTION = 0
END FUNCTION ' Emit_Union


FUNCTION Emit_PPType(sWord$, FuncRetnFlag AS PINT)
  SELECT CASE sWord$

    CASE "pptype"
      Outfile = FP_UDT
      IF InClassModule OR InTypeDef OR InFunc <> eNotInOne OR InPPTypeModule OR Stk$[2] = "" THEN CALL Abort("Syntax Error")
      FPRINT FP_UDT,""

      IF InIfDef$ <> "FP3" AND InIfDef$ <> "" THEN
        FPRINT FP_UDT, InIfDef$
      END IF

      FPRINT FP_UDT,"struct ";
      FOR INT i = 2 TO Ndx
      	IF iMatchWrd(Stk$[i], "using") THEN Stk$[i] = ": "
        AddSpace(i)
        FPRINT FP_UDT, Stk$[i];
      NEXT
      CALL BumpUp
      FPRINT FP_UDT,"\n";Scoot$;"{"
      InPPTypeModule++
      ' Add loop control test

    CASE "endpptype"
      IF InPPTypeModule <> 1 THEN CALL Abort("Syntax Error")
      CALL BumpDown("Extra un-indent(s) and/or missing indents before END PPTYPE")
      FPRINT FP_UDT,Scoot$;"};"
      InPPTypeModule--
      ' Add loop control test

    CASE ELSE
      CALL EmitOld(FuncRetnFlag)

  END SELECT
  FUNCTION = 0
END FUNCTION ' Emit_PPType



SUB GetParameterASHelper(iEQPos AS INT, iASPos AS INT, iOptOk AS INT, iLoc AS INT)
  IF iOptOk = 0 THEN CALL Abort("Optional variables not supported without OPTIONAL")
  RAW iLast
  IF iASPos = 0 THEN
    iLast = iLoc
  ELSE
    IF iASPos < iEQPos THEN
      iLast = iLoc
    ELSE
      iLast = iASPos-1
    END IF
  END IF
  FOR INT i = iEQPos+1 TO iLast
    CONCAT(Stk$[iEQPos]," ")
    CONCAT(Stk$[iEQPos],Stk$[i])
    Stk$[i] = ""
  NEXT
END SUB ' GetParameterASHelper



SUB GetParameter(piStart AS PINT,ptVar AS VARCODE PTR, iAParam AS INT, iNoParam AS INT, iOptOk AS INT)
  RAW iASPos = 0
  RAW iEQPos = 0
  RAW iNd
  RAW iLoc = *piStart
  IF Stk$[iLoc] = "" THEN EXIT SUB

  ptVar->Token$ = Clean$(Stk$[iLoc])
  DO
    IF Stk$[iLoc+1] = "(" THEN
      ' function as parameter type
      RAW iEndPoint
      RAW lszTmp$
      RAW iStartPoint
      RAW FP AS functionParse
      CallType$ = ""
      CALL SepFuncArgs(iLoc-1, &FP, TRUE)
      'jcf 11/02/2013
      'iStartPoint = MAX(FP.CommaPos[0], iLoc)
      iStartPoint = max(FP.CommaPos[0], iLoc)
      SFPOINTER = TRUE
      '------------------------------------------------------
      '  Get intialized data  " = xxx" or "= {xxx,xxx}"
      '------------------------------------------------------
      IF FP.NumArgs = 0 THEN
        'iEndPoint = MIN(FP.CommaPos[1]+1, Ndx)
        iEndPoint = min(FP.CommaPos[1]+1, Ndx)
      ELSE
        'iEndPoint = MIN(FP.CommaPos[FP.NumArgs]+1, Ndx)
        iEndPoint = min(FP.CommaPos[FP.NumArgs]+1, Ndx)
      END IF

      IF Stk$[iEndPoint] = "=" THEN
        Stk$[iEndPoint++] = ""
        WHILE NOT iMatchWrd(Stk$[iEndPoint], "as") AND iEndPoint <= Ndx
          lszTmp$ = lszTmp$ +Stk$[iEndPoint]
          Stk$[iEndPoint++] = ""
        WEND
        RemoveAll(lszTmp$, "{}", 1)
        IF lszTmp$ <> "" THEN CALL RemEmptyTokens()
      END IF
      '------------------------------------------------------
      RAW Funcname$
      RAW OldiEndPoint
      IF iMatchWrd(Stk$[iEndPoint], "as") THEN
        iEndPoint++
        IF iMatchWrd(Stk$[iEndPoint], "function") THEN CALL DeleteTokens(iEndPoint, 1)
        WHILE *Stk$[iEndPoint] <> ASC(",") AND *Stk$[iEndPoint] <> ASC(")")
          IF Stk$[iEndPoint] = "" THEN
            CALL DeleteTokens(iEndPoint, 1)
          ELSE
            iEndPoint++
          END IF
        WEND
        'iEndPoint--
      END IF
      OldiEndPoint = iEndPoint

      RAW tVar AS VARCODE
      tVar.IsExported = FALSE
      tVar.UseInLine = UseInLine

      *piStart = iStartPoint-1
      CALL InsertTokens((*piStart)-1, 1, "function")

'IF _ZTRACE_ Then
'	zTrace(ANSITOWIDE((char*)"Hello From GetParameter"))
'	zTrace(ANSITOWIDE((char*) "iEndPoint = " + Str$(iEndPoint)))
'END IF

      CALL FuncSubDecs1("sub", iStartPoint-1, iEndPoint, &tVar)
      CALL FuncSubDecs2("sub", mt_FuncSubDecC_Dec, &tVar, *piStart, &OldiEndPoint)
      tVar.Functype$ = LTRIM$(tVar.Functype$)
      Funcname$ = Clean$(Stk$[iStartPoint])
      *piStart = iStartPoint+2
      WHILE *piStart < OldiEndPoint
        CALL GetParameter(piStart,&tVar, mt_FuncSubDecC_DecAParam, mt_FuncSubDecC_DecNoParam, 0)
        (*piStart)++
      WEND

      tVar.Methd% = mt_FuncSubDecC_DecAParam
      tVar.Token$ = Funcname$
      FuncSubDecs3(&tVar, OldiEndPoint, 1)
      CONCAT(ptVar->Header$,tVar.Header$)
      CONCAT(ptVar->Proto$,tVar.Proto$)
      *piStart = iEndPoint
      IF Stk$[(*piStart)+1] = "," THEN
        CONCAT(ptVar->Header$,",")
        CONCAT(ptVar->Proto$,",")
        (*piStart)++
      END IF
      SFPOINTER = FALSE
      EXIT SUB
    END IF
    IF Stk$[iLoc] = "," OR Stk$[iLoc] = ")" THEN EXIT DO
    IF iMatchWrd(Stk$[iLoc], "as") THEN iASPos = iLoc
    IF iMatchWrd(Stk$[iLoc], "=") THEN iEQPos = iLoc
    iLoc++
  LOOP
  iLoc--
  IF Stk$[iLoc] <> "..." THEN
    RAW iIsConst = 0
    IF iEQPos THEN CALL GetParameterASHelper(iEQPos, iASPos, iOptOk, iLoc)
    IF iASPos THEN
      RAW iLast = iLoc
      RAW iAfterAs1 = iASPos+1
      RAW iAfterAs2 = iASPos+2
      IF iASPos < iEQPos THEN iLast = iEQPos-1
      IF iAfterAs1 <> iLast THEN
        IF iMatchWrd(Stk$[iAfterAs1], "const") THEN
'IF _ZTRACE_ THEN
'	zTrace(ANSITOWIDE((char*)"Hello From line 33467"))
'END IF
          iIsConst = 1
          CONCAT(Stk$[iAfterAs1],SPC$)
          CONCAT(Stk$[iAfterAs1],Stk$[iAfterAs2])
          Stk$[iAfterAs2] = ""
        END IF
        XFOR INT i = iAfterAs2 WHILE i <= iLast BY i++
          IF iMatchWrd(Stk$[i],"ptr") THEN Stk$[i] = "*"
          CONCAT(Stk$[iAfterAs1],Stk$[i])
          Stk$[i] = ""
        XNEXT
      END IF
      ptVar->AsToken$ = Stk$[iAfterAs1]
      'IF ptVar->Methd <> mt_ConsDesNoParam THEN
        CALL GetTypeInfo(ptVar->AsToken$, &(ptVar->IsPtrFlag), &iNd, &(ptVar->VarNo))
      'END IF
    ELSE
      RAW iPtrCnt = TALLY(Stk$[*piStart],"*")
      ptVar->AsToken$ = VarTypeLookup$[INCHR(VarTypes$, RIGHT$(Stk$[*piStart],1))]+STRING$(iPtrCnt,ASC("*"))
      REMOVE "*" FROM Stk$[*piStart]
      CALL GetTypeInfo(ptVar->AsToken$, &(ptVar->IsPtrFlag), &iNd, &(ptVar->VarNo))
    END IF

    ptVar->Methd% = iAParam
    CALL GetVarCode(ptVar,"GetParameter 1")

    IF iEQPos THEN
      ptVar->Methd% = iNoParam
      ptVar->Token$ = Stk$[iEQPos]
      CALL GetVarCode(ptVar,"GetParameter 2")
    END IF

    CALL AddLocal(ptVar->Token$,ptVar->VarNo,0,"",ptVar->IsPtrFlag,0,0,iIsConst)
  ELSE
    ptVar->Methd% = iNoParam
    ptVar->Token$ = Stk$[iLoc]
    CALL GetVarCode(ptVar, "GetParameter 3")
  END IF

  ++iLoc
  IF Stk$[iLoc] = "," THEN
    ptVar->Methd% = iNoParam
    ptVar->Token$ = Stk$[iLoc]
    CALL GetVarCode(ptVar, "GetParameter 4")
  END IF

  *piStart = iLoc
END SUB ' GetParameter



FUNCTION Emit_OptFuncSub(sWord$, FuncRetnFlag AS PINT)
  SELECT CASE sWord$

    CASE "optfunction", "optsub"  ', "optdeclare"
      RAW IOptLoc AS INT
      RAW VarCode AS VARCODE
      VarCode.IsExported = FALSE
      VarCode.UseInLine = UseInLine

      IF sWord$ = "optfunction" OR sWord$ = "optsub" THEN
        IF Indent THEN
          CALL Abort("Possible missing END IF before start of OPTSUB/OPTFUNCTION")
        END IF
      END IF
'IF _ZTRACE_ Then
'	zTrace(ANSITOWIDE((char*)"Hello From Emit_OptFuncSub"))
	'zTrace(ANSITOWIDE((char*) "iEndPoint = " + Str$(iEndPoint)))
'END IF

      CALL FuncSubDecs1("optsub", 1, Ndx, &VarCode)

      InFunc  = TRUE
      LocalVarCnt = 0

      IF InNameSpace THEN
        Outfile = FP2
      ELSE
        IF UsingTemplate = FALSE THEN
          Outfile = FP3
        END IF
      END IF

      CALL FuncSubDecs2("optsub", mt_Opts, &VarCode, 1, &Ndx)

      Funcname$ = Clean$(Stk$[2])

      IOptLoc = 4

      WHILE IOptLoc < Ndx
        CALL GetParameter(&IOptLoc,&VarCode, mt_OptsAParam, mt_OptsNoParam, 1)
        IOptLoc++
      WEND

      VarCode.Methd% = mt_FuncSubDecC_DecAParam
      VarCode.Token$ = Funcname$
      FuncSubDecs3(&VarCode, Ndx, 0)

      IF Use_Static THEN
        VarCode.Header$ = "static " + VarCode.Header$
        VarCode.Proto$ = "static " + VarCode.Proto$
      END IF

	If Use_ExternC Then
        VarCode.Header$ = "extern " + Enc$("C") + " " +VarCode.Header$
        VarCode.Proto$ = "extern " +  Enc$("C") + " " +VarCode.Proto$
	End If
      CALL AddProto(VarCode.Proto$)

      IF InIfDef$ = "FP3" THEN
        ProtoType[ProtoCnt].Condition$ = ""
      ELSE
        ProtoType[ProtoCnt].Condition$ = InIfDef$
      END IF
      ProtoType[ProtoCnt].CondLevel  = InConditional

      FPRINT Outfile,VarCode.Header$
      FPRINT Outfile,Scoot$;"{"
      CALL BumpUp

    CASE ELSE
      CALL EmitOld(FuncRetnFlag)

  END SELECT
  FUNCTION = 0
END FUNCTION ' Emit_OptFuncSub



FUNCTION Emit_OverLoadFuncSub(sWord$, FuncRetnFlag AS PINT)
  RAW VarCode AS VARCODE
  VarCode.IsExported = FALSE
  VarCode.UseInLine = UseInLine
  SELECT CASE sWord$

    CASE "overloadedfunction", "overloadedsub"
      RAW lszTmp$
      RAW A
      Use_Overloaded = TRUE
'IF _ZTRACE_ Then
'	zTrace(ANSITOWIDE((char*)"Hello From Emit_OverLoadFuncSub"))
'END IF


      'InFunc = TRUE
'jcfuller added from bcx 7.0.7
      IF sWord$ = "overloadedfunction" THEN
        InFunc = eFunctionType
      ELSE
        InFunc = eSubType
      END IF

      CALL FuncSubDecs1("overloadedsub", 1, Ndx, &VarCode)


      InMain = FALSE
      LocalVarCnt = 0

      IF UsingTemplate = FALSE THEN
        Outfile = FP_OVR    '<<----- writing TO BCX.OVR
      END IF

      CALL FuncSubDecs2("overloadedsub", mt_OverLoad, &VarCode, 1, &Ndx)

      Funcname$ = Clean$(Stk$[2])
      lszTmp$ = " overloaded " + Funcname$
      Funcname$ = lszTmp$
      'VarCode.Methd% = mt_OverLoadAParam

      A = 4
      WHILE A < Ndx
        CALL GetParameter(&A,&VarCode, mt_OverLoadAParam, mt_OverLoadNoParam, 0)
        A++
      WEND

      VarCode.Methd% = mt_FuncSubDecC_Dec
      VarCode.Token$ = Funcname$
      FuncSubDecs3(&VarCode, Ndx, 0)

      IF Use_Static THEN
        VarCode.Header$ = "static " + VarCode.Header$
      END IF
	If Use_ExternC Then
        VarCode.Header$ = "extern " + Enc$("C") + " " +VarCode.Header$
	End If

      FPRINT Outfile,VarCode.Header$
      FPRINT Outfile,Scoot$;"{"

      CALL BumpUp

    CASE ELSE
      CALL EmitOld(FuncRetnFlag)

  END SELECT
  FUNCTION = 0
END FUNCTION ' Emit_OverLoadFuncSub
'------------------------------------------------------------------------------
'jcfuller added 9/14/2013 from bcx 7.0.8
FUNCTION ClassModuleProto(szProto AS PCHAR)
  RAW iReturn
  RAW iCnt
  XFOR iReturn = 0, iCnt = 0 WHILE iCnt < iClassModuleCnt AND iReturn=0 BY iCnt++
    IF szProto$ = szClassModuleNames[iCnt] THEN iReturn = 1
  XNEXT
  FUNCTION = iReturn
END FUNCTION
'------------------------------------------------------------------------------

FUNCTION Emit_ConDes(sWord$, FuncRetnFlag AS PINT)
  SELECT CASE sWord$
    CASE "constructor", "destructor"

      IF InFunc <> eNotInOne THEN CALL Abort("Syntex Error: already in function")
      'IF Indent > InNameSpace * cINDENT THEN
      '  IF InClassModule OR InNameSpace THEN CALL Abort("Syntax Error. Something missing before start of SUB/FUNCTION")
      '  CALL Abort("Possible missing END IF before start of SUB/FUNCTION")
      'END IF
      RAW A
      RAW CTOR_USE$
      RAW New_Ndx = Ndx
      RAW iCPPFunSub
      RAW VarCode AS VARCODE
      VarCode.IsExported = FALSE
      VarCode.UseInLine = UseInLine

      iCPPFunSub = 0
      FOR INTEGER ct = 1 TO Ndx
        IF Stk$[ct] = "using" THEN
          iCPPFunSub = 1
          New_Ndx = ct-1
          CALL BuildDelimStr(ct+1, Ndx, CTOR_USE$)
          EXIT FOR
        END IF
      NEXT
      Ndx = New_Ndx

      CALL FuncSubDecs1("sub", 1, Ndx, &VarCode)
      IsStdFunc = FALSE

      InMain = FALSE
      LocalVarCnt = 0

      'IF InNameSpace OR InClassModule THEN
      IF InNameSpace OR InClassModule OR InPPTypeModule THEN
        'InFunc = FALSE
        InFunc = eNotInOne
        'Outfile = FP2
        Outfile = FP_UDT
      ELSE
        'InFunc = TRUE
        InFunc = eConstructorType
        IF UsingTemplate = FALSE THEN
          Outfile = FP3
        END IF
      END IF

      CALL FuncSubDecs2("sub", mt_ConsDes, &VarCode, 1, &Ndx)
      ' to compensate previous substitution errors not fixed

      VarCode.Functype$ = LTRIM$(VarCode.Functype$)
      Funcname$ = Clean$(Stk$[2])

      'VarCode.Methd% = mt_FuncSubDecC_DecAParam
      A = 4
      WHILE A < Ndx
        CALL GetParameter(&A,&VarCode, mt_ConsDesAParam, mt_ConsDesNoParam, 1)
        A++
      WEND

      IF (sWord$ = "constructor") OR (INSTR(Funcname$, "~") <> 0) THEN
        VarCode.Token$ = Funcname$

      ELSE
        VarCode.Token$ = "~" & Funcname$
      END IF
'jcfuller added 12/03/2013
		If iMatchRgt(Src$,"virtual") Then
			VarCode.Token$ = "virtual " & VarCode.Token$
		End If





      VarCode.Methd% = mt_FuncSubDecC_DecAParam
      FuncSubDecs3(&VarCode, Ndx, 0)

      IF Use_Static THEN
        VarCode.Header$ = "static " + VarCode.Header$
        VarCode.Proto$  = "static " + VarCode.Proto$
      END IF

	If Use_ExternC Then
        VarCode.Header$ = "extern " + Enc$("C") + " " + VarCode.Header$
        VarCode.Proto$ = "extern " +  Enc$("C") + " " + VarCode.Proto$
	End If


      IF INSTR(VarCode.Proto$,"::") = 0 AND IAmNot(InNameSpace) AND IAmNot(InClassModule) AND IAmNot(InPPTypeModule) THEN
        iCPPFunSub = 0
        CALL AddProto(VarCode.Proto$)
        IF InIfDef$ = "FP3" THEN
          IF ProtoCnt > 1 THEN
            ProtoType[ProtoCnt].Condition$ = ProtoType[ProtoCnt-1].Condition$
          ELSE
            ProtoType[ProtoCnt].Condition$ = ""
          END IF
        ELSE
          ProtoType[ProtoCnt].Condition$ = InIfDef$
        END IF

        ProtoType[ProtoCnt].CondLevel  = InConditional

        IF *InIfDef$ THEN
          IF InIfDef$ <> "FP3" THEN
            FPRINT Outfile,InIfDef$
          END IF
        END IF
      END IF

      IF iCPPFunSub = 1 THEN
        FPRINT Outfile,Scoot$;VarCode.Header$;": ";CTOR_USE$
      ELSE
        FPRINT Outfile,Scoot$;VarCode.Header$
      END IF

      FPRINT Outfile,Scoot$;"{"
      CALL BumpUp

    CASE "endconstructor"
      CALL BumpDown("Extra un-indent(s) and/or missing indents in CONSTRUCTOR/END CONSTRUCTOR")
      FPRINT Outfile,Scoot$;"}"
      'InFunc = FALSE
      InFunc = eNotInOne

    CASE "enddestructor"
      CALL BumpDown("Extra un-indent(s) and/or missing indents in DESTRUCTOR/END DESTRUCTOR")
      FPRINT Outfile,Scoot$;"}"
      'InFunc = FALSE
      InFunc = eNotInOne

    CASE ELSE
      CALL EmitOld(FuncRetnFlag)

  END SELECT
  FUNCTION = 0
END FUNCTION ' Emit_ConDes



FUNCTION Emit_Implied(sWord$, FuncRetnFlag AS PINT)
  SELECT CASE sWord$
    'IMPFUNCTION module() = 0 AS virtual double
    CASE "impfunction"
      RAW A
      RAW szImp$
      RAW VarCode AS VARCODE
      VarCode.IsExported = FALSE
      VarCode.UseInLine = UseInLine
'IF _ZTRACE_ Then
'	zTrace(ANSITOWIDE((char*)"Hello From Emit_Implied"))
'END IF

      CALL FuncSubDecs1("sub", 1, Ndx, &VarCode)
      IsStdFunc = FALSE
      InMain = FALSE
      LocalVarCnt = 0
      CALL FuncSubDecs2("sub", mt_FuncSubDecC_Dec, &VarCode, 1, &Ndx)
      szImp$ = ""
      DO
        szImp$ = Stk$[Ndx]+ szImp$
      LOOP WHILE Stk$[Ndx--] <> "="
      ' to compensate previous substitution errors not fixed
      VarCode.Functype$ = LTRIM$(VarCode.Functype$)
      Funcname$ = Clean$(Stk$[2])
      'VarCode.Methd% = mt_FuncSubDecC_DecAParam
      A = 4
      WHILE A < Ndx
        CALL GetParameter(&A,&VarCode, mt_OptsAParam, mt_OptsNoParam, 1)
        A++
      WEND

      VarCode.Methd% = mt_FuncSubDecC_DecAParam
      VarCode.Token$ = Funcname$
      FuncSubDecs3(&VarCode, Ndx, 0)
      FPRINT FP_UDT,Scoot$;VarCode.Header$;szImp$;";"

    CASE ELSE
      CALL EmitOld(FuncRetnFlag)
  END SELECT
  FUNCTION = 0
END FUNCTION

'FUNCTION Emit_FuncSub(sWord$, FuncRetnFlag AS PINT)
  'SELECT CASE sWord$

    'CASE "function", "sub", "publicfunction", "publicsub", "privatefunction", "privatesub"
      'IF InFunc <> eNotInOne THEN CALL Abort("Syntex Error: already in function")
      ''IF Indent > InNameSpace * cINDENT THEN
      ''  IF InClassModule OR InNameSpace THEN CALL Abort("Syntax Error. Something missing before start of SUB/FUNCTION")
      ''  CALL Abort("Possible missing END IF before start of SUB/FUNCTION")
      ''END IF
      'RAW A
      'RAW CTOR_USE$
      'RAW New_Ndx = Ndx
      'RAW iCPPFunSub
      'RAW VarCode AS VARCODE
      'VarCode.IsExported = FALSE
      'VarCode.UseInLine = UseInLine

      'SELECT CASE sWord$
        'CASE "publicfunction", "publicsub"
          'Stk$[1] = MID$(Stk$[1],6)
        'CASE "privatefunction", "privatesub"
          'Stk$[1] = MID$(Stk$[1],7)
      'END SELECT

      'iCPPFunSub = 0
      'FOR INTEGER ct = 1 TO Ndx
        'IF iMatchWrd(Stk$[ct], "using") THEN
          'iCPPFunSub = 1
          'New_Ndx = ct-1
          'CALL BuildDelimStr(ct+1, Ndx, CTOR_USE$)
          'EXIT FOR
        'END IF
      'NEXT
      'Ndx = New_Ndx

      'IF Stk$[2] = "main" THEN
        'Stk$[1] = "function"
        'Stk$[2] = "main%"
        'ForceMainToFunc = TRUE
      'END IF

''IF _ZTRACE_ Then
''	zTrace(ANSITOWIDE((char*)"Hello From Emit_FuncSub"))
''	zTrace(ANSITOWIDE((char*)"Ndx = " + Str$(Ndx)))
''	ZPRINT("Ndx = " + Str$(Ndx))
''END IF

      'CALL FuncSubDecs1("sub", 1, Ndx, &VarCode)
      'IsStdFunc = FALSE

      'IF iMatchWrd(Stk$[Ndx],"stdcall") THEN
        'CallType$ = "__stdcall "
        'Ndx--
        'IsStdFunc = TRUE
      'END IF

      'InMain = FALSE
      'LocalVarCnt = 0

      'IF InNameSpace OR InClassModule OR InPPTypeModule THEN
        ''InFunc = FALSE
        'InFunc = eNotInOne
        'Outfile = FP2
      'ELSE
        ''InFunc = TRUE
        'IF INSTR(sWord$, "function") THEN
          'InFunc = eFunctionType
        'ELSE
          'InFunc = eSubType
        'END IF

        'IF UsingTemplate = FALSE THEN
          'Outfile = FP3
        'END IF
      'END IF

      'CALL FuncSubDecs2("sub", mt_FuncSubDecC_Dec, &VarCode, 1, &Ndx)

      '' to compensate previous substitution errors not fixed

      'VarCode.Functype$ = LTRIM$(VarCode.Functype$)

      'IF iMatchRgt(Stk$[2],"operator") THEN
''IF _ZTRACE_ THEN
''zTrace(ANSITOWIDE((char*)"Hello From line 33910"))
''END IF

        'CONCAT(VarCode.Functype$,Stk$[2])
        'CONCAT(VarCode.Functype$,SPC$)
        'Funcname$ = ""
        'RAW bOppFound AS BOOL
        'XFOR A = 3,bOppFound = FALSE WHILE NOT bOppFound BY A++
          'IF Stk$[A] = "(" THEN
            'IF Stk$[A+1] <> ")" AND Stk$[A+2] <> "(" THEN bOppFound = TRUE
            'IF Stk$[A+1] = ")" AND A > 3 THEN bOppFound = TRUE
          'END IF
          'IF NOT bOppFound THEN
            'CONCAT(VarCode.Functype$,Stk$[A])
          'END IF
        'XNEXT
      'ELSE
        'Funcname$ = Clean$(Stk$[2])
        'IF VarCode.IsExported OR IsStdFunc THEN
          'Funcname$ = CallType$ + Funcname$
        'END IF
        'A = 4
      'END IF

      'WHILE A < Ndx
        'IF UseCpp THEN
          'CALL GetParameter(&A,&VarCode, mt_OptsAParam, mt_OptsNoParam, 1)
        'ELSE
          'CALL GetParameter(&A,&VarCode, mt_FuncSubDecC_DecAParam, mt_FuncSubDecC_DecNoParam, 0)
        'END IF
        'A++
      'WEND

''IF _ZTRACE_ Then
''  ZPRINT("VarCode.Header -> ")
''  ZPRINT(VarCode.Header$)
''END IF


      'VarCode.Methd% = mt_FuncSubDecC_DecAParam
      'VarCode.Token$ = Funcname$
      'FuncSubDecs3(&VarCode, Ndx, 0)

      'IF iMatchWrd(Stk$[Ndx], "const") THEN
        'CONCAT(VarCode.Header$," const")
      'END IF

      'IF iMatchLft(VarCode.Header$,"main(")  THEN



        'VarCode.Header$ = "int main(int argc, char *argv[])"
        'VarCode.Proto$  = "int main(int argc, char *argv[]);"
        'CurrentFuncType = vt_INTEGER
      'END IF

      'IF Use_Static THEN
        'VarCode.Header$ = "static " + VarCode.Header$
        'VarCode.Proto$  = "static " + VarCode.Proto$
      'END IF

''      IF INSTR(VarCode.Proto$,"::") = 0 AND IAmNot(InNameSpace) AND IAmNot(InClassModule) AND IAmNot(InPPTypeModule) THEN
      'Raw tmp$
      'tmp$ = Extract$(VarCode.Proto$,"(")
      'IF INSTR(tmp$,"::") = 0 AND IAmNot(InNameSpace) AND IAmNot(InClassModule) AND IAmNot(InPPTypeModule) THEN
        'CALL AddProto(VarCode.Proto$)
        'IF InIfDef$ = "FP3" THEN
          'IF ProtoCnt > 1 THEN
            'ProtoType[ProtoCnt].Condition$ = ProtoType[ProtoCnt-1].Condition$
          'ELSE
            'ProtoType[ProtoCnt].Condition$ = ""
          'END IF
        'ELSE
          'ProtoType[ProtoCnt].Condition$ = InIfDef$
        'END IF

        'ProtoType[ProtoCnt].CondLevel  = InConditional

        'IF *InIfDef$ THEN
          'IF InIfDef$ <> "FP3" THEN
            'FPRINT Outfile,InIfDef$
          'END IF
        'END IF
      'END IF

      'IF InNameSpace OR InClassModule OR InPPTypeModule THEN
        'RAW szCPP_SF1$
        'szCPP_SF1$ = ""

        'IF iMatchLft(Stk$[2], InClassModuleName$) AND InClassModule THEN
          'VarCode.Header$ = REMAIN$(VarCode.Header$," ")
        'END IF
        'FPRINT FP_UDT,Scoot$;szCPP_SF1$;VarCode.Header$;
        'IF iCPPFunSub = 1 THEN
          'FPRINT FP_UDT," : ";CTOR_USE$
        'ELSE
          'FPRINT FP_UDT,""
        'END IF
        'Outfile = FP_UDT
        ''iCPPFunSub = 2
      'ELSE
        'FPRINT Outfile,VarCode.Header$
      'END IF

      'FPRINT Outfile,Scoot$;"{"
      'CALL BumpUp

    'CASE ELSE
      'CALL EmitOld(FuncRetnFlag)

  'END SELECT
  'FUNCTION = 0
'END FUNCTION ' Emit_FuncSub
'==============================================================================
'jcfuller added from bcx 7.0.8
FUNCTION Emit_FuncSub(sWord$, FuncRetnFlag AS PINT)
  Dim stmp$
  SELECT CASE sWord$

    CASE "function", "sub", "publicfunction", "publicsub", "privatefunction", "privatesub"
      IF InFunc <> eNotInOne THEN CALL Abort("Syntex Error: already in function")
      'IF Indent > InNameSpace * cINDENT THEN
      '  IF InClassModule OR InNameSpace THEN CALL Abort("Syntax Error. Something missing before start of SUB/FUNCTION")
      '  CALL Abort("Possible missing END IF before start of SUB/FUNCTION")
      'END IF
      RAW A
      RAW CTOR_USE$
      RAW New_Ndx = Ndx
      RAW iCPPFunSub
      RAW VarCode AS VARCODE
      VarCode.IsExported = FALSE
      VarCode.UseInLine = UseInLine

      SELECT CASE sWord$
        CASE "publicfunction", "publicsub"
          Stk$[1] = MID$(Stk$[1],6)
        CASE "privatefunction", "privatesub"
          Stk$[1] = MID$(Stk$[1],7)
      END SELECT

      iCPPFunSub = 0
      FOR INTEGER ct = 1 TO Ndx
        IF iMatchWrd(Stk$[ct], "using") THEN
          iCPPFunSub = 1
          New_Ndx = ct-1
          CALL BuildDelimStr(ct+1, Ndx, CTOR_USE$)
          EXIT FOR
        END IF
      NEXT
      Ndx = New_Ndx

      IF Stk$[2] = "main" THEN
        Stk$[1] = "function"
        Stk$[2] = "main%"
        ForceMainToFunc = TRUE
      END IF

      CALL FuncSubDecs1("sub", 1, Ndx, &VarCode)

      IsStdFunc = FALSE

      IF iMatchWrd(Stk$[Ndx],"stdcall") THEN
        CallType$ = "__stdcall "
        Ndx--
        IsStdFunc = TRUE
      END IF

      InMain = FALSE
      LocalVarCnt = 0

      IF InNameSpace OR InClassModule OR InPPTypeModule THEN
        InFunc = eNotInOne
        Outfile = FP2
      ELSE
        IF INSTR(sWord$, "function") THEN
          InFunc = eFunctionType
        ELSE
          InFunc = eSubType
        END IF
        IF UsingTemplate = FALSE THEN
          Outfile = FP3
        END IF
      END IF

      CALL FuncSubDecs2("sub", mt_FuncSubDecC_Dec, &VarCode, 1, &Ndx)

      ' to compensate previous substitution errors not fixed

      VarCode.Functype$ = LTRIM$(VarCode.Functype$)

      IF iMatchRgt(Stk$[2],"operator") THEN
        CONCAT(VarCode.Functype$,Stk$[2])
        CONCAT(VarCode.Functype$,SPC$)
        Funcname$ = ""
        RAW bOppFound AS BOOL
        XFOR A = 3,bOppFound = FALSE WHILE NOT bOppFound BY A++
          IF Stk$[A] = "(" THEN
            IF Stk$[A+1] <> ")" AND Stk$[A+2] <> "(" THEN bOppFound = TRUE
            IF Stk$[A+1] = ")" AND A > 3 THEN bOppFound = TRUE
          END IF
          IF NOT bOppFound THEN
            CONCAT(VarCode.Functype$,Stk$[A])
          END IF
        XNEXT
      ELSE
        Funcname$ = Clean$(Stk$[2])
        IF VarCode.IsExported OR IsStdFunc THEN
          Funcname$ = CallType$ + Funcname$
        END IF
        A = 4
      END IF

      WHILE A < Ndx
        IF UseCpp THEN
          CALL GetParameter(&A,&VarCode, mt_OptsAParam, mt_OptsNoParam, 1)
        ELSE
          CALL GetParameter(&A,&VarCode, mt_FuncSubDecC_DecAParam, mt_FuncSubDecC_DecNoParam, 0)
        END IF
        A++
      WEND

      VarCode.Methd% = mt_FuncSubDecC_DecAParam
      VarCode.Token$ = Funcname$
      FuncSubDecs3(&VarCode, Ndx, 0)

      IF iMatchWrd(Stk$[Ndx], "const") THEN
        CONCAT(VarCode.Header$," const")
      END IF

      IF iMatchLft(VarCode.Header$,"main(")  THEN
        VarCode.Header$ = "int main(int argc, char *argv[])"
        VarCode.Proto$  = "int main(int argc, char *argv[]);"
        CurrentFuncType = vt_INTEGER
      END IF

      IF Use_Static THEN
        VarCode.Header$ = "static " + VarCode.Header$
        VarCode.Proto$  = "static " + VarCode.Proto$
      END IF

	If Use_ExternC Then
        VarCode.Header$ = "extern " + Enc$("C") + " " + VarCode.Header$
        VarCode.Proto$ = "extern " +  Enc$("C") + " " + VarCode.Proto$
	End If

      IF IAmNot(InNameSpace) AND IAmNot(InClassModule) AND IAmNot(InPPTypeModule) THEN
        RAW iClassFunction
        Raw tmp$

        tmp$ = Extract$(VarCode.Proto$,"(")
        IF INSTR(tmp$,"::") > 0 THEN
          tmp$ = EXTRACT$(tmp,"::")
          iClassFunction = ClassModuleProto(tmp$)
          IF iClassFunction = 0 THEN
            IF cMaxClassModuleNames = iClassModuleCnt THEN CALL Abort("Maximum cMaxClassModuleNames ="+STR$(cMaxClassModuleNames)+" reached")
            szClassModuleNames$[iClassModuleCnt] = tmp$
            iClassModuleCnt++
          END IF
          iClassFunction = 1
        ELSE
          iClassFunction = 0
        END IF
        IF iClassFunction = 0 THEN
          CALL AddProto(VarCode.Proto$)
          IF InIfDef$ = "FP3" THEN
            IF ProtoCnt > 1 THEN
              ProtoType[ProtoCnt].Condition$ = ProtoType[ProtoCnt-1].Condition$
            ELSE
              ProtoType[ProtoCnt].Condition$ = ""
            END IF
          ELSE
            ProtoType[ProtoCnt].Condition$ = InIfDef$
          END IF

          ProtoType[ProtoCnt].CondLevel  = InConditional

          IF *InIfDef$ THEN
            IF InIfDef$ <> "FP3" THEN
              FPRINT Outfile, InIfDef$
            END IF
          END IF
        END IF
      END IF

      IF InNameSpace OR InClassModule OR InPPTypeModule THEN

        RAW szCPP_SF1$
        szCPP_SF1$ = ""
        'cout << "iMatchLft(Stk$[2] -> " << iMatchLft(Stk$[2] << endl
'        cout << "Stk$[2] -> " << Stk$[2] << endl
'        cout << "InClassModuleName$ -> " << InClassModuleName$ << endl
'I'm not sure where this comes in to play?
'right now it is stripping return type if the sub/func starts with the class name.
'it may have been for constructor/destructor before the Constructor/Destructor
'key words?
'jcf removed  08/11/2015
'        IF iMatchLft(Stk$[2], InClassModuleName$) AND InClassModule THEN
'          VarCode.Header$ = REMAIN$(VarCode.Header$," ")
'        END IF
'jcf changed ala Robert 08/20/2015
        IF iMatchWrd(Stk$[2], InClassModuleName$) AND InClassModule THEN
          VarCode.Header$ = REMAIN$(VarCode.Header$," ")
        END IF


        FPRINT FP_UDT, Scoot$;szCPP_SF1$;VarCode.Header$;
        IF iCPPFunSub = 1 THEN
          FPRINT FP_UDT, " : ";CTOR_USE$
        ELSE
          FPRINT FP_UDT, ""
        END IF
        Outfile = FP_UDT
        'iCPPFunSub = 2

      ELSE
        FPRINT Outfile, VarCode.Header$
      END IF

      FPRINT Outfile, Scoot$;"{"
      CALL BumpUp

    CASE ELSE
      CALL EmitOld(FuncRetnFlag)

  END SELECT
  FUNCTION = 0
END FUNCTION ' Emit_FuncSub


'*******************************************************************
' Global variable emitter for variable used by BCX functions.

ENUM
  ePrinterGroup   = 0x0001
  eFontGroup      = 0x0002
  eClassName      = 0x0004
  eBCX_hInstance  = 0x0008
END ENUM

GLOBAL iEmitVariableGroup

SUB EmitBCXVariables()
  WHILE iEmitVariableGroup
    SELECT CASE 1

      CASE (iEmitVariableGroup BAND 1)
        CALL EmitPrinterVariables()
        iEmitVariableGroup = iEmitVariableGroup XOR ePrinterGroup

      CASE ((iEmitVariableGroup >> 1) BAND 1)

        CALL AddFontVariables()
        iEmitVariableGroup = iEmitVariableGroup XOR eFontGroup

      CASE ((iEmitVariableGroup >> 2) BAND 1)

        CALL AddClassName()
        iEmitVariableGroup = iEmitVariableGroup XOR eClassName

      CASE ((iEmitVariableGroup >> 3) BAND 1)

        CALL AddBCX_hInstance()
        iEmitVariableGroup = iEmitVariableGroup XOR eBCX_hInstance

      CASE ELSE
        CALL Abort("Unknown variable grouping was selected (Add to SUB EmitBCXVariables).")
    END SELECT
  WEND
  ' iEmitVariableGroup is zero when it gets here
END SUB ' EmitBCXVariables



SUB AddBCX_hInstance()
  STATIC IWasHere = 0
  IF FirstTime(IWasHere) THEN
    CALL AddGlobal("BCX_hInstance",vt_HINSTANCE,0,"",0,0,0,0,0)
    IWasHere++
  END IF
END SUB ' AddBCX_hInstance



SUB AddClassName()
  STATIC IWasHere = 0
  IF FirstTime(IWasHere) THEN
    CALL AddGlobal("BCX_ClassName",vt_STRVAR,  0,"",0,0,0,0,0)
    IWasHere++
  END IF
END SUB ' AddClassName



SUB EmitPrinterVariables()
  STATIC IWasHere = 0
  IF FirstTime(IWasHere) THEN
    CALL AddGlobal("BcxPtr_hDC"       ,vt_HDC        ,0,"",0,0,0,0,0)
    CALL AddGlobal("BcxPtr_FontMetrix",vt_LONG       ,0,"",0,0,0,0,0)
    CALL AddGlobal("BcxPtr_LineCtr"   ,vt_LONG       ,0,"",0,0,0,0,0)
    CALL AddGlobal("BcxPtr_PrinterOn" ,vt_LONG       ,0,"",0,0,0,0,0)
    CALL AddGlobal("BcxPtr_hFont"     ,vt_HFONT      ,0,"",0,0,0,0,0)
    CALL AddGlobal("BcxPtr_hFontOld"  ,vt_HFONT      ,0,"",0,0,0,0,0)
    CALL AddGlobal("BcxPtr_di"        ,vt_DOCINFO    ,0,"",0,0,0,0,0)
    CALL AddGlobal("BcxPtr_Lf"        ,vt_LOGFONT    ,0,"",0,0,0,0,0)
    CALL AddGlobal("BcxPtr_tm"        ,vt_TEXTMETRIC ,0,"",0,0,0,0,0)
    CALL AddGlobal("BcxPtr_Text"      ,vt_STRVAR     ,0,"",0,0,0,0,0)
    CALL AddGlobal("BcxPtr_Buffer"    ,vt_STRVAR     ,0,"",0,0,0,0,0)
    IWasHere++
  END IF
END SUB ' EmitPrinterVariables



SUB AddFontVariables()
  STATIC IWasHere = 0
  IF FirstTime(IWasHere) THEN
    CALL AddGlobal("BcxFont"      ,vt_HFONT,  0,"",0,0,0,0,0)
    CALL AddGlobal("BCX_ScaleX",   vt_SINGLE, 0,"",0,0,0,0,0)
    CALL AddGlobal("BCX_ScaleY",   vt_SINGLE, 0,"",0,0,0,0,0)
    IWasHere++
  END IF
END SUB ' AddFontVariables



SUB AddGUIGlobals()
  STATIC IWasHere = 0
  IF FirstTime(IWasHere) THEN
    CALL AddFontVariables()
    CALL AddBCX_hInstance()
    CALL AddGlobal("BCX_hwndMDIClient",vt_HWND      ,0,"",0,0,0,0,0)
    CALL AddGlobal("BCX_WndClass"     ,vt_WNDCLASSEX,0,"",0,0,0,0,0)
    CALL AddGlobal("BCX_GUI_Init"     ,vt_WINBOOL      ,0,"",0,0,0,0,0)
    CALL AddGlobal("BCX_ClassName"    ,vt_STRVAR    ,0,"",0,0,0,0,0)
    IWasHere++
  END IF
END SUB ' AddGUIGlobals



SUB ProcessMsgCracker()
  ' HANDLE_MSG WM_SIZE INLINE SendMessage(hWnd, WM_XXXX, 0, 0 ) : EXIT FUNCTION
  RAW msg_$
  RAW proc_$
  RAW ret_$
  RAW tmp_$[16]
  RAW tmpNdx = 0
  RAW i
  RAW j

  FastLexer(Src$, SPC$, ":")
  IF LCASE$(Stk$[3]) = "inline" THEN
    tmp_$[++tmpNdx] = "IF Msg = " + Stk$[2] + " THEN"
    IF Stk$[Ndx] <> ":" THEN Stk$[++Ndx] = ":"
    XFOR i = 4, j = 4 WHILE i <= Ndx BY i++
      IF Stk$[i] = ":" THEN
        CALL BuildDelimStr(j, i-1, tmp_$[++tmpNdx])
        j = i+1
      END IF
    XNEXT
    tmp_$[++tmpNdx] = "END IF"
    FOR i = 1 TO tmpNdx
      CALL XParse(tmp_$[i]) : CALL FixUps() : CALL EmitMain()
    NEXT
  ELSE
    'handle_msg( WM_SIZE, form1_onSize)
    FastLexer(Src$, " ,()","")
    msg_$  = Stk$[2]
    proc_$ = Stk$[3]
    ret_$  = Stk$[4]
    IF ret_$ <> "" THEN ret_$ = ","+ret_$
    Src$ = "IF Msg = " + msg_$ + " THEN" : CALL XFE(Src$)
    IF LEN(TRIM$(ret_$)) THEN
      Src$ = "  FUNCTION=" + proc_$ + "(hWnd,wParam,lParam" + ret_$ + ")"
    ELSE
      Src$ = "  " + proc_$ + "(hWnd,wParam,lParam" + ret_$ + ")"
    END IF
    CALL XFE(Src$)
    Src$ = "END IF" : CALL XFE(Src$)
  END IF
  Src$ = ""
END SUB ' ProcessMsgCracker



SUB ProcessCmdHandler()
  DIM RAW id_$
  DIM RAW proc_$
  DIM RAW ret_$
  DIM RAW tmp_$[16]
  DIM RAW tmpNdx
  DIM RAW i, j
  tmpNdx = 0
  FastLexer(Src$, SPC$, ":")
  IF LCASE$(Stk$[3]) = "inline" THEN
  ' handle_cmd IDM_NEW INLINE SendMessage(hWnd, WM_XXXX, 0, 0) : EXIT FUNCTION:
    tmp_$[++tmpNdx] = "IF Msg = WM_COMMAND AND CBCTL = " + Stk$[2] + " THEN "
    IF Stk$[Ndx] <> ":" THEN Stk$[++Ndx] = ":"
    XFOR i = 4, j = 4 WHILE i <= Ndx BY i++
      IF Stk$[i] = ":" THEN
        CALL BuildDelimStr(j, i-1, tmp_$[++tmpNdx])
        j = i+1
      END IF
    XNEXT
    tmp_$[++tmpNdx] = "END IF"
    FOR i = 1 TO tmpNdx
      CALL XParse(tmp_$[i]) : CALL FixUps() : CALL EmitMain()
    NEXT
  ELSE
    ' handle_cmd( IDM_NEW, procedure, retval )
    FastLexer(Src$, " ,()","")
    id_$ = Stk$[2]
    proc_$ = Stk$[3]
    ret_$ = Stk$[4]
    IF ret_$ <> "" THEN ret_$ = ","+ret_$
    Src$ = "IF Msg = WM_COMMAND AND CBCTL = " + id_$ + " THEN" : CALL XFE(Src$)
    IF LEN(TRIM$(ret_$)) THEN
      Src$ = "  FUNCTION=" + proc_$ + "(hWnd,wParam,lParam" + ret_$ + ")" : CALL XFE(Src$)
    ELSE
      Src$ = "  " + proc_$ + "(hWnd,wParam,lParam" + ret_$ + ") " : CALL XFE(Src$)
    END IF
    Src$ = "END IF" : CALL XFE(Src$)
  END IF
  Src$ = ""
END SUB ' ProcessCmdHandler



SUB ProcessMsgHandler()
  'MSGHANDLER procedure or CMDHANDLER procedure
  FastLexer(Src$, ", ()","")
  Src$ = "FUNCTION " + Stk$[2] + " OPTIONAL ( hWnd AS HWND, wParam AS WPARAM, lParam AS LPARAM, LReturn AS LONG=0 ) AS LONG"
  CALL XFE(Src$)
  Src$ = ""
END SUB ' ProcessMsgHandler



SUB ProcessMsgHandlerEnd
  'END HANDLER
  Src$ = "FUNCTION = LReturn"
  CALL XFE(Src$)
  Src$ = "END FUNCTION"
  CALL XFE(Src$)
  Src$ = ""
END SUB ' ProcessMsgHandlerEnd
' End Expand Macros
'==================================================================================
' Direcectives - tDirectives[].Emitter()
FUNCTION Doinclude(szWord$, iFLAG AS PINT)
  *iFLAG = 0

  SELECT CASE szWord$

    CASE "#include"
      FPRINT FP_HDR,"#include";Src + 8

    CASE "$include"
      DIM RAW orgfileName$
      IREPLACE "$BCX$" WITH BCXPATH$ IN Src$
      szFile$ = TRIM$(REMOVE$(MID$(Src$,9),DQ$))
      IF *szFile = ASC("<") THEN
        szFile$ = MID$(szFile$, 2, LEN(szFile$)-2)
        szFile$ = ENVIRON$("BCXLIB") + szFile$
      END IF
      orgfileName$ = szFile$
      IF NOT EXIST(szFile$) THEN
        szFile$ = BcxSplitPath$(szFile$, FNAME|FEXT)
        szFile$ = BcxSplitPath$(Modules$[ModuleNdx], FDRV|FPATH) + szFile$  '//; changed/added by whatsup
      END IF
      IF NOT EXIST(szFile$) THEN Abort("Unable to locate " + orgfileName$)
      CALL PushFileIO

	'IF _ZTRACE_ Then
	'	ZPRINT(STR$(ModuleNdx))
	'END IF


      OPEN szFile$ FOR INPUT AS SourceFile

      IF ModuleNdx = cMaxLoopLocal-1 THEN CALL Abort("Maximum Include Files exceeded.")
      Modules$[++ModuleNdx] = szFile$
      ModuleLineNos[ModuleNdx] = 0

  END SELECT

  FUNCTION = 0
END FUNCTION



FUNCTION Doaccelerator(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  Accelerator$ = REMOVE$(Stk$[2],DQ$)
  FUNCTION = 0
END FUNCTION



FUNCTION Doasm(szWord$, iFLAG AS PINT)
  RAW lszTmp$
  lszTmp$ = ""
  *iFLAG = 0

  CALL EmitOptimize((char*)"none",(char*)"0",(char*)"  // No Optimizations in ASM block")

  DO
    IF EOF(SourceFile) THEN Abort ("Unbalanced $Asm")
    LINE INPUT SourceFile,Src$
    ModuleLineNos[ModuleNdx]++
    IF SrcFlag THEN
      FPRINT Outfile,"// ",Src$
    END IF
    CALL StripTabs()
    Src$ = TRIM$(Src$)

    DIM meta_asm_loop
    DIM meta_asm_comment_present AS BOOL
    DIM Src_Len
    Src_Len = LEN(Src$)
    meta_asm_comment_present = FALSE

    FOR meta_asm_loop = 0 TO Src_Len
      '******************************************
      '   Extracts both the Basic Single Quote
      '   and the Assembly Semicolon
      '******************************************
      IF Src[meta_asm_loop] = c_SglQt OR Src[meta_asm_loop] = 59 THEN
        lszTmp$ = RIGHT$(Src$,Src_Len - meta_asm_loop - 1)
        Src[meta_asm_loop] = 0
        meta_asm_comment_present = TRUE
        EXIT FOR
      END IF
    NEXT

    Src$ = TRIM$(Src$)
    IF iMatchLft(Src$,"$asm") THEN EXIT DO
    REPLACE "$" WITH "0x" IN Src$
    IREPLACE "&h" WITH "0x" IN Src$
    IF Src$ <> "" THEN
      Src$ = "_asm(" + ENC$(Src$) + CHR$(1)
      IF meta_asm_comment_present THEN
        Src$ = Src$ + TAB$ + "//" + lszTmp$
      END IF
      SrcTmp$ = Src$
      FPRINT Outfile,"#if !defined( __POCC__ ) && !defined (__cplusplus )"
      REPLACE CHR$(1) WITH ")" IN Src$
      FPRINT Outfile,Src$
      FPRINT Outfile,"#else"
      REPLACE "_asm(" WITH "__asm{" IN SrcTmp$
      REPLACE CHR$(1) WITH "}" IN SrcTmp$
      FPRINT Outfile,REMOVE$(SrcTmp$,DQ$)
      FPRINT Outfile,"#endif"
    END IF
  LOOP

  CALL EmitOptimize((char*)"",(char*)"1",(char*)"  // Restoring Optimizer state")
  FUNCTION = 0
END FUNCTION



FUNCTION Dobcx_resource(szWord$, iFLAG AS PINT)
  *iFLAG = 0

  Use_GenResFile = TRUE

  DO
    IF EOF(SourceFile) THEN Abort ("Unbalanced $BCX_RESOURCE")
    LINE INPUT SourceFile,Src$
    ModuleLineNos[ModuleNdx]++
    CALL StripCode(Src$)
    IF iMatchLft(LTRIM$(Src$),"$bcx_r") THEN EXIT DO
    FPRINT FP_RES,Src$
  LOOP

  FUNCTION = 0
END FUNCTION



FUNCTION Dobcxversion(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  Src$ = TRIM$(MID$(Src$,12))
  REMOVE DQ$ FROM Src$
  IF LCASE$(Version$) < LCASE$(Src$) THEN
    Abort (CRLF$ + "Your Translator needs updating." + CRLF$ + _
      "This program " + ENC$(Modules$[ModuleNdx]) + " requires BCX Version: " + Src$ + " or later." + CRLF$ + CRLF$)
  ELSE
    PRINT ""
    PRINT "Program written for BCX Version ", Src$
    PRINT ""
  END IF
  FUNCTION = 0
END FUNCTION



FUNCTION Docatch(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  Src$ = TRIM$(MID$(Src$,8))
  IF Src$ = "" THEN Src$ = "char *str"
  FPRINT Outfile,"}"
  FPRINT Outfile,"catch (";Src$;")" ' catch (char *str)
  FPRINT Outfile,"{"
  FUNCTION = 0
END FUNCTION



'FUNCTION Doccode(szWord$, iFLAG AS PINT)
  'RAW FP_TMP AS FILE
  '*iFLAG = 0
  'IF InFunc THEN
    'FP_TMP = FP3
  'ELSE
    'IF InClassModule OR InNameSpace OR InPPTypeModule THEN
      'FP_TMP = FP_UDT
    'ELSE
      'FP_TMP = FP_CCODE
    'END IF
  'END IF
  'DO
    'IF EOF(SourceFile) THEN Abort ("Unbalanced $Ccode")
    'LINE INPUT SourceFile,Src$
    'ModuleLineNos[ModuleNdx]++
    'CALL StripTabs
    'IF iMatchLft(LTRIM$(Src$) ,"$ccode") THEN
      'IF SrcFlag THEN 'comments seem to interfere with C line continuations '\'
        'FPRINT FP_TMP,"// [", TRIM$(Modules$[ModuleNdx]), " - ", _
          'TRIM$(STR$(ModuleLineNos[ModuleNdx])), "] End of $CCODE Block"
      'END IF
      'EXIT DO
    'END IF
    'FPRINT FP_TMP,RTRIM$(Src$)
  'LOOP

  'FUNCTION = 0
'END FUNCTION
'==============================================================================
'Wayne and Robert replacement 06/29/2013
'
FUNCTION Doccode(szWord$, iFLAG AS PINT)
    RAW FP_TMP AS FILE
    RAW szWhere$
    *iFLAG = 0
    IF Ndx > 1 THEN
        szWhere$ = LCASE$(Stk$[2])
    ELSE
        szWhere$ = "default"
    END IF
    SELECT CASE szWhere$
        CASE "set"
            FP_TMP = FP_SET ' Temp File FOR Storing GLOBAL SET Vars
        CASE "header"
            FP_TMP = FP_HDR ' Temp File FOR Storing User .H files
        CASE "const"
            FP_TMP = FP_CST ' Temp File FOR Storing User CONST
        CASE "udt"
            FP_TMP = FP_UDT ' Temp File FOR Storing User Def Types
        CASE "enum"
            FP_TMP = FP_ENU ' Temp File FOR Storing User global enums
        CASE "funcsub"
            FP_TMP = FP_CCODE ' Temp File FOR Storing User C code
        CASE ELSE
            IF InFunc <> eNotInOne THEN
                FP_TMP = FP3
            ELSE
                IF InClassModule OR InNameSpace OR InPPTypeModule THEN
                    FP_TMP = FP_UDT ' Temp File FOR Storing User Def Types
                ELSE
                    FP_TMP = FP2
                END IF
            END IF
    END SELECT

    DO
        IF EOF(SourceFile) THEN Abort ("Unbalanced $Ccode")
        LINE INPUT SourceFile,Src$
        ModuleLineNos[ModuleNdx]++
        CALL StripTabs
        IF iMatchLft(LTRIM$(Src$) ,"$ccode") THEN
            IF SrcFlag THEN 'comments seem to interfere with C line continuations '\'
                FPRINT FP_TMP, "// [", TRIM$(Modules$[ModuleNdx]), " - ", _
                TRIM$(STR$(ModuleLineNos[ModuleNdx])), "] End of $CCODE Block"
            END IF
            EXIT DO
        END IF
        FPRINT FP_TMP, RTRIM$(Src$)
    LOOP

    FUNCTION = 0
END FUNCTION


'Only Called when using $class ?
FUNCTION Doclass(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  IF UseCpp = FALSE THEN CALL Abort("'Class' can only be used with C++")
  Src$ = REMAIN$(Src$, SPC$)
  FPRINT FP_UDT,"class ";Src$;"\n  {"   '<--------------

  DO
    IF EOF(SourceFile) THEN Abort ("$Class Without $EndClass")
    LINE INPUT SourceFile,Src$
    ModuleLineNos[ModuleNdx]++
    IF iMatchLft(LTRIM$(Src$),"$endclass") THEN
      EXIT DO
    END IF
    FPRINT FP_UDT,Src$
  LOOP

  Src$ = MID$(Src$, INSTR(Src$,"$endclass",1,1)+9)
  Src$ = TRIM$(Src$)
  FPRINT FP_UDT,"} ";Src$;";"   '<--------------
  FUNCTION = 0
END FUNCTION



FUNCTION Docom_op(szWord$, iFLAG AS PINT)
  *iFLAG = 0

  SELECT CASE szWord$

    CASE "$com_off"
      Use_COM = FALSE
      ComSwitchON = FALSE

    CASE "$com_on"
      Use_COM = UseFlag = TRUE
      ComSwitchON = TRUE

    CASE "$com_trace"
      build_com_trace_code = TRUE
      PRINT "COM trace code added to translated C file!"
      PRINT "Trace informations will be sent to file: c:\\com_trace.txt"

  END SELECT
  FUNCTION = 0
END FUNCTION



FUNCTION Docomment(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  DIM RAW TmpFile AS FILE
  IF IAm(InClassModule) OR IAm(InPPTypeModule) THEN TmpFile = FP_UDT ELSE TmpFile = Outfile

  DO
    IF EOF(SourceFile) THEN Abort ("Unbalanced $Comment")
    LINE INPUT SourceFile,Src$
    ModuleLineNos[ModuleNdx]++
    CALL StripTabs
    IF iMatchLft(LTRIM$(Src$),"$comment") THEN EXIT DO
    'jcffuller added 11/15/2013
If InsertComments Then
    FPRINT TmpFile,"// ";Src$
End If
  LOOP

  FUNCTION = 0
END FUNCTION



FUNCTION Docompiler(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  Src$ = REMAIN$(Src$," ")
  Compiler$ = TRIM$(Src$)
  FUNCTION = 0
END FUNCTION



FUNCTION Docpp(szWord$, iFLAG AS PINT)
  STATIC BeenHere
  IF NOT BeenHere THEN
    BeenHere++
    FPRINT FP_HDR,"#ifndef __cplusplus"
    FPRINT FP_HDR,"  #error A C++ compiler is required"
    FPRINT FP_HDR,"#endif"
'jcfuller added 07/02/2013
	'FPRINT FP_HDR,"#define _bool	bool"
	'FPRINT FP_HDR,"#define _Bool	bool"
	'FPRINT FP_HDR,"#define bool	bool"
	'FPRINT FP_HDR,"#define false false"
	'FPRINT FP_HDR,"#define true	true"
	'FPRINT FP_HDR,"#define _false false"
	'FPRINT FP_HDR,"#define _true true"

    'WinHeaders  = FALSE
  END IF
  UseIO = UseCpp = TRUE
  FUNCTION = 0
END FUNCTION

FUNCTION Docpphdr(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  UseCpphdr = TRUE
  UseIO = TRUE
  UseCpp = TRUE
  FUNCTION = 0
END FUNCTION

'jcfuller added 07/07/2012
Function Domingw(szWord$,iFLAG As PINT)
	*iFLAG = 0
    g_EmitLibs = FALSE
    FUNCTION = 0
End Function
'jcfuller added 07/08/2013
Function DoExitDirective(szWord$, iFLAG AS PINT)
	*iFLAG = 0
	FUNCTION = 0

End Function

FUNCTION Docproto(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  FastLexer(Src$, SPC$, "!")

  IF iMatchWrd(Stk$[2], "!") THEN
    CALL AddProto(REMAIN$(Src$, "!"))
    ProtoType[ProtoCnt].Condition$ = ""
    ProtoType[ProtoCnt].CondLevel  = 0
  ELSE
    RAW i = iMatchNQ(Src$, "function")
    IF i = 0 THEN
      i = iMatchNQ(Src$, "sub")
    END IF
    IF i THEN
      Src$ = "c_declare " + MID$(Src$, i)
    ELSE
      i = iMatchNQ(Src$, "$cproto")
      Src$ = "c_declare function " + MID$(Src$, i+7)
    END IF
    PassOne = TRUE
    CALL XParse(Src$) ' : CALL FixUps() : CALL EmitMain()
    PassOne = FALSE
    UseCProto = TRUE
    *iFLAG = 2
  END IF
  FUNCTION = *iFLAG
END FUNCTION



FUNCTION Dodebug(szWord$, iFLAG AS PINT)
  InDebug = 1 XOR InDebug
  IF InDebug THEN
    Src$ = "$IF _DEBUG_"
  ELSE
    Src$ = "$ENDIF"
  END IF
  PassOne = TRUE
  CALL XParse(Src$) ' : CALL FixUps() : CALL EmitMain()
  PassOne = FALSE
  UseCProto = TRUE
  *iFLAG = 2
  FUNCTION = 2
END FUNCTION



FUNCTION Dodll(szWord$, iFLAG AS PINT)
'cout << szWord$ << endl
  *iFLAG = 0
  SELECT CASE szWord$

    CASE "$dll"
      MakeDLL = TRUE
      Ndx = 0

      IF LCASE$(Stk$[2]) = "stdcall" THEN
        UseStdCall = TRUE
      END IF

      IF NoDllMain = FALSE THEN
        FPRINT Outfile,""
        'FPRINT Outfile,"__declspec(dllexport) BOOL WINAPI DllMain (HINSTANCE hInst, DWORD Reason, LPVOID Reserved)"
        FPRINT Outfile,"BOOL WINAPI DllMain (HINSTANCE hInst, DWORD Reason, LPVOID Reserved)"
        FPRINT Outfile,"{"
        FPRINT Outfile," switch (Reason)"
        FPRINT Outfile," {"
        FPRINT Outfile," case DLL_PROCESS_ATTACH:"
        FPRINT Outfile," BCX_hInstance = hInst;"
        FPRINT Outfile," break;"
        FPRINT Outfile," case DLL_PROCESS_DETACH:"
        FPRINT Outfile," break;"
        FPRINT Outfile," case DLL_THREAD_ATTACH:"
        FPRINT Outfile," break;"
        FPRINT Outfile," case DLL_THREAD_DETACH:"
        FPRINT Outfile," break;"
        FPRINT Outfile," }"
        FPRINT Outfile," return TRUE;"
        FPRINT Outfile,"}\n\n"
        CALL AddBCX_hInstance()
        'Src$ = "GLOBAL BCX_hInstance AS HINSTANCE"
        'CALL XT1E(Src$)
      END IF

    CASE "$nodllmain"
      NoDllMain = TRUE

  END SELECT
  FUNCTION = 0
END FUNCTION



FUNCTION DoNameSpace(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  SELECT CASE szWord$

    CASE "$endnamespace"
      InNameSpace--
      CALL BumpDown("Extra un-indent(s) and/or missing indents in $NAMESPACE/$END$NAMESPACE")
      FPRINT Outfile,Scoot$;"}"

    CASE "$namespace" ' $namespace/$endnamespace
      IF UseCpp = FALSE THEN CALL Abort("'Namespace' can only be used with C++")
      FPRINT Outfile,Scoot$;"namespace ";Stk$[2]
      FPRINT Outfile,Scoot$;"{"
      InNameSpace++
      CALL BumpUp

    CASE "$usenamespace" ' $usenamespace = using namespace std; etc.

      IF UseCpp = FALSE THEN CALL Abort("'Usenamespace' can only be used with C++")
      Src$ = REMAIN$(Src$, SPC$)
      IF RIGHT$(TRIM$(Src$),1) <> ";" THEN
        FPRINT Outfile,"using namespace ", Src$, ";"
      ELSE
        FPRINT Outfile,"using namespace ", Src$
      END IF

  END SELECT
  FUNCTION = 0
END FUNCTION



FUNCTION DoTry(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  SELECT CASE szWord$

    CASE "$endtr"
      FPRINT Outfile,"}"

    CASE "$try"
      FPRINT Outfile,"try {"

  END SELECT
  FUNCTION = 0
END FUNCTION



FUNCTION Dofiletest(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  IF iMatchWrd(Stk$[2],"ON") THEN
    UseFileTest = TRUE
  ELSEIF iMatchWrd(Stk$[2],"OFF") THEN
    UseFileTest = FALSE
  ELSE
    Abort("Unrecognized argument '"+Stk$[2]+"' to $FILETEST")
  END IF
  FUNCTION = 0
END FUNCTION



FUNCTION Dofsstatic(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  Use_Static = NOT Use_Static
  FUNCTION = 0
END FUNCTION

Function DoExternC(szWord$, iFLAG AS PINT)
	*iFLAG = 0
	Use_ExternC = NOT Use_ExternC
	Function = 0
End Function

FUNCTION Dogenfree(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  Use_GenFree = TRUE
  FUNCTION = 0
END FUNCTION



FUNCTION Doheader(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  'FPRINT FP_HDR,"// ***************************************************"
  FPRINT FP_HDR,"// $HEADER BEGIN"
  'FPRINT FP_HDR,"// ***************************************************"
  'FPRINT FP_HDR,""

  DO
    IF EOF(SourceFile) THEN Abort ("Unbalanced $Header")
    LINE INPUT SourceFile,Src$
    ModuleLineNos[ModuleNdx]++
    CALL StripTabs
    Src$ = TRIM$(Src$)
    If iMatchLft(Src$,"#include <windows.h>") Then
       RemoveTypeDef = 1
	 End If

    IF iMatchLft(Src$,"$heade") THEN EXIT DO
    FPRINT FP_HDR,Src$
  LOOP
'jcfuller added 02/15/2015
	If Use_BC9Dialog Then
		If Not WinHeaders Then
			FPRINT FP_HDR,"#include ",Enc$("Win95ADG.h")
			FPRINT FP_HDR,"#include ",Enc$("DlgTmplt.h")
			FPRINT FP_HDR,"#include ",Enc$("DlgTmplt.c")
		End If
	End If
  FPRINT FP_HDR,"// $HEADER END"
  FPRINT FP_HDR,""
  FUNCTION = 0
END FUNCTION



FUNCTION Dointerface(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  IF UseCpp = FALSE THEN CALL Abort("'Interface' can only be used with C++")
  Src$ = REMAIN$(Src$, SPC$)
  FPRINT FP_UDT,"interface ";Src$;"\n  {"   '<--------------

  DO
    IF EOF(SourceFile) THEN Abort ("$Interface Without $EndInterface")
    LINE INPUT SourceFile,Src$
    ModuleLineNos[ModuleNdx]++
    IF iMatchLft(LTRIM$(Src$),"$endinterface") THEN
      EXIT DO
    END IF
    FPRINT FP_UDT,Src$
  LOOP

  Src$ = REMAIN$(Src$, " ")
  Src$ = TRIM$(Src$)
  FPRINT FP_UDT,"} ";Src$;";"   '<--------------
  FUNCTION = 0
END FUNCTION



FUNCTION Doiprint_offon(szWord$, iFLAG AS PINT)
  *iFLAG = 0

  SELECT CASE szWord$

    CASE "$iprint_on"

      TranslateSlash = TRUE

    CASE "$iprint_off"
      TranslateSlash = FALSE

  END SELECT
  FUNCTION = 0
END FUNCTION



FUNCTION Doleanandmean(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  Use_LeanAndMean = TRUE

  FUNCTION = 0
END FUNCTION



FUNCTION Doliberror(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  UseFlag = Use_Date = Use_Time = Use_LoadLibraryError = TRUE
  IF *Stk[2] <> c_DblQt THEN CALL Abort("$LIBERROR requires as string literal")
  LibraryErrorLog$ = Stk$[2]
  FUNCTION = 0
END FUNCTION



FUNCTION Dolibrary(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  REPLACE "\\" WITH "\\\\" IN Src$
  Src$ = IREMOVE$(Src$,"$library")
  Src$ = TRIM$(Src$)
  AddLibrary(Src$)
  FUNCTION = 0
END FUNCTION



FUNCTION Dolinker(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  Src$ = REMAIN$(Src$," ")
  Linker$ = Src$
  FUNCTION = 0
END FUNCTION



FUNCTION Domultithread(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  Use_MULTITHREADED_SW = TRUE
  FUNCTION = 0
END FUNCTION



FUNCTION Donoini(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  TestForBcxIni = TRUE
  FUNCTION = 0
END FUNCTION



FUNCTION Donoio(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  UseIO = FALSE
  FUNCTION = 0
END FUNCTION

'jcfuller
FUNCTION Doclassprops(szWord$, iFLAG AS PINT)
	*iFLAG = 0
	Use_ClassProps = TRUE
	FUNCTION = 0
END FUNCTION


FUNCTION Donoinc(szWord$, iFLAG AS PINT)
  WinHeaders = FALSE
  UseWinApi = FALSE
  NoIncludes = TRUE
  FUNCTION = 0
End Function

FUNCTION Donolibmain(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  REPLACE "\\" WITH "\\\\" IN Src$
  Src$ = IREMOVE$(Src$,"$nolibrary")
  RemoveLibrary(Src$)
  FUNCTION = 0
END FUNCTION



FUNCTION Donomain(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  NoMain = TRUE
  FUNCTION = 0
END FUNCTION



FUNCTION Donowin(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  WinHeaders = FALSE
  UseWinApi = FALSE
  FUNCTION = 0
END FUNCTION

FUNCTION Donoapi(szWord$, iFLAG AS PINT)
	*iFLAG = 0
	UseWinApi = FALSE
	WinHeaders = FALSE
	FUNCTION = 0
End Function

FUNCTION Doonentry(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  PassOne = TRUE
  CALL XParse(Src$)
  PassOne = FALSE
  EntryCnt++
  IF cMaxOnEntry = EntryCnt THEN CALL Abort("Maximum $OnEnty exceeded.")
  Entry$[EntryCnt] = Stk$[2]
  FUNCTION = 0
END FUNCTION



FUNCTION Doonexit(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  XitCount++
  IF cMaxOnExit = XitCount THEN CALL Abort("Maximum $OnExit exceeded.")
  Xit$[XitCount]= Stk$[2]
  FUNCTION = 0
END FUNCTION



FUNCTION Dooptimizer(szWord$, iFLAG AS PINT)
  RAW szState$
  *iFLAG = 2
  szState$ = LCASE$(Stk$[2])
  Src$ = ""

  IF szState$ = "on" THEN
    'IF OptimizerFirstSetting = TRUE THEN
    IF OptimizerFirstSetting THEN
      OptimizerFirstSetting = FALSE
      Src$ = "~pragmaoptimizeon"
      OptimizerEnabled = TRUE
    ELSE
      IF OptimizerEnabled = FALSE THEN
        OptimizerEnabled = TRUE
        Src$ = "~pragmaoptimizeon"
      END IF
    END IF

  ELSEIF szState$ = "off" THEN
    IF OptimizerFirstSetting THEN
      OptimizerFirstSetting = FALSE
      Src$ = "~pragmaoptimizeoff"
      OptimizerEnabled = FALSE
    ELSE
      IF OptimizerEnabled THEN          'IF OptimizerEnabled = TRUE THEN
        OptimizerEnabled = FALSE
        Src$ = "~pragmaoptimizeoff"
      END IF
    END IF
  ELSE
    Abort("Error in $OPTIMIZER MetaStatement: " + Src$ )
  END IF
  CALL XParse(Src$)
  FUNCTION = 2
END FUNCTION



FUNCTION Dopack(szWord$, iFLAG AS PINT)
  RAW iLoc = 2
  *iFLAG = 0
  FastLexer(Src$, "","()")
  IF Stk$[iLoc] = "(" THEN iLoc++
  FPRINT FP_UDT,"#pragma pack (";Stk$[iLoc];")"
  FUNCTION = 0
END FUNCTION



FUNCTION Dopp(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  PPFlag = NOT PPFlag
  IF PPFlag THEN
    IF PPDLL_HANDLE = NULL THEN
      PPDLL_HANDLE = LOADLIBRARY( "BCXPP.DLL")
      IF NOT PPDLL_HANDLE THEN ' failed to load preprocessor dll
        Abort ("Failed to Open BCX Preprocessor DLL!")
      ELSE
        PRINT "BCXPP.DLL Successfully Loaded"
      END IF
      PPProc = (CPP_FARPROC) GetProcAddress (PPDLL_HANDLE,"_ProcessLine");
      IF NOT PPProc THEN
        Abort ("Couldn't Find 'ProcessLine' Procedure in BCX Preprocessor DLL!")
      END IF
    END IF
  END IF
  FUNCTION = 0
END FUNCTION



FUNCTION Doprj(szWord$, iFLAG AS PINT)
  *iFLAG = 0

  SELECT CASE szWord$
    CASE "$prj"
'jcfuller 1/29/2013
'      Project$ = UCASE$(EXTRACT$(COMMAND$(1),".")) + ".USE"
'      HFile$   = UCASE$(EXTRACT$(COMMAND$(1),".")) + ".H"

      Project$ = UCASE$(RemoveExtension$(COMMAND$(1))) + ".USE"
      HFile$   = UCASE$(RemoveExtension$(COMMAND$(1))) + ".H"
      Use_SingleFile = FALSE

    CASE "$prjuse"
      PreParse(Src$)
      CALL SetUsed()

  END SELECT
  FUNCTION = 0
END FUNCTION



FUNCTION Doproject(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  CALL EnableProject()
  FUNCTION = 0
END FUNCTION



FUNCTION Dorems(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  InsertComments = ~InsertComments
  FUNCTION = 0
END FUNCTION



FUNCTION Doresource(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  Use_Resource = TRUE
  ResCompiler$ = Stk$[2]
  UserResFile$ = REMOVE$(Stk$[3], DQ$)
  FUNCTION = 0
END FUNCTION



FUNCTION Dosource(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  SrcFlag = NOT SrcFlag
  FUNCTION = 0
END FUNCTION



FUNCTION Dostdcall(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  UseStdCall = TRUE
  FUNCTION = 0
END FUNCTION



FUNCTION Dotest(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  TestState = NOT TestState
  FUNCTION = 0
END FUNCTION



FUNCTION Dothrow(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  szTmp$ = MID$(Src$,8)
  IF szTmp$ = "" THEN szTmp$ = ENC$("An Exception has occured!")
  FPRINT Outfile,Scoot$;"throw ";szTmp$;";"
  FUNCTION = 0
END FUNCTION



FUNCTION Dotrace(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  TrcFlag = NOT TrcFlag
  FUNCTION = 0
END FUNCTION



FUNCTION Doturbo(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  Src$ = LTRIM$(MID$(Src$,7))
  IF *Src$ <> 0 THEN
    BCX_TmpStrSize = VAL(Src$)
    IF (BCX_TmpStrSize & (BCX_TmpStrSize-1)) <> 0 THEN
      BCX_TmpStrSize = 512
      Warning("Invalid $Turbo size - defaulting to 512")
    END IF
  ELSE
    BCX_TmpStrSize = 512
  END IF

  FUNCTION = 0
END FUNCTION



FUNCTION Dotypedef(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  FPRINT FP_HDR,"typedef ";REMAIN$(Src$,SPC$),";"
  FUNCTION = 0
END FUNCTION

FUNCTION DoCppUsing(szWord$, iFLAG AS PINT)
  *iFLAG = 0
  FPRINT FP_HDR,"using ";REMAIN$(Src$,SPC$),";"
  FUNCTION = 0
END FUNCTION
' End Direcectives
'
'==================================================================================



SUB DoGoto(i AS INT, iSend AS INT)
  sprintf(LoopType[i].szUseNeedLabel,"L%i:;",LoopType[i].iJumpTo)
  IF iSend THEN
    RAW szGL$
    sprintf(szGL, "goto L%i;",LoopType[i].iJumpTo)
    FPRINT Outfile,Scoot$;szGL$
  END IF
END SUB
'==============================================================================
! void Dobc9Prj ();
$CCODE
void stdstr_split(const string& str, const string& delim, vector<string>& parts) {
  size_t start, end = 0;
  while (end < str.size()) {
    start = end;
    while (start < str.size() && (delim.find(str[start]) != string::npos)) {
      start++;  // skip initial whitespace
    }
    end = start;
    while (end < str.size() && (delim.find(str[end]) == string::npos)) {
      end++; // skip to end of word
    }
    if (end-start != 0) {  // just ignore zero-length strings.
      parts.push_back(string(str, start, end-start));
    }
  }
}
void Dobc9Prj ()
{
  // stdstr   sLine;
  stdstr   stmp1;
  stdstr   stmp2;
  int      i;
  stdstr   sFile;
  stdstr   sFileIn;
  stdstr   sFileOut;
  stdstr   sFileH;
  bool    TypesAndUnions=0;
  bool    UserPrototypes=0;
  bool    OkToWrite=1;
  char    S1[cSizeOfDefaultString]={0};

  strcpy(S1,BcxSplitPath(FileOut,FNAME));
  sFile= RemoveExtension( S1);
  sFileIn= sFile+".cpp";
  sFileH= sFile+".h";
  sFileOut= sFileIn;
  fstream  f(sFileIn,ios::in);
  // fstream  f2;
  vector<string>  vs;
  vector<string>  parts;
  vector<string>  vsheader;
  vector<string>  vsNewCpp;
  stdstr   ssLine;
  int      item={0};
  if(!f.is_open())
    {
      cout<<"Could not locate file"<<endl;
      Pause();
      return;
    }
  if(Exist(sFileH.c_str()))
    {
      remove (sFileH.c_str());
    }
  if(Exist(sFileOut.c_str()))
    {
      remove (sFileOut.c_str());
    }
  while(f.good())
    {
      getline(f,ssLine);
      vs.push_back(ssLine);
    }

  f.close();
  remove (sFileIn.c_str());
 for(auto it : vs)
    {
      if(instr(it,"using"))
        {
          i= tally( it.c_str(),";");
          if(i>1 )
            {
              stdstr_split(it,";",parts);
            }
          else
            {
              parts.push_back(it);
            }
        }
    }

  vsheader.push_back("// *************************************************");
  vsheader.push_back("#ifndef GUARD_"+sFile);
  vsheader.push_back("  #define GUARD_"+sFile);
  vsheader.push_back("  // "+sFileH+" header file");
 for(auto it : vs)
    {
      if(it.length())
        {
          if(str_cmp(left(it.c_str(),8),"#include")==0)
            {
              vsheader.push_back("  "+it);
              continue;
            }
          if(TypesAndUnions )
            {
              if(instr(it,"User Global Variables"))
                {
                  vsheader.erase(vsheader.end());
                  TypesAndUnions= 0;
                  continue;
                }
 for(auto it2:parts)
                {
                  i= instr( it2,"::")+ 1;
                  stmp1=right( it2, it2.size()- i);
                  stmp2=trim(mid( it2, 6, it2.length()));
                  if(instr(it,stmp1))
                    {
                      it=replace( it, stmp1, stmp2);
                    }
                }

              vsheader.push_back(it);
              continue;
            }
          if(instr(it,"User Defined Types"))
            {
              TypesAndUnions= 1;
              continue;
            }
          if(UserPrototypes )
            {
              if(instr(it,"User Global Initialized Arrays"))
                {
                  UserPrototypes= 0;
                  continue;
                }
 for(auto it2:parts)
                {
                  i= instr( it2,"::")+ 1;
                  stmp1=right( it2, it2.size()- i);
                  stmp2=trim(mid( it2, 6, it2.length()));
                  if(instr(it,stmp1))
                    {
                      it=replace( it, stmp1, stmp2);
                    }
                }

              vsheader.push_back(it);
              continue;
            }
          if(instr(it,"User Prototypes"))
            {
              UserPrototypes= 1;
              continue;
            }
        }
    }

  vsheader.push_back("#endif");
 for(auto it : vs)
    {
      if(it.length())
        {
          if(str_cmp(left(it.c_str(),8),"#include")==0)
            {
              continue;
            }
          if(instr(it,"// this is missing"))
            {
              OkToWrite= FALSE;
              continue;
            }
          if(instr(it,"#ifndef __cplusplus"))
            {
              OkToWrite= TRUE;
              vsNewCpp.push_back(join(2,"#include ",DQ)+sFileH+DQ);
            }
          if(instr(it,"User Subs and Functions"))
            {
              OkToWrite= TRUE;
            }
          if(instr(it,"User Defined Types And Unions"))
            {
              OkToWrite= FALSE;
            }
          if(instr(it, "User Global Variables"))
            {
                OkToWrite = TRUE;
            }
          if(instr(it, "User Prototypes"))
            {
                OkToWrite = FALSE;
            }

          if(OkToWrite )
            {
              vsNewCpp.push_back(it);
            }
        }
    }

  f.open(sFileH,ios::out);
 for(auto it : vsheader)
    {
      f<<it<<endl;
    }

  f.close();
  f.open(sFileOut,ios::out);
 for(auto it : vsNewCpp)
    {
      f<<it<<endl;
    }

  f.close();
}

$CCODE

Function DoWx(szWord As char Ptr, iFLAG AS PINT) As Integer
   *iFLAG = 0
    NoMain = TRUE
    Docpp((char*)"$cpp",0)
    Function = 0
End Function

